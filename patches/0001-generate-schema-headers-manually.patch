From 6de1f1016692bf4097a487b024f86ce67913f40c Mon Sep 17 00:00:00 2001
From: Zhu Guodong <zhuguodong0001@163.com>
Date: Mon, 6 Mar 2023 16:02:07 +0800
Subject: [PATCH 1/4] generate schema headers manually

---
 .gitignore                                    |     2 -
 mindspore/lite/schema/gpu_cache_generated.h   |   319 +
 .../lite/schema/inner/gpu_cache_generated.h   |   573 +
 mindspore/lite/schema/inner/model_generated.h |  3377 ++
 mindspore/lite/schema/inner/ops_generated.h   | 33649 ++++++++++++++++
 .../lite/schema/inner/ops_types_generated.h   |  1164 +
 mindspore/lite/schema/model_generated.h       |  2551 ++
 mindspore/lite/schema/ops_generated.h         | 14383 +++++++
 mindspore/lite/schema/ops_types_generated.h   |   747 +
 9 files changed, 56763 insertions(+), 2 deletions(-)
 create mode 100644 mindspore/lite/schema/gpu_cache_generated.h
 create mode 100644 mindspore/lite/schema/inner/gpu_cache_generated.h
 create mode 100644 mindspore/lite/schema/inner/model_generated.h
 create mode 100644 mindspore/lite/schema/inner/ops_generated.h
 create mode 100644 mindspore/lite/schema/inner/ops_types_generated.h
 create mode 100644 mindspore/lite/schema/model_generated.h
 create mode 100644 mindspore/lite/schema/ops_generated.h
 create mode 100644 mindspore/lite/schema/ops_types_generated.h

diff --git a/.gitignore b/.gitignore
index bcb8498b..05a18946 100644
--- a/.gitignore
+++ b/.gitignore
@@ -25,8 +25,6 @@ mindspore/lite/tools/converter/parser/onnx/onnx.pb.h
 mindspore/lite/tools/converter/parser/onnx/onnx.pb.h
 mindspore/lite/tools/converter/schema/*.h
 mindspore/lite/tools/converter/schema/inner
-mindspore/lite/schema/*.h
-mindspore/lite/schema/inner
 
 mindspore/lite/src/runtime/kernel/opencl/cl/fp16/*.inc
 mindspore/lite/src/runtime/kernel/opencl/cl/fp32/*.inc
diff --git a/mindspore/lite/schema/gpu_cache_generated.h b/mindspore/lite/schema/gpu_cache_generated.h
new file mode 100644
index 00000000..4a95aa29
--- /dev/null
+++ b/mindspore/lite/schema/gpu_cache_generated.h
@@ -0,0 +1,319 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+
+
+#ifndef FLATBUFFERS_GENERATED_GPUCACHE_MINDSPORE_SCHEMA_H_
+#define FLATBUFFERS_GENERATED_GPUCACHE_MINDSPORE_SCHEMA_H_
+
+#include "flatbuffers/flatbuffers.h"
+
+namespace mindspore {
+namespace schema {
+
+struct TuneParam;
+struct TuneParamBuilder;
+
+struct ProgramBinary;
+struct ProgramBinaryBuilder;
+
+struct GpuCache;
+struct GpuCacheBuilder;
+
+struct TuneParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TuneParamBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_LOCAL = 4,
+    VT_BLOCK = 6,
+    VT_SHAPE = 8,
+    VT_OPPARA = 10
+  };
+  const flatbuffers::Vector<int32_t> *local() const {
+    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_LOCAL);
+  }
+  const flatbuffers::Vector<int32_t> *block() const {
+    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK);
+  }
+  const flatbuffers::Vector<int32_t> *shape() const {
+    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
+  }
+  const flatbuffers::Vector<int32_t> *opPara() const {
+    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OPPARA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_LOCAL) &&
+           verifier.VerifyVector(local()) &&
+           VerifyOffset(verifier, VT_BLOCK) &&
+           verifier.VerifyVector(block()) &&
+           VerifyOffset(verifier, VT_SHAPE) &&
+           verifier.VerifyVector(shape()) &&
+           VerifyOffset(verifier, VT_OPPARA) &&
+           verifier.VerifyVector(opPara()) &&
+           verifier.EndTable();
+  }
+};
+
+struct TuneParamBuilder {
+  typedef TuneParam Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_local(flatbuffers::Offset<flatbuffers::Vector<int32_t>> local) {
+    fbb_.AddOffset(TuneParam::VT_LOCAL, local);
+  }
+  void add_block(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block) {
+    fbb_.AddOffset(TuneParam::VT_BLOCK, block);
+  }
+  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
+    fbb_.AddOffset(TuneParam::VT_SHAPE, shape);
+  }
+  void add_opPara(flatbuffers::Offset<flatbuffers::Vector<int32_t>> opPara) {
+    fbb_.AddOffset(TuneParam::VT_OPPARA, opPara);
+  }
+  explicit TuneParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TuneParam> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TuneParam>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TuneParam> CreateTuneParam(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int32_t>> local = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int32_t>> opPara = 0) {
+  TuneParamBuilder builder_(_fbb);
+  builder_.add_opPara(opPara);
+  builder_.add_shape(shape);
+  builder_.add_block(block);
+  builder_.add_local(local);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<TuneParam> CreateTuneParamDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int32_t> *local = nullptr,
+    const std::vector<int32_t> *block = nullptr,
+    const std::vector<int32_t> *shape = nullptr,
+    const std::vector<int32_t> *opPara = nullptr) {
+  auto local__ = local ? _fbb.CreateVector<int32_t>(*local) : 0;
+  auto block__ = block ? _fbb.CreateVector<int32_t>(*block) : 0;
+  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
+  auto opPara__ = opPara ? _fbb.CreateVector<int32_t>(*opPara) : 0;
+  return mindspore::schema::CreateTuneParam(
+      _fbb,
+      local__,
+      block__,
+      shape__,
+      opPara__);
+}
+
+struct ProgramBinary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ProgramBinaryBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_PROGRAM_NAME = 4,
+    VT_BUILD_OPTION = 6,
+    VT_TUNE = 8,
+    VT_DATA = 10
+  };
+  const flatbuffers::String *program_name() const {
+    return GetPointer<const flatbuffers::String *>(VT_PROGRAM_NAME);
+  }
+  const flatbuffers::String *build_option() const {
+    return GetPointer<const flatbuffers::String *>(VT_BUILD_OPTION);
+  }
+  const mindspore::schema::TuneParam *tune() const {
+    return GetPointer<const mindspore::schema::TuneParam *>(VT_TUNE);
+  }
+  const flatbuffers::Vector<uint8_t> *data() const {
+    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_PROGRAM_NAME) &&
+           verifier.VerifyString(program_name()) &&
+           VerifyOffset(verifier, VT_BUILD_OPTION) &&
+           verifier.VerifyString(build_option()) &&
+           VerifyOffset(verifier, VT_TUNE) &&
+           verifier.VerifyTable(tune()) &&
+           VerifyOffset(verifier, VT_DATA) &&
+           verifier.VerifyVector(data()) &&
+           verifier.EndTable();
+  }
+};
+
+struct ProgramBinaryBuilder {
+  typedef ProgramBinary Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_program_name(flatbuffers::Offset<flatbuffers::String> program_name) {
+    fbb_.AddOffset(ProgramBinary::VT_PROGRAM_NAME, program_name);
+  }
+  void add_build_option(flatbuffers::Offset<flatbuffers::String> build_option) {
+    fbb_.AddOffset(ProgramBinary::VT_BUILD_OPTION, build_option);
+  }
+  void add_tune(flatbuffers::Offset<mindspore::schema::TuneParam> tune) {
+    fbb_.AddOffset(ProgramBinary::VT_TUNE, tune);
+  }
+  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
+    fbb_.AddOffset(ProgramBinary::VT_DATA, data);
+  }
+  explicit ProgramBinaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ProgramBinary> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ProgramBinary>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ProgramBinary> CreateProgramBinary(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> program_name = 0,
+    flatbuffers::Offset<flatbuffers::String> build_option = 0,
+    flatbuffers::Offset<mindspore::schema::TuneParam> tune = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
+  ProgramBinaryBuilder builder_(_fbb);
+  builder_.add_data(data);
+  builder_.add_tune(tune);
+  builder_.add_build_option(build_option);
+  builder_.add_program_name(program_name);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<ProgramBinary> CreateProgramBinaryDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *program_name = nullptr,
+    const char *build_option = nullptr,
+    flatbuffers::Offset<mindspore::schema::TuneParam> tune = 0,
+    const std::vector<uint8_t> *data = nullptr) {
+  auto program_name__ = program_name ? _fbb.CreateString(program_name) : 0;
+  auto build_option__ = build_option ? _fbb.CreateString(build_option) : 0;
+  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
+  return mindspore::schema::CreateProgramBinary(
+      _fbb,
+      program_name__,
+      build_option__,
+      tune,
+      data__);
+}
+
+struct GpuCache FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GpuCacheBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NAME = 4,
+    VT_VERSION = 6,
+    VT_ALLBINS = 8
+  };
+  const flatbuffers::String *name() const {
+    return GetPointer<const flatbuffers::String *>(VT_NAME);
+  }
+  const flatbuffers::String *version() const {
+    return GetPointer<const flatbuffers::String *>(VT_VERSION);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ProgramBinary>> *allBins() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ProgramBinary>> *>(VT_ALLBINS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_NAME) &&
+           verifier.VerifyString(name()) &&
+           VerifyOffset(verifier, VT_VERSION) &&
+           verifier.VerifyString(version()) &&
+           VerifyOffset(verifier, VT_ALLBINS) &&
+           verifier.VerifyVector(allBins()) &&
+           verifier.VerifyVectorOfTables(allBins()) &&
+           verifier.EndTable();
+  }
+};
+
+struct GpuCacheBuilder {
+  typedef GpuCache Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
+    fbb_.AddOffset(GpuCache::VT_NAME, name);
+  }
+  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
+    fbb_.AddOffset(GpuCache::VT_VERSION, version);
+  }
+  void add_allBins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ProgramBinary>>> allBins) {
+    fbb_.AddOffset(GpuCache::VT_ALLBINS, allBins);
+  }
+  explicit GpuCacheBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GpuCache> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GpuCache>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GpuCache> CreateGpuCache(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> name = 0,
+    flatbuffers::Offset<flatbuffers::String> version = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ProgramBinary>>> allBins = 0) {
+  GpuCacheBuilder builder_(_fbb);
+  builder_.add_allBins(allBins);
+  builder_.add_version(version);
+  builder_.add_name(name);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<GpuCache> CreateGpuCacheDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *name = nullptr,
+    const char *version = nullptr,
+    const std::vector<flatbuffers::Offset<mindspore::schema::ProgramBinary>> *allBins = nullptr) {
+  auto name__ = name ? _fbb.CreateString(name) : 0;
+  auto version__ = version ? _fbb.CreateString(version) : 0;
+  auto allBins__ = allBins ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::ProgramBinary>>(*allBins) : 0;
+  return mindspore::schema::CreateGpuCache(
+      _fbb,
+      name__,
+      version__,
+      allBins__);
+}
+
+inline const mindspore::schema::GpuCache *GetGpuCache(const void *buf) {
+  return flatbuffers::GetRoot<mindspore::schema::GpuCache>(buf);
+}
+
+inline const mindspore::schema::GpuCache *GetSizePrefixedGpuCache(const void *buf) {
+  return flatbuffers::GetSizePrefixedRoot<mindspore::schema::GpuCache>(buf);
+}
+
+inline bool VerifyGpuCacheBuffer(
+    flatbuffers::Verifier &verifier) {
+  return verifier.VerifyBuffer<mindspore::schema::GpuCache>(nullptr);
+}
+
+inline bool VerifySizePrefixedGpuCacheBuffer(
+    flatbuffers::Verifier &verifier) {
+  return verifier.VerifySizePrefixedBuffer<mindspore::schema::GpuCache>(nullptr);
+}
+
+inline void FinishGpuCacheBuffer(
+    flatbuffers::FlatBufferBuilder &fbb,
+    flatbuffers::Offset<mindspore::schema::GpuCache> root) {
+  fbb.Finish(root);
+}
+
+inline void FinishSizePrefixedGpuCacheBuffer(
+    flatbuffers::FlatBufferBuilder &fbb,
+    flatbuffers::Offset<mindspore::schema::GpuCache> root) {
+  fbb.FinishSizePrefixed(root);
+}
+
+}  // namespace schema
+}  // namespace mindspore
+
+#endif  // FLATBUFFERS_GENERATED_GPUCACHE_MINDSPORE_SCHEMA_H_
diff --git a/mindspore/lite/schema/inner/gpu_cache_generated.h b/mindspore/lite/schema/inner/gpu_cache_generated.h
new file mode 100644
index 00000000..7641a210
--- /dev/null
+++ b/mindspore/lite/schema/inner/gpu_cache_generated.h
@@ -0,0 +1,573 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+
+
+#ifndef FLATBUFFERS_GENERATED_GPUCACHE_MINDSPORE_SCHEMA_H_
+#define FLATBUFFERS_GENERATED_GPUCACHE_MINDSPORE_SCHEMA_H_
+
+#include "flatbuffers/flatbuffers.h"
+
+namespace mindspore {
+namespace schema {
+
+struct TuneParam;
+struct TuneParamBuilder;
+struct TuneParamT;
+
+struct ProgramBinary;
+struct ProgramBinaryBuilder;
+struct ProgramBinaryT;
+
+struct GpuCache;
+struct GpuCacheBuilder;
+struct GpuCacheT;
+
+inline const flatbuffers::TypeTable *TuneParamTypeTable();
+
+inline const flatbuffers::TypeTable *ProgramBinaryTypeTable();
+
+inline const flatbuffers::TypeTable *GpuCacheTypeTable();
+
+struct TuneParamT : public flatbuffers::NativeTable {
+  typedef TuneParam TableType;
+  std::vector<int32_t> local{};
+  std::vector<int32_t> block{};
+  std::vector<int32_t> shape{};
+  std::vector<int32_t> opPara{};
+};
+
+struct TuneParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TuneParamT NativeTableType;
+  typedef TuneParamBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TuneParamTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_LOCAL = 4,
+    VT_BLOCK = 6,
+    VT_SHAPE = 8,
+    VT_OPPARA = 10
+  };
+  const flatbuffers::Vector<int32_t> *local() const {
+    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_LOCAL);
+  }
+  flatbuffers::Vector<int32_t> *mutable_local() {
+    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_LOCAL);
+  }
+  const flatbuffers::Vector<int32_t> *block() const {
+    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK);
+  }
+  flatbuffers::Vector<int32_t> *mutable_block() {
+    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_BLOCK);
+  }
+  const flatbuffers::Vector<int32_t> *shape() const {
+    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
+  }
+  flatbuffers::Vector<int32_t> *mutable_shape() {
+    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_SHAPE);
+  }
+  const flatbuffers::Vector<int32_t> *opPara() const {
+    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OPPARA);
+  }
+  flatbuffers::Vector<int32_t> *mutable_opPara() {
+    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_OPPARA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_LOCAL) &&
+           verifier.VerifyVector(local()) &&
+           VerifyOffset(verifier, VT_BLOCK) &&
+           verifier.VerifyVector(block()) &&
+           VerifyOffset(verifier, VT_SHAPE) &&
+           verifier.VerifyVector(shape()) &&
+           VerifyOffset(verifier, VT_OPPARA) &&
+           verifier.VerifyVector(opPara()) &&
+           verifier.EndTable();
+  }
+  TuneParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TuneParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<TuneParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TuneParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TuneParamBuilder {
+  typedef TuneParam Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_local(flatbuffers::Offset<flatbuffers::Vector<int32_t>> local) {
+    fbb_.AddOffset(TuneParam::VT_LOCAL, local);
+  }
+  void add_block(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block) {
+    fbb_.AddOffset(TuneParam::VT_BLOCK, block);
+  }
+  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
+    fbb_.AddOffset(TuneParam::VT_SHAPE, shape);
+  }
+  void add_opPara(flatbuffers::Offset<flatbuffers::Vector<int32_t>> opPara) {
+    fbb_.AddOffset(TuneParam::VT_OPPARA, opPara);
+  }
+  explicit TuneParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TuneParam> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TuneParam>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TuneParam> CreateTuneParam(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int32_t>> local = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int32_t>> opPara = 0) {
+  TuneParamBuilder builder_(_fbb);
+  builder_.add_opPara(opPara);
+  builder_.add_shape(shape);
+  builder_.add_block(block);
+  builder_.add_local(local);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<TuneParam> CreateTuneParamDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int32_t> *local = nullptr,
+    const std::vector<int32_t> *block = nullptr,
+    const std::vector<int32_t> *shape = nullptr,
+    const std::vector<int32_t> *opPara = nullptr) {
+  auto local__ = local ? _fbb.CreateVector<int32_t>(*local) : 0;
+  auto block__ = block ? _fbb.CreateVector<int32_t>(*block) : 0;
+  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
+  auto opPara__ = opPara ? _fbb.CreateVector<int32_t>(*opPara) : 0;
+  return mindspore::schema::CreateTuneParam(
+      _fbb,
+      local__,
+      block__,
+      shape__,
+      opPara__);
+}
+
+flatbuffers::Offset<TuneParam> CreateTuneParam(flatbuffers::FlatBufferBuilder &_fbb, const TuneParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ProgramBinaryT : public flatbuffers::NativeTable {
+  typedef ProgramBinary TableType;
+  std::string program_name{};
+  std::string build_option{};
+  std::unique_ptr<mindspore::schema::TuneParamT> tune{};
+  std::vector<uint8_t> data{};
+};
+
+struct ProgramBinary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ProgramBinaryT NativeTableType;
+  typedef ProgramBinaryBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ProgramBinaryTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_PROGRAM_NAME = 4,
+    VT_BUILD_OPTION = 6,
+    VT_TUNE = 8,
+    VT_DATA = 10
+  };
+  const flatbuffers::String *program_name() const {
+    return GetPointer<const flatbuffers::String *>(VT_PROGRAM_NAME);
+  }
+  flatbuffers::String *mutable_program_name() {
+    return GetPointer<flatbuffers::String *>(VT_PROGRAM_NAME);
+  }
+  const flatbuffers::String *build_option() const {
+    return GetPointer<const flatbuffers::String *>(VT_BUILD_OPTION);
+  }
+  flatbuffers::String *mutable_build_option() {
+    return GetPointer<flatbuffers::String *>(VT_BUILD_OPTION);
+  }
+  const mindspore::schema::TuneParam *tune() const {
+    return GetPointer<const mindspore::schema::TuneParam *>(VT_TUNE);
+  }
+  mindspore::schema::TuneParam *mutable_tune() {
+    return GetPointer<mindspore::schema::TuneParam *>(VT_TUNE);
+  }
+  const flatbuffers::Vector<uint8_t> *data() const {
+    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
+  }
+  flatbuffers::Vector<uint8_t> *mutable_data() {
+    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_PROGRAM_NAME) &&
+           verifier.VerifyString(program_name()) &&
+           VerifyOffset(verifier, VT_BUILD_OPTION) &&
+           verifier.VerifyString(build_option()) &&
+           VerifyOffset(verifier, VT_TUNE) &&
+           verifier.VerifyTable(tune()) &&
+           VerifyOffset(verifier, VT_DATA) &&
+           verifier.VerifyVector(data()) &&
+           verifier.EndTable();
+  }
+  ProgramBinaryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ProgramBinaryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ProgramBinary> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgramBinaryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ProgramBinaryBuilder {
+  typedef ProgramBinary Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_program_name(flatbuffers::Offset<flatbuffers::String> program_name) {
+    fbb_.AddOffset(ProgramBinary::VT_PROGRAM_NAME, program_name);
+  }
+  void add_build_option(flatbuffers::Offset<flatbuffers::String> build_option) {
+    fbb_.AddOffset(ProgramBinary::VT_BUILD_OPTION, build_option);
+  }
+  void add_tune(flatbuffers::Offset<mindspore::schema::TuneParam> tune) {
+    fbb_.AddOffset(ProgramBinary::VT_TUNE, tune);
+  }
+  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
+    fbb_.AddOffset(ProgramBinary::VT_DATA, data);
+  }
+  explicit ProgramBinaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ProgramBinary> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ProgramBinary>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ProgramBinary> CreateProgramBinary(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> program_name = 0,
+    flatbuffers::Offset<flatbuffers::String> build_option = 0,
+    flatbuffers::Offset<mindspore::schema::TuneParam> tune = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
+  ProgramBinaryBuilder builder_(_fbb);
+  builder_.add_data(data);
+  builder_.add_tune(tune);
+  builder_.add_build_option(build_option);
+  builder_.add_program_name(program_name);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<ProgramBinary> CreateProgramBinaryDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *program_name = nullptr,
+    const char *build_option = nullptr,
+    flatbuffers::Offset<mindspore::schema::TuneParam> tune = 0,
+    const std::vector<uint8_t> *data = nullptr) {
+  auto program_name__ = program_name ? _fbb.CreateString(program_name) : 0;
+  auto build_option__ = build_option ? _fbb.CreateString(build_option) : 0;
+  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
+  return mindspore::schema::CreateProgramBinary(
+      _fbb,
+      program_name__,
+      build_option__,
+      tune,
+      data__);
+}
+
+flatbuffers::Offset<ProgramBinary> CreateProgramBinary(flatbuffers::FlatBufferBuilder &_fbb, const ProgramBinaryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct GpuCacheT : public flatbuffers::NativeTable {
+  typedef GpuCache TableType;
+  std::string name{};
+  std::string version{};
+  std::vector<std::unique_ptr<mindspore::schema::ProgramBinaryT>> allBins{};
+};
+
+struct GpuCache FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GpuCacheT NativeTableType;
+  typedef GpuCacheBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return GpuCacheTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NAME = 4,
+    VT_VERSION = 6,
+    VT_ALLBINS = 8
+  };
+  const flatbuffers::String *name() const {
+    return GetPointer<const flatbuffers::String *>(VT_NAME);
+  }
+  flatbuffers::String *mutable_name() {
+    return GetPointer<flatbuffers::String *>(VT_NAME);
+  }
+  const flatbuffers::String *version() const {
+    return GetPointer<const flatbuffers::String *>(VT_VERSION);
+  }
+  flatbuffers::String *mutable_version() {
+    return GetPointer<flatbuffers::String *>(VT_VERSION);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ProgramBinary>> *allBins() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ProgramBinary>> *>(VT_ALLBINS);
+  }
+  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ProgramBinary>> *mutable_allBins() {
+    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ProgramBinary>> *>(VT_ALLBINS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_NAME) &&
+           verifier.VerifyString(name()) &&
+           VerifyOffset(verifier, VT_VERSION) &&
+           verifier.VerifyString(version()) &&
+           VerifyOffset(verifier, VT_ALLBINS) &&
+           verifier.VerifyVector(allBins()) &&
+           verifier.VerifyVectorOfTables(allBins()) &&
+           verifier.EndTable();
+  }
+  GpuCacheT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(GpuCacheT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<GpuCache> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GpuCacheT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct GpuCacheBuilder {
+  typedef GpuCache Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
+    fbb_.AddOffset(GpuCache::VT_NAME, name);
+  }
+  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
+    fbb_.AddOffset(GpuCache::VT_VERSION, version);
+  }
+  void add_allBins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ProgramBinary>>> allBins) {
+    fbb_.AddOffset(GpuCache::VT_ALLBINS, allBins);
+  }
+  explicit GpuCacheBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GpuCache> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GpuCache>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GpuCache> CreateGpuCache(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> name = 0,
+    flatbuffers::Offset<flatbuffers::String> version = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ProgramBinary>>> allBins = 0) {
+  GpuCacheBuilder builder_(_fbb);
+  builder_.add_allBins(allBins);
+  builder_.add_version(version);
+  builder_.add_name(name);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<GpuCache> CreateGpuCacheDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *name = nullptr,
+    const char *version = nullptr,
+    const std::vector<flatbuffers::Offset<mindspore::schema::ProgramBinary>> *allBins = nullptr) {
+  auto name__ = name ? _fbb.CreateString(name) : 0;
+  auto version__ = version ? _fbb.CreateString(version) : 0;
+  auto allBins__ = allBins ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::ProgramBinary>>(*allBins) : 0;
+  return mindspore::schema::CreateGpuCache(
+      _fbb,
+      name__,
+      version__,
+      allBins__);
+}
+
+flatbuffers::Offset<GpuCache> CreateGpuCache(flatbuffers::FlatBufferBuilder &_fbb, const GpuCacheT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+inline TuneParamT *TuneParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TuneParamT>(new TuneParamT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void TuneParam::UnPackTo(TuneParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = local(); if (_e) { _o->local.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->local[_i] = _e->Get(_i); } } }
+  { auto _e = block(); if (_e) { _o->block.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block[_i] = _e->Get(_i); } } }
+  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } }
+  { auto _e = opPara(); if (_e) { _o->opPara.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->opPara[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<TuneParam> TuneParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TuneParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTuneParam(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<TuneParam> CreateTuneParam(flatbuffers::FlatBufferBuilder &_fbb, const TuneParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TuneParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _local = _o->local.size() ? _fbb.CreateVector(_o->local) : 0;
+  auto _block = _o->block.size() ? _fbb.CreateVector(_o->block) : 0;
+  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
+  auto _opPara = _o->opPara.size() ? _fbb.CreateVector(_o->opPara) : 0;
+  return mindspore::schema::CreateTuneParam(
+      _fbb,
+      _local,
+      _block,
+      _shape,
+      _opPara);
+}
+
+inline ProgramBinaryT *ProgramBinary::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ProgramBinaryT>(new ProgramBinaryT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ProgramBinary::UnPackTo(ProgramBinaryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = program_name(); if (_e) _o->program_name = _e->str(); }
+  { auto _e = build_option(); if (_e) _o->build_option = _e->str(); }
+  { auto _e = tune(); if (_e) _o->tune = std::unique_ptr<mindspore::schema::TuneParamT>(_e->UnPack(_resolver)); }
+  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
+}
+
+inline flatbuffers::Offset<ProgramBinary> ProgramBinary::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgramBinaryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateProgramBinary(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ProgramBinary> CreateProgramBinary(flatbuffers::FlatBufferBuilder &_fbb, const ProgramBinaryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProgramBinaryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _program_name = _o->program_name.empty() ? 0 : _fbb.CreateString(_o->program_name);
+  auto _build_option = _o->build_option.empty() ? 0 : _fbb.CreateString(_o->build_option);
+  auto _tune = _o->tune ? CreateTuneParam(_fbb, _o->tune.get(), _rehasher) : 0;
+  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
+  return mindspore::schema::CreateProgramBinary(
+      _fbb,
+      _program_name,
+      _build_option,
+      _tune,
+      _data);
+}
+
+inline GpuCacheT *GpuCache::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<GpuCacheT>(new GpuCacheT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void GpuCache::UnPackTo(GpuCacheT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = name(); if (_e) _o->name = _e->str(); }
+  { auto _e = version(); if (_e) _o->version = _e->str(); }
+  { auto _e = allBins(); if (_e) { _o->allBins.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->allBins[_i] = std::unique_ptr<mindspore::schema::ProgramBinaryT>(_e->Get(_i)->UnPack(_resolver)); } } }
+}
+
+inline flatbuffers::Offset<GpuCache> GpuCache::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GpuCacheT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateGpuCache(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<GpuCache> CreateGpuCache(flatbuffers::FlatBufferBuilder &_fbb, const GpuCacheT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GpuCacheT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
+  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
+  auto _allBins = _o->allBins.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::ProgramBinary>> (_o->allBins.size(), [](size_t i, _VectorArgs *__va) { return CreateProgramBinary(*__va->__fbb, __va->__o->allBins[i].get(), __va->__rehasher); }, &_va ) : 0;
+  return mindspore::schema::CreateGpuCache(
+      _fbb,
+      _name,
+      _version,
+      _allBins);
+}
+
+inline const flatbuffers::TypeTable *TuneParamTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 1, -1 },
+    { flatbuffers::ET_INT, 1, -1 },
+    { flatbuffers::ET_INT, 1, -1 },
+    { flatbuffers::ET_INT, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ProgramBinaryTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_SEQUENCE, 0, 0 },
+    { flatbuffers::ET_UCHAR, 1, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::TuneParamTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *GpuCacheTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_SEQUENCE, 1, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ProgramBinaryTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const mindspore::schema::GpuCache *GetGpuCache(const void *buf) {
+  return flatbuffers::GetRoot<mindspore::schema::GpuCache>(buf);
+}
+
+inline const mindspore::schema::GpuCache *GetSizePrefixedGpuCache(const void *buf) {
+  return flatbuffers::GetSizePrefixedRoot<mindspore::schema::GpuCache>(buf);
+}
+
+inline GpuCache *GetMutableGpuCache(void *buf) {
+  return flatbuffers::GetMutableRoot<GpuCache>(buf);
+}
+
+inline bool VerifyGpuCacheBuffer(
+    flatbuffers::Verifier &verifier) {
+  return verifier.VerifyBuffer<mindspore::schema::GpuCache>(nullptr);
+}
+
+inline bool VerifySizePrefixedGpuCacheBuffer(
+    flatbuffers::Verifier &verifier) {
+  return verifier.VerifySizePrefixedBuffer<mindspore::schema::GpuCache>(nullptr);
+}
+
+inline void FinishGpuCacheBuffer(
+    flatbuffers::FlatBufferBuilder &fbb,
+    flatbuffers::Offset<mindspore::schema::GpuCache> root) {
+  fbb.Finish(root);
+}
+
+inline void FinishSizePrefixedGpuCacheBuffer(
+    flatbuffers::FlatBufferBuilder &fbb,
+    flatbuffers::Offset<mindspore::schema::GpuCache> root) {
+  fbb.FinishSizePrefixed(root);
+}
+
+inline std::unique_ptr<mindspore::schema::GpuCacheT> UnPackGpuCache(
+    const void *buf,
+    const flatbuffers::resolver_function_t *res = nullptr) {
+  return std::unique_ptr<mindspore::schema::GpuCacheT>(GetGpuCache(buf)->UnPack(res));
+}
+
+inline std::unique_ptr<mindspore::schema::GpuCacheT> UnPackSizePrefixedGpuCache(
+    const void *buf,
+    const flatbuffers::resolver_function_t *res = nullptr) {
+  return std::unique_ptr<mindspore::schema::GpuCacheT>(GetSizePrefixedGpuCache(buf)->UnPack(res));
+}
+
+}  // namespace schema
+}  // namespace mindspore
+
+#endif  // FLATBUFFERS_GENERATED_GPUCACHE_MINDSPORE_SCHEMA_H_
diff --git a/mindspore/lite/schema/inner/model_generated.h b/mindspore/lite/schema/inner/model_generated.h
new file mode 100644
index 00000000..1a134024
--- /dev/null
+++ b/mindspore/lite/schema/inner/model_generated.h
@@ -0,0 +1,3377 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+
+
+#ifndef FLATBUFFERS_GENERATED_MODEL_MINDSPORE_SCHEMA_H_
+#define FLATBUFFERS_GENERATED_MODEL_MINDSPORE_SCHEMA_H_
+
+#include "flatbuffers/flatbuffers.h"
+
+#include "ops_types_generated.h"
+#include "ops_generated.h"
+
+namespace mindspore {
+namespace schema {
+
+struct QuantParam;
+struct QuantParamBuilder;
+struct QuantParamT;
+
+struct ExternalData;
+struct ExternalDataBuilder;
+struct ExternalDataT;
+
+struct Tensor;
+struct TensorBuilder;
+struct TensorT;
+
+struct Primitive;
+struct PrimitiveBuilder;
+struct PrimitiveT;
+
+struct CNode;
+struct CNodeBuilder;
+struct CNodeT;
+
+struct SubGraph;
+struct SubGraphBuilder;
+struct SubGraphT;
+
+struct MetaGraph;
+struct MetaGraphBuilder;
+struct MetaGraphT;
+
+inline const flatbuffers::TypeTable *QuantParamTypeTable();
+
+inline const flatbuffers::TypeTable *ExternalDataTypeTable();
+
+inline const flatbuffers::TypeTable *TensorTypeTable();
+
+inline const flatbuffers::TypeTable *PrimitiveTypeTable();
+
+inline const flatbuffers::TypeTable *CNodeTypeTable();
+
+inline const flatbuffers::TypeTable *SubGraphTypeTable();
+
+inline const flatbuffers::TypeTable *MetaGraphTypeTable();
+
+enum WeightQunatCompressType : int32_t {
+  WeightQunatCompressType_NONE = 0,
+  WeightQunatCompressType_INDEXING = 1,
+  WeightQunatCompressType_SPARSE = 2,
+  WeightQunatCompressType_FSE = 3,
+  WeightQunatCompressType_MIN = WeightQunatCompressType_NONE,
+  WeightQunatCompressType_MAX = WeightQunatCompressType_FSE
+};
+
+inline const WeightQunatCompressType (&EnumValuesWeightQunatCompressType())[4] {
+  static const WeightQunatCompressType values[] = {
+    WeightQunatCompressType_NONE,
+    WeightQunatCompressType_INDEXING,
+    WeightQunatCompressType_SPARSE,
+    WeightQunatCompressType_FSE
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesWeightQunatCompressType() {
+  static const char * const names[5] = {
+    "NONE",
+    "INDEXING",
+    "SPARSE",
+    "FSE",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameWeightQunatCompressType(WeightQunatCompressType e) {
+  if (flatbuffers::IsOutRange(e, WeightQunatCompressType_NONE, WeightQunatCompressType_FSE)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesWeightQunatCompressType()[index];
+}
+
+enum QuantType : int32_t {
+  QuantType_QUANT_NONE = 0,
+  QuantType_AwareTraining = 1,
+  QuantType_WeightQuant = 2,
+  QuantType_PostTraining = 3,
+  QuantType_QUANT_WEIGHT = 4,
+  QuantType_QUANT_ALL = 5,
+  QuantType_QUANT_DYNAMIC = 6,
+  QuantType_MIN = QuantType_QUANT_NONE,
+  QuantType_MAX = QuantType_QUANT_DYNAMIC
+};
+
+inline const QuantType (&EnumValuesQuantType())[7] {
+  static const QuantType values[] = {
+    QuantType_QUANT_NONE,
+    QuantType_AwareTraining,
+    QuantType_WeightQuant,
+    QuantType_PostTraining,
+    QuantType_QUANT_WEIGHT,
+    QuantType_QUANT_ALL,
+    QuantType_QUANT_DYNAMIC
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesQuantType() {
+  static const char * const names[8] = {
+    "QUANT_NONE",
+    "AwareTraining",
+    "WeightQuant",
+    "PostTraining",
+    "QUANT_WEIGHT",
+    "QUANT_ALL",
+    "QUANT_DYNAMIC",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameQuantType(QuantType e) {
+  if (flatbuffers::IsOutRange(e, QuantType_QUANT_NONE, QuantType_QUANT_DYNAMIC)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesQuantType()[index];
+}
+
+struct QuantParamT : public flatbuffers::NativeTable {
+  typedef QuantParam TableType;
+  double scale = 1.0;
+  int32_t zeroPoint = 0;
+  double min = 0.0;
+  double max = 0.0;
+  bool narrowRange = true;
+  int32_t numBits = 8;
+  bool inited = false;
+  float varCorr = 1.0f;
+  float meanCorr = 0.0f;
+  int32_t dstDtype = 32;
+  int32_t roundType = 1;
+  int32_t multiplier = 1;
+};
+
+struct QuantParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef QuantParamT NativeTableType;
+  typedef QuantParamBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return QuantParamTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SCALE = 4,
+    VT_ZEROPOINT = 6,
+    VT_MIN = 8,
+    VT_MAX = 10,
+    VT_NARROWRANGE = 12,
+    VT_NUMBITS = 14,
+    VT_INITED = 16,
+    VT_VARCORR = 18,
+    VT_MEANCORR = 20,
+    VT_DSTDTYPE = 22,
+    VT_ROUNDTYPE = 24,
+    VT_MULTIPLIER = 26
+  };
+  double scale() const {
+    return GetField<double>(VT_SCALE, 1.0);
+  }
+  bool mutate_scale(double _scale) {
+    return SetField<double>(VT_SCALE, _scale, 1.0);
+  }
+  int32_t zeroPoint() const {
+    return GetField<int32_t>(VT_ZEROPOINT, 0);
+  }
+  bool mutate_zeroPoint(int32_t _zeroPoint) {
+    return SetField<int32_t>(VT_ZEROPOINT, _zeroPoint, 0);
+  }
+  double min() const {
+    return GetField<double>(VT_MIN, 0.0);
+  }
+  bool mutate_min(double _min) {
+    return SetField<double>(VT_MIN, _min, 0.0);
+  }
+  double max() const {
+    return GetField<double>(VT_MAX, 0.0);
+  }
+  bool mutate_max(double _max) {
+    return SetField<double>(VT_MAX, _max, 0.0);
+  }
+  bool narrowRange() const {
+    return GetField<uint8_t>(VT_NARROWRANGE, 1) != 0;
+  }
+  bool mutate_narrowRange(bool _narrowRange) {
+    return SetField<uint8_t>(VT_NARROWRANGE, static_cast<uint8_t>(_narrowRange), 1);
+  }
+  int32_t numBits() const {
+    return GetField<int32_t>(VT_NUMBITS, 8);
+  }
+  bool mutate_numBits(int32_t _numBits) {
+    return SetField<int32_t>(VT_NUMBITS, _numBits, 8);
+  }
+  bool inited() const {
+    return GetField<uint8_t>(VT_INITED, 0) != 0;
+  }
+  bool mutate_inited(bool _inited) {
+    return SetField<uint8_t>(VT_INITED, static_cast<uint8_t>(_inited), 0);
+  }
+  float varCorr() const {
+    return GetField<float>(VT_VARCORR, 1.0f);
+  }
+  bool mutate_varCorr(float _varCorr) {
+    return SetField<float>(VT_VARCORR, _varCorr, 1.0f);
+  }
+  float meanCorr() const {
+    return GetField<float>(VT_MEANCORR, 0.0f);
+  }
+  bool mutate_meanCorr(float _meanCorr) {
+    return SetField<float>(VT_MEANCORR, _meanCorr, 0.0f);
+  }
+  int32_t dstDtype() const {
+    return GetField<int32_t>(VT_DSTDTYPE, 32);
+  }
+  bool mutate_dstDtype(int32_t _dstDtype) {
+    return SetField<int32_t>(VT_DSTDTYPE, _dstDtype, 32);
+  }
+  int32_t roundType() const {
+    return GetField<int32_t>(VT_ROUNDTYPE, 1);
+  }
+  bool mutate_roundType(int32_t _roundType) {
+    return SetField<int32_t>(VT_ROUNDTYPE, _roundType, 1);
+  }
+  int32_t multiplier() const {
+    return GetField<int32_t>(VT_MULTIPLIER, 1);
+  }
+  bool mutate_multiplier(int32_t _multiplier) {
+    return SetField<int32_t>(VT_MULTIPLIER, _multiplier, 1);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<double>(verifier, VT_SCALE) &&
+           VerifyField<int32_t>(verifier, VT_ZEROPOINT) &&
+           VerifyField<double>(verifier, VT_MIN) &&
+           VerifyField<double>(verifier, VT_MAX) &&
+           VerifyField<uint8_t>(verifier, VT_NARROWRANGE) &&
+           VerifyField<int32_t>(verifier, VT_NUMBITS) &&
+           VerifyField<uint8_t>(verifier, VT_INITED) &&
+           VerifyField<float>(verifier, VT_VARCORR) &&
+           VerifyField<float>(verifier, VT_MEANCORR) &&
+           VerifyField<int32_t>(verifier, VT_DSTDTYPE) &&
+           VerifyField<int32_t>(verifier, VT_ROUNDTYPE) &&
+           VerifyField<int32_t>(verifier, VT_MULTIPLIER) &&
+           verifier.EndTable();
+  }
+  QuantParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(QuantParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<QuantParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct QuantParamBuilder {
+  typedef QuantParam Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_scale(double scale) {
+    fbb_.AddElement<double>(QuantParam::VT_SCALE, scale, 1.0);
+  }
+  void add_zeroPoint(int32_t zeroPoint) {
+    fbb_.AddElement<int32_t>(QuantParam::VT_ZEROPOINT, zeroPoint, 0);
+  }
+  void add_min(double min) {
+    fbb_.AddElement<double>(QuantParam::VT_MIN, min, 0.0);
+  }
+  void add_max(double max) {
+    fbb_.AddElement<double>(QuantParam::VT_MAX, max, 0.0);
+  }
+  void add_narrowRange(bool narrowRange) {
+    fbb_.AddElement<uint8_t>(QuantParam::VT_NARROWRANGE, static_cast<uint8_t>(narrowRange), 1);
+  }
+  void add_numBits(int32_t numBits) {
+    fbb_.AddElement<int32_t>(QuantParam::VT_NUMBITS, numBits, 8);
+  }
+  void add_inited(bool inited) {
+    fbb_.AddElement<uint8_t>(QuantParam::VT_INITED, static_cast<uint8_t>(inited), 0);
+  }
+  void add_varCorr(float varCorr) {
+    fbb_.AddElement<float>(QuantParam::VT_VARCORR, varCorr, 1.0f);
+  }
+  void add_meanCorr(float meanCorr) {
+    fbb_.AddElement<float>(QuantParam::VT_MEANCORR, meanCorr, 0.0f);
+  }
+  void add_dstDtype(int32_t dstDtype) {
+    fbb_.AddElement<int32_t>(QuantParam::VT_DSTDTYPE, dstDtype, 32);
+  }
+  void add_roundType(int32_t roundType) {
+    fbb_.AddElement<int32_t>(QuantParam::VT_ROUNDTYPE, roundType, 1);
+  }
+  void add_multiplier(int32_t multiplier) {
+    fbb_.AddElement<int32_t>(QuantParam::VT_MULTIPLIER, multiplier, 1);
+  }
+  explicit QuantParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<QuantParam> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<QuantParam>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<QuantParam> CreateQuantParam(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    double scale = 1.0,
+    int32_t zeroPoint = 0,
+    double min = 0.0,
+    double max = 0.0,
+    bool narrowRange = true,
+    int32_t numBits = 8,
+    bool inited = false,
+    float varCorr = 1.0f,
+    float meanCorr = 0.0f,
+    int32_t dstDtype = 32,
+    int32_t roundType = 1,
+    int32_t multiplier = 1) {
+  QuantParamBuilder builder_(_fbb);
+  builder_.add_max(max);
+  builder_.add_min(min);
+  builder_.add_scale(scale);
+  builder_.add_multiplier(multiplier);
+  builder_.add_roundType(roundType);
+  builder_.add_dstDtype(dstDtype);
+  builder_.add_meanCorr(meanCorr);
+  builder_.add_varCorr(varCorr);
+  builder_.add_numBits(numBits);
+  builder_.add_zeroPoint(zeroPoint);
+  builder_.add_inited(inited);
+  builder_.add_narrowRange(narrowRange);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<QuantParam> CreateQuantParam(flatbuffers::FlatBufferBuilder &_fbb, const QuantParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ExternalDataT : public flatbuffers::NativeTable {
+  typedef ExternalData TableType;
+  std::string checkSum{};
+  std::string location{};
+  int64_t offset = 0;
+  int64_t length = -1LL;
+};
+
+struct ExternalData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ExternalDataT NativeTableType;
+  typedef ExternalDataBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ExternalDataTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_CHECKSUM = 4,
+    VT_LOCATION = 6,
+    VT_OFFSET = 8,
+    VT_LENGTH = 10
+  };
+  const flatbuffers::String *checkSum() const {
+    return GetPointer<const flatbuffers::String *>(VT_CHECKSUM);
+  }
+  flatbuffers::String *mutable_checkSum() {
+    return GetPointer<flatbuffers::String *>(VT_CHECKSUM);
+  }
+  const flatbuffers::String *location() const {
+    return GetPointer<const flatbuffers::String *>(VT_LOCATION);
+  }
+  flatbuffers::String *mutable_location() {
+    return GetPointer<flatbuffers::String *>(VT_LOCATION);
+  }
+  int64_t offset() const {
+    return GetField<int64_t>(VT_OFFSET, 0);
+  }
+  bool mutate_offset(int64_t _offset) {
+    return SetField<int64_t>(VT_OFFSET, _offset, 0);
+  }
+  int64_t length() const {
+    return GetField<int64_t>(VT_LENGTH, -1LL);
+  }
+  bool mutate_length(int64_t _length) {
+    return SetField<int64_t>(VT_LENGTH, _length, -1LL);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_CHECKSUM) &&
+           verifier.VerifyString(checkSum()) &&
+           VerifyOffset(verifier, VT_LOCATION) &&
+           verifier.VerifyString(location()) &&
+           VerifyField<int64_t>(verifier, VT_OFFSET) &&
+           VerifyField<int64_t>(verifier, VT_LENGTH) &&
+           verifier.EndTable();
+  }
+  ExternalDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ExternalDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ExternalData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExternalDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ExternalDataBuilder {
+  typedef ExternalData Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_checkSum(flatbuffers::Offset<flatbuffers::String> checkSum) {
+    fbb_.AddOffset(ExternalData::VT_CHECKSUM, checkSum);
+  }
+  void add_location(flatbuffers::Offset<flatbuffers::String> location) {
+    fbb_.AddOffset(ExternalData::VT_LOCATION, location);
+  }
+  void add_offset(int64_t offset) {
+    fbb_.AddElement<int64_t>(ExternalData::VT_OFFSET, offset, 0);
+  }
+  void add_length(int64_t length) {
+    fbb_.AddElement<int64_t>(ExternalData::VT_LENGTH, length, -1LL);
+  }
+  explicit ExternalDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ExternalData> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ExternalData>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ExternalData> CreateExternalData(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> checkSum = 0,
+    flatbuffers::Offset<flatbuffers::String> location = 0,
+    int64_t offset = 0,
+    int64_t length = -1LL) {
+  ExternalDataBuilder builder_(_fbb);
+  builder_.add_length(length);
+  builder_.add_offset(offset);
+  builder_.add_location(location);
+  builder_.add_checkSum(checkSum);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<ExternalData> CreateExternalDataDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *checkSum = nullptr,
+    const char *location = nullptr,
+    int64_t offset = 0,
+    int64_t length = -1LL) {
+  auto checkSum__ = checkSum ? _fbb.CreateString(checkSum) : 0;
+  auto location__ = location ? _fbb.CreateString(location) : 0;
+  return mindspore::schema::CreateExternalData(
+      _fbb,
+      checkSum__,
+      location__,
+      offset,
+      length);
+}
+
+flatbuffers::Offset<ExternalData> CreateExternalData(flatbuffers::FlatBufferBuilder &_fbb, const ExternalDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct TensorT : public flatbuffers::NativeTable {
+  typedef Tensor TableType;
+  int32_t nodeType = 0;
+  int32_t dataType = 0;
+  std::vector<int32_t> dims{};
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  int32_t refCount = 0;
+  int32_t offset = 0;
+  std::vector<uint8_t> data{};
+  std::vector<std::unique_ptr<mindspore::schema::QuantParamT>> quantParams{};
+  std::vector<float> quantClusters{};
+  std::string name{};
+  bool enableHuffmanCode = false;
+  mindspore::schema::WeightQunatCompressType weightQunatCompressType = mindspore::schema::WeightQunatCompressType_NONE;
+  std::vector<std::unique_ptr<mindspore::schema::ExternalDataT>> externalData{};
+};
+
+struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorT NativeTableType;
+  typedef TensorBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TensorTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NODETYPE = 4,
+    VT_DATATYPE = 6,
+    VT_DIMS = 8,
+    VT_FORMAT = 10,
+    VT_REFCOUNT = 12,
+    VT_OFFSET = 14,
+    VT_DATA = 16,
+    VT_QUANTPARAMS = 18,
+    VT_QUANTCLUSTERS = 20,
+    VT_NAME = 22,
+    VT_ENABLEHUFFMANCODE = 24,
+    VT_WEIGHTQUNATCOMPRESSTYPE = 26,
+    VT_EXTERNALDATA = 28
+  };
+  int32_t nodeType() const {
+    return GetField<int32_t>(VT_NODETYPE, 0);
+  }
+  bool mutate_nodeType(int32_t _nodeType) {
+    return SetField<int32_t>(VT_NODETYPE, _nodeType, 0);
+  }
+  int32_t dataType() const {
+    return GetField<int32_t>(VT_DATATYPE, 0);
+  }
+  bool mutate_dataType(int32_t _dataType) {
+    return SetField<int32_t>(VT_DATATYPE, _dataType, 0);
+  }
+  const flatbuffers::Vector<int32_t> *dims() const {
+    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
+  }
+  flatbuffers::Vector<int32_t> *mutable_dims() {
+    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_DIMS);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  int32_t refCount() const {
+    return GetField<int32_t>(VT_REFCOUNT, 0);
+  }
+  bool mutate_refCount(int32_t _refCount) {
+    return SetField<int32_t>(VT_REFCOUNT, _refCount, 0);
+  }
+  int32_t offset() const {
+    return GetField<int32_t>(VT_OFFSET, 0);
+  }
+  bool mutate_offset(int32_t _offset) {
+    return SetField<int32_t>(VT_OFFSET, _offset, 0);
+  }
+  const flatbuffers::Vector<uint8_t> *data() const {
+    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
+  }
+  flatbuffers::Vector<uint8_t> *mutable_data() {
+    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::QuantParam>> *quantParams() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::QuantParam>> *>(VT_QUANTPARAMS);
+  }
+  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::QuantParam>> *mutable_quantParams() {
+    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::QuantParam>> *>(VT_QUANTPARAMS);
+  }
+  const flatbuffers::Vector<float> *quantClusters() const {
+    return GetPointer<const flatbuffers::Vector<float> *>(VT_QUANTCLUSTERS);
+  }
+  flatbuffers::Vector<float> *mutable_quantClusters() {
+    return GetPointer<flatbuffers::Vector<float> *>(VT_QUANTCLUSTERS);
+  }
+  const flatbuffers::String *name() const {
+    return GetPointer<const flatbuffers::String *>(VT_NAME);
+  }
+  flatbuffers::String *mutable_name() {
+    return GetPointer<flatbuffers::String *>(VT_NAME);
+  }
+  bool enableHuffmanCode() const {
+    return GetField<uint8_t>(VT_ENABLEHUFFMANCODE, 0) != 0;
+  }
+  bool mutate_enableHuffmanCode(bool _enableHuffmanCode) {
+    return SetField<uint8_t>(VT_ENABLEHUFFMANCODE, static_cast<uint8_t>(_enableHuffmanCode), 0);
+  }
+  mindspore::schema::WeightQunatCompressType weightQunatCompressType() const {
+    return static_cast<mindspore::schema::WeightQunatCompressType>(GetField<int32_t>(VT_WEIGHTQUNATCOMPRESSTYPE, 0));
+  }
+  bool mutate_weightQunatCompressType(mindspore::schema::WeightQunatCompressType _weightQunatCompressType) {
+    return SetField<int32_t>(VT_WEIGHTQUNATCOMPRESSTYPE, static_cast<int32_t>(_weightQunatCompressType), 0);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ExternalData>> *externalData() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ExternalData>> *>(VT_EXTERNALDATA);
+  }
+  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ExternalData>> *mutable_externalData() {
+    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ExternalData>> *>(VT_EXTERNALDATA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_NODETYPE) &&
+           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
+           VerifyOffset(verifier, VT_DIMS) &&
+           verifier.VerifyVector(dims()) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<int32_t>(verifier, VT_REFCOUNT) &&
+           VerifyField<int32_t>(verifier, VT_OFFSET) &&
+           VerifyOffset(verifier, VT_DATA) &&
+           verifier.VerifyVector(data()) &&
+           VerifyOffset(verifier, VT_QUANTPARAMS) &&
+           verifier.VerifyVector(quantParams()) &&
+           verifier.VerifyVectorOfTables(quantParams()) &&
+           VerifyOffset(verifier, VT_QUANTCLUSTERS) &&
+           verifier.VerifyVector(quantClusters()) &&
+           VerifyOffset(verifier, VT_NAME) &&
+           verifier.VerifyString(name()) &&
+           VerifyField<uint8_t>(verifier, VT_ENABLEHUFFMANCODE) &&
+           VerifyField<int32_t>(verifier, VT_WEIGHTQUNATCOMPRESSTYPE) &&
+           VerifyOffset(verifier, VT_EXTERNALDATA) &&
+           verifier.VerifyVector(externalData()) &&
+           verifier.VerifyVectorOfTables(externalData()) &&
+           verifier.EndTable();
+  }
+  TensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Tensor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TensorBuilder {
+  typedef Tensor Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_nodeType(int32_t nodeType) {
+    fbb_.AddElement<int32_t>(Tensor::VT_NODETYPE, nodeType, 0);
+  }
+  void add_dataType(int32_t dataType) {
+    fbb_.AddElement<int32_t>(Tensor::VT_DATATYPE, dataType, 0);
+  }
+  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
+    fbb_.AddOffset(Tensor::VT_DIMS, dims);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(Tensor::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_refCount(int32_t refCount) {
+    fbb_.AddElement<int32_t>(Tensor::VT_REFCOUNT, refCount, 0);
+  }
+  void add_offset(int32_t offset) {
+    fbb_.AddElement<int32_t>(Tensor::VT_OFFSET, offset, 0);
+  }
+  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
+    fbb_.AddOffset(Tensor::VT_DATA, data);
+  }
+  void add_quantParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::QuantParam>>> quantParams) {
+    fbb_.AddOffset(Tensor::VT_QUANTPARAMS, quantParams);
+  }
+  void add_quantClusters(flatbuffers::Offset<flatbuffers::Vector<float>> quantClusters) {
+    fbb_.AddOffset(Tensor::VT_QUANTCLUSTERS, quantClusters);
+  }
+  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
+    fbb_.AddOffset(Tensor::VT_NAME, name);
+  }
+  void add_enableHuffmanCode(bool enableHuffmanCode) {
+    fbb_.AddElement<uint8_t>(Tensor::VT_ENABLEHUFFMANCODE, static_cast<uint8_t>(enableHuffmanCode), 0);
+  }
+  void add_weightQunatCompressType(mindspore::schema::WeightQunatCompressType weightQunatCompressType) {
+    fbb_.AddElement<int32_t>(Tensor::VT_WEIGHTQUNATCOMPRESSTYPE, static_cast<int32_t>(weightQunatCompressType), 0);
+  }
+  void add_externalData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ExternalData>>> externalData) {
+    fbb_.AddOffset(Tensor::VT_EXTERNALDATA, externalData);
+  }
+  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Tensor> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Tensor>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Tensor> CreateTensor(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int32_t nodeType = 0,
+    int32_t dataType = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    int32_t refCount = 0,
+    int32_t offset = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::QuantParam>>> quantParams = 0,
+    flatbuffers::Offset<flatbuffers::Vector<float>> quantClusters = 0,
+    flatbuffers::Offset<flatbuffers::String> name = 0,
+    bool enableHuffmanCode = false,
+    mindspore::schema::WeightQunatCompressType weightQunatCompressType = mindspore::schema::WeightQunatCompressType_NONE,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ExternalData>>> externalData = 0) {
+  TensorBuilder builder_(_fbb);
+  builder_.add_externalData(externalData);
+  builder_.add_weightQunatCompressType(weightQunatCompressType);
+  builder_.add_name(name);
+  builder_.add_quantClusters(quantClusters);
+  builder_.add_quantParams(quantParams);
+  builder_.add_data(data);
+  builder_.add_offset(offset);
+  builder_.add_refCount(refCount);
+  builder_.add_format(format);
+  builder_.add_dims(dims);
+  builder_.add_dataType(dataType);
+  builder_.add_nodeType(nodeType);
+  builder_.add_enableHuffmanCode(enableHuffmanCode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Tensor> CreateTensorDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int32_t nodeType = 0,
+    int32_t dataType = 0,
+    const std::vector<int32_t> *dims = nullptr,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    int32_t refCount = 0,
+    int32_t offset = 0,
+    const std::vector<uint8_t> *data = nullptr,
+    const std::vector<flatbuffers::Offset<mindspore::schema::QuantParam>> *quantParams = nullptr,
+    const std::vector<float> *quantClusters = nullptr,
+    const char *name = nullptr,
+    bool enableHuffmanCode = false,
+    mindspore::schema::WeightQunatCompressType weightQunatCompressType = mindspore::schema::WeightQunatCompressType_NONE,
+    const std::vector<flatbuffers::Offset<mindspore::schema::ExternalData>> *externalData = nullptr) {
+  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
+  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
+  auto quantParams__ = quantParams ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::QuantParam>>(*quantParams) : 0;
+  auto quantClusters__ = quantClusters ? _fbb.CreateVector<float>(*quantClusters) : 0;
+  auto name__ = name ? _fbb.CreateString(name) : 0;
+  auto externalData__ = externalData ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::ExternalData>>(*externalData) : 0;
+  return mindspore::schema::CreateTensor(
+      _fbb,
+      nodeType,
+      dataType,
+      dims__,
+      format,
+      refCount,
+      offset,
+      data__,
+      quantParams__,
+      quantClusters__,
+      name__,
+      enableHuffmanCode,
+      weightQunatCompressType,
+      externalData__);
+}
+
+flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct PrimitiveT : public flatbuffers::NativeTable {
+  typedef Primitive TableType;
+  mindspore::schema::PrimitiveTypeUnion value{};
+};
+
+struct Primitive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PrimitiveT NativeTableType;
+  typedef PrimitiveBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return PrimitiveTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_VALUE_TYPE = 4,
+    VT_VALUE = 6
+  };
+  mindspore::schema::PrimitiveType value_type() const {
+    return static_cast<mindspore::schema::PrimitiveType>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
+  }
+  const void *value() const {
+    return GetPointer<const void *>(VT_VALUE);
+  }
+  template<typename T> const T *value_as() const;
+  const mindspore::schema::Abs *value_as_Abs() const {
+    return value_type() == mindspore::schema::PrimitiveType_Abs ? static_cast<const mindspore::schema::Abs *>(value()) : nullptr;
+  }
+  const mindspore::schema::Activation *value_as_Activation() const {
+    return value_type() == mindspore::schema::PrimitiveType_Activation ? static_cast<const mindspore::schema::Activation *>(value()) : nullptr;
+  }
+  const mindspore::schema::ActivationGrad *value_as_ActivationGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_ActivationGrad ? static_cast<const mindspore::schema::ActivationGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Adam *value_as_Adam() const {
+    return value_type() == mindspore::schema::PrimitiveType_Adam ? static_cast<const mindspore::schema::Adam *>(value()) : nullptr;
+  }
+  const mindspore::schema::AddFusion *value_as_AddFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_AddFusion ? static_cast<const mindspore::schema::AddFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::AdderFusion *value_as_AdderFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_AdderFusion ? static_cast<const mindspore::schema::AdderFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::AddGrad *value_as_AddGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_AddGrad ? static_cast<const mindspore::schema::AddGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::AddN *value_as_AddN() const {
+    return value_type() == mindspore::schema::PrimitiveType_AddN ? static_cast<const mindspore::schema::AddN *>(value()) : nullptr;
+  }
+  const mindspore::schema::All *value_as_All() const {
+    return value_type() == mindspore::schema::PrimitiveType_All ? static_cast<const mindspore::schema::All *>(value()) : nullptr;
+  }
+  const mindspore::schema::ApplyMomentum *value_as_ApplyMomentum() const {
+    return value_type() == mindspore::schema::PrimitiveType_ApplyMomentum ? static_cast<const mindspore::schema::ApplyMomentum *>(value()) : nullptr;
+  }
+  const mindspore::schema::ArgMaxFusion *value_as_ArgMaxFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_ArgMaxFusion ? static_cast<const mindspore::schema::ArgMaxFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::ArgMinFusion *value_as_ArgMinFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_ArgMinFusion ? static_cast<const mindspore::schema::ArgMinFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Assert *value_as_Assert() const {
+    return value_type() == mindspore::schema::PrimitiveType_Assert ? static_cast<const mindspore::schema::Assert *>(value()) : nullptr;
+  }
+  const mindspore::schema::Assign *value_as_Assign() const {
+    return value_type() == mindspore::schema::PrimitiveType_Assign ? static_cast<const mindspore::schema::Assign *>(value()) : nullptr;
+  }
+  const mindspore::schema::AssignAdd *value_as_AssignAdd() const {
+    return value_type() == mindspore::schema::PrimitiveType_AssignAdd ? static_cast<const mindspore::schema::AssignAdd *>(value()) : nullptr;
+  }
+  const mindspore::schema::AudioSpectrogram *value_as_AudioSpectrogram() const {
+    return value_type() == mindspore::schema::PrimitiveType_AudioSpectrogram ? static_cast<const mindspore::schema::AudioSpectrogram *>(value()) : nullptr;
+  }
+  const mindspore::schema::AvgPoolFusion *value_as_AvgPoolFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_AvgPoolFusion ? static_cast<const mindspore::schema::AvgPoolFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::AvgPoolGrad *value_as_AvgPoolGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_AvgPoolGrad ? static_cast<const mindspore::schema::AvgPoolGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::BatchNorm *value_as_BatchNorm() const {
+    return value_type() == mindspore::schema::PrimitiveType_BatchNorm ? static_cast<const mindspore::schema::BatchNorm *>(value()) : nullptr;
+  }
+  const mindspore::schema::BatchNormGrad *value_as_BatchNormGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_BatchNormGrad ? static_cast<const mindspore::schema::BatchNormGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::BatchToSpace *value_as_BatchToSpace() const {
+    return value_type() == mindspore::schema::PrimitiveType_BatchToSpace ? static_cast<const mindspore::schema::BatchToSpace *>(value()) : nullptr;
+  }
+  const mindspore::schema::BatchToSpaceND *value_as_BatchToSpaceND() const {
+    return value_type() == mindspore::schema::PrimitiveType_BatchToSpaceND ? static_cast<const mindspore::schema::BatchToSpaceND *>(value()) : nullptr;
+  }
+  const mindspore::schema::BiasAdd *value_as_BiasAdd() const {
+    return value_type() == mindspore::schema::PrimitiveType_BiasAdd ? static_cast<const mindspore::schema::BiasAdd *>(value()) : nullptr;
+  }
+  const mindspore::schema::BinaryCrossEntropy *value_as_BinaryCrossEntropy() const {
+    return value_type() == mindspore::schema::PrimitiveType_BinaryCrossEntropy ? static_cast<const mindspore::schema::BinaryCrossEntropy *>(value()) : nullptr;
+  }
+  const mindspore::schema::BinaryCrossEntropyGrad *value_as_BinaryCrossEntropyGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_BinaryCrossEntropyGrad ? static_cast<const mindspore::schema::BinaryCrossEntropyGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::BiasAddGrad *value_as_BiasAddGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_BiasAddGrad ? static_cast<const mindspore::schema::BiasAddGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::BroadcastTo *value_as_BroadcastTo() const {
+    return value_type() == mindspore::schema::PrimitiveType_BroadcastTo ? static_cast<const mindspore::schema::BroadcastTo *>(value()) : nullptr;
+  }
+  const mindspore::schema::Cast *value_as_Cast() const {
+    return value_type() == mindspore::schema::PrimitiveType_Cast ? static_cast<const mindspore::schema::Cast *>(value()) : nullptr;
+  }
+  const mindspore::schema::Ceil *value_as_Ceil() const {
+    return value_type() == mindspore::schema::PrimitiveType_Ceil ? static_cast<const mindspore::schema::Ceil *>(value()) : nullptr;
+  }
+  const mindspore::schema::Clip *value_as_Clip() const {
+    return value_type() == mindspore::schema::PrimitiveType_Clip ? static_cast<const mindspore::schema::Clip *>(value()) : nullptr;
+  }
+  const mindspore::schema::Concat *value_as_Concat() const {
+    return value_type() == mindspore::schema::PrimitiveType_Concat ? static_cast<const mindspore::schema::Concat *>(value()) : nullptr;
+  }
+  const mindspore::schema::Attention *value_as_Attention() const {
+    return value_type() == mindspore::schema::PrimitiveType_Attention ? static_cast<const mindspore::schema::Attention *>(value()) : nullptr;
+  }
+  const mindspore::schema::Conv2DBackpropFilterFusion *value_as_Conv2DBackpropFilterFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_Conv2DBackpropFilterFusion ? static_cast<const mindspore::schema::Conv2DBackpropFilterFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Conv2DBackpropInputFusion *value_as_Conv2DBackpropInputFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_Conv2DBackpropInputFusion ? static_cast<const mindspore::schema::Conv2DBackpropInputFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Conv2DFusion *value_as_Conv2DFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_Conv2DFusion ? static_cast<const mindspore::schema::Conv2DFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Conv2dTransposeFusion *value_as_Conv2dTransposeFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_Conv2dTransposeFusion ? static_cast<const mindspore::schema::Conv2dTransposeFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Cos *value_as_Cos() const {
+    return value_type() == mindspore::schema::PrimitiveType_Cos ? static_cast<const mindspore::schema::Cos *>(value()) : nullptr;
+  }
+  const mindspore::schema::ConstantOfShape *value_as_ConstantOfShape() const {
+    return value_type() == mindspore::schema::PrimitiveType_ConstantOfShape ? static_cast<const mindspore::schema::ConstantOfShape *>(value()) : nullptr;
+  }
+  const mindspore::schema::Crop *value_as_Crop() const {
+    return value_type() == mindspore::schema::PrimitiveType_Crop ? static_cast<const mindspore::schema::Crop *>(value()) : nullptr;
+  }
+  const mindspore::schema::CustomExtractFeatures *value_as_CustomExtractFeatures() const {
+    return value_type() == mindspore::schema::PrimitiveType_CustomExtractFeatures ? static_cast<const mindspore::schema::CustomExtractFeatures *>(value()) : nullptr;
+  }
+  const mindspore::schema::CustomNormalize *value_as_CustomNormalize() const {
+    return value_type() == mindspore::schema::PrimitiveType_CustomNormalize ? static_cast<const mindspore::schema::CustomNormalize *>(value()) : nullptr;
+  }
+  const mindspore::schema::CustomPredict *value_as_CustomPredict() const {
+    return value_type() == mindspore::schema::PrimitiveType_CustomPredict ? static_cast<const mindspore::schema::CustomPredict *>(value()) : nullptr;
+  }
+  const mindspore::schema::DeConv2DGradFilter *value_as_DeConv2DGradFilter() const {
+    return value_type() == mindspore::schema::PrimitiveType_DeConv2DGradFilter ? static_cast<const mindspore::schema::DeConv2DGradFilter *>(value()) : nullptr;
+  }
+  const mindspore::schema::Depend *value_as_Depend() const {
+    return value_type() == mindspore::schema::PrimitiveType_Depend ? static_cast<const mindspore::schema::Depend *>(value()) : nullptr;
+  }
+  const mindspore::schema::DepthToSpace *value_as_DepthToSpace() const {
+    return value_type() == mindspore::schema::PrimitiveType_DepthToSpace ? static_cast<const mindspore::schema::DepthToSpace *>(value()) : nullptr;
+  }
+  const mindspore::schema::DetectionPostProcess *value_as_DetectionPostProcess() const {
+    return value_type() == mindspore::schema::PrimitiveType_DetectionPostProcess ? static_cast<const mindspore::schema::DetectionPostProcess *>(value()) : nullptr;
+  }
+  const mindspore::schema::DivFusion *value_as_DivFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_DivFusion ? static_cast<const mindspore::schema::DivFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::DivGrad *value_as_DivGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_DivGrad ? static_cast<const mindspore::schema::DivGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Dropout *value_as_Dropout() const {
+    return value_type() == mindspore::schema::PrimitiveType_Dropout ? static_cast<const mindspore::schema::Dropout *>(value()) : nullptr;
+  }
+  const mindspore::schema::DropoutGrad *value_as_DropoutGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_DropoutGrad ? static_cast<const mindspore::schema::DropoutGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Elu *value_as_Elu() const {
+    return value_type() == mindspore::schema::PrimitiveType_Elu ? static_cast<const mindspore::schema::Elu *>(value()) : nullptr;
+  }
+  const mindspore::schema::Eltwise *value_as_Eltwise() const {
+    return value_type() == mindspore::schema::PrimitiveType_Eltwise ? static_cast<const mindspore::schema::Eltwise *>(value()) : nullptr;
+  }
+  const mindspore::schema::Equal *value_as_Equal() const {
+    return value_type() == mindspore::schema::PrimitiveType_Equal ? static_cast<const mindspore::schema::Equal *>(value()) : nullptr;
+  }
+  const mindspore::schema::EmbeddingLookupFusion *value_as_EmbeddingLookupFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_EmbeddingLookupFusion ? static_cast<const mindspore::schema::EmbeddingLookupFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::ExpFusion *value_as_ExpFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_ExpFusion ? static_cast<const mindspore::schema::ExpFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::ExpandDims *value_as_ExpandDims() const {
+    return value_type() == mindspore::schema::PrimitiveType_ExpandDims ? static_cast<const mindspore::schema::ExpandDims *>(value()) : nullptr;
+  }
+  const mindspore::schema::FakeQuantWithMinMaxVars *value_as_FakeQuantWithMinMaxVars() const {
+    return value_type() == mindspore::schema::PrimitiveType_FakeQuantWithMinMaxVars ? static_cast<const mindspore::schema::FakeQuantWithMinMaxVars *>(value()) : nullptr;
+  }
+  const mindspore::schema::FakeQuantWithMinMaxVarsPerChannel *value_as_FakeQuantWithMinMaxVarsPerChannel() const {
+    return value_type() == mindspore::schema::PrimitiveType_FakeQuantWithMinMaxVarsPerChannel ? static_cast<const mindspore::schema::FakeQuantWithMinMaxVarsPerChannel *>(value()) : nullptr;
+  }
+  const mindspore::schema::FftReal *value_as_FftReal() const {
+    return value_type() == mindspore::schema::PrimitiveType_FftReal ? static_cast<const mindspore::schema::FftReal *>(value()) : nullptr;
+  }
+  const mindspore::schema::FftImag *value_as_FftImag() const {
+    return value_type() == mindspore::schema::PrimitiveType_FftImag ? static_cast<const mindspore::schema::FftImag *>(value()) : nullptr;
+  }
+  const mindspore::schema::Flatten *value_as_Flatten() const {
+    return value_type() == mindspore::schema::PrimitiveType_Flatten ? static_cast<const mindspore::schema::Flatten *>(value()) : nullptr;
+  }
+  const mindspore::schema::FlattenGrad *value_as_FlattenGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_FlattenGrad ? static_cast<const mindspore::schema::FlattenGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Floor *value_as_Floor() const {
+    return value_type() == mindspore::schema::PrimitiveType_Floor ? static_cast<const mindspore::schema::Floor *>(value()) : nullptr;
+  }
+  const mindspore::schema::FloorDiv *value_as_FloorDiv() const {
+    return value_type() == mindspore::schema::PrimitiveType_FloorDiv ? static_cast<const mindspore::schema::FloorDiv *>(value()) : nullptr;
+  }
+  const mindspore::schema::FloorMod *value_as_FloorMod() const {
+    return value_type() == mindspore::schema::PrimitiveType_FloorMod ? static_cast<const mindspore::schema::FloorMod *>(value()) : nullptr;
+  }
+  const mindspore::schema::Fill *value_as_Fill() const {
+    return value_type() == mindspore::schema::PrimitiveType_Fill ? static_cast<const mindspore::schema::Fill *>(value()) : nullptr;
+  }
+  const mindspore::schema::FullConnection *value_as_FullConnection() const {
+    return value_type() == mindspore::schema::PrimitiveType_FullConnection ? static_cast<const mindspore::schema::FullConnection *>(value()) : nullptr;
+  }
+  const mindspore::schema::FusedBatchNorm *value_as_FusedBatchNorm() const {
+    return value_type() == mindspore::schema::PrimitiveType_FusedBatchNorm ? static_cast<const mindspore::schema::FusedBatchNorm *>(value()) : nullptr;
+  }
+  const mindspore::schema::Gather *value_as_Gather() const {
+    return value_type() == mindspore::schema::PrimitiveType_Gather ? static_cast<const mindspore::schema::Gather *>(value()) : nullptr;
+  }
+  const mindspore::schema::GatherNd *value_as_GatherNd() const {
+    return value_type() == mindspore::schema::PrimitiveType_GatherNd ? static_cast<const mindspore::schema::GatherNd *>(value()) : nullptr;
+  }
+  const mindspore::schema::Greater *value_as_Greater() const {
+    return value_type() == mindspore::schema::PrimitiveType_Greater ? static_cast<const mindspore::schema::Greater *>(value()) : nullptr;
+  }
+  const mindspore::schema::GreaterEqual *value_as_GreaterEqual() const {
+    return value_type() == mindspore::schema::PrimitiveType_GreaterEqual ? static_cast<const mindspore::schema::GreaterEqual *>(value()) : nullptr;
+  }
+  const mindspore::schema::HashtableLookup *value_as_HashtableLookup() const {
+    return value_type() == mindspore::schema::PrimitiveType_HashtableLookup ? static_cast<const mindspore::schema::HashtableLookup *>(value()) : nullptr;
+  }
+  const mindspore::schema::InstanceNorm *value_as_InstanceNorm() const {
+    return value_type() == mindspore::schema::PrimitiveType_InstanceNorm ? static_cast<const mindspore::schema::InstanceNorm *>(value()) : nullptr;
+  }
+  const mindspore::schema::LayerNormFusion *value_as_LayerNormFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_LayerNormFusion ? static_cast<const mindspore::schema::LayerNormFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::LeakyRelu *value_as_LeakyRelu() const {
+    return value_type() == mindspore::schema::PrimitiveType_LeakyRelu ? static_cast<const mindspore::schema::LeakyRelu *>(value()) : nullptr;
+  }
+  const mindspore::schema::Less *value_as_Less() const {
+    return value_type() == mindspore::schema::PrimitiveType_Less ? static_cast<const mindspore::schema::Less *>(value()) : nullptr;
+  }
+  const mindspore::schema::LessEqual *value_as_LessEqual() const {
+    return value_type() == mindspore::schema::PrimitiveType_LessEqual ? static_cast<const mindspore::schema::LessEqual *>(value()) : nullptr;
+  }
+  const mindspore::schema::Log *value_as_Log() const {
+    return value_type() == mindspore::schema::PrimitiveType_Log ? static_cast<const mindspore::schema::Log *>(value()) : nullptr;
+  }
+  const mindspore::schema::LogGrad *value_as_LogGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_LogGrad ? static_cast<const mindspore::schema::LogGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::LogicalAnd *value_as_LogicalAnd() const {
+    return value_type() == mindspore::schema::PrimitiveType_LogicalAnd ? static_cast<const mindspore::schema::LogicalAnd *>(value()) : nullptr;
+  }
+  const mindspore::schema::LogicalNot *value_as_LogicalNot() const {
+    return value_type() == mindspore::schema::PrimitiveType_LogicalNot ? static_cast<const mindspore::schema::LogicalNot *>(value()) : nullptr;
+  }
+  const mindspore::schema::LogicalOr *value_as_LogicalOr() const {
+    return value_type() == mindspore::schema::PrimitiveType_LogicalOr ? static_cast<const mindspore::schema::LogicalOr *>(value()) : nullptr;
+  }
+  const mindspore::schema::LpNormalization *value_as_LpNormalization() const {
+    return value_type() == mindspore::schema::PrimitiveType_LpNormalization ? static_cast<const mindspore::schema::LpNormalization *>(value()) : nullptr;
+  }
+  const mindspore::schema::LRN *value_as_LRN() const {
+    return value_type() == mindspore::schema::PrimitiveType_LRN ? static_cast<const mindspore::schema::LRN *>(value()) : nullptr;
+  }
+  const mindspore::schema::LshProjection *value_as_LshProjection() const {
+    return value_type() == mindspore::schema::PrimitiveType_LshProjection ? static_cast<const mindspore::schema::LshProjection *>(value()) : nullptr;
+  }
+  const mindspore::schema::LSTM *value_as_LSTM() const {
+    return value_type() == mindspore::schema::PrimitiveType_LSTM ? static_cast<const mindspore::schema::LSTM *>(value()) : nullptr;
+  }
+  const mindspore::schema::L2NormalizeFusion *value_as_L2NormalizeFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_L2NormalizeFusion ? static_cast<const mindspore::schema::L2NormalizeFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::MatMulFusion *value_as_MatMulFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_MatMulFusion ? static_cast<const mindspore::schema::MatMulFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Maximum *value_as_Maximum() const {
+    return value_type() == mindspore::schema::PrimitiveType_Maximum ? static_cast<const mindspore::schema::Maximum *>(value()) : nullptr;
+  }
+  const mindspore::schema::MaximumGrad *value_as_MaximumGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_MaximumGrad ? static_cast<const mindspore::schema::MaximumGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::MaxPoolFusion *value_as_MaxPoolFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_MaxPoolFusion ? static_cast<const mindspore::schema::MaxPoolFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::MaxPoolGrad *value_as_MaxPoolGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_MaxPoolGrad ? static_cast<const mindspore::schema::MaxPoolGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::SwitchLayer *value_as_SwitchLayer() const {
+    return value_type() == mindspore::schema::PrimitiveType_SwitchLayer ? static_cast<const mindspore::schema::SwitchLayer *>(value()) : nullptr;
+  }
+  const mindspore::schema::Mfcc *value_as_Mfcc() const {
+    return value_type() == mindspore::schema::PrimitiveType_Mfcc ? static_cast<const mindspore::schema::Mfcc *>(value()) : nullptr;
+  }
+  const mindspore::schema::Minimum *value_as_Minimum() const {
+    return value_type() == mindspore::schema::PrimitiveType_Minimum ? static_cast<const mindspore::schema::Minimum *>(value()) : nullptr;
+  }
+  const mindspore::schema::MinimumGrad *value_as_MinimumGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_MinimumGrad ? static_cast<const mindspore::schema::MinimumGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Mod *value_as_Mod() const {
+    return value_type() == mindspore::schema::PrimitiveType_Mod ? static_cast<const mindspore::schema::Mod *>(value()) : nullptr;
+  }
+  const mindspore::schema::MulFusion *value_as_MulFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_MulFusion ? static_cast<const mindspore::schema::MulFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::MulGrad *value_as_MulGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_MulGrad ? static_cast<const mindspore::schema::MulGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Neg *value_as_Neg() const {
+    return value_type() == mindspore::schema::PrimitiveType_Neg ? static_cast<const mindspore::schema::Neg *>(value()) : nullptr;
+  }
+  const mindspore::schema::NegGrad *value_as_NegGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_NegGrad ? static_cast<const mindspore::schema::NegGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::NotEqual *value_as_NotEqual() const {
+    return value_type() == mindspore::schema::PrimitiveType_NotEqual ? static_cast<const mindspore::schema::NotEqual *>(value()) : nullptr;
+  }
+  const mindspore::schema::NonMaxSuppression *value_as_NonMaxSuppression() const {
+    return value_type() == mindspore::schema::PrimitiveType_NonMaxSuppression ? static_cast<const mindspore::schema::NonMaxSuppression *>(value()) : nullptr;
+  }
+  const mindspore::schema::OneHot *value_as_OneHot() const {
+    return value_type() == mindspore::schema::PrimitiveType_OneHot ? static_cast<const mindspore::schema::OneHot *>(value()) : nullptr;
+  }
+  const mindspore::schema::OnesLike *value_as_OnesLike() const {
+    return value_type() == mindspore::schema::PrimitiveType_OnesLike ? static_cast<const mindspore::schema::OnesLike *>(value()) : nullptr;
+  }
+  const mindspore::schema::PadFusion *value_as_PadFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_PadFusion ? static_cast<const mindspore::schema::PadFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::PartialFusion *value_as_PartialFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_PartialFusion ? static_cast<const mindspore::schema::PartialFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::PowerGrad *value_as_PowerGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_PowerGrad ? static_cast<const mindspore::schema::PowerGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::PowFusion *value_as_PowFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_PowFusion ? static_cast<const mindspore::schema::PowFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::PriorBox *value_as_PriorBox() const {
+    return value_type() == mindspore::schema::PrimitiveType_PriorBox ? static_cast<const mindspore::schema::PriorBox *>(value()) : nullptr;
+  }
+  const mindspore::schema::PReLUFusion *value_as_PReLUFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_PReLUFusion ? static_cast<const mindspore::schema::PReLUFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::QuantDTypeCast *value_as_QuantDTypeCast() const {
+    return value_type() == mindspore::schema::PrimitiveType_QuantDTypeCast ? static_cast<const mindspore::schema::QuantDTypeCast *>(value()) : nullptr;
+  }
+  const mindspore::schema::Rank *value_as_Rank() const {
+    return value_type() == mindspore::schema::PrimitiveType_Rank ? static_cast<const mindspore::schema::Rank *>(value()) : nullptr;
+  }
+  const mindspore::schema::Range *value_as_Range() const {
+    return value_type() == mindspore::schema::PrimitiveType_Range ? static_cast<const mindspore::schema::Range *>(value()) : nullptr;
+  }
+  const mindspore::schema::Reciprocal *value_as_Reciprocal() const {
+    return value_type() == mindspore::schema::PrimitiveType_Reciprocal ? static_cast<const mindspore::schema::Reciprocal *>(value()) : nullptr;
+  }
+  const mindspore::schema::RealDiv *value_as_RealDiv() const {
+    return value_type() == mindspore::schema::PrimitiveType_RealDiv ? static_cast<const mindspore::schema::RealDiv *>(value()) : nullptr;
+  }
+  const mindspore::schema::ReduceFusion *value_as_ReduceFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_ReduceFusion ? static_cast<const mindspore::schema::ReduceFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Reshape *value_as_Reshape() const {
+    return value_type() == mindspore::schema::PrimitiveType_Reshape ? static_cast<const mindspore::schema::Reshape *>(value()) : nullptr;
+  }
+  const mindspore::schema::Resize *value_as_Resize() const {
+    return value_type() == mindspore::schema::PrimitiveType_Resize ? static_cast<const mindspore::schema::Resize *>(value()) : nullptr;
+  }
+  const mindspore::schema::ReverseSequence *value_as_ReverseSequence() const {
+    return value_type() == mindspore::schema::PrimitiveType_ReverseSequence ? static_cast<const mindspore::schema::ReverseSequence *>(value()) : nullptr;
+  }
+  const mindspore::schema::ReverseV2 *value_as_ReverseV2() const {
+    return value_type() == mindspore::schema::PrimitiveType_ReverseV2 ? static_cast<const mindspore::schema::ReverseV2 *>(value()) : nullptr;
+  }
+  const mindspore::schema::Rfft *value_as_Rfft() const {
+    return value_type() == mindspore::schema::PrimitiveType_Rfft ? static_cast<const mindspore::schema::Rfft *>(value()) : nullptr;
+  }
+  const mindspore::schema::ROIPooling *value_as_ROIPooling() const {
+    return value_type() == mindspore::schema::PrimitiveType_ROIPooling ? static_cast<const mindspore::schema::ROIPooling *>(value()) : nullptr;
+  }
+  const mindspore::schema::Round *value_as_Round() const {
+    return value_type() == mindspore::schema::PrimitiveType_Round ? static_cast<const mindspore::schema::Round *>(value()) : nullptr;
+  }
+  const mindspore::schema::Rsqrt *value_as_Rsqrt() const {
+    return value_type() == mindspore::schema::PrimitiveType_Rsqrt ? static_cast<const mindspore::schema::Rsqrt *>(value()) : nullptr;
+  }
+  const mindspore::schema::ScaleFusion *value_as_ScaleFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_ScaleFusion ? static_cast<const mindspore::schema::ScaleFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::ScatterNd *value_as_ScatterNd() const {
+    return value_type() == mindspore::schema::PrimitiveType_ScatterNd ? static_cast<const mindspore::schema::ScatterNd *>(value()) : nullptr;
+  }
+  const mindspore::schema::SGD *value_as_SGD() const {
+    return value_type() == mindspore::schema::PrimitiveType_SGD ? static_cast<const mindspore::schema::SGD *>(value()) : nullptr;
+  }
+  const mindspore::schema::Shape *value_as_Shape() const {
+    return value_type() == mindspore::schema::PrimitiveType_Shape ? static_cast<const mindspore::schema::Shape *>(value()) : nullptr;
+  }
+  const mindspore::schema::SigmoidCrossEntropyWithLogits *value_as_SigmoidCrossEntropyWithLogits() const {
+    return value_type() == mindspore::schema::PrimitiveType_SigmoidCrossEntropyWithLogits ? static_cast<const mindspore::schema::SigmoidCrossEntropyWithLogits *>(value()) : nullptr;
+  }
+  const mindspore::schema::SigmoidCrossEntropyWithLogitsGrad *value_as_SigmoidCrossEntropyWithLogitsGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_SigmoidCrossEntropyWithLogitsGrad ? static_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Sin *value_as_Sin() const {
+    return value_type() == mindspore::schema::PrimitiveType_Sin ? static_cast<const mindspore::schema::Sin *>(value()) : nullptr;
+  }
+  const mindspore::schema::SkipGram *value_as_SkipGram() const {
+    return value_type() == mindspore::schema::PrimitiveType_SkipGram ? static_cast<const mindspore::schema::SkipGram *>(value()) : nullptr;
+  }
+  const mindspore::schema::SliceFusion *value_as_SliceFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_SliceFusion ? static_cast<const mindspore::schema::SliceFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::SmoothL1Loss *value_as_SmoothL1Loss() const {
+    return value_type() == mindspore::schema::PrimitiveType_SmoothL1Loss ? static_cast<const mindspore::schema::SmoothL1Loss *>(value()) : nullptr;
+  }
+  const mindspore::schema::SmoothL1LossGrad *value_as_SmoothL1LossGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_SmoothL1LossGrad ? static_cast<const mindspore::schema::SmoothL1LossGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Softmax *value_as_Softmax() const {
+    return value_type() == mindspore::schema::PrimitiveType_Softmax ? static_cast<const mindspore::schema::Softmax *>(value()) : nullptr;
+  }
+  const mindspore::schema::SoftmaxCrossEntropyWithLogits *value_as_SoftmaxCrossEntropyWithLogits() const {
+    return value_type() == mindspore::schema::PrimitiveType_SoftmaxCrossEntropyWithLogits ? static_cast<const mindspore::schema::SoftmaxCrossEntropyWithLogits *>(value()) : nullptr;
+  }
+  const mindspore::schema::SpaceToBatch *value_as_SpaceToBatch() const {
+    return value_type() == mindspore::schema::PrimitiveType_SpaceToBatch ? static_cast<const mindspore::schema::SpaceToBatch *>(value()) : nullptr;
+  }
+  const mindspore::schema::SpaceToBatchND *value_as_SpaceToBatchND() const {
+    return value_type() == mindspore::schema::PrimitiveType_SpaceToBatchND ? static_cast<const mindspore::schema::SpaceToBatchND *>(value()) : nullptr;
+  }
+  const mindspore::schema::SpaceToDepth *value_as_SpaceToDepth() const {
+    return value_type() == mindspore::schema::PrimitiveType_SpaceToDepth ? static_cast<const mindspore::schema::SpaceToDepth *>(value()) : nullptr;
+  }
+  const mindspore::schema::SparseSoftmaxCrossEntropyWithLogits *value_as_SparseSoftmaxCrossEntropyWithLogits() const {
+    return value_type() == mindspore::schema::PrimitiveType_SparseSoftmaxCrossEntropyWithLogits ? static_cast<const mindspore::schema::SparseSoftmaxCrossEntropyWithLogits *>(value()) : nullptr;
+  }
+  const mindspore::schema::SparseToDense *value_as_SparseToDense() const {
+    return value_type() == mindspore::schema::PrimitiveType_SparseToDense ? static_cast<const mindspore::schema::SparseToDense *>(value()) : nullptr;
+  }
+  const mindspore::schema::Split *value_as_Split() const {
+    return value_type() == mindspore::schema::PrimitiveType_Split ? static_cast<const mindspore::schema::Split *>(value()) : nullptr;
+  }
+  const mindspore::schema::Sqrt *value_as_Sqrt() const {
+    return value_type() == mindspore::schema::PrimitiveType_Sqrt ? static_cast<const mindspore::schema::Sqrt *>(value()) : nullptr;
+  }
+  const mindspore::schema::Squeeze *value_as_Squeeze() const {
+    return value_type() == mindspore::schema::PrimitiveType_Squeeze ? static_cast<const mindspore::schema::Squeeze *>(value()) : nullptr;
+  }
+  const mindspore::schema::Square *value_as_Square() const {
+    return value_type() == mindspore::schema::PrimitiveType_Square ? static_cast<const mindspore::schema::Square *>(value()) : nullptr;
+  }
+  const mindspore::schema::SquaredDifference *value_as_SquaredDifference() const {
+    return value_type() == mindspore::schema::PrimitiveType_SquaredDifference ? static_cast<const mindspore::schema::SquaredDifference *>(value()) : nullptr;
+  }
+  const mindspore::schema::Stack *value_as_Stack() const {
+    return value_type() == mindspore::schema::PrimitiveType_Stack ? static_cast<const mindspore::schema::Stack *>(value()) : nullptr;
+  }
+  const mindspore::schema::StridedSlice *value_as_StridedSlice() const {
+    return value_type() == mindspore::schema::PrimitiveType_StridedSlice ? static_cast<const mindspore::schema::StridedSlice *>(value()) : nullptr;
+  }
+  const mindspore::schema::SubFusion *value_as_SubFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_SubFusion ? static_cast<const mindspore::schema::SubFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::SubGrad *value_as_SubGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_SubGrad ? static_cast<const mindspore::schema::SubGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Switch *value_as_Switch() const {
+    return value_type() == mindspore::schema::PrimitiveType_Switch ? static_cast<const mindspore::schema::Switch *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorListFromTensor *value_as_TensorListFromTensor() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorListFromTensor ? static_cast<const mindspore::schema::TensorListFromTensor *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorListGetItem *value_as_TensorListGetItem() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorListGetItem ? static_cast<const mindspore::schema::TensorListGetItem *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorListReserve *value_as_TensorListReserve() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorListReserve ? static_cast<const mindspore::schema::TensorListReserve *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorListSetItem *value_as_TensorListSetItem() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorListSetItem ? static_cast<const mindspore::schema::TensorListSetItem *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorListStack *value_as_TensorListStack() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorListStack ? static_cast<const mindspore::schema::TensorListStack *>(value()) : nullptr;
+  }
+  const mindspore::schema::TileFusion *value_as_TileFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_TileFusion ? static_cast<const mindspore::schema::TileFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::TopKFusion *value_as_TopKFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_TopKFusion ? static_cast<const mindspore::schema::TopKFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Transpose *value_as_Transpose() const {
+    return value_type() == mindspore::schema::PrimitiveType_Transpose ? static_cast<const mindspore::schema::Transpose *>(value()) : nullptr;
+  }
+  const mindspore::schema::Unique *value_as_Unique() const {
+    return value_type() == mindspore::schema::PrimitiveType_Unique ? static_cast<const mindspore::schema::Unique *>(value()) : nullptr;
+  }
+  const mindspore::schema::UnsortedSegmentSum *value_as_UnsortedSegmentSum() const {
+    return value_type() == mindspore::schema::PrimitiveType_UnsortedSegmentSum ? static_cast<const mindspore::schema::UnsortedSegmentSum *>(value()) : nullptr;
+  }
+  const mindspore::schema::Unsqueeze *value_as_Unsqueeze() const {
+    return value_type() == mindspore::schema::PrimitiveType_Unsqueeze ? static_cast<const mindspore::schema::Unsqueeze *>(value()) : nullptr;
+  }
+  const mindspore::schema::Unstack *value_as_Unstack() const {
+    return value_type() == mindspore::schema::PrimitiveType_Unstack ? static_cast<const mindspore::schema::Unstack *>(value()) : nullptr;
+  }
+  const mindspore::schema::LSTMGrad *value_as_LSTMGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_LSTMGrad ? static_cast<const mindspore::schema::LSTMGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Where *value_as_Where() const {
+    return value_type() == mindspore::schema::PrimitiveType_Where ? static_cast<const mindspore::schema::Where *>(value()) : nullptr;
+  }
+  const mindspore::schema::ZerosLike *value_as_ZerosLike() const {
+    return value_type() == mindspore::schema::PrimitiveType_ZerosLike ? static_cast<const mindspore::schema::ZerosLike *>(value()) : nullptr;
+  }
+  const mindspore::schema::Select *value_as_Select() const {
+    return value_type() == mindspore::schema::PrimitiveType_Select ? static_cast<const mindspore::schema::Select *>(value()) : nullptr;
+  }
+  const mindspore::schema::ScatterNdUpdate *value_as_ScatterNdUpdate() const {
+    return value_type() == mindspore::schema::PrimitiveType_ScatterNdUpdate ? static_cast<const mindspore::schema::ScatterNdUpdate *>(value()) : nullptr;
+  }
+  const mindspore::schema::GRU *value_as_GRU() const {
+    return value_type() == mindspore::schema::PrimitiveType_GRU ? static_cast<const mindspore::schema::GRU *>(value()) : nullptr;
+  }
+  const mindspore::schema::NonZero *value_as_NonZero() const {
+    return value_type() == mindspore::schema::PrimitiveType_NonZero ? static_cast<const mindspore::schema::NonZero *>(value()) : nullptr;
+  }
+  const mindspore::schema::InvertPermutation *value_as_InvertPermutation() const {
+    return value_type() == mindspore::schema::PrimitiveType_InvertPermutation ? static_cast<const mindspore::schema::InvertPermutation *>(value()) : nullptr;
+  }
+  const mindspore::schema::Size *value_as_Size() const {
+    return value_type() == mindspore::schema::PrimitiveType_Size ? static_cast<const mindspore::schema::Size *>(value()) : nullptr;
+  }
+  const mindspore::schema::RandomStandardNormal *value_as_RandomStandardNormal() const {
+    return value_type() == mindspore::schema::PrimitiveType_RandomStandardNormal ? static_cast<const mindspore::schema::RandomStandardNormal *>(value()) : nullptr;
+  }
+  const mindspore::schema::CropAndResize *value_as_CropAndResize() const {
+    return value_type() == mindspore::schema::PrimitiveType_CropAndResize ? static_cast<const mindspore::schema::CropAndResize *>(value()) : nullptr;
+  }
+  const mindspore::schema::Erf *value_as_Erf() const {
+    return value_type() == mindspore::schema::PrimitiveType_Erf ? static_cast<const mindspore::schema::Erf *>(value()) : nullptr;
+  }
+  const mindspore::schema::StridedSliceGrad *value_as_StridedSliceGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_StridedSliceGrad ? static_cast<const mindspore::schema::StridedSliceGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::IsFinite *value_as_IsFinite() const {
+    return value_type() == mindspore::schema::PrimitiveType_IsFinite ? static_cast<const mindspore::schema::IsFinite *>(value()) : nullptr;
+  }
+  const mindspore::schema::LinSpace *value_as_LinSpace() const {
+    return value_type() == mindspore::schema::PrimitiveType_LinSpace ? static_cast<const mindspore::schema::LinSpace *>(value()) : nullptr;
+  }
+  const mindspore::schema::UniformReal *value_as_UniformReal() const {
+    return value_type() == mindspore::schema::PrimitiveType_UniformReal ? static_cast<const mindspore::schema::UniformReal *>(value()) : nullptr;
+  }
+  const mindspore::schema::AbsGrad *value_as_AbsGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_AbsGrad ? static_cast<const mindspore::schema::AbsGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::RsqrtGrad *value_as_RsqrtGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_RsqrtGrad ? static_cast<const mindspore::schema::RsqrtGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::SqrtGrad *value_as_SqrtGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_SqrtGrad ? static_cast<const mindspore::schema::SqrtGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::LayerNormGrad *value_as_LayerNormGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_LayerNormGrad ? static_cast<const mindspore::schema::LayerNormGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::ResizeGrad *value_as_ResizeGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_ResizeGrad ? static_cast<const mindspore::schema::ResizeGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Splice *value_as_Splice() const {
+    return value_type() == mindspore::schema::PrimitiveType_Splice ? static_cast<const mindspore::schema::Splice *>(value()) : nullptr;
+  }
+  const mindspore::schema::LogSoftmax *value_as_LogSoftmax() const {
+    return value_type() == mindspore::schema::PrimitiveType_LogSoftmax ? static_cast<const mindspore::schema::LogSoftmax *>(value()) : nullptr;
+  }
+  const mindspore::schema::Call *value_as_Call() const {
+    return value_type() == mindspore::schema::PrimitiveType_Call ? static_cast<const mindspore::schema::Call *>(value()) : nullptr;
+  }
+  const mindspore::schema::Custom *value_as_Custom() const {
+    return value_type() == mindspore::schema::PrimitiveType_Custom ? static_cast<const mindspore::schema::Custom *>(value()) : nullptr;
+  }
+  const mindspore::schema::CumSum *value_as_CumSum() const {
+    return value_type() == mindspore::schema::PrimitiveType_CumSum ? static_cast<const mindspore::schema::CumSum *>(value()) : nullptr;
+  }
+  const mindspore::schema::SplitWithOverlap *value_as_SplitWithOverlap() const {
+    return value_type() == mindspore::schema::PrimitiveType_SplitWithOverlap ? static_cast<const mindspore::schema::SplitWithOverlap *>(value()) : nullptr;
+  }
+  const mindspore::schema::GenOP *value_as_GenOP() const {
+    return value_type() == mindspore::schema::PrimitiveType_GenOP ? static_cast<const mindspore::schema::GenOP *>(value()) : nullptr;
+  }
+  const mindspore::schema::RaggedRange *value_as_RaggedRange() const {
+    return value_type() == mindspore::schema::PrimitiveType_RaggedRange ? static_cast<const mindspore::schema::RaggedRange *>(value()) : nullptr;
+  }
+  const mindspore::schema::GLU *value_as_GLU() const {
+    return value_type() == mindspore::schema::PrimitiveType_GLU ? static_cast<const mindspore::schema::GLU *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorArray *value_as_TensorArray() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorArray ? static_cast<const mindspore::schema::TensorArray *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorArrayRead *value_as_TensorArrayRead() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorArrayRead ? static_cast<const mindspore::schema::TensorArrayRead *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorArrayWrite *value_as_TensorArrayWrite() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorArrayWrite ? static_cast<const mindspore::schema::TensorArrayWrite *>(value()) : nullptr;
+  }
+  const mindspore::schema::Affine *value_as_Affine() const {
+    return value_type() == mindspore::schema::PrimitiveType_Affine ? static_cast<const mindspore::schema::Affine *>(value()) : nullptr;
+  }
+  const mindspore::schema::AllGather *value_as_AllGather() const {
+    return value_type() == mindspore::schema::PrimitiveType_AllGather ? static_cast<const mindspore::schema::AllGather *>(value()) : nullptr;
+  }
+  const mindspore::schema::ReduceScatter *value_as_ReduceScatter() const {
+    return value_type() == mindspore::schema::PrimitiveType_ReduceScatter ? static_cast<const mindspore::schema::ReduceScatter *>(value()) : nullptr;
+  }
+  const mindspore::schema::DynamicQuant *value_as_DynamicQuant() const {
+    return value_type() == mindspore::schema::PrimitiveType_DynamicQuant ? static_cast<const mindspore::schema::DynamicQuant *>(value()) : nullptr;
+  }
+  const mindspore::schema::LSTMGradData *value_as_LSTMGradData() const {
+    return value_type() == mindspore::schema::PrimitiveType_LSTMGradData ? static_cast<const mindspore::schema::LSTMGradData *>(value()) : nullptr;
+  }
+  const mindspore::schema::LSTMGradWeight *value_as_LSTMGradWeight() const {
+    return value_type() == mindspore::schema::PrimitiveType_LSTMGradWeight ? static_cast<const mindspore::schema::LSTMGradWeight *>(value()) : nullptr;
+  }
+  const mindspore::schema::RandomNormal *value_as_RandomNormal() const {
+    return value_type() == mindspore::schema::PrimitiveType_RandomNormal ? static_cast<const mindspore::schema::RandomNormal *>(value()) : nullptr;
+  }
+  const mindspore::schema::NLLLoss *value_as_NLLLoss() const {
+    return value_type() == mindspore::schema::PrimitiveType_NLLLoss ? static_cast<const mindspore::schema::NLLLoss *>(value()) : nullptr;
+  }
+  const mindspore::schema::NLLLossGrad *value_as_NLLLossGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_NLLLossGrad ? static_cast<const mindspore::schema::NLLLossGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::FormatTranspose *value_as_FormatTranspose() const {
+    return value_type() == mindspore::schema::PrimitiveType_FormatTranspose ? static_cast<const mindspore::schema::FormatTranspose *>(value()) : nullptr;
+  }
+  const mindspore::schema::GatherD *value_as_GatherD() const {
+    return value_type() == mindspore::schema::PrimitiveType_GatherD ? static_cast<const mindspore::schema::GatherD *>(value()) : nullptr;
+  }
+  const mindspore::schema::GroupNormFusion *value_as_GroupNormFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_GroupNormFusion ? static_cast<const mindspore::schema::GroupNormFusion *>(value()) : nullptr;
+  }
+  void *mutable_value() {
+    return GetPointer<void *>(VT_VALUE);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
+           VerifyOffset(verifier, VT_VALUE) &&
+           VerifyPrimitiveType(verifier, value(), value_type()) &&
+           verifier.EndTable();
+  }
+  PrimitiveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(PrimitiveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Primitive> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+template<> inline const mindspore::schema::Abs *Primitive::value_as<mindspore::schema::Abs>() const {
+  return value_as_Abs();
+}
+
+template<> inline const mindspore::schema::Activation *Primitive::value_as<mindspore::schema::Activation>() const {
+  return value_as_Activation();
+}
+
+template<> inline const mindspore::schema::ActivationGrad *Primitive::value_as<mindspore::schema::ActivationGrad>() const {
+  return value_as_ActivationGrad();
+}
+
+template<> inline const mindspore::schema::Adam *Primitive::value_as<mindspore::schema::Adam>() const {
+  return value_as_Adam();
+}
+
+template<> inline const mindspore::schema::AddFusion *Primitive::value_as<mindspore::schema::AddFusion>() const {
+  return value_as_AddFusion();
+}
+
+template<> inline const mindspore::schema::AdderFusion *Primitive::value_as<mindspore::schema::AdderFusion>() const {
+  return value_as_AdderFusion();
+}
+
+template<> inline const mindspore::schema::AddGrad *Primitive::value_as<mindspore::schema::AddGrad>() const {
+  return value_as_AddGrad();
+}
+
+template<> inline const mindspore::schema::AddN *Primitive::value_as<mindspore::schema::AddN>() const {
+  return value_as_AddN();
+}
+
+template<> inline const mindspore::schema::All *Primitive::value_as<mindspore::schema::All>() const {
+  return value_as_All();
+}
+
+template<> inline const mindspore::schema::ApplyMomentum *Primitive::value_as<mindspore::schema::ApplyMomentum>() const {
+  return value_as_ApplyMomentum();
+}
+
+template<> inline const mindspore::schema::ArgMaxFusion *Primitive::value_as<mindspore::schema::ArgMaxFusion>() const {
+  return value_as_ArgMaxFusion();
+}
+
+template<> inline const mindspore::schema::ArgMinFusion *Primitive::value_as<mindspore::schema::ArgMinFusion>() const {
+  return value_as_ArgMinFusion();
+}
+
+template<> inline const mindspore::schema::Assert *Primitive::value_as<mindspore::schema::Assert>() const {
+  return value_as_Assert();
+}
+
+template<> inline const mindspore::schema::Assign *Primitive::value_as<mindspore::schema::Assign>() const {
+  return value_as_Assign();
+}
+
+template<> inline const mindspore::schema::AssignAdd *Primitive::value_as<mindspore::schema::AssignAdd>() const {
+  return value_as_AssignAdd();
+}
+
+template<> inline const mindspore::schema::AudioSpectrogram *Primitive::value_as<mindspore::schema::AudioSpectrogram>() const {
+  return value_as_AudioSpectrogram();
+}
+
+template<> inline const mindspore::schema::AvgPoolFusion *Primitive::value_as<mindspore::schema::AvgPoolFusion>() const {
+  return value_as_AvgPoolFusion();
+}
+
+template<> inline const mindspore::schema::AvgPoolGrad *Primitive::value_as<mindspore::schema::AvgPoolGrad>() const {
+  return value_as_AvgPoolGrad();
+}
+
+template<> inline const mindspore::schema::BatchNorm *Primitive::value_as<mindspore::schema::BatchNorm>() const {
+  return value_as_BatchNorm();
+}
+
+template<> inline const mindspore::schema::BatchNormGrad *Primitive::value_as<mindspore::schema::BatchNormGrad>() const {
+  return value_as_BatchNormGrad();
+}
+
+template<> inline const mindspore::schema::BatchToSpace *Primitive::value_as<mindspore::schema::BatchToSpace>() const {
+  return value_as_BatchToSpace();
+}
+
+template<> inline const mindspore::schema::BatchToSpaceND *Primitive::value_as<mindspore::schema::BatchToSpaceND>() const {
+  return value_as_BatchToSpaceND();
+}
+
+template<> inline const mindspore::schema::BiasAdd *Primitive::value_as<mindspore::schema::BiasAdd>() const {
+  return value_as_BiasAdd();
+}
+
+template<> inline const mindspore::schema::BinaryCrossEntropy *Primitive::value_as<mindspore::schema::BinaryCrossEntropy>() const {
+  return value_as_BinaryCrossEntropy();
+}
+
+template<> inline const mindspore::schema::BinaryCrossEntropyGrad *Primitive::value_as<mindspore::schema::BinaryCrossEntropyGrad>() const {
+  return value_as_BinaryCrossEntropyGrad();
+}
+
+template<> inline const mindspore::schema::BiasAddGrad *Primitive::value_as<mindspore::schema::BiasAddGrad>() const {
+  return value_as_BiasAddGrad();
+}
+
+template<> inline const mindspore::schema::BroadcastTo *Primitive::value_as<mindspore::schema::BroadcastTo>() const {
+  return value_as_BroadcastTo();
+}
+
+template<> inline const mindspore::schema::Cast *Primitive::value_as<mindspore::schema::Cast>() const {
+  return value_as_Cast();
+}
+
+template<> inline const mindspore::schema::Ceil *Primitive::value_as<mindspore::schema::Ceil>() const {
+  return value_as_Ceil();
+}
+
+template<> inline const mindspore::schema::Clip *Primitive::value_as<mindspore::schema::Clip>() const {
+  return value_as_Clip();
+}
+
+template<> inline const mindspore::schema::Concat *Primitive::value_as<mindspore::schema::Concat>() const {
+  return value_as_Concat();
+}
+
+template<> inline const mindspore::schema::Attention *Primitive::value_as<mindspore::schema::Attention>() const {
+  return value_as_Attention();
+}
+
+template<> inline const mindspore::schema::Conv2DBackpropFilterFusion *Primitive::value_as<mindspore::schema::Conv2DBackpropFilterFusion>() const {
+  return value_as_Conv2DBackpropFilterFusion();
+}
+
+template<> inline const mindspore::schema::Conv2DBackpropInputFusion *Primitive::value_as<mindspore::schema::Conv2DBackpropInputFusion>() const {
+  return value_as_Conv2DBackpropInputFusion();
+}
+
+template<> inline const mindspore::schema::Conv2DFusion *Primitive::value_as<mindspore::schema::Conv2DFusion>() const {
+  return value_as_Conv2DFusion();
+}
+
+template<> inline const mindspore::schema::Conv2dTransposeFusion *Primitive::value_as<mindspore::schema::Conv2dTransposeFusion>() const {
+  return value_as_Conv2dTransposeFusion();
+}
+
+template<> inline const mindspore::schema::Cos *Primitive::value_as<mindspore::schema::Cos>() const {
+  return value_as_Cos();
+}
+
+template<> inline const mindspore::schema::ConstantOfShape *Primitive::value_as<mindspore::schema::ConstantOfShape>() const {
+  return value_as_ConstantOfShape();
+}
+
+template<> inline const mindspore::schema::Crop *Primitive::value_as<mindspore::schema::Crop>() const {
+  return value_as_Crop();
+}
+
+template<> inline const mindspore::schema::CustomExtractFeatures *Primitive::value_as<mindspore::schema::CustomExtractFeatures>() const {
+  return value_as_CustomExtractFeatures();
+}
+
+template<> inline const mindspore::schema::CustomNormalize *Primitive::value_as<mindspore::schema::CustomNormalize>() const {
+  return value_as_CustomNormalize();
+}
+
+template<> inline const mindspore::schema::CustomPredict *Primitive::value_as<mindspore::schema::CustomPredict>() const {
+  return value_as_CustomPredict();
+}
+
+template<> inline const mindspore::schema::DeConv2DGradFilter *Primitive::value_as<mindspore::schema::DeConv2DGradFilter>() const {
+  return value_as_DeConv2DGradFilter();
+}
+
+template<> inline const mindspore::schema::Depend *Primitive::value_as<mindspore::schema::Depend>() const {
+  return value_as_Depend();
+}
+
+template<> inline const mindspore::schema::DepthToSpace *Primitive::value_as<mindspore::schema::DepthToSpace>() const {
+  return value_as_DepthToSpace();
+}
+
+template<> inline const mindspore::schema::DetectionPostProcess *Primitive::value_as<mindspore::schema::DetectionPostProcess>() const {
+  return value_as_DetectionPostProcess();
+}
+
+template<> inline const mindspore::schema::DivFusion *Primitive::value_as<mindspore::schema::DivFusion>() const {
+  return value_as_DivFusion();
+}
+
+template<> inline const mindspore::schema::DivGrad *Primitive::value_as<mindspore::schema::DivGrad>() const {
+  return value_as_DivGrad();
+}
+
+template<> inline const mindspore::schema::Dropout *Primitive::value_as<mindspore::schema::Dropout>() const {
+  return value_as_Dropout();
+}
+
+template<> inline const mindspore::schema::DropoutGrad *Primitive::value_as<mindspore::schema::DropoutGrad>() const {
+  return value_as_DropoutGrad();
+}
+
+template<> inline const mindspore::schema::Elu *Primitive::value_as<mindspore::schema::Elu>() const {
+  return value_as_Elu();
+}
+
+template<> inline const mindspore::schema::Eltwise *Primitive::value_as<mindspore::schema::Eltwise>() const {
+  return value_as_Eltwise();
+}
+
+template<> inline const mindspore::schema::Equal *Primitive::value_as<mindspore::schema::Equal>() const {
+  return value_as_Equal();
+}
+
+template<> inline const mindspore::schema::EmbeddingLookupFusion *Primitive::value_as<mindspore::schema::EmbeddingLookupFusion>() const {
+  return value_as_EmbeddingLookupFusion();
+}
+
+template<> inline const mindspore::schema::ExpFusion *Primitive::value_as<mindspore::schema::ExpFusion>() const {
+  return value_as_ExpFusion();
+}
+
+template<> inline const mindspore::schema::ExpandDims *Primitive::value_as<mindspore::schema::ExpandDims>() const {
+  return value_as_ExpandDims();
+}
+
+template<> inline const mindspore::schema::FakeQuantWithMinMaxVars *Primitive::value_as<mindspore::schema::FakeQuantWithMinMaxVars>() const {
+  return value_as_FakeQuantWithMinMaxVars();
+}
+
+template<> inline const mindspore::schema::FakeQuantWithMinMaxVarsPerChannel *Primitive::value_as<mindspore::schema::FakeQuantWithMinMaxVarsPerChannel>() const {
+  return value_as_FakeQuantWithMinMaxVarsPerChannel();
+}
+
+template<> inline const mindspore::schema::FftReal *Primitive::value_as<mindspore::schema::FftReal>() const {
+  return value_as_FftReal();
+}
+
+template<> inline const mindspore::schema::FftImag *Primitive::value_as<mindspore::schema::FftImag>() const {
+  return value_as_FftImag();
+}
+
+template<> inline const mindspore::schema::Flatten *Primitive::value_as<mindspore::schema::Flatten>() const {
+  return value_as_Flatten();
+}
+
+template<> inline const mindspore::schema::FlattenGrad *Primitive::value_as<mindspore::schema::FlattenGrad>() const {
+  return value_as_FlattenGrad();
+}
+
+template<> inline const mindspore::schema::Floor *Primitive::value_as<mindspore::schema::Floor>() const {
+  return value_as_Floor();
+}
+
+template<> inline const mindspore::schema::FloorDiv *Primitive::value_as<mindspore::schema::FloorDiv>() const {
+  return value_as_FloorDiv();
+}
+
+template<> inline const mindspore::schema::FloorMod *Primitive::value_as<mindspore::schema::FloorMod>() const {
+  return value_as_FloorMod();
+}
+
+template<> inline const mindspore::schema::Fill *Primitive::value_as<mindspore::schema::Fill>() const {
+  return value_as_Fill();
+}
+
+template<> inline const mindspore::schema::FullConnection *Primitive::value_as<mindspore::schema::FullConnection>() const {
+  return value_as_FullConnection();
+}
+
+template<> inline const mindspore::schema::FusedBatchNorm *Primitive::value_as<mindspore::schema::FusedBatchNorm>() const {
+  return value_as_FusedBatchNorm();
+}
+
+template<> inline const mindspore::schema::Gather *Primitive::value_as<mindspore::schema::Gather>() const {
+  return value_as_Gather();
+}
+
+template<> inline const mindspore::schema::GatherNd *Primitive::value_as<mindspore::schema::GatherNd>() const {
+  return value_as_GatherNd();
+}
+
+template<> inline const mindspore::schema::Greater *Primitive::value_as<mindspore::schema::Greater>() const {
+  return value_as_Greater();
+}
+
+template<> inline const mindspore::schema::GreaterEqual *Primitive::value_as<mindspore::schema::GreaterEqual>() const {
+  return value_as_GreaterEqual();
+}
+
+template<> inline const mindspore::schema::HashtableLookup *Primitive::value_as<mindspore::schema::HashtableLookup>() const {
+  return value_as_HashtableLookup();
+}
+
+template<> inline const mindspore::schema::InstanceNorm *Primitive::value_as<mindspore::schema::InstanceNorm>() const {
+  return value_as_InstanceNorm();
+}
+
+template<> inline const mindspore::schema::LayerNormFusion *Primitive::value_as<mindspore::schema::LayerNormFusion>() const {
+  return value_as_LayerNormFusion();
+}
+
+template<> inline const mindspore::schema::LeakyRelu *Primitive::value_as<mindspore::schema::LeakyRelu>() const {
+  return value_as_LeakyRelu();
+}
+
+template<> inline const mindspore::schema::Less *Primitive::value_as<mindspore::schema::Less>() const {
+  return value_as_Less();
+}
+
+template<> inline const mindspore::schema::LessEqual *Primitive::value_as<mindspore::schema::LessEqual>() const {
+  return value_as_LessEqual();
+}
+
+template<> inline const mindspore::schema::Log *Primitive::value_as<mindspore::schema::Log>() const {
+  return value_as_Log();
+}
+
+template<> inline const mindspore::schema::LogGrad *Primitive::value_as<mindspore::schema::LogGrad>() const {
+  return value_as_LogGrad();
+}
+
+template<> inline const mindspore::schema::LogicalAnd *Primitive::value_as<mindspore::schema::LogicalAnd>() const {
+  return value_as_LogicalAnd();
+}
+
+template<> inline const mindspore::schema::LogicalNot *Primitive::value_as<mindspore::schema::LogicalNot>() const {
+  return value_as_LogicalNot();
+}
+
+template<> inline const mindspore::schema::LogicalOr *Primitive::value_as<mindspore::schema::LogicalOr>() const {
+  return value_as_LogicalOr();
+}
+
+template<> inline const mindspore::schema::LpNormalization *Primitive::value_as<mindspore::schema::LpNormalization>() const {
+  return value_as_LpNormalization();
+}
+
+template<> inline const mindspore::schema::LRN *Primitive::value_as<mindspore::schema::LRN>() const {
+  return value_as_LRN();
+}
+
+template<> inline const mindspore::schema::LshProjection *Primitive::value_as<mindspore::schema::LshProjection>() const {
+  return value_as_LshProjection();
+}
+
+template<> inline const mindspore::schema::LSTM *Primitive::value_as<mindspore::schema::LSTM>() const {
+  return value_as_LSTM();
+}
+
+template<> inline const mindspore::schema::L2NormalizeFusion *Primitive::value_as<mindspore::schema::L2NormalizeFusion>() const {
+  return value_as_L2NormalizeFusion();
+}
+
+template<> inline const mindspore::schema::MatMulFusion *Primitive::value_as<mindspore::schema::MatMulFusion>() const {
+  return value_as_MatMulFusion();
+}
+
+template<> inline const mindspore::schema::Maximum *Primitive::value_as<mindspore::schema::Maximum>() const {
+  return value_as_Maximum();
+}
+
+template<> inline const mindspore::schema::MaximumGrad *Primitive::value_as<mindspore::schema::MaximumGrad>() const {
+  return value_as_MaximumGrad();
+}
+
+template<> inline const mindspore::schema::MaxPoolFusion *Primitive::value_as<mindspore::schema::MaxPoolFusion>() const {
+  return value_as_MaxPoolFusion();
+}
+
+template<> inline const mindspore::schema::MaxPoolGrad *Primitive::value_as<mindspore::schema::MaxPoolGrad>() const {
+  return value_as_MaxPoolGrad();
+}
+
+template<> inline const mindspore::schema::SwitchLayer *Primitive::value_as<mindspore::schema::SwitchLayer>() const {
+  return value_as_SwitchLayer();
+}
+
+template<> inline const mindspore::schema::Mfcc *Primitive::value_as<mindspore::schema::Mfcc>() const {
+  return value_as_Mfcc();
+}
+
+template<> inline const mindspore::schema::Minimum *Primitive::value_as<mindspore::schema::Minimum>() const {
+  return value_as_Minimum();
+}
+
+template<> inline const mindspore::schema::MinimumGrad *Primitive::value_as<mindspore::schema::MinimumGrad>() const {
+  return value_as_MinimumGrad();
+}
+
+template<> inline const mindspore::schema::Mod *Primitive::value_as<mindspore::schema::Mod>() const {
+  return value_as_Mod();
+}
+
+template<> inline const mindspore::schema::MulFusion *Primitive::value_as<mindspore::schema::MulFusion>() const {
+  return value_as_MulFusion();
+}
+
+template<> inline const mindspore::schema::MulGrad *Primitive::value_as<mindspore::schema::MulGrad>() const {
+  return value_as_MulGrad();
+}
+
+template<> inline const mindspore::schema::Neg *Primitive::value_as<mindspore::schema::Neg>() const {
+  return value_as_Neg();
+}
+
+template<> inline const mindspore::schema::NegGrad *Primitive::value_as<mindspore::schema::NegGrad>() const {
+  return value_as_NegGrad();
+}
+
+template<> inline const mindspore::schema::NotEqual *Primitive::value_as<mindspore::schema::NotEqual>() const {
+  return value_as_NotEqual();
+}
+
+template<> inline const mindspore::schema::NonMaxSuppression *Primitive::value_as<mindspore::schema::NonMaxSuppression>() const {
+  return value_as_NonMaxSuppression();
+}
+
+template<> inline const mindspore::schema::OneHot *Primitive::value_as<mindspore::schema::OneHot>() const {
+  return value_as_OneHot();
+}
+
+template<> inline const mindspore::schema::OnesLike *Primitive::value_as<mindspore::schema::OnesLike>() const {
+  return value_as_OnesLike();
+}
+
+template<> inline const mindspore::schema::PadFusion *Primitive::value_as<mindspore::schema::PadFusion>() const {
+  return value_as_PadFusion();
+}
+
+template<> inline const mindspore::schema::PartialFusion *Primitive::value_as<mindspore::schema::PartialFusion>() const {
+  return value_as_PartialFusion();
+}
+
+template<> inline const mindspore::schema::PowerGrad *Primitive::value_as<mindspore::schema::PowerGrad>() const {
+  return value_as_PowerGrad();
+}
+
+template<> inline const mindspore::schema::PowFusion *Primitive::value_as<mindspore::schema::PowFusion>() const {
+  return value_as_PowFusion();
+}
+
+template<> inline const mindspore::schema::PriorBox *Primitive::value_as<mindspore::schema::PriorBox>() const {
+  return value_as_PriorBox();
+}
+
+template<> inline const mindspore::schema::PReLUFusion *Primitive::value_as<mindspore::schema::PReLUFusion>() const {
+  return value_as_PReLUFusion();
+}
+
+template<> inline const mindspore::schema::QuantDTypeCast *Primitive::value_as<mindspore::schema::QuantDTypeCast>() const {
+  return value_as_QuantDTypeCast();
+}
+
+template<> inline const mindspore::schema::Rank *Primitive::value_as<mindspore::schema::Rank>() const {
+  return value_as_Rank();
+}
+
+template<> inline const mindspore::schema::Range *Primitive::value_as<mindspore::schema::Range>() const {
+  return value_as_Range();
+}
+
+template<> inline const mindspore::schema::Reciprocal *Primitive::value_as<mindspore::schema::Reciprocal>() const {
+  return value_as_Reciprocal();
+}
+
+template<> inline const mindspore::schema::RealDiv *Primitive::value_as<mindspore::schema::RealDiv>() const {
+  return value_as_RealDiv();
+}
+
+template<> inline const mindspore::schema::ReduceFusion *Primitive::value_as<mindspore::schema::ReduceFusion>() const {
+  return value_as_ReduceFusion();
+}
+
+template<> inline const mindspore::schema::Reshape *Primitive::value_as<mindspore::schema::Reshape>() const {
+  return value_as_Reshape();
+}
+
+template<> inline const mindspore::schema::Resize *Primitive::value_as<mindspore::schema::Resize>() const {
+  return value_as_Resize();
+}
+
+template<> inline const mindspore::schema::ReverseSequence *Primitive::value_as<mindspore::schema::ReverseSequence>() const {
+  return value_as_ReverseSequence();
+}
+
+template<> inline const mindspore::schema::ReverseV2 *Primitive::value_as<mindspore::schema::ReverseV2>() const {
+  return value_as_ReverseV2();
+}
+
+template<> inline const mindspore::schema::Rfft *Primitive::value_as<mindspore::schema::Rfft>() const {
+  return value_as_Rfft();
+}
+
+template<> inline const mindspore::schema::ROIPooling *Primitive::value_as<mindspore::schema::ROIPooling>() const {
+  return value_as_ROIPooling();
+}
+
+template<> inline const mindspore::schema::Round *Primitive::value_as<mindspore::schema::Round>() const {
+  return value_as_Round();
+}
+
+template<> inline const mindspore::schema::Rsqrt *Primitive::value_as<mindspore::schema::Rsqrt>() const {
+  return value_as_Rsqrt();
+}
+
+template<> inline const mindspore::schema::ScaleFusion *Primitive::value_as<mindspore::schema::ScaleFusion>() const {
+  return value_as_ScaleFusion();
+}
+
+template<> inline const mindspore::schema::ScatterNd *Primitive::value_as<mindspore::schema::ScatterNd>() const {
+  return value_as_ScatterNd();
+}
+
+template<> inline const mindspore::schema::SGD *Primitive::value_as<mindspore::schema::SGD>() const {
+  return value_as_SGD();
+}
+
+template<> inline const mindspore::schema::Shape *Primitive::value_as<mindspore::schema::Shape>() const {
+  return value_as_Shape();
+}
+
+template<> inline const mindspore::schema::SigmoidCrossEntropyWithLogits *Primitive::value_as<mindspore::schema::SigmoidCrossEntropyWithLogits>() const {
+  return value_as_SigmoidCrossEntropyWithLogits();
+}
+
+template<> inline const mindspore::schema::SigmoidCrossEntropyWithLogitsGrad *Primitive::value_as<mindspore::schema::SigmoidCrossEntropyWithLogitsGrad>() const {
+  return value_as_SigmoidCrossEntropyWithLogitsGrad();
+}
+
+template<> inline const mindspore::schema::Sin *Primitive::value_as<mindspore::schema::Sin>() const {
+  return value_as_Sin();
+}
+
+template<> inline const mindspore::schema::SkipGram *Primitive::value_as<mindspore::schema::SkipGram>() const {
+  return value_as_SkipGram();
+}
+
+template<> inline const mindspore::schema::SliceFusion *Primitive::value_as<mindspore::schema::SliceFusion>() const {
+  return value_as_SliceFusion();
+}
+
+template<> inline const mindspore::schema::SmoothL1Loss *Primitive::value_as<mindspore::schema::SmoothL1Loss>() const {
+  return value_as_SmoothL1Loss();
+}
+
+template<> inline const mindspore::schema::SmoothL1LossGrad *Primitive::value_as<mindspore::schema::SmoothL1LossGrad>() const {
+  return value_as_SmoothL1LossGrad();
+}
+
+template<> inline const mindspore::schema::Softmax *Primitive::value_as<mindspore::schema::Softmax>() const {
+  return value_as_Softmax();
+}
+
+template<> inline const mindspore::schema::SoftmaxCrossEntropyWithLogits *Primitive::value_as<mindspore::schema::SoftmaxCrossEntropyWithLogits>() const {
+  return value_as_SoftmaxCrossEntropyWithLogits();
+}
+
+template<> inline const mindspore::schema::SpaceToBatch *Primitive::value_as<mindspore::schema::SpaceToBatch>() const {
+  return value_as_SpaceToBatch();
+}
+
+template<> inline const mindspore::schema::SpaceToBatchND *Primitive::value_as<mindspore::schema::SpaceToBatchND>() const {
+  return value_as_SpaceToBatchND();
+}
+
+template<> inline const mindspore::schema::SpaceToDepth *Primitive::value_as<mindspore::schema::SpaceToDepth>() const {
+  return value_as_SpaceToDepth();
+}
+
+template<> inline const mindspore::schema::SparseSoftmaxCrossEntropyWithLogits *Primitive::value_as<mindspore::schema::SparseSoftmaxCrossEntropyWithLogits>() const {
+  return value_as_SparseSoftmaxCrossEntropyWithLogits();
+}
+
+template<> inline const mindspore::schema::SparseToDense *Primitive::value_as<mindspore::schema::SparseToDense>() const {
+  return value_as_SparseToDense();
+}
+
+template<> inline const mindspore::schema::Split *Primitive::value_as<mindspore::schema::Split>() const {
+  return value_as_Split();
+}
+
+template<> inline const mindspore::schema::Sqrt *Primitive::value_as<mindspore::schema::Sqrt>() const {
+  return value_as_Sqrt();
+}
+
+template<> inline const mindspore::schema::Squeeze *Primitive::value_as<mindspore::schema::Squeeze>() const {
+  return value_as_Squeeze();
+}
+
+template<> inline const mindspore::schema::Square *Primitive::value_as<mindspore::schema::Square>() const {
+  return value_as_Square();
+}
+
+template<> inline const mindspore::schema::SquaredDifference *Primitive::value_as<mindspore::schema::SquaredDifference>() const {
+  return value_as_SquaredDifference();
+}
+
+template<> inline const mindspore::schema::Stack *Primitive::value_as<mindspore::schema::Stack>() const {
+  return value_as_Stack();
+}
+
+template<> inline const mindspore::schema::StridedSlice *Primitive::value_as<mindspore::schema::StridedSlice>() const {
+  return value_as_StridedSlice();
+}
+
+template<> inline const mindspore::schema::SubFusion *Primitive::value_as<mindspore::schema::SubFusion>() const {
+  return value_as_SubFusion();
+}
+
+template<> inline const mindspore::schema::SubGrad *Primitive::value_as<mindspore::schema::SubGrad>() const {
+  return value_as_SubGrad();
+}
+
+template<> inline const mindspore::schema::Switch *Primitive::value_as<mindspore::schema::Switch>() const {
+  return value_as_Switch();
+}
+
+template<> inline const mindspore::schema::TensorListFromTensor *Primitive::value_as<mindspore::schema::TensorListFromTensor>() const {
+  return value_as_TensorListFromTensor();
+}
+
+template<> inline const mindspore::schema::TensorListGetItem *Primitive::value_as<mindspore::schema::TensorListGetItem>() const {
+  return value_as_TensorListGetItem();
+}
+
+template<> inline const mindspore::schema::TensorListReserve *Primitive::value_as<mindspore::schema::TensorListReserve>() const {
+  return value_as_TensorListReserve();
+}
+
+template<> inline const mindspore::schema::TensorListSetItem *Primitive::value_as<mindspore::schema::TensorListSetItem>() const {
+  return value_as_TensorListSetItem();
+}
+
+template<> inline const mindspore::schema::TensorListStack *Primitive::value_as<mindspore::schema::TensorListStack>() const {
+  return value_as_TensorListStack();
+}
+
+template<> inline const mindspore::schema::TileFusion *Primitive::value_as<mindspore::schema::TileFusion>() const {
+  return value_as_TileFusion();
+}
+
+template<> inline const mindspore::schema::TopKFusion *Primitive::value_as<mindspore::schema::TopKFusion>() const {
+  return value_as_TopKFusion();
+}
+
+template<> inline const mindspore::schema::Transpose *Primitive::value_as<mindspore::schema::Transpose>() const {
+  return value_as_Transpose();
+}
+
+template<> inline const mindspore::schema::Unique *Primitive::value_as<mindspore::schema::Unique>() const {
+  return value_as_Unique();
+}
+
+template<> inline const mindspore::schema::UnsortedSegmentSum *Primitive::value_as<mindspore::schema::UnsortedSegmentSum>() const {
+  return value_as_UnsortedSegmentSum();
+}
+
+template<> inline const mindspore::schema::Unsqueeze *Primitive::value_as<mindspore::schema::Unsqueeze>() const {
+  return value_as_Unsqueeze();
+}
+
+template<> inline const mindspore::schema::Unstack *Primitive::value_as<mindspore::schema::Unstack>() const {
+  return value_as_Unstack();
+}
+
+template<> inline const mindspore::schema::LSTMGrad *Primitive::value_as<mindspore::schema::LSTMGrad>() const {
+  return value_as_LSTMGrad();
+}
+
+template<> inline const mindspore::schema::Where *Primitive::value_as<mindspore::schema::Where>() const {
+  return value_as_Where();
+}
+
+template<> inline const mindspore::schema::ZerosLike *Primitive::value_as<mindspore::schema::ZerosLike>() const {
+  return value_as_ZerosLike();
+}
+
+template<> inline const mindspore::schema::Select *Primitive::value_as<mindspore::schema::Select>() const {
+  return value_as_Select();
+}
+
+template<> inline const mindspore::schema::ScatterNdUpdate *Primitive::value_as<mindspore::schema::ScatterNdUpdate>() const {
+  return value_as_ScatterNdUpdate();
+}
+
+template<> inline const mindspore::schema::GRU *Primitive::value_as<mindspore::schema::GRU>() const {
+  return value_as_GRU();
+}
+
+template<> inline const mindspore::schema::NonZero *Primitive::value_as<mindspore::schema::NonZero>() const {
+  return value_as_NonZero();
+}
+
+template<> inline const mindspore::schema::InvertPermutation *Primitive::value_as<mindspore::schema::InvertPermutation>() const {
+  return value_as_InvertPermutation();
+}
+
+template<> inline const mindspore::schema::Size *Primitive::value_as<mindspore::schema::Size>() const {
+  return value_as_Size();
+}
+
+template<> inline const mindspore::schema::RandomStandardNormal *Primitive::value_as<mindspore::schema::RandomStandardNormal>() const {
+  return value_as_RandomStandardNormal();
+}
+
+template<> inline const mindspore::schema::CropAndResize *Primitive::value_as<mindspore::schema::CropAndResize>() const {
+  return value_as_CropAndResize();
+}
+
+template<> inline const mindspore::schema::Erf *Primitive::value_as<mindspore::schema::Erf>() const {
+  return value_as_Erf();
+}
+
+template<> inline const mindspore::schema::StridedSliceGrad *Primitive::value_as<mindspore::schema::StridedSliceGrad>() const {
+  return value_as_StridedSliceGrad();
+}
+
+template<> inline const mindspore::schema::IsFinite *Primitive::value_as<mindspore::schema::IsFinite>() const {
+  return value_as_IsFinite();
+}
+
+template<> inline const mindspore::schema::LinSpace *Primitive::value_as<mindspore::schema::LinSpace>() const {
+  return value_as_LinSpace();
+}
+
+template<> inline const mindspore::schema::UniformReal *Primitive::value_as<mindspore::schema::UniformReal>() const {
+  return value_as_UniformReal();
+}
+
+template<> inline const mindspore::schema::AbsGrad *Primitive::value_as<mindspore::schema::AbsGrad>() const {
+  return value_as_AbsGrad();
+}
+
+template<> inline const mindspore::schema::RsqrtGrad *Primitive::value_as<mindspore::schema::RsqrtGrad>() const {
+  return value_as_RsqrtGrad();
+}
+
+template<> inline const mindspore::schema::SqrtGrad *Primitive::value_as<mindspore::schema::SqrtGrad>() const {
+  return value_as_SqrtGrad();
+}
+
+template<> inline const mindspore::schema::LayerNormGrad *Primitive::value_as<mindspore::schema::LayerNormGrad>() const {
+  return value_as_LayerNormGrad();
+}
+
+template<> inline const mindspore::schema::ResizeGrad *Primitive::value_as<mindspore::schema::ResizeGrad>() const {
+  return value_as_ResizeGrad();
+}
+
+template<> inline const mindspore::schema::Splice *Primitive::value_as<mindspore::schema::Splice>() const {
+  return value_as_Splice();
+}
+
+template<> inline const mindspore::schema::LogSoftmax *Primitive::value_as<mindspore::schema::LogSoftmax>() const {
+  return value_as_LogSoftmax();
+}
+
+template<> inline const mindspore::schema::Call *Primitive::value_as<mindspore::schema::Call>() const {
+  return value_as_Call();
+}
+
+template<> inline const mindspore::schema::Custom *Primitive::value_as<mindspore::schema::Custom>() const {
+  return value_as_Custom();
+}
+
+template<> inline const mindspore::schema::CumSum *Primitive::value_as<mindspore::schema::CumSum>() const {
+  return value_as_CumSum();
+}
+
+template<> inline const mindspore::schema::SplitWithOverlap *Primitive::value_as<mindspore::schema::SplitWithOverlap>() const {
+  return value_as_SplitWithOverlap();
+}
+
+template<> inline const mindspore::schema::GenOP *Primitive::value_as<mindspore::schema::GenOP>() const {
+  return value_as_GenOP();
+}
+
+template<> inline const mindspore::schema::RaggedRange *Primitive::value_as<mindspore::schema::RaggedRange>() const {
+  return value_as_RaggedRange();
+}
+
+template<> inline const mindspore::schema::GLU *Primitive::value_as<mindspore::schema::GLU>() const {
+  return value_as_GLU();
+}
+
+template<> inline const mindspore::schema::TensorArray *Primitive::value_as<mindspore::schema::TensorArray>() const {
+  return value_as_TensorArray();
+}
+
+template<> inline const mindspore::schema::TensorArrayRead *Primitive::value_as<mindspore::schema::TensorArrayRead>() const {
+  return value_as_TensorArrayRead();
+}
+
+template<> inline const mindspore::schema::TensorArrayWrite *Primitive::value_as<mindspore::schema::TensorArrayWrite>() const {
+  return value_as_TensorArrayWrite();
+}
+
+template<> inline const mindspore::schema::Affine *Primitive::value_as<mindspore::schema::Affine>() const {
+  return value_as_Affine();
+}
+
+template<> inline const mindspore::schema::AllGather *Primitive::value_as<mindspore::schema::AllGather>() const {
+  return value_as_AllGather();
+}
+
+template<> inline const mindspore::schema::ReduceScatter *Primitive::value_as<mindspore::schema::ReduceScatter>() const {
+  return value_as_ReduceScatter();
+}
+
+template<> inline const mindspore::schema::DynamicQuant *Primitive::value_as<mindspore::schema::DynamicQuant>() const {
+  return value_as_DynamicQuant();
+}
+
+template<> inline const mindspore::schema::LSTMGradData *Primitive::value_as<mindspore::schema::LSTMGradData>() const {
+  return value_as_LSTMGradData();
+}
+
+template<> inline const mindspore::schema::LSTMGradWeight *Primitive::value_as<mindspore::schema::LSTMGradWeight>() const {
+  return value_as_LSTMGradWeight();
+}
+
+template<> inline const mindspore::schema::RandomNormal *Primitive::value_as<mindspore::schema::RandomNormal>() const {
+  return value_as_RandomNormal();
+}
+
+template<> inline const mindspore::schema::NLLLoss *Primitive::value_as<mindspore::schema::NLLLoss>() const {
+  return value_as_NLLLoss();
+}
+
+template<> inline const mindspore::schema::NLLLossGrad *Primitive::value_as<mindspore::schema::NLLLossGrad>() const {
+  return value_as_NLLLossGrad();
+}
+
+template<> inline const mindspore::schema::FormatTranspose *Primitive::value_as<mindspore::schema::FormatTranspose>() const {
+  return value_as_FormatTranspose();
+}
+
+template<> inline const mindspore::schema::GatherD *Primitive::value_as<mindspore::schema::GatherD>() const {
+  return value_as_GatherD();
+}
+
+template<> inline const mindspore::schema::GroupNormFusion *Primitive::value_as<mindspore::schema::GroupNormFusion>() const {
+  return value_as_GroupNormFusion();
+}
+
+struct PrimitiveBuilder {
+  typedef Primitive Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_value_type(mindspore::schema::PrimitiveType value_type) {
+    fbb_.AddElement<uint8_t>(Primitive::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
+  }
+  void add_value(flatbuffers::Offset<void> value) {
+    fbb_.AddOffset(Primitive::VT_VALUE, value);
+  }
+  explicit PrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Primitive> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Primitive>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Primitive> CreatePrimitive(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::PrimitiveType value_type = mindspore::schema::PrimitiveType_NONE,
+    flatbuffers::Offset<void> value = 0) {
+  PrimitiveBuilder builder_(_fbb);
+  builder_.add_value(value);
+  builder_.add_value_type(value_type);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Primitive> CreatePrimitive(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct CNodeT : public flatbuffers::NativeTable {
+  typedef CNode TableType;
+  std::string name{};
+  std::unique_ptr<mindspore::schema::PrimitiveT> primitive{};
+  std::vector<uint32_t> inputIndex{};
+  std::vector<uint32_t> outputIndex{};
+  mindspore::schema::QuantType quantType = mindspore::schema::QuantType_QUANT_NONE;
+  int32_t deviceType = -1;
+};
+
+struct CNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CNodeT NativeTableType;
+  typedef CNodeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return CNodeTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NAME = 4,
+    VT_PRIMITIVE = 8,
+    VT_INPUTINDEX = 10,
+    VT_OUTPUTINDEX = 12,
+    VT_QUANTTYPE = 14,
+    VT_DEVICETYPE = 16
+  };
+  const flatbuffers::String *name() const {
+    return GetPointer<const flatbuffers::String *>(VT_NAME);
+  }
+  flatbuffers::String *mutable_name() {
+    return GetPointer<flatbuffers::String *>(VT_NAME);
+  }
+  const mindspore::schema::Primitive *primitive() const {
+    return GetPointer<const mindspore::schema::Primitive *>(VT_PRIMITIVE);
+  }
+  mindspore::schema::Primitive *mutable_primitive() {
+    return GetPointer<mindspore::schema::Primitive *>(VT_PRIMITIVE);
+  }
+  const flatbuffers::Vector<uint32_t> *inputIndex() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
+  }
+  flatbuffers::Vector<uint32_t> *mutable_inputIndex() {
+    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
+  }
+  const flatbuffers::Vector<uint32_t> *outputIndex() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
+  }
+  flatbuffers::Vector<uint32_t> *mutable_outputIndex() {
+    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
+  }
+  mindspore::schema::QuantType quantType() const {
+    return static_cast<mindspore::schema::QuantType>(GetField<int32_t>(VT_QUANTTYPE, 0));
+  }
+  bool mutate_quantType(mindspore::schema::QuantType _quantType) {
+    return SetField<int32_t>(VT_QUANTTYPE, static_cast<int32_t>(_quantType), 0);
+  }
+  int32_t deviceType() const {
+    return GetField<int32_t>(VT_DEVICETYPE, -1);
+  }
+  bool mutate_deviceType(int32_t _deviceType) {
+    return SetField<int32_t>(VT_DEVICETYPE, _deviceType, -1);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_NAME) &&
+           verifier.VerifyString(name()) &&
+           VerifyOffset(verifier, VT_PRIMITIVE) &&
+           verifier.VerifyTable(primitive()) &&
+           VerifyOffset(verifier, VT_INPUTINDEX) &&
+           verifier.VerifyVector(inputIndex()) &&
+           VerifyOffset(verifier, VT_OUTPUTINDEX) &&
+           verifier.VerifyVector(outputIndex()) &&
+           VerifyField<int32_t>(verifier, VT_QUANTTYPE) &&
+           VerifyField<int32_t>(verifier, VT_DEVICETYPE) &&
+           verifier.EndTable();
+  }
+  CNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(CNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<CNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct CNodeBuilder {
+  typedef CNode Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
+    fbb_.AddOffset(CNode::VT_NAME, name);
+  }
+  void add_primitive(flatbuffers::Offset<mindspore::schema::Primitive> primitive) {
+    fbb_.AddOffset(CNode::VT_PRIMITIVE, primitive);
+  }
+  void add_inputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex) {
+    fbb_.AddOffset(CNode::VT_INPUTINDEX, inputIndex);
+  }
+  void add_outputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex) {
+    fbb_.AddOffset(CNode::VT_OUTPUTINDEX, outputIndex);
+  }
+  void add_quantType(mindspore::schema::QuantType quantType) {
+    fbb_.AddElement<int32_t>(CNode::VT_QUANTTYPE, static_cast<int32_t>(quantType), 0);
+  }
+  void add_deviceType(int32_t deviceType) {
+    fbb_.AddElement<int32_t>(CNode::VT_DEVICETYPE, deviceType, -1);
+  }
+  explicit CNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<CNode> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<CNode>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<CNode> CreateCNode(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> name = 0,
+    flatbuffers::Offset<mindspore::schema::Primitive> primitive = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex = 0,
+    mindspore::schema::QuantType quantType = mindspore::schema::QuantType_QUANT_NONE,
+    int32_t deviceType = -1) {
+  CNodeBuilder builder_(_fbb);
+  builder_.add_deviceType(deviceType);
+  builder_.add_quantType(quantType);
+  builder_.add_outputIndex(outputIndex);
+  builder_.add_inputIndex(inputIndex);
+  builder_.add_primitive(primitive);
+  builder_.add_name(name);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<CNode> CreateCNodeDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *name = nullptr,
+    flatbuffers::Offset<mindspore::schema::Primitive> primitive = 0,
+    const std::vector<uint32_t> *inputIndex = nullptr,
+    const std::vector<uint32_t> *outputIndex = nullptr,
+    mindspore::schema::QuantType quantType = mindspore::schema::QuantType_QUANT_NONE,
+    int32_t deviceType = -1) {
+  auto name__ = name ? _fbb.CreateString(name) : 0;
+  auto inputIndex__ = inputIndex ? _fbb.CreateVector<uint32_t>(*inputIndex) : 0;
+  auto outputIndex__ = outputIndex ? _fbb.CreateVector<uint32_t>(*outputIndex) : 0;
+  return mindspore::schema::CreateCNode(
+      _fbb,
+      name__,
+      primitive,
+      inputIndex__,
+      outputIndex__,
+      quantType,
+      deviceType);
+}
+
+flatbuffers::Offset<CNode> CreateCNode(flatbuffers::FlatBufferBuilder &_fbb, const CNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SubGraphT : public flatbuffers::NativeTable {
+  typedef SubGraph TableType;
+  std::string name{};
+  std::vector<uint32_t> inputIndices{};
+  std::vector<uint32_t> outputIndices{};
+  std::vector<uint32_t> nodeIndices{};
+  std::vector<uint32_t> tensorIndices{};
+};
+
+struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SubGraphT NativeTableType;
+  typedef SubGraphBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SubGraphTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NAME = 4,
+    VT_INPUTINDICES = 6,
+    VT_OUTPUTINDICES = 8,
+    VT_NODEINDICES = 10,
+    VT_TENSORINDICES = 12
+  };
+  const flatbuffers::String *name() const {
+    return GetPointer<const flatbuffers::String *>(VT_NAME);
+  }
+  flatbuffers::String *mutable_name() {
+    return GetPointer<flatbuffers::String *>(VT_NAME);
+  }
+  const flatbuffers::Vector<uint32_t> *inputIndices() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDICES);
+  }
+  flatbuffers::Vector<uint32_t> *mutable_inputIndices() {
+    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_INPUTINDICES);
+  }
+  const flatbuffers::Vector<uint32_t> *outputIndices() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDICES);
+  }
+  flatbuffers::Vector<uint32_t> *mutable_outputIndices() {
+    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDICES);
+  }
+  const flatbuffers::Vector<uint32_t> *nodeIndices() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NODEINDICES);
+  }
+  flatbuffers::Vector<uint32_t> *mutable_nodeIndices() {
+    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_NODEINDICES);
+  }
+  const flatbuffers::Vector<uint32_t> *tensorIndices() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_TENSORINDICES);
+  }
+  flatbuffers::Vector<uint32_t> *mutable_tensorIndices() {
+    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_TENSORINDICES);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_NAME) &&
+           verifier.VerifyString(name()) &&
+           VerifyOffset(verifier, VT_INPUTINDICES) &&
+           verifier.VerifyVector(inputIndices()) &&
+           VerifyOffset(verifier, VT_OUTPUTINDICES) &&
+           verifier.VerifyVector(outputIndices()) &&
+           VerifyOffset(verifier, VT_NODEINDICES) &&
+           verifier.VerifyVector(nodeIndices()) &&
+           VerifyOffset(verifier, VT_TENSORINDICES) &&
+           verifier.VerifyVector(tensorIndices()) &&
+           verifier.EndTable();
+  }
+  SubGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SubGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SubGraphBuilder {
+  typedef SubGraph Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
+    fbb_.AddOffset(SubGraph::VT_NAME, name);
+  }
+  void add_inputIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndices) {
+    fbb_.AddOffset(SubGraph::VT_INPUTINDICES, inputIndices);
+  }
+  void add_outputIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndices) {
+    fbb_.AddOffset(SubGraph::VT_OUTPUTINDICES, outputIndices);
+  }
+  void add_nodeIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> nodeIndices) {
+    fbb_.AddOffset(SubGraph::VT_NODEINDICES, nodeIndices);
+  }
+  void add_tensorIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tensorIndices) {
+    fbb_.AddOffset(SubGraph::VT_TENSORINDICES, tensorIndices);
+  }
+  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SubGraph> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SubGraph>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SubGraph> CreateSubGraph(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> name = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndices = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndices = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> nodeIndices = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tensorIndices = 0) {
+  SubGraphBuilder builder_(_fbb);
+  builder_.add_tensorIndices(tensorIndices);
+  builder_.add_nodeIndices(nodeIndices);
+  builder_.add_outputIndices(outputIndices);
+  builder_.add_inputIndices(inputIndices);
+  builder_.add_name(name);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *name = nullptr,
+    const std::vector<uint32_t> *inputIndices = nullptr,
+    const std::vector<uint32_t> *outputIndices = nullptr,
+    const std::vector<uint32_t> *nodeIndices = nullptr,
+    const std::vector<uint32_t> *tensorIndices = nullptr) {
+  auto name__ = name ? _fbb.CreateString(name) : 0;
+  auto inputIndices__ = inputIndices ? _fbb.CreateVector<uint32_t>(*inputIndices) : 0;
+  auto outputIndices__ = outputIndices ? _fbb.CreateVector<uint32_t>(*outputIndices) : 0;
+  auto nodeIndices__ = nodeIndices ? _fbb.CreateVector<uint32_t>(*nodeIndices) : 0;
+  auto tensorIndices__ = tensorIndices ? _fbb.CreateVector<uint32_t>(*tensorIndices) : 0;
+  return mindspore::schema::CreateSubGraph(
+      _fbb,
+      name__,
+      inputIndices__,
+      outputIndices__,
+      nodeIndices__,
+      tensorIndices__);
+}
+
+flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct MetaGraphT : public flatbuffers::NativeTable {
+  typedef MetaGraph TableType;
+  std::string name{};
+  std::string version{};
+  int32_t fmkType = 0;
+  std::vector<uint32_t> inputIndex{};
+  std::vector<uint32_t> outputIndex{};
+  uint32_t mempoolSize = 0;
+  std::vector<std::unique_ptr<mindspore::schema::CNodeT>> nodes{};
+  std::vector<std::unique_ptr<mindspore::schema::TensorT>> allTensors{};
+  std::vector<std::unique_ptr<mindspore::schema::SubGraphT>> subGraph{};
+  bool obfuscate = false;
+  std::vector<uint8_t> obfMetaData{};
+};
+
+struct MetaGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MetaGraphT NativeTableType;
+  typedef MetaGraphBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return MetaGraphTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NAME = 4,
+    VT_VERSION = 6,
+    VT_FMKTYPE = 8,
+    VT_INPUTINDEX = 10,
+    VT_OUTPUTINDEX = 12,
+    VT_MEMPOOLSIZE = 14,
+    VT_NODES = 16,
+    VT_ALLTENSORS = 18,
+    VT_SUBGRAPH = 20,
+    VT_OBFUSCATE = 22,
+    VT_OBFMETADATA = 24
+  };
+  const flatbuffers::String *name() const {
+    return GetPointer<const flatbuffers::String *>(VT_NAME);
+  }
+  flatbuffers::String *mutable_name() {
+    return GetPointer<flatbuffers::String *>(VT_NAME);
+  }
+  const flatbuffers::String *version() const {
+    return GetPointer<const flatbuffers::String *>(VT_VERSION);
+  }
+  flatbuffers::String *mutable_version() {
+    return GetPointer<flatbuffers::String *>(VT_VERSION);
+  }
+  int32_t fmkType() const {
+    return GetField<int32_t>(VT_FMKTYPE, 0);
+  }
+  bool mutate_fmkType(int32_t _fmkType) {
+    return SetField<int32_t>(VT_FMKTYPE, _fmkType, 0);
+  }
+  const flatbuffers::Vector<uint32_t> *inputIndex() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
+  }
+  flatbuffers::Vector<uint32_t> *mutable_inputIndex() {
+    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
+  }
+  const flatbuffers::Vector<uint32_t> *outputIndex() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
+  }
+  flatbuffers::Vector<uint32_t> *mutable_outputIndex() {
+    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
+  }
+  uint32_t mempoolSize() const {
+    return GetField<uint32_t>(VT_MEMPOOLSIZE, 0);
+  }
+  bool mutate_mempoolSize(uint32_t _mempoolSize) {
+    return SetField<uint32_t>(VT_MEMPOOLSIZE, _mempoolSize, 0);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::CNode>> *nodes() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::CNode>> *>(VT_NODES);
+  }
+  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::CNode>> *mutable_nodes() {
+    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::CNode>> *>(VT_NODES);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Tensor>> *allTensors() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Tensor>> *>(VT_ALLTENSORS);
+  }
+  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Tensor>> *mutable_allTensors() {
+    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Tensor>> *>(VT_ALLTENSORS);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::SubGraph>> *subGraph() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::SubGraph>> *>(VT_SUBGRAPH);
+  }
+  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::SubGraph>> *mutable_subGraph() {
+    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::SubGraph>> *>(VT_SUBGRAPH);
+  }
+  bool obfuscate() const {
+    return GetField<uint8_t>(VT_OBFUSCATE, 0) != 0;
+  }
+  bool mutate_obfuscate(bool _obfuscate) {
+    return SetField<uint8_t>(VT_OBFUSCATE, static_cast<uint8_t>(_obfuscate), 0);
+  }
+  const flatbuffers::Vector<uint8_t> *obfMetaData() const {
+    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OBFMETADATA);
+  }
+  flatbuffers::Vector<uint8_t> *mutable_obfMetaData() {
+    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_OBFMETADATA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_NAME) &&
+           verifier.VerifyString(name()) &&
+           VerifyOffset(verifier, VT_VERSION) &&
+           verifier.VerifyString(version()) &&
+           VerifyField<int32_t>(verifier, VT_FMKTYPE) &&
+           VerifyOffset(verifier, VT_INPUTINDEX) &&
+           verifier.VerifyVector(inputIndex()) &&
+           VerifyOffset(verifier, VT_OUTPUTINDEX) &&
+           verifier.VerifyVector(outputIndex()) &&
+           VerifyField<uint32_t>(verifier, VT_MEMPOOLSIZE) &&
+           VerifyOffset(verifier, VT_NODES) &&
+           verifier.VerifyVector(nodes()) &&
+           verifier.VerifyVectorOfTables(nodes()) &&
+           VerifyOffset(verifier, VT_ALLTENSORS) &&
+           verifier.VerifyVector(allTensors()) &&
+           verifier.VerifyVectorOfTables(allTensors()) &&
+           VerifyOffset(verifier, VT_SUBGRAPH) &&
+           verifier.VerifyVector(subGraph()) &&
+           verifier.VerifyVectorOfTables(subGraph()) &&
+           VerifyField<uint8_t>(verifier, VT_OBFUSCATE) &&
+           VerifyOffset(verifier, VT_OBFMETADATA) &&
+           verifier.VerifyVector(obfMetaData()) &&
+           verifier.EndTable();
+  }
+  MetaGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(MetaGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<MetaGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetaGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct MetaGraphBuilder {
+  typedef MetaGraph Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
+    fbb_.AddOffset(MetaGraph::VT_NAME, name);
+  }
+  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
+    fbb_.AddOffset(MetaGraph::VT_VERSION, version);
+  }
+  void add_fmkType(int32_t fmkType) {
+    fbb_.AddElement<int32_t>(MetaGraph::VT_FMKTYPE, fmkType, 0);
+  }
+  void add_inputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex) {
+    fbb_.AddOffset(MetaGraph::VT_INPUTINDEX, inputIndex);
+  }
+  void add_outputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex) {
+    fbb_.AddOffset(MetaGraph::VT_OUTPUTINDEX, outputIndex);
+  }
+  void add_mempoolSize(uint32_t mempoolSize) {
+    fbb_.AddElement<uint32_t>(MetaGraph::VT_MEMPOOLSIZE, mempoolSize, 0);
+  }
+  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::CNode>>> nodes) {
+    fbb_.AddOffset(MetaGraph::VT_NODES, nodes);
+  }
+  void add_allTensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Tensor>>> allTensors) {
+    fbb_.AddOffset(MetaGraph::VT_ALLTENSORS, allTensors);
+  }
+  void add_subGraph(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::SubGraph>>> subGraph) {
+    fbb_.AddOffset(MetaGraph::VT_SUBGRAPH, subGraph);
+  }
+  void add_obfuscate(bool obfuscate) {
+    fbb_.AddElement<uint8_t>(MetaGraph::VT_OBFUSCATE, static_cast<uint8_t>(obfuscate), 0);
+  }
+  void add_obfMetaData(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> obfMetaData) {
+    fbb_.AddOffset(MetaGraph::VT_OBFMETADATA, obfMetaData);
+  }
+  explicit MetaGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MetaGraph> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MetaGraph>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MetaGraph> CreateMetaGraph(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> name = 0,
+    flatbuffers::Offset<flatbuffers::String> version = 0,
+    int32_t fmkType = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex = 0,
+    uint32_t mempoolSize = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::CNode>>> nodes = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Tensor>>> allTensors = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::SubGraph>>> subGraph = 0,
+    bool obfuscate = false,
+    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> obfMetaData = 0) {
+  MetaGraphBuilder builder_(_fbb);
+  builder_.add_obfMetaData(obfMetaData);
+  builder_.add_subGraph(subGraph);
+  builder_.add_allTensors(allTensors);
+  builder_.add_nodes(nodes);
+  builder_.add_mempoolSize(mempoolSize);
+  builder_.add_outputIndex(outputIndex);
+  builder_.add_inputIndex(inputIndex);
+  builder_.add_fmkType(fmkType);
+  builder_.add_version(version);
+  builder_.add_name(name);
+  builder_.add_obfuscate(obfuscate);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<MetaGraph> CreateMetaGraphDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *name = nullptr,
+    const char *version = nullptr,
+    int32_t fmkType = 0,
+    const std::vector<uint32_t> *inputIndex = nullptr,
+    const std::vector<uint32_t> *outputIndex = nullptr,
+    uint32_t mempoolSize = 0,
+    const std::vector<flatbuffers::Offset<mindspore::schema::CNode>> *nodes = nullptr,
+    const std::vector<flatbuffers::Offset<mindspore::schema::Tensor>> *allTensors = nullptr,
+    const std::vector<flatbuffers::Offset<mindspore::schema::SubGraph>> *subGraph = nullptr,
+    bool obfuscate = false,
+    const std::vector<uint8_t> *obfMetaData = nullptr) {
+  auto name__ = name ? _fbb.CreateString(name) : 0;
+  auto version__ = version ? _fbb.CreateString(version) : 0;
+  auto inputIndex__ = inputIndex ? _fbb.CreateVector<uint32_t>(*inputIndex) : 0;
+  auto outputIndex__ = outputIndex ? _fbb.CreateVector<uint32_t>(*outputIndex) : 0;
+  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::CNode>>(*nodes) : 0;
+  auto allTensors__ = allTensors ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Tensor>>(*allTensors) : 0;
+  auto subGraph__ = subGraph ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::SubGraph>>(*subGraph) : 0;
+  auto obfMetaData__ = obfMetaData ? _fbb.CreateVector<uint8_t>(*obfMetaData) : 0;
+  return mindspore::schema::CreateMetaGraph(
+      _fbb,
+      name__,
+      version__,
+      fmkType,
+      inputIndex__,
+      outputIndex__,
+      mempoolSize,
+      nodes__,
+      allTensors__,
+      subGraph__,
+      obfuscate,
+      obfMetaData__);
+}
+
+flatbuffers::Offset<MetaGraph> CreateMetaGraph(flatbuffers::FlatBufferBuilder &_fbb, const MetaGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+inline QuantParamT *QuantParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<QuantParamT>(new QuantParamT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void QuantParam::UnPackTo(QuantParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = scale(); _o->scale = _e; }
+  { auto _e = zeroPoint(); _o->zeroPoint = _e; }
+  { auto _e = min(); _o->min = _e; }
+  { auto _e = max(); _o->max = _e; }
+  { auto _e = narrowRange(); _o->narrowRange = _e; }
+  { auto _e = numBits(); _o->numBits = _e; }
+  { auto _e = inited(); _o->inited = _e; }
+  { auto _e = varCorr(); _o->varCorr = _e; }
+  { auto _e = meanCorr(); _o->meanCorr = _e; }
+  { auto _e = dstDtype(); _o->dstDtype = _e; }
+  { auto _e = roundType(); _o->roundType = _e; }
+  { auto _e = multiplier(); _o->multiplier = _e; }
+}
+
+inline flatbuffers::Offset<QuantParam> QuantParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateQuantParam(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<QuantParam> CreateQuantParam(flatbuffers::FlatBufferBuilder &_fbb, const QuantParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _scale = _o->scale;
+  auto _zeroPoint = _o->zeroPoint;
+  auto _min = _o->min;
+  auto _max = _o->max;
+  auto _narrowRange = _o->narrowRange;
+  auto _numBits = _o->numBits;
+  auto _inited = _o->inited;
+  auto _varCorr = _o->varCorr;
+  auto _meanCorr = _o->meanCorr;
+  auto _dstDtype = _o->dstDtype;
+  auto _roundType = _o->roundType;
+  auto _multiplier = _o->multiplier;
+  return mindspore::schema::CreateQuantParam(
+      _fbb,
+      _scale,
+      _zeroPoint,
+      _min,
+      _max,
+      _narrowRange,
+      _numBits,
+      _inited,
+      _varCorr,
+      _meanCorr,
+      _dstDtype,
+      _roundType,
+      _multiplier);
+}
+
+inline ExternalDataT *ExternalData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ExternalDataT>(new ExternalDataT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ExternalData::UnPackTo(ExternalDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = checkSum(); if (_e) _o->checkSum = _e->str(); }
+  { auto _e = location(); if (_e) _o->location = _e->str(); }
+  { auto _e = offset(); _o->offset = _e; }
+  { auto _e = length(); _o->length = _e; }
+}
+
+inline flatbuffers::Offset<ExternalData> ExternalData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExternalDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateExternalData(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ExternalData> CreateExternalData(flatbuffers::FlatBufferBuilder &_fbb, const ExternalDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExternalDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _checkSum = _o->checkSum.empty() ? 0 : _fbb.CreateString(_o->checkSum);
+  auto _location = _o->location.empty() ? 0 : _fbb.CreateString(_o->location);
+  auto _offset = _o->offset;
+  auto _length = _o->length;
+  return mindspore::schema::CreateExternalData(
+      _fbb,
+      _checkSum,
+      _location,
+      _offset,
+      _length);
+}
+
+inline TensorT *Tensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TensorT>(new TensorT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Tensor::UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = nodeType(); _o->nodeType = _e; }
+  { auto _e = dataType(); _o->dataType = _e; }
+  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = refCount(); _o->refCount = _e; }
+  { auto _e = offset(); _o->offset = _e; }
+  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
+  { auto _e = quantParams(); if (_e) { _o->quantParams.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->quantParams[_i] = std::unique_ptr<mindspore::schema::QuantParamT>(_e->Get(_i)->UnPack(_resolver)); } } }
+  { auto _e = quantClusters(); if (_e) { _o->quantClusters.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->quantClusters[_i] = _e->Get(_i); } } }
+  { auto _e = name(); if (_e) _o->name = _e->str(); }
+  { auto _e = enableHuffmanCode(); _o->enableHuffmanCode = _e; }
+  { auto _e = weightQunatCompressType(); _o->weightQunatCompressType = _e; }
+  { auto _e = externalData(); if (_e) { _o->externalData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->externalData[_i] = std::unique_ptr<mindspore::schema::ExternalDataT>(_e->Get(_i)->UnPack(_resolver)); } } }
+}
+
+inline flatbuffers::Offset<Tensor> Tensor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTensor(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _nodeType = _o->nodeType;
+  auto _dataType = _o->dataType;
+  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
+  auto _format = _o->format;
+  auto _refCount = _o->refCount;
+  auto _offset = _o->offset;
+  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
+  auto _quantParams = _o->quantParams.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::QuantParam>> (_o->quantParams.size(), [](size_t i, _VectorArgs *__va) { return CreateQuantParam(*__va->__fbb, __va->__o->quantParams[i].get(), __va->__rehasher); }, &_va ) : 0;
+  auto _quantClusters = _o->quantClusters.size() ? _fbb.CreateVector(_o->quantClusters) : 0;
+  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
+  auto _enableHuffmanCode = _o->enableHuffmanCode;
+  auto _weightQunatCompressType = _o->weightQunatCompressType;
+  auto _externalData = _o->externalData.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::ExternalData>> (_o->externalData.size(), [](size_t i, _VectorArgs *__va) { return CreateExternalData(*__va->__fbb, __va->__o->externalData[i].get(), __va->__rehasher); }, &_va ) : 0;
+  return mindspore::schema::CreateTensor(
+      _fbb,
+      _nodeType,
+      _dataType,
+      _dims,
+      _format,
+      _refCount,
+      _offset,
+      _data,
+      _quantParams,
+      _quantClusters,
+      _name,
+      _enableHuffmanCode,
+      _weightQunatCompressType,
+      _externalData);
+}
+
+inline PrimitiveT *Primitive::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<PrimitiveT>(new PrimitiveT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Primitive::UnPackTo(PrimitiveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = value_type(); _o->value.type = _e; }
+  { auto _e = value(); if (_e) _o->value.value = mindspore::schema::PrimitiveTypeUnion::UnPack(_e, value_type(), _resolver); }
+}
+
+inline flatbuffers::Offset<Primitive> Primitive::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreatePrimitive(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Primitive> CreatePrimitive(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PrimitiveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _value_type = _o->value.type;
+  auto _value = _o->value.Pack(_fbb);
+  return mindspore::schema::CreatePrimitive(
+      _fbb,
+      _value_type,
+      _value);
+}
+
+inline CNodeT *CNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<CNodeT>(new CNodeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void CNode::UnPackTo(CNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = name(); if (_e) _o->name = _e->str(); }
+  { auto _e = primitive(); if (_e) _o->primitive = std::unique_ptr<mindspore::schema::PrimitiveT>(_e->UnPack(_resolver)); }
+  { auto _e = inputIndex(); if (_e) { _o->inputIndex.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputIndex[_i] = _e->Get(_i); } } }
+  { auto _e = outputIndex(); if (_e) { _o->outputIndex.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputIndex[_i] = _e->Get(_i); } } }
+  { auto _e = quantType(); _o->quantType = _e; }
+  { auto _e = deviceType(); _o->deviceType = _e; }
+}
+
+inline flatbuffers::Offset<CNode> CNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateCNode(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<CNode> CreateCNode(flatbuffers::FlatBufferBuilder &_fbb, const CNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CNodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
+  auto _primitive = _o->primitive ? CreatePrimitive(_fbb, _o->primitive.get(), _rehasher) : 0;
+  auto _inputIndex = _o->inputIndex.size() ? _fbb.CreateVector(_o->inputIndex) : 0;
+  auto _outputIndex = _o->outputIndex.size() ? _fbb.CreateVector(_o->outputIndex) : 0;
+  auto _quantType = _o->quantType;
+  auto _deviceType = _o->deviceType;
+  return mindspore::schema::CreateCNode(
+      _fbb,
+      _name,
+      _primitive,
+      _inputIndex,
+      _outputIndex,
+      _quantType,
+      _deviceType);
+}
+
+inline SubGraphT *SubGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SubGraphT>(new SubGraphT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SubGraph::UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = name(); if (_e) _o->name = _e->str(); }
+  { auto _e = inputIndices(); if (_e) { _o->inputIndices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputIndices[_i] = _e->Get(_i); } } }
+  { auto _e = outputIndices(); if (_e) { _o->outputIndices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputIndices[_i] = _e->Get(_i); } } }
+  { auto _e = nodeIndices(); if (_e) { _o->nodeIndices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodeIndices[_i] = _e->Get(_i); } } }
+  { auto _e = tensorIndices(); if (_e) { _o->tensorIndices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensorIndices[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<SubGraph> SubGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSubGraph(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGraphT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
+  auto _inputIndices = _o->inputIndices.size() ? _fbb.CreateVector(_o->inputIndices) : 0;
+  auto _outputIndices = _o->outputIndices.size() ? _fbb.CreateVector(_o->outputIndices) : 0;
+  auto _nodeIndices = _o->nodeIndices.size() ? _fbb.CreateVector(_o->nodeIndices) : 0;
+  auto _tensorIndices = _o->tensorIndices.size() ? _fbb.CreateVector(_o->tensorIndices) : 0;
+  return mindspore::schema::CreateSubGraph(
+      _fbb,
+      _name,
+      _inputIndices,
+      _outputIndices,
+      _nodeIndices,
+      _tensorIndices);
+}
+
+inline MetaGraphT *MetaGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<MetaGraphT>(new MetaGraphT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void MetaGraph::UnPackTo(MetaGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = name(); if (_e) _o->name = _e->str(); }
+  { auto _e = version(); if (_e) _o->version = _e->str(); }
+  { auto _e = fmkType(); _o->fmkType = _e; }
+  { auto _e = inputIndex(); if (_e) { _o->inputIndex.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputIndex[_i] = _e->Get(_i); } } }
+  { auto _e = outputIndex(); if (_e) { _o->outputIndex.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputIndex[_i] = _e->Get(_i); } } }
+  { auto _e = mempoolSize(); _o->mempoolSize = _e; }
+  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodes[_i] = std::unique_ptr<mindspore::schema::CNodeT>(_e->Get(_i)->UnPack(_resolver)); } } }
+  { auto _e = allTensors(); if (_e) { _o->allTensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->allTensors[_i] = std::unique_ptr<mindspore::schema::TensorT>(_e->Get(_i)->UnPack(_resolver)); } } }
+  { auto _e = subGraph(); if (_e) { _o->subGraph.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->subGraph[_i] = std::unique_ptr<mindspore::schema::SubGraphT>(_e->Get(_i)->UnPack(_resolver)); } } }
+  { auto _e = obfuscate(); _o->obfuscate = _e; }
+  { auto _e = obfMetaData(); if (_e) { _o->obfMetaData.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->obfMetaData.begin()); } }
+}
+
+inline flatbuffers::Offset<MetaGraph> MetaGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetaGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateMetaGraph(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<MetaGraph> CreateMetaGraph(flatbuffers::FlatBufferBuilder &_fbb, const MetaGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MetaGraphT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
+  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
+  auto _fmkType = _o->fmkType;
+  auto _inputIndex = _o->inputIndex.size() ? _fbb.CreateVector(_o->inputIndex) : 0;
+  auto _outputIndex = _o->outputIndex.size() ? _fbb.CreateVector(_o->outputIndex) : 0;
+  auto _mempoolSize = _o->mempoolSize;
+  auto _nodes = _o->nodes.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::CNode>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateCNode(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va ) : 0;
+  auto _allTensors = _o->allTensors.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Tensor>> (_o->allTensors.size(), [](size_t i, _VectorArgs *__va) { return CreateTensor(*__va->__fbb, __va->__o->allTensors[i].get(), __va->__rehasher); }, &_va ) : 0;
+  auto _subGraph = _o->subGraph.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::SubGraph>> (_o->subGraph.size(), [](size_t i, _VectorArgs *__va) { return CreateSubGraph(*__va->__fbb, __va->__o->subGraph[i].get(), __va->__rehasher); }, &_va ) : 0;
+  auto _obfuscate = _o->obfuscate;
+  auto _obfMetaData = _o->obfMetaData.size() ? _fbb.CreateVector(_o->obfMetaData) : 0;
+  return mindspore::schema::CreateMetaGraph(
+      _fbb,
+      _name,
+      _version,
+      _fmkType,
+      _inputIndex,
+      _outputIndex,
+      _mempoolSize,
+      _nodes,
+      _allTensors,
+      _subGraph,
+      _obfuscate,
+      _obfMetaData);
+}
+
+inline const flatbuffers::TypeTable *WeightQunatCompressTypeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::WeightQunatCompressTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *QuantTypeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::QuantTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 7, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *QuantParamTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_DOUBLE, 0, -1 },
+    { flatbuffers::ET_INT, 0, -1 },
+    { flatbuffers::ET_DOUBLE, 0, -1 },
+    { flatbuffers::ET_DOUBLE, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_INT, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_INT, 0, -1 },
+    { flatbuffers::ET_INT, 0, -1 },
+    { flatbuffers::ET_INT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 12, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ExternalDataTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *TensorTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, -1 },
+    { flatbuffers::ET_INT, 0, -1 },
+    { flatbuffers::ET_INT, 1, -1 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, -1 },
+    { flatbuffers::ET_INT, 0, -1 },
+    { flatbuffers::ET_UCHAR, 1, -1 },
+    { flatbuffers::ET_SEQUENCE, 1, 1 },
+    { flatbuffers::ET_FLOAT, 1, -1 },
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_INT, 0, 2 },
+    { flatbuffers::ET_SEQUENCE, 1, 3 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable,
+    mindspore::schema::QuantParamTypeTable,
+    mindspore::schema::WeightQunatCompressTypeTypeTable,
+    mindspore::schema::ExternalDataTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 13, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *PrimitiveTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_UTYPE, 0, 0 },
+    { flatbuffers::ET_SEQUENCE, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::PrimitiveTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CNodeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_INT, 0, -1 },
+    { flatbuffers::ET_SEQUENCE, 0, 0 },
+    { flatbuffers::ET_UINT, 1, -1 },
+    { flatbuffers::ET_UINT, 1, -1 },
+    { flatbuffers::ET_INT, 0, 1 },
+    { flatbuffers::ET_INT, 0, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::PrimitiveTypeTable,
+    mindspore::schema::QuantTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SubGraphTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_UINT, 1, -1 },
+    { flatbuffers::ET_UINT, 1, -1 },
+    { flatbuffers::ET_UINT, 1, -1 },
+    { flatbuffers::ET_UINT, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *MetaGraphTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_INT, 0, -1 },
+    { flatbuffers::ET_UINT, 1, -1 },
+    { flatbuffers::ET_UINT, 1, -1 },
+    { flatbuffers::ET_UINT, 0, -1 },
+    { flatbuffers::ET_SEQUENCE, 1, 0 },
+    { flatbuffers::ET_SEQUENCE, 1, 1 },
+    { flatbuffers::ET_SEQUENCE, 1, 2 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_UCHAR, 1, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::CNodeTypeTable,
+    mindspore::schema::TensorTypeTable,
+    mindspore::schema::SubGraphTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const mindspore::schema::MetaGraph *GetMetaGraph(const void *buf) {
+  return flatbuffers::GetRoot<mindspore::schema::MetaGraph>(buf);
+}
+
+inline const mindspore::schema::MetaGraph *GetSizePrefixedMetaGraph(const void *buf) {
+  return flatbuffers::GetSizePrefixedRoot<mindspore::schema::MetaGraph>(buf);
+}
+
+inline MetaGraph *GetMutableMetaGraph(void *buf) {
+  return flatbuffers::GetMutableRoot<MetaGraph>(buf);
+}
+
+inline const char *MetaGraphIdentifier() {
+  return "MSL2";
+}
+
+inline bool MetaGraphBufferHasIdentifier(const void *buf) {
+  return flatbuffers::BufferHasIdentifier(
+      buf, MetaGraphIdentifier());
+}
+
+inline bool VerifyMetaGraphBuffer(
+    flatbuffers::Verifier &verifier) {
+  return verifier.VerifyBuffer<mindspore::schema::MetaGraph>(MetaGraphIdentifier());
+}
+
+inline bool VerifySizePrefixedMetaGraphBuffer(
+    flatbuffers::Verifier &verifier) {
+  return verifier.VerifySizePrefixedBuffer<mindspore::schema::MetaGraph>(MetaGraphIdentifier());
+}
+
+inline const char *MetaGraphExtension() {
+  return "ms";
+}
+
+inline void FinishMetaGraphBuffer(
+    flatbuffers::FlatBufferBuilder &fbb,
+    flatbuffers::Offset<mindspore::schema::MetaGraph> root) {
+  fbb.Finish(root, MetaGraphIdentifier());
+}
+
+inline void FinishSizePrefixedMetaGraphBuffer(
+    flatbuffers::FlatBufferBuilder &fbb,
+    flatbuffers::Offset<mindspore::schema::MetaGraph> root) {
+  fbb.FinishSizePrefixed(root, MetaGraphIdentifier());
+}
+
+inline std::unique_ptr<mindspore::schema::MetaGraphT> UnPackMetaGraph(
+    const void *buf,
+    const flatbuffers::resolver_function_t *res = nullptr) {
+  return std::unique_ptr<mindspore::schema::MetaGraphT>(GetMetaGraph(buf)->UnPack(res));
+}
+
+inline std::unique_ptr<mindspore::schema::MetaGraphT> UnPackSizePrefixedMetaGraph(
+    const void *buf,
+    const flatbuffers::resolver_function_t *res = nullptr) {
+  return std::unique_ptr<mindspore::schema::MetaGraphT>(GetSizePrefixedMetaGraph(buf)->UnPack(res));
+}
+
+}  // namespace schema
+}  // namespace mindspore
+
+#endif  // FLATBUFFERS_GENERATED_MODEL_MINDSPORE_SCHEMA_H_
diff --git a/mindspore/lite/schema/inner/ops_generated.h b/mindspore/lite/schema/inner/ops_generated.h
new file mode 100644
index 00000000..e0614168
--- /dev/null
+++ b/mindspore/lite/schema/inner/ops_generated.h
@@ -0,0 +1,33649 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+
+
+#ifndef FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
+#define FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
+
+#include "flatbuffers/flatbuffers.h"
+
+#include "ops_types_generated.h"
+
+namespace mindspore {
+namespace schema {
+
+struct Abs;
+struct AbsBuilder;
+struct AbsT;
+
+struct Activation;
+struct ActivationBuilder;
+struct ActivationT;
+
+struct ActivationGrad;
+struct ActivationGradBuilder;
+struct ActivationGradT;
+
+struct Adam;
+struct AdamBuilder;
+struct AdamT;
+
+struct AddFusion;
+struct AddFusionBuilder;
+struct AddFusionT;
+
+struct AdderFusion;
+struct AdderFusionBuilder;
+struct AdderFusionT;
+
+struct AddGrad;
+struct AddGradBuilder;
+struct AddGradT;
+
+struct AddN;
+struct AddNBuilder;
+struct AddNT;
+
+struct All;
+struct AllBuilder;
+struct AllT;
+
+struct ApplyMomentum;
+struct ApplyMomentumBuilder;
+struct ApplyMomentumT;
+
+struct ArgMaxFusion;
+struct ArgMaxFusionBuilder;
+struct ArgMaxFusionT;
+
+struct ArgMinFusion;
+struct ArgMinFusionBuilder;
+struct ArgMinFusionT;
+
+struct Assert;
+struct AssertBuilder;
+struct AssertT;
+
+struct Assign;
+struct AssignBuilder;
+struct AssignT;
+
+struct AssignAdd;
+struct AssignAddBuilder;
+struct AssignAddT;
+
+struct AudioSpectrogram;
+struct AudioSpectrogramBuilder;
+struct AudioSpectrogramT;
+
+struct AvgPoolFusion;
+struct AvgPoolFusionBuilder;
+struct AvgPoolFusionT;
+
+struct AvgPoolGrad;
+struct AvgPoolGradBuilder;
+struct AvgPoolGradT;
+
+struct BatchNorm;
+struct BatchNormBuilder;
+struct BatchNormT;
+
+struct BatchNormGrad;
+struct BatchNormGradBuilder;
+struct BatchNormGradT;
+
+struct BatchToSpace;
+struct BatchToSpaceBuilder;
+struct BatchToSpaceT;
+
+struct BatchToSpaceND;
+struct BatchToSpaceNDBuilder;
+struct BatchToSpaceNDT;
+
+struct BiasAdd;
+struct BiasAddBuilder;
+struct BiasAddT;
+
+struct BinaryCrossEntropy;
+struct BinaryCrossEntropyBuilder;
+struct BinaryCrossEntropyT;
+
+struct BinaryCrossEntropyGrad;
+struct BinaryCrossEntropyGradBuilder;
+struct BinaryCrossEntropyGradT;
+
+struct BiasAddGrad;
+struct BiasAddGradBuilder;
+struct BiasAddGradT;
+
+struct BroadcastTo;
+struct BroadcastToBuilder;
+struct BroadcastToT;
+
+struct Cast;
+struct CastBuilder;
+struct CastT;
+
+struct Ceil;
+struct CeilBuilder;
+struct CeilT;
+
+struct Clip;
+struct ClipBuilder;
+struct ClipT;
+
+struct Concat;
+struct ConcatBuilder;
+struct ConcatT;
+
+struct Attention;
+struct AttentionBuilder;
+struct AttentionT;
+
+struct Conv2DBackpropFilterFusion;
+struct Conv2DBackpropFilterFusionBuilder;
+struct Conv2DBackpropFilterFusionT;
+
+struct Conv2DBackpropInputFusion;
+struct Conv2DBackpropInputFusionBuilder;
+struct Conv2DBackpropInputFusionT;
+
+struct Conv2DFusion;
+struct Conv2DFusionBuilder;
+struct Conv2DFusionT;
+
+struct Conv2dTransposeFusion;
+struct Conv2dTransposeFusionBuilder;
+struct Conv2dTransposeFusionT;
+
+struct Cos;
+struct CosBuilder;
+struct CosT;
+
+struct ConstantOfShape;
+struct ConstantOfShapeBuilder;
+struct ConstantOfShapeT;
+
+struct Crop;
+struct CropBuilder;
+struct CropT;
+
+struct CustomExtractFeatures;
+struct CustomExtractFeaturesBuilder;
+struct CustomExtractFeaturesT;
+
+struct CustomNormalize;
+struct CustomNormalizeBuilder;
+struct CustomNormalizeT;
+
+struct CustomPredict;
+struct CustomPredictBuilder;
+struct CustomPredictT;
+
+struct DeConv2DGradFilter;
+struct DeConv2DGradFilterBuilder;
+struct DeConv2DGradFilterT;
+
+struct Depend;
+struct DependBuilder;
+struct DependT;
+
+struct DepthToSpace;
+struct DepthToSpaceBuilder;
+struct DepthToSpaceT;
+
+struct DetectionPostProcess;
+struct DetectionPostProcessBuilder;
+struct DetectionPostProcessT;
+
+struct DivFusion;
+struct DivFusionBuilder;
+struct DivFusionT;
+
+struct DivGrad;
+struct DivGradBuilder;
+struct DivGradT;
+
+struct Dropout;
+struct DropoutBuilder;
+struct DropoutT;
+
+struct DropoutGrad;
+struct DropoutGradBuilder;
+struct DropoutGradT;
+
+struct Elu;
+struct EluBuilder;
+struct EluT;
+
+struct Eltwise;
+struct EltwiseBuilder;
+struct EltwiseT;
+
+struct Equal;
+struct EqualBuilder;
+struct EqualT;
+
+struct EmbeddingLookupFusion;
+struct EmbeddingLookupFusionBuilder;
+struct EmbeddingLookupFusionT;
+
+struct ExpFusion;
+struct ExpFusionBuilder;
+struct ExpFusionT;
+
+struct ExpandDims;
+struct ExpandDimsBuilder;
+struct ExpandDimsT;
+
+struct FakeQuantWithMinMaxVars;
+struct FakeQuantWithMinMaxVarsBuilder;
+struct FakeQuantWithMinMaxVarsT;
+
+struct FakeQuantWithMinMaxVarsPerChannel;
+struct FakeQuantWithMinMaxVarsPerChannelBuilder;
+struct FakeQuantWithMinMaxVarsPerChannelT;
+
+struct FftReal;
+struct FftRealBuilder;
+struct FftRealT;
+
+struct FftImag;
+struct FftImagBuilder;
+struct FftImagT;
+
+struct Flatten;
+struct FlattenBuilder;
+struct FlattenT;
+
+struct FlattenGrad;
+struct FlattenGradBuilder;
+struct FlattenGradT;
+
+struct Floor;
+struct FloorBuilder;
+struct FloorT;
+
+struct FloorDiv;
+struct FloorDivBuilder;
+struct FloorDivT;
+
+struct FloorMod;
+struct FloorModBuilder;
+struct FloorModT;
+
+struct Fill;
+struct FillBuilder;
+struct FillT;
+
+struct FullConnection;
+struct FullConnectionBuilder;
+struct FullConnectionT;
+
+struct FusedBatchNorm;
+struct FusedBatchNormBuilder;
+struct FusedBatchNormT;
+
+struct Gather;
+struct GatherBuilder;
+struct GatherT;
+
+struct GatherNd;
+struct GatherNdBuilder;
+struct GatherNdT;
+
+struct Greater;
+struct GreaterBuilder;
+struct GreaterT;
+
+struct GreaterEqual;
+struct GreaterEqualBuilder;
+struct GreaterEqualT;
+
+struct HashtableLookup;
+struct HashtableLookupBuilder;
+struct HashtableLookupT;
+
+struct InstanceNorm;
+struct InstanceNormBuilder;
+struct InstanceNormT;
+
+struct LayerNormFusion;
+struct LayerNormFusionBuilder;
+struct LayerNormFusionT;
+
+struct LeakyRelu;
+struct LeakyReluBuilder;
+struct LeakyReluT;
+
+struct Less;
+struct LessBuilder;
+struct LessT;
+
+struct LessEqual;
+struct LessEqualBuilder;
+struct LessEqualT;
+
+struct Log;
+struct LogBuilder;
+struct LogT;
+
+struct LogGrad;
+struct LogGradBuilder;
+struct LogGradT;
+
+struct LogicalAnd;
+struct LogicalAndBuilder;
+struct LogicalAndT;
+
+struct LogicalNot;
+struct LogicalNotBuilder;
+struct LogicalNotT;
+
+struct LogicalOr;
+struct LogicalOrBuilder;
+struct LogicalOrT;
+
+struct LpNormalization;
+struct LpNormalizationBuilder;
+struct LpNormalizationT;
+
+struct LRN;
+struct LRNBuilder;
+struct LRNT;
+
+struct LshProjection;
+struct LshProjectionBuilder;
+struct LshProjectionT;
+
+struct LSTM;
+struct LSTMBuilder;
+struct LSTMT;
+
+struct LSTMGrad;
+struct LSTMGradBuilder;
+struct LSTMGradT;
+
+struct L2NormalizeFusion;
+struct L2NormalizeFusionBuilder;
+struct L2NormalizeFusionT;
+
+struct MatMulFusion;
+struct MatMulFusionBuilder;
+struct MatMulFusionT;
+
+struct Maximum;
+struct MaximumBuilder;
+struct MaximumT;
+
+struct MaximumGrad;
+struct MaximumGradBuilder;
+struct MaximumGradT;
+
+struct MaxPoolFusion;
+struct MaxPoolFusionBuilder;
+struct MaxPoolFusionT;
+
+struct MaxPoolGrad;
+struct MaxPoolGradBuilder;
+struct MaxPoolGradT;
+
+struct SwitchLayer;
+struct SwitchLayerBuilder;
+struct SwitchLayerT;
+
+struct Mfcc;
+struct MfccBuilder;
+struct MfccT;
+
+struct Minimum;
+struct MinimumBuilder;
+struct MinimumT;
+
+struct MinimumGrad;
+struct MinimumGradBuilder;
+struct MinimumGradT;
+
+struct Mod;
+struct ModBuilder;
+struct ModT;
+
+struct MulFusion;
+struct MulFusionBuilder;
+struct MulFusionT;
+
+struct MulGrad;
+struct MulGradBuilder;
+struct MulGradT;
+
+struct Neg;
+struct NegBuilder;
+struct NegT;
+
+struct NegGrad;
+struct NegGradBuilder;
+struct NegGradT;
+
+struct NotEqual;
+struct NotEqualBuilder;
+struct NotEqualT;
+
+struct NonMaxSuppression;
+struct NonMaxSuppressionBuilder;
+struct NonMaxSuppressionT;
+
+struct OneHot;
+struct OneHotBuilder;
+struct OneHotT;
+
+struct OnesLike;
+struct OnesLikeBuilder;
+struct OnesLikeT;
+
+struct PadFusion;
+struct PadFusionBuilder;
+struct PadFusionT;
+
+struct PartialFusion;
+struct PartialFusionBuilder;
+struct PartialFusionT;
+
+struct PowerGrad;
+struct PowerGradBuilder;
+struct PowerGradT;
+
+struct PowFusion;
+struct PowFusionBuilder;
+struct PowFusionT;
+
+struct PriorBox;
+struct PriorBoxBuilder;
+struct PriorBoxT;
+
+struct PReLUFusion;
+struct PReLUFusionBuilder;
+struct PReLUFusionT;
+
+struct Rank;
+struct RankBuilder;
+struct RankT;
+
+struct Range;
+struct RangeBuilder;
+struct RangeT;
+
+struct Reciprocal;
+struct ReciprocalBuilder;
+struct ReciprocalT;
+
+struct RealDiv;
+struct RealDivBuilder;
+struct RealDivT;
+
+struct ReduceFusion;
+struct ReduceFusionBuilder;
+struct ReduceFusionT;
+
+struct Reshape;
+struct ReshapeBuilder;
+struct ReshapeT;
+
+struct Resize;
+struct ResizeBuilder;
+struct ResizeT;
+
+struct ReverseSequence;
+struct ReverseSequenceBuilder;
+struct ReverseSequenceT;
+
+struct ReverseV2;
+struct ReverseV2Builder;
+struct ReverseV2T;
+
+struct Rfft;
+struct RfftBuilder;
+struct RfftT;
+
+struct ROIPooling;
+struct ROIPoolingBuilder;
+struct ROIPoolingT;
+
+struct Round;
+struct RoundBuilder;
+struct RoundT;
+
+struct Rsqrt;
+struct RsqrtBuilder;
+struct RsqrtT;
+
+struct QuantDTypeCast;
+struct QuantDTypeCastBuilder;
+struct QuantDTypeCastT;
+
+struct ScaleFusion;
+struct ScaleFusionBuilder;
+struct ScaleFusionT;
+
+struct ScatterNd;
+struct ScatterNdBuilder;
+struct ScatterNdT;
+
+struct SGD;
+struct SGDBuilder;
+struct SGDT;
+
+struct Shape;
+struct ShapeBuilder;
+struct ShapeT;
+
+struct SigmoidCrossEntropyWithLogits;
+struct SigmoidCrossEntropyWithLogitsBuilder;
+struct SigmoidCrossEntropyWithLogitsT;
+
+struct SigmoidCrossEntropyWithLogitsGrad;
+struct SigmoidCrossEntropyWithLogitsGradBuilder;
+struct SigmoidCrossEntropyWithLogitsGradT;
+
+struct Sin;
+struct SinBuilder;
+struct SinT;
+
+struct SkipGram;
+struct SkipGramBuilder;
+struct SkipGramT;
+
+struct SliceFusion;
+struct SliceFusionBuilder;
+struct SliceFusionT;
+
+struct SmoothL1Loss;
+struct SmoothL1LossBuilder;
+struct SmoothL1LossT;
+
+struct SmoothL1LossGrad;
+struct SmoothL1LossGradBuilder;
+struct SmoothL1LossGradT;
+
+struct Softmax;
+struct SoftmaxBuilder;
+struct SoftmaxT;
+
+struct SoftmaxCrossEntropyWithLogits;
+struct SoftmaxCrossEntropyWithLogitsBuilder;
+struct SoftmaxCrossEntropyWithLogitsT;
+
+struct SpaceToBatch;
+struct SpaceToBatchBuilder;
+struct SpaceToBatchT;
+
+struct SpaceToBatchND;
+struct SpaceToBatchNDBuilder;
+struct SpaceToBatchNDT;
+
+struct SpaceToDepth;
+struct SpaceToDepthBuilder;
+struct SpaceToDepthT;
+
+struct SparseSoftmaxCrossEntropyWithLogits;
+struct SparseSoftmaxCrossEntropyWithLogitsBuilder;
+struct SparseSoftmaxCrossEntropyWithLogitsT;
+
+struct SparseToDense;
+struct SparseToDenseBuilder;
+struct SparseToDenseT;
+
+struct Split;
+struct SplitBuilder;
+struct SplitT;
+
+struct Sqrt;
+struct SqrtBuilder;
+struct SqrtT;
+
+struct Squeeze;
+struct SqueezeBuilder;
+struct SqueezeT;
+
+struct Square;
+struct SquareBuilder;
+struct SquareT;
+
+struct SquaredDifference;
+struct SquaredDifferenceBuilder;
+struct SquaredDifferenceT;
+
+struct Stack;
+struct StackBuilder;
+struct StackT;
+
+struct StridedSlice;
+struct StridedSliceBuilder;
+struct StridedSliceT;
+
+struct SubFusion;
+struct SubFusionBuilder;
+struct SubFusionT;
+
+struct SubGrad;
+struct SubGradBuilder;
+struct SubGradT;
+
+struct Switch;
+struct SwitchBuilder;
+struct SwitchT;
+
+struct TensorListFromTensor;
+struct TensorListFromTensorBuilder;
+struct TensorListFromTensorT;
+
+struct TensorListGetItem;
+struct TensorListGetItemBuilder;
+struct TensorListGetItemT;
+
+struct TensorListReserve;
+struct TensorListReserveBuilder;
+struct TensorListReserveT;
+
+struct TensorListSetItem;
+struct TensorListSetItemBuilder;
+struct TensorListSetItemT;
+
+struct TensorListStack;
+struct TensorListStackBuilder;
+struct TensorListStackT;
+
+struct TileFusion;
+struct TileFusionBuilder;
+struct TileFusionT;
+
+struct TopKFusion;
+struct TopKFusionBuilder;
+struct TopKFusionT;
+
+struct Transpose;
+struct TransposeBuilder;
+struct TransposeT;
+
+struct Unique;
+struct UniqueBuilder;
+struct UniqueT;
+
+struct UnsortedSegmentSum;
+struct UnsortedSegmentSumBuilder;
+struct UnsortedSegmentSumT;
+
+struct Unsqueeze;
+struct UnsqueezeBuilder;
+struct UnsqueezeT;
+
+struct Unstack;
+struct UnstackBuilder;
+struct UnstackT;
+
+struct Where;
+struct WhereBuilder;
+struct WhereT;
+
+struct ZerosLike;
+struct ZerosLikeBuilder;
+struct ZerosLikeT;
+
+struct Select;
+struct SelectBuilder;
+struct SelectT;
+
+struct GRU;
+struct GRUBuilder;
+struct GRUT;
+
+struct NonZero;
+struct NonZeroBuilder;
+struct NonZeroT;
+
+struct InvertPermutation;
+struct InvertPermutationBuilder;
+struct InvertPermutationT;
+
+struct Size;
+struct SizeBuilder;
+struct SizeT;
+
+struct RandomStandardNormal;
+struct RandomStandardNormalBuilder;
+struct RandomStandardNormalT;
+
+struct CropAndResize;
+struct CropAndResizeBuilder;
+struct CropAndResizeT;
+
+struct Erf;
+struct ErfBuilder;
+struct ErfT;
+
+struct StridedSliceGrad;
+struct StridedSliceGradBuilder;
+struct StridedSliceGradT;
+
+struct IsFinite;
+struct IsFiniteBuilder;
+struct IsFiniteT;
+
+struct LinSpace;
+struct LinSpaceBuilder;
+struct LinSpaceT;
+
+struct UniformReal;
+struct UniformRealBuilder;
+struct UniformRealT;
+
+struct AbsGrad;
+struct AbsGradBuilder;
+struct AbsGradT;
+
+struct RsqrtGrad;
+struct RsqrtGradBuilder;
+struct RsqrtGradT;
+
+struct SqrtGrad;
+struct SqrtGradBuilder;
+struct SqrtGradT;
+
+struct LayerNormGrad;
+struct LayerNormGradBuilder;
+struct LayerNormGradT;
+
+struct ResizeGrad;
+struct ResizeGradBuilder;
+struct ResizeGradT;
+
+struct Splice;
+struct SpliceBuilder;
+struct SpliceT;
+
+struct LogSoftmax;
+struct LogSoftmaxBuilder;
+struct LogSoftmaxT;
+
+struct Call;
+struct CallBuilder;
+struct CallT;
+
+struct CumSum;
+struct CumSumBuilder;
+struct CumSumT;
+
+struct Custom;
+struct CustomBuilder;
+struct CustomT;
+
+struct SplitWithOverlap;
+struct SplitWithOverlapBuilder;
+struct SplitWithOverlapT;
+
+struct GenOP;
+struct GenOPBuilder;
+struct GenOPT;
+
+struct RaggedRange;
+struct RaggedRangeBuilder;
+struct RaggedRangeT;
+
+struct GLU;
+struct GLUBuilder;
+struct GLUT;
+
+struct TensorArray;
+struct TensorArrayBuilder;
+struct TensorArrayT;
+
+struct TensorArrayRead;
+struct TensorArrayReadBuilder;
+struct TensorArrayReadT;
+
+struct TensorArrayWrite;
+struct TensorArrayWriteBuilder;
+struct TensorArrayWriteT;
+
+struct Affine;
+struct AffineBuilder;
+struct AffineT;
+
+struct ScatterNdUpdate;
+struct ScatterNdUpdateBuilder;
+struct ScatterNdUpdateT;
+
+struct AllGather;
+struct AllGatherBuilder;
+struct AllGatherT;
+
+struct ReduceScatter;
+struct ReduceScatterBuilder;
+struct ReduceScatterT;
+
+struct DynamicQuant;
+struct DynamicQuantBuilder;
+struct DynamicQuantT;
+
+struct LSTMGradData;
+struct LSTMGradDataBuilder;
+struct LSTMGradDataT;
+
+struct LSTMGradWeight;
+struct LSTMGradWeightBuilder;
+struct LSTMGradWeightT;
+
+struct RandomNormal;
+struct RandomNormalBuilder;
+struct RandomNormalT;
+
+struct NLLLoss;
+struct NLLLossBuilder;
+struct NLLLossT;
+
+struct NLLLossGrad;
+struct NLLLossGradBuilder;
+struct NLLLossGradT;
+
+struct FormatTranspose;
+struct FormatTransposeBuilder;
+struct FormatTransposeT;
+
+struct GatherD;
+struct GatherDBuilder;
+struct GatherDT;
+
+struct GroupNormFusion;
+struct GroupNormFusionBuilder;
+struct GroupNormFusionT;
+
+inline const flatbuffers::TypeTable *AbsTypeTable();
+
+inline const flatbuffers::TypeTable *ActivationTypeTable();
+
+inline const flatbuffers::TypeTable *ActivationGradTypeTable();
+
+inline const flatbuffers::TypeTable *AdamTypeTable();
+
+inline const flatbuffers::TypeTable *AddFusionTypeTable();
+
+inline const flatbuffers::TypeTable *AdderFusionTypeTable();
+
+inline const flatbuffers::TypeTable *AddGradTypeTable();
+
+inline const flatbuffers::TypeTable *AddNTypeTable();
+
+inline const flatbuffers::TypeTable *AllTypeTable();
+
+inline const flatbuffers::TypeTable *ApplyMomentumTypeTable();
+
+inline const flatbuffers::TypeTable *ArgMaxFusionTypeTable();
+
+inline const flatbuffers::TypeTable *ArgMinFusionTypeTable();
+
+inline const flatbuffers::TypeTable *AssertTypeTable();
+
+inline const flatbuffers::TypeTable *AssignTypeTable();
+
+inline const flatbuffers::TypeTable *AssignAddTypeTable();
+
+inline const flatbuffers::TypeTable *AudioSpectrogramTypeTable();
+
+inline const flatbuffers::TypeTable *AvgPoolFusionTypeTable();
+
+inline const flatbuffers::TypeTable *AvgPoolGradTypeTable();
+
+inline const flatbuffers::TypeTable *BatchNormTypeTable();
+
+inline const flatbuffers::TypeTable *BatchNormGradTypeTable();
+
+inline const flatbuffers::TypeTable *BatchToSpaceTypeTable();
+
+inline const flatbuffers::TypeTable *BatchToSpaceNDTypeTable();
+
+inline const flatbuffers::TypeTable *BiasAddTypeTable();
+
+inline const flatbuffers::TypeTable *BinaryCrossEntropyTypeTable();
+
+inline const flatbuffers::TypeTable *BinaryCrossEntropyGradTypeTable();
+
+inline const flatbuffers::TypeTable *BiasAddGradTypeTable();
+
+inline const flatbuffers::TypeTable *BroadcastToTypeTable();
+
+inline const flatbuffers::TypeTable *CastTypeTable();
+
+inline const flatbuffers::TypeTable *CeilTypeTable();
+
+inline const flatbuffers::TypeTable *ClipTypeTable();
+
+inline const flatbuffers::TypeTable *ConcatTypeTable();
+
+inline const flatbuffers::TypeTable *AttentionTypeTable();
+
+inline const flatbuffers::TypeTable *Conv2DBackpropFilterFusionTypeTable();
+
+inline const flatbuffers::TypeTable *Conv2DBackpropInputFusionTypeTable();
+
+inline const flatbuffers::TypeTable *Conv2DFusionTypeTable();
+
+inline const flatbuffers::TypeTable *Conv2dTransposeFusionTypeTable();
+
+inline const flatbuffers::TypeTable *CosTypeTable();
+
+inline const flatbuffers::TypeTable *ConstantOfShapeTypeTable();
+
+inline const flatbuffers::TypeTable *CropTypeTable();
+
+inline const flatbuffers::TypeTable *CustomExtractFeaturesTypeTable();
+
+inline const flatbuffers::TypeTable *CustomNormalizeTypeTable();
+
+inline const flatbuffers::TypeTable *CustomPredictTypeTable();
+
+inline const flatbuffers::TypeTable *DeConv2DGradFilterTypeTable();
+
+inline const flatbuffers::TypeTable *DependTypeTable();
+
+inline const flatbuffers::TypeTable *DepthToSpaceTypeTable();
+
+inline const flatbuffers::TypeTable *DetectionPostProcessTypeTable();
+
+inline const flatbuffers::TypeTable *DivFusionTypeTable();
+
+inline const flatbuffers::TypeTable *DivGradTypeTable();
+
+inline const flatbuffers::TypeTable *DropoutTypeTable();
+
+inline const flatbuffers::TypeTable *DropoutGradTypeTable();
+
+inline const flatbuffers::TypeTable *EluTypeTable();
+
+inline const flatbuffers::TypeTable *EltwiseTypeTable();
+
+inline const flatbuffers::TypeTable *EqualTypeTable();
+
+inline const flatbuffers::TypeTable *EmbeddingLookupFusionTypeTable();
+
+inline const flatbuffers::TypeTable *ExpFusionTypeTable();
+
+inline const flatbuffers::TypeTable *ExpandDimsTypeTable();
+
+inline const flatbuffers::TypeTable *FakeQuantWithMinMaxVarsTypeTable();
+
+inline const flatbuffers::TypeTable *FakeQuantWithMinMaxVarsPerChannelTypeTable();
+
+inline const flatbuffers::TypeTable *FftRealTypeTable();
+
+inline const flatbuffers::TypeTable *FftImagTypeTable();
+
+inline const flatbuffers::TypeTable *FlattenTypeTable();
+
+inline const flatbuffers::TypeTable *FlattenGradTypeTable();
+
+inline const flatbuffers::TypeTable *FloorTypeTable();
+
+inline const flatbuffers::TypeTable *FloorDivTypeTable();
+
+inline const flatbuffers::TypeTable *FloorModTypeTable();
+
+inline const flatbuffers::TypeTable *FillTypeTable();
+
+inline const flatbuffers::TypeTable *FullConnectionTypeTable();
+
+inline const flatbuffers::TypeTable *FusedBatchNormTypeTable();
+
+inline const flatbuffers::TypeTable *GatherTypeTable();
+
+inline const flatbuffers::TypeTable *GatherNdTypeTable();
+
+inline const flatbuffers::TypeTable *GreaterTypeTable();
+
+inline const flatbuffers::TypeTable *GreaterEqualTypeTable();
+
+inline const flatbuffers::TypeTable *HashtableLookupTypeTable();
+
+inline const flatbuffers::TypeTable *InstanceNormTypeTable();
+
+inline const flatbuffers::TypeTable *LayerNormFusionTypeTable();
+
+inline const flatbuffers::TypeTable *LeakyReluTypeTable();
+
+inline const flatbuffers::TypeTable *LessTypeTable();
+
+inline const flatbuffers::TypeTable *LessEqualTypeTable();
+
+inline const flatbuffers::TypeTable *LogTypeTable();
+
+inline const flatbuffers::TypeTable *LogGradTypeTable();
+
+inline const flatbuffers::TypeTable *LogicalAndTypeTable();
+
+inline const flatbuffers::TypeTable *LogicalNotTypeTable();
+
+inline const flatbuffers::TypeTable *LogicalOrTypeTable();
+
+inline const flatbuffers::TypeTable *LpNormalizationTypeTable();
+
+inline const flatbuffers::TypeTable *LRNTypeTable();
+
+inline const flatbuffers::TypeTable *LshProjectionTypeTable();
+
+inline const flatbuffers::TypeTable *LSTMTypeTable();
+
+inline const flatbuffers::TypeTable *LSTMGradTypeTable();
+
+inline const flatbuffers::TypeTable *L2NormalizeFusionTypeTable();
+
+inline const flatbuffers::TypeTable *MatMulFusionTypeTable();
+
+inline const flatbuffers::TypeTable *MaximumTypeTable();
+
+inline const flatbuffers::TypeTable *MaximumGradTypeTable();
+
+inline const flatbuffers::TypeTable *MaxPoolFusionTypeTable();
+
+inline const flatbuffers::TypeTable *MaxPoolGradTypeTable();
+
+inline const flatbuffers::TypeTable *SwitchLayerTypeTable();
+
+inline const flatbuffers::TypeTable *MfccTypeTable();
+
+inline const flatbuffers::TypeTable *MinimumTypeTable();
+
+inline const flatbuffers::TypeTable *MinimumGradTypeTable();
+
+inline const flatbuffers::TypeTable *ModTypeTable();
+
+inline const flatbuffers::TypeTable *MulFusionTypeTable();
+
+inline const flatbuffers::TypeTable *MulGradTypeTable();
+
+inline const flatbuffers::TypeTable *NegTypeTable();
+
+inline const flatbuffers::TypeTable *NegGradTypeTable();
+
+inline const flatbuffers::TypeTable *NotEqualTypeTable();
+
+inline const flatbuffers::TypeTable *NonMaxSuppressionTypeTable();
+
+inline const flatbuffers::TypeTable *OneHotTypeTable();
+
+inline const flatbuffers::TypeTable *OnesLikeTypeTable();
+
+inline const flatbuffers::TypeTable *PadFusionTypeTable();
+
+inline const flatbuffers::TypeTable *PartialFusionTypeTable();
+
+inline const flatbuffers::TypeTable *PowerGradTypeTable();
+
+inline const flatbuffers::TypeTable *PowFusionTypeTable();
+
+inline const flatbuffers::TypeTable *PriorBoxTypeTable();
+
+inline const flatbuffers::TypeTable *PReLUFusionTypeTable();
+
+inline const flatbuffers::TypeTable *RankTypeTable();
+
+inline const flatbuffers::TypeTable *RangeTypeTable();
+
+inline const flatbuffers::TypeTable *ReciprocalTypeTable();
+
+inline const flatbuffers::TypeTable *RealDivTypeTable();
+
+inline const flatbuffers::TypeTable *ReduceFusionTypeTable();
+
+inline const flatbuffers::TypeTable *ReshapeTypeTable();
+
+inline const flatbuffers::TypeTable *ResizeTypeTable();
+
+inline const flatbuffers::TypeTable *ReverseSequenceTypeTable();
+
+inline const flatbuffers::TypeTable *ReverseV2TypeTable();
+
+inline const flatbuffers::TypeTable *RfftTypeTable();
+
+inline const flatbuffers::TypeTable *ROIPoolingTypeTable();
+
+inline const flatbuffers::TypeTable *RoundTypeTable();
+
+inline const flatbuffers::TypeTable *RsqrtTypeTable();
+
+inline const flatbuffers::TypeTable *QuantDTypeCastTypeTable();
+
+inline const flatbuffers::TypeTable *ScaleFusionTypeTable();
+
+inline const flatbuffers::TypeTable *ScatterNdTypeTable();
+
+inline const flatbuffers::TypeTable *SGDTypeTable();
+
+inline const flatbuffers::TypeTable *ShapeTypeTable();
+
+inline const flatbuffers::TypeTable *SigmoidCrossEntropyWithLogitsTypeTable();
+
+inline const flatbuffers::TypeTable *SigmoidCrossEntropyWithLogitsGradTypeTable();
+
+inline const flatbuffers::TypeTable *SinTypeTable();
+
+inline const flatbuffers::TypeTable *SkipGramTypeTable();
+
+inline const flatbuffers::TypeTable *SliceFusionTypeTable();
+
+inline const flatbuffers::TypeTable *SmoothL1LossTypeTable();
+
+inline const flatbuffers::TypeTable *SmoothL1LossGradTypeTable();
+
+inline const flatbuffers::TypeTable *SoftmaxTypeTable();
+
+inline const flatbuffers::TypeTable *SoftmaxCrossEntropyWithLogitsTypeTable();
+
+inline const flatbuffers::TypeTable *SpaceToBatchTypeTable();
+
+inline const flatbuffers::TypeTable *SpaceToBatchNDTypeTable();
+
+inline const flatbuffers::TypeTable *SpaceToDepthTypeTable();
+
+inline const flatbuffers::TypeTable *SparseSoftmaxCrossEntropyWithLogitsTypeTable();
+
+inline const flatbuffers::TypeTable *SparseToDenseTypeTable();
+
+inline const flatbuffers::TypeTable *SplitTypeTable();
+
+inline const flatbuffers::TypeTable *SqrtTypeTable();
+
+inline const flatbuffers::TypeTable *SqueezeTypeTable();
+
+inline const flatbuffers::TypeTable *SquareTypeTable();
+
+inline const flatbuffers::TypeTable *SquaredDifferenceTypeTable();
+
+inline const flatbuffers::TypeTable *StackTypeTable();
+
+inline const flatbuffers::TypeTable *StridedSliceTypeTable();
+
+inline const flatbuffers::TypeTable *SubFusionTypeTable();
+
+inline const flatbuffers::TypeTable *SubGradTypeTable();
+
+inline const flatbuffers::TypeTable *SwitchTypeTable();
+
+inline const flatbuffers::TypeTable *TensorListFromTensorTypeTable();
+
+inline const flatbuffers::TypeTable *TensorListGetItemTypeTable();
+
+inline const flatbuffers::TypeTable *TensorListReserveTypeTable();
+
+inline const flatbuffers::TypeTable *TensorListSetItemTypeTable();
+
+inline const flatbuffers::TypeTable *TensorListStackTypeTable();
+
+inline const flatbuffers::TypeTable *TileFusionTypeTable();
+
+inline const flatbuffers::TypeTable *TopKFusionTypeTable();
+
+inline const flatbuffers::TypeTable *TransposeTypeTable();
+
+inline const flatbuffers::TypeTable *UniqueTypeTable();
+
+inline const flatbuffers::TypeTable *UnsortedSegmentSumTypeTable();
+
+inline const flatbuffers::TypeTable *UnsqueezeTypeTable();
+
+inline const flatbuffers::TypeTable *UnstackTypeTable();
+
+inline const flatbuffers::TypeTable *WhereTypeTable();
+
+inline const flatbuffers::TypeTable *ZerosLikeTypeTable();
+
+inline const flatbuffers::TypeTable *SelectTypeTable();
+
+inline const flatbuffers::TypeTable *GRUTypeTable();
+
+inline const flatbuffers::TypeTable *NonZeroTypeTable();
+
+inline const flatbuffers::TypeTable *InvertPermutationTypeTable();
+
+inline const flatbuffers::TypeTable *SizeTypeTable();
+
+inline const flatbuffers::TypeTable *RandomStandardNormalTypeTable();
+
+inline const flatbuffers::TypeTable *CropAndResizeTypeTable();
+
+inline const flatbuffers::TypeTable *ErfTypeTable();
+
+inline const flatbuffers::TypeTable *StridedSliceGradTypeTable();
+
+inline const flatbuffers::TypeTable *IsFiniteTypeTable();
+
+inline const flatbuffers::TypeTable *LinSpaceTypeTable();
+
+inline const flatbuffers::TypeTable *UniformRealTypeTable();
+
+inline const flatbuffers::TypeTable *AbsGradTypeTable();
+
+inline const flatbuffers::TypeTable *RsqrtGradTypeTable();
+
+inline const flatbuffers::TypeTable *SqrtGradTypeTable();
+
+inline const flatbuffers::TypeTable *LayerNormGradTypeTable();
+
+inline const flatbuffers::TypeTable *ResizeGradTypeTable();
+
+inline const flatbuffers::TypeTable *SpliceTypeTable();
+
+inline const flatbuffers::TypeTable *LogSoftmaxTypeTable();
+
+inline const flatbuffers::TypeTable *CallTypeTable();
+
+inline const flatbuffers::TypeTable *CumSumTypeTable();
+
+inline const flatbuffers::TypeTable *CustomTypeTable();
+
+inline const flatbuffers::TypeTable *SplitWithOverlapTypeTable();
+
+inline const flatbuffers::TypeTable *GenOPTypeTable();
+
+inline const flatbuffers::TypeTable *RaggedRangeTypeTable();
+
+inline const flatbuffers::TypeTable *GLUTypeTable();
+
+inline const flatbuffers::TypeTable *TensorArrayTypeTable();
+
+inline const flatbuffers::TypeTable *TensorArrayReadTypeTable();
+
+inline const flatbuffers::TypeTable *TensorArrayWriteTypeTable();
+
+inline const flatbuffers::TypeTable *AffineTypeTable();
+
+inline const flatbuffers::TypeTable *ScatterNdUpdateTypeTable();
+
+inline const flatbuffers::TypeTable *AllGatherTypeTable();
+
+inline const flatbuffers::TypeTable *ReduceScatterTypeTable();
+
+inline const flatbuffers::TypeTable *DynamicQuantTypeTable();
+
+inline const flatbuffers::TypeTable *LSTMGradDataTypeTable();
+
+inline const flatbuffers::TypeTable *LSTMGradWeightTypeTable();
+
+inline const flatbuffers::TypeTable *RandomNormalTypeTable();
+
+inline const flatbuffers::TypeTable *NLLLossTypeTable();
+
+inline const flatbuffers::TypeTable *NLLLossGradTypeTable();
+
+inline const flatbuffers::TypeTable *FormatTransposeTypeTable();
+
+inline const flatbuffers::TypeTable *GatherDTypeTable();
+
+inline const flatbuffers::TypeTable *GroupNormFusionTypeTable();
+
+enum PrimitiveType : uint8_t {
+  PrimitiveType_NONE = 0,
+  PrimitiveType_Abs = 1,
+  PrimitiveType_Activation = 2,
+  PrimitiveType_ActivationGrad = 3,
+  PrimitiveType_Adam = 4,
+  PrimitiveType_AddFusion = 5,
+  PrimitiveType_AdderFusion = 6,
+  PrimitiveType_AddGrad = 7,
+  PrimitiveType_AddN = 8,
+  PrimitiveType_All = 9,
+  PrimitiveType_ApplyMomentum = 10,
+  PrimitiveType_ArgMaxFusion = 11,
+  PrimitiveType_ArgMinFusion = 12,
+  PrimitiveType_Assert = 13,
+  PrimitiveType_Assign = 14,
+  PrimitiveType_AssignAdd = 15,
+  PrimitiveType_AudioSpectrogram = 16,
+  PrimitiveType_AvgPoolFusion = 17,
+  PrimitiveType_AvgPoolGrad = 18,
+  PrimitiveType_BatchNorm = 19,
+  PrimitiveType_BatchNormGrad = 20,
+  PrimitiveType_BatchToSpace = 21,
+  PrimitiveType_BatchToSpaceND = 22,
+  PrimitiveType_BiasAdd = 23,
+  PrimitiveType_BinaryCrossEntropy = 24,
+  PrimitiveType_BinaryCrossEntropyGrad = 25,
+  PrimitiveType_BiasAddGrad = 26,
+  PrimitiveType_BroadcastTo = 27,
+  PrimitiveType_Cast = 28,
+  PrimitiveType_Ceil = 29,
+  PrimitiveType_Clip = 30,
+  PrimitiveType_Concat = 31,
+  PrimitiveType_Attention = 32,
+  PrimitiveType_Conv2DBackpropFilterFusion = 33,
+  PrimitiveType_Conv2DBackpropInputFusion = 34,
+  PrimitiveType_Conv2DFusion = 35,
+  PrimitiveType_Conv2dTransposeFusion = 36,
+  PrimitiveType_Cos = 37,
+  PrimitiveType_ConstantOfShape = 38,
+  PrimitiveType_Crop = 39,
+  PrimitiveType_CustomExtractFeatures = 40,
+  PrimitiveType_CustomNormalize = 41,
+  PrimitiveType_CustomPredict = 42,
+  PrimitiveType_DeConv2DGradFilter = 43,
+  PrimitiveType_Depend = 44,
+  PrimitiveType_DepthToSpace = 45,
+  PrimitiveType_DetectionPostProcess = 46,
+  PrimitiveType_DivFusion = 47,
+  PrimitiveType_DivGrad = 48,
+  PrimitiveType_Dropout = 49,
+  PrimitiveType_DropoutGrad = 50,
+  PrimitiveType_Elu = 51,
+  PrimitiveType_Eltwise = 52,
+  PrimitiveType_Equal = 53,
+  PrimitiveType_EmbeddingLookupFusion = 54,
+  PrimitiveType_ExpFusion = 55,
+  PrimitiveType_ExpandDims = 56,
+  PrimitiveType_FakeQuantWithMinMaxVars = 57,
+  PrimitiveType_FakeQuantWithMinMaxVarsPerChannel = 58,
+  PrimitiveType_FftReal = 59,
+  PrimitiveType_FftImag = 60,
+  PrimitiveType_Flatten = 61,
+  PrimitiveType_FlattenGrad = 62,
+  PrimitiveType_Floor = 63,
+  PrimitiveType_FloorDiv = 64,
+  PrimitiveType_FloorMod = 65,
+  PrimitiveType_Fill = 66,
+  PrimitiveType_FullConnection = 67,
+  PrimitiveType_FusedBatchNorm = 68,
+  PrimitiveType_Gather = 69,
+  PrimitiveType_GatherNd = 70,
+  PrimitiveType_Greater = 71,
+  PrimitiveType_GreaterEqual = 72,
+  PrimitiveType_HashtableLookup = 73,
+  PrimitiveType_InstanceNorm = 74,
+  PrimitiveType_LayerNormFusion = 75,
+  PrimitiveType_LeakyRelu = 76,
+  PrimitiveType_Less = 77,
+  PrimitiveType_LessEqual = 78,
+  PrimitiveType_Log = 79,
+  PrimitiveType_LogGrad = 80,
+  PrimitiveType_LogicalAnd = 81,
+  PrimitiveType_LogicalNot = 82,
+  PrimitiveType_LogicalOr = 83,
+  PrimitiveType_LpNormalization = 84,
+  PrimitiveType_LRN = 85,
+  PrimitiveType_LshProjection = 86,
+  PrimitiveType_LSTM = 87,
+  PrimitiveType_L2NormalizeFusion = 88,
+  PrimitiveType_MatMulFusion = 89,
+  PrimitiveType_Maximum = 90,
+  PrimitiveType_MaximumGrad = 91,
+  PrimitiveType_MaxPoolFusion = 92,
+  PrimitiveType_MaxPoolGrad = 93,
+  PrimitiveType_SwitchLayer = 94,
+  PrimitiveType_Mfcc = 95,
+  PrimitiveType_Minimum = 96,
+  PrimitiveType_MinimumGrad = 97,
+  PrimitiveType_Mod = 98,
+  PrimitiveType_MulFusion = 99,
+  PrimitiveType_MulGrad = 100,
+  PrimitiveType_Neg = 101,
+  PrimitiveType_NegGrad = 102,
+  PrimitiveType_NotEqual = 103,
+  PrimitiveType_NonMaxSuppression = 104,
+  PrimitiveType_OneHot = 105,
+  PrimitiveType_OnesLike = 106,
+  PrimitiveType_PadFusion = 107,
+  PrimitiveType_PartialFusion = 108,
+  PrimitiveType_PowerGrad = 109,
+  PrimitiveType_PowFusion = 110,
+  PrimitiveType_PriorBox = 111,
+  PrimitiveType_PReLUFusion = 112,
+  PrimitiveType_QuantDTypeCast = 113,
+  PrimitiveType_Rank = 114,
+  PrimitiveType_Range = 115,
+  PrimitiveType_Reciprocal = 116,
+  PrimitiveType_RealDiv = 117,
+  PrimitiveType_ReduceFusion = 118,
+  PrimitiveType_Reshape = 119,
+  PrimitiveType_Resize = 120,
+  PrimitiveType_ReverseSequence = 121,
+  PrimitiveType_ReverseV2 = 122,
+  PrimitiveType_Rfft = 123,
+  PrimitiveType_ROIPooling = 124,
+  PrimitiveType_Round = 125,
+  PrimitiveType_Rsqrt = 126,
+  PrimitiveType_ScaleFusion = 127,
+  PrimitiveType_ScatterNd = 128,
+  PrimitiveType_SGD = 129,
+  PrimitiveType_Shape = 130,
+  PrimitiveType_SigmoidCrossEntropyWithLogits = 131,
+  PrimitiveType_SigmoidCrossEntropyWithLogitsGrad = 132,
+  PrimitiveType_Sin = 133,
+  PrimitiveType_SkipGram = 134,
+  PrimitiveType_SliceFusion = 135,
+  PrimitiveType_SmoothL1Loss = 136,
+  PrimitiveType_SmoothL1LossGrad = 137,
+  PrimitiveType_Softmax = 138,
+  PrimitiveType_SoftmaxCrossEntropyWithLogits = 139,
+  PrimitiveType_SpaceToBatch = 140,
+  PrimitiveType_SpaceToBatchND = 141,
+  PrimitiveType_SpaceToDepth = 142,
+  PrimitiveType_SparseSoftmaxCrossEntropyWithLogits = 143,
+  PrimitiveType_SparseToDense = 144,
+  PrimitiveType_Split = 145,
+  PrimitiveType_Sqrt = 146,
+  PrimitiveType_Squeeze = 147,
+  PrimitiveType_Square = 148,
+  PrimitiveType_SquaredDifference = 149,
+  PrimitiveType_Stack = 150,
+  PrimitiveType_StridedSlice = 151,
+  PrimitiveType_SubFusion = 152,
+  PrimitiveType_SubGrad = 153,
+  PrimitiveType_Switch = 154,
+  PrimitiveType_TensorListFromTensor = 155,
+  PrimitiveType_TensorListGetItem = 156,
+  PrimitiveType_TensorListReserve = 157,
+  PrimitiveType_TensorListSetItem = 158,
+  PrimitiveType_TensorListStack = 159,
+  PrimitiveType_TileFusion = 160,
+  PrimitiveType_TopKFusion = 161,
+  PrimitiveType_Transpose = 162,
+  PrimitiveType_Unique = 163,
+  PrimitiveType_UnsortedSegmentSum = 164,
+  PrimitiveType_Unsqueeze = 165,
+  PrimitiveType_Unstack = 166,
+  PrimitiveType_LSTMGrad = 167,
+  PrimitiveType_Where = 168,
+  PrimitiveType_ZerosLike = 169,
+  PrimitiveType_Select = 170,
+  PrimitiveType_ScatterNdUpdate = 171,
+  PrimitiveType_GRU = 172,
+  PrimitiveType_NonZero = 173,
+  PrimitiveType_InvertPermutation = 174,
+  PrimitiveType_Size = 175,
+  PrimitiveType_RandomStandardNormal = 176,
+  PrimitiveType_CropAndResize = 177,
+  PrimitiveType_Erf = 178,
+  PrimitiveType_StridedSliceGrad = 179,
+  PrimitiveType_IsFinite = 180,
+  PrimitiveType_LinSpace = 181,
+  PrimitiveType_UniformReal = 182,
+  PrimitiveType_AbsGrad = 183,
+  PrimitiveType_RsqrtGrad = 184,
+  PrimitiveType_SqrtGrad = 185,
+  PrimitiveType_LayerNormGrad = 186,
+  PrimitiveType_ResizeGrad = 187,
+  PrimitiveType_Splice = 188,
+  PrimitiveType_LogSoftmax = 189,
+  PrimitiveType_Call = 190,
+  PrimitiveType_Custom = 191,
+  PrimitiveType_CumSum = 192,
+  PrimitiveType_SplitWithOverlap = 193,
+  PrimitiveType_GenOP = 194,
+  PrimitiveType_RaggedRange = 195,
+  PrimitiveType_GLU = 196,
+  PrimitiveType_TensorArray = 197,
+  PrimitiveType_TensorArrayRead = 198,
+  PrimitiveType_TensorArrayWrite = 199,
+  PrimitiveType_Affine = 200,
+  PrimitiveType_AllGather = 201,
+  PrimitiveType_ReduceScatter = 202,
+  PrimitiveType_DynamicQuant = 203,
+  PrimitiveType_LSTMGradData = 204,
+  PrimitiveType_LSTMGradWeight = 205,
+  PrimitiveType_RandomNormal = 206,
+  PrimitiveType_NLLLoss = 207,
+  PrimitiveType_NLLLossGrad = 208,
+  PrimitiveType_FormatTranspose = 209,
+  PrimitiveType_GatherD = 210,
+  PrimitiveType_GroupNormFusion = 211,
+  PrimitiveType_MIN = PrimitiveType_NONE,
+  PrimitiveType_MAX = PrimitiveType_GroupNormFusion
+};
+
+inline const PrimitiveType (&EnumValuesPrimitiveType())[212] {
+  static const PrimitiveType values[] = {
+    PrimitiveType_NONE,
+    PrimitiveType_Abs,
+    PrimitiveType_Activation,
+    PrimitiveType_ActivationGrad,
+    PrimitiveType_Adam,
+    PrimitiveType_AddFusion,
+    PrimitiveType_AdderFusion,
+    PrimitiveType_AddGrad,
+    PrimitiveType_AddN,
+    PrimitiveType_All,
+    PrimitiveType_ApplyMomentum,
+    PrimitiveType_ArgMaxFusion,
+    PrimitiveType_ArgMinFusion,
+    PrimitiveType_Assert,
+    PrimitiveType_Assign,
+    PrimitiveType_AssignAdd,
+    PrimitiveType_AudioSpectrogram,
+    PrimitiveType_AvgPoolFusion,
+    PrimitiveType_AvgPoolGrad,
+    PrimitiveType_BatchNorm,
+    PrimitiveType_BatchNormGrad,
+    PrimitiveType_BatchToSpace,
+    PrimitiveType_BatchToSpaceND,
+    PrimitiveType_BiasAdd,
+    PrimitiveType_BinaryCrossEntropy,
+    PrimitiveType_BinaryCrossEntropyGrad,
+    PrimitiveType_BiasAddGrad,
+    PrimitiveType_BroadcastTo,
+    PrimitiveType_Cast,
+    PrimitiveType_Ceil,
+    PrimitiveType_Clip,
+    PrimitiveType_Concat,
+    PrimitiveType_Attention,
+    PrimitiveType_Conv2DBackpropFilterFusion,
+    PrimitiveType_Conv2DBackpropInputFusion,
+    PrimitiveType_Conv2DFusion,
+    PrimitiveType_Conv2dTransposeFusion,
+    PrimitiveType_Cos,
+    PrimitiveType_ConstantOfShape,
+    PrimitiveType_Crop,
+    PrimitiveType_CustomExtractFeatures,
+    PrimitiveType_CustomNormalize,
+    PrimitiveType_CustomPredict,
+    PrimitiveType_DeConv2DGradFilter,
+    PrimitiveType_Depend,
+    PrimitiveType_DepthToSpace,
+    PrimitiveType_DetectionPostProcess,
+    PrimitiveType_DivFusion,
+    PrimitiveType_DivGrad,
+    PrimitiveType_Dropout,
+    PrimitiveType_DropoutGrad,
+    PrimitiveType_Elu,
+    PrimitiveType_Eltwise,
+    PrimitiveType_Equal,
+    PrimitiveType_EmbeddingLookupFusion,
+    PrimitiveType_ExpFusion,
+    PrimitiveType_ExpandDims,
+    PrimitiveType_FakeQuantWithMinMaxVars,
+    PrimitiveType_FakeQuantWithMinMaxVarsPerChannel,
+    PrimitiveType_FftReal,
+    PrimitiveType_FftImag,
+    PrimitiveType_Flatten,
+    PrimitiveType_FlattenGrad,
+    PrimitiveType_Floor,
+    PrimitiveType_FloorDiv,
+    PrimitiveType_FloorMod,
+    PrimitiveType_Fill,
+    PrimitiveType_FullConnection,
+    PrimitiveType_FusedBatchNorm,
+    PrimitiveType_Gather,
+    PrimitiveType_GatherNd,
+    PrimitiveType_Greater,
+    PrimitiveType_GreaterEqual,
+    PrimitiveType_HashtableLookup,
+    PrimitiveType_InstanceNorm,
+    PrimitiveType_LayerNormFusion,
+    PrimitiveType_LeakyRelu,
+    PrimitiveType_Less,
+    PrimitiveType_LessEqual,
+    PrimitiveType_Log,
+    PrimitiveType_LogGrad,
+    PrimitiveType_LogicalAnd,
+    PrimitiveType_LogicalNot,
+    PrimitiveType_LogicalOr,
+    PrimitiveType_LpNormalization,
+    PrimitiveType_LRN,
+    PrimitiveType_LshProjection,
+    PrimitiveType_LSTM,
+    PrimitiveType_L2NormalizeFusion,
+    PrimitiveType_MatMulFusion,
+    PrimitiveType_Maximum,
+    PrimitiveType_MaximumGrad,
+    PrimitiveType_MaxPoolFusion,
+    PrimitiveType_MaxPoolGrad,
+    PrimitiveType_SwitchLayer,
+    PrimitiveType_Mfcc,
+    PrimitiveType_Minimum,
+    PrimitiveType_MinimumGrad,
+    PrimitiveType_Mod,
+    PrimitiveType_MulFusion,
+    PrimitiveType_MulGrad,
+    PrimitiveType_Neg,
+    PrimitiveType_NegGrad,
+    PrimitiveType_NotEqual,
+    PrimitiveType_NonMaxSuppression,
+    PrimitiveType_OneHot,
+    PrimitiveType_OnesLike,
+    PrimitiveType_PadFusion,
+    PrimitiveType_PartialFusion,
+    PrimitiveType_PowerGrad,
+    PrimitiveType_PowFusion,
+    PrimitiveType_PriorBox,
+    PrimitiveType_PReLUFusion,
+    PrimitiveType_QuantDTypeCast,
+    PrimitiveType_Rank,
+    PrimitiveType_Range,
+    PrimitiveType_Reciprocal,
+    PrimitiveType_RealDiv,
+    PrimitiveType_ReduceFusion,
+    PrimitiveType_Reshape,
+    PrimitiveType_Resize,
+    PrimitiveType_ReverseSequence,
+    PrimitiveType_ReverseV2,
+    PrimitiveType_Rfft,
+    PrimitiveType_ROIPooling,
+    PrimitiveType_Round,
+    PrimitiveType_Rsqrt,
+    PrimitiveType_ScaleFusion,
+    PrimitiveType_ScatterNd,
+    PrimitiveType_SGD,
+    PrimitiveType_Shape,
+    PrimitiveType_SigmoidCrossEntropyWithLogits,
+    PrimitiveType_SigmoidCrossEntropyWithLogitsGrad,
+    PrimitiveType_Sin,
+    PrimitiveType_SkipGram,
+    PrimitiveType_SliceFusion,
+    PrimitiveType_SmoothL1Loss,
+    PrimitiveType_SmoothL1LossGrad,
+    PrimitiveType_Softmax,
+    PrimitiveType_SoftmaxCrossEntropyWithLogits,
+    PrimitiveType_SpaceToBatch,
+    PrimitiveType_SpaceToBatchND,
+    PrimitiveType_SpaceToDepth,
+    PrimitiveType_SparseSoftmaxCrossEntropyWithLogits,
+    PrimitiveType_SparseToDense,
+    PrimitiveType_Split,
+    PrimitiveType_Sqrt,
+    PrimitiveType_Squeeze,
+    PrimitiveType_Square,
+    PrimitiveType_SquaredDifference,
+    PrimitiveType_Stack,
+    PrimitiveType_StridedSlice,
+    PrimitiveType_SubFusion,
+    PrimitiveType_SubGrad,
+    PrimitiveType_Switch,
+    PrimitiveType_TensorListFromTensor,
+    PrimitiveType_TensorListGetItem,
+    PrimitiveType_TensorListReserve,
+    PrimitiveType_TensorListSetItem,
+    PrimitiveType_TensorListStack,
+    PrimitiveType_TileFusion,
+    PrimitiveType_TopKFusion,
+    PrimitiveType_Transpose,
+    PrimitiveType_Unique,
+    PrimitiveType_UnsortedSegmentSum,
+    PrimitiveType_Unsqueeze,
+    PrimitiveType_Unstack,
+    PrimitiveType_LSTMGrad,
+    PrimitiveType_Where,
+    PrimitiveType_ZerosLike,
+    PrimitiveType_Select,
+    PrimitiveType_ScatterNdUpdate,
+    PrimitiveType_GRU,
+    PrimitiveType_NonZero,
+    PrimitiveType_InvertPermutation,
+    PrimitiveType_Size,
+    PrimitiveType_RandomStandardNormal,
+    PrimitiveType_CropAndResize,
+    PrimitiveType_Erf,
+    PrimitiveType_StridedSliceGrad,
+    PrimitiveType_IsFinite,
+    PrimitiveType_LinSpace,
+    PrimitiveType_UniformReal,
+    PrimitiveType_AbsGrad,
+    PrimitiveType_RsqrtGrad,
+    PrimitiveType_SqrtGrad,
+    PrimitiveType_LayerNormGrad,
+    PrimitiveType_ResizeGrad,
+    PrimitiveType_Splice,
+    PrimitiveType_LogSoftmax,
+    PrimitiveType_Call,
+    PrimitiveType_Custom,
+    PrimitiveType_CumSum,
+    PrimitiveType_SplitWithOverlap,
+    PrimitiveType_GenOP,
+    PrimitiveType_RaggedRange,
+    PrimitiveType_GLU,
+    PrimitiveType_TensorArray,
+    PrimitiveType_TensorArrayRead,
+    PrimitiveType_TensorArrayWrite,
+    PrimitiveType_Affine,
+    PrimitiveType_AllGather,
+    PrimitiveType_ReduceScatter,
+    PrimitiveType_DynamicQuant,
+    PrimitiveType_LSTMGradData,
+    PrimitiveType_LSTMGradWeight,
+    PrimitiveType_RandomNormal,
+    PrimitiveType_NLLLoss,
+    PrimitiveType_NLLLossGrad,
+    PrimitiveType_FormatTranspose,
+    PrimitiveType_GatherD,
+    PrimitiveType_GroupNormFusion
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesPrimitiveType() {
+  static const char * const names[213] = {
+    "NONE",
+    "Abs",
+    "Activation",
+    "ActivationGrad",
+    "Adam",
+    "AddFusion",
+    "AdderFusion",
+    "AddGrad",
+    "AddN",
+    "All",
+    "ApplyMomentum",
+    "ArgMaxFusion",
+    "ArgMinFusion",
+    "Assert",
+    "Assign",
+    "AssignAdd",
+    "AudioSpectrogram",
+    "AvgPoolFusion",
+    "AvgPoolGrad",
+    "BatchNorm",
+    "BatchNormGrad",
+    "BatchToSpace",
+    "BatchToSpaceND",
+    "BiasAdd",
+    "BinaryCrossEntropy",
+    "BinaryCrossEntropyGrad",
+    "BiasAddGrad",
+    "BroadcastTo",
+    "Cast",
+    "Ceil",
+    "Clip",
+    "Concat",
+    "Attention",
+    "Conv2DBackpropFilterFusion",
+    "Conv2DBackpropInputFusion",
+    "Conv2DFusion",
+    "Conv2dTransposeFusion",
+    "Cos",
+    "ConstantOfShape",
+    "Crop",
+    "CustomExtractFeatures",
+    "CustomNormalize",
+    "CustomPredict",
+    "DeConv2DGradFilter",
+    "Depend",
+    "DepthToSpace",
+    "DetectionPostProcess",
+    "DivFusion",
+    "DivGrad",
+    "Dropout",
+    "DropoutGrad",
+    "Elu",
+    "Eltwise",
+    "Equal",
+    "EmbeddingLookupFusion",
+    "ExpFusion",
+    "ExpandDims",
+    "FakeQuantWithMinMaxVars",
+    "FakeQuantWithMinMaxVarsPerChannel",
+    "FftReal",
+    "FftImag",
+    "Flatten",
+    "FlattenGrad",
+    "Floor",
+    "FloorDiv",
+    "FloorMod",
+    "Fill",
+    "FullConnection",
+    "FusedBatchNorm",
+    "Gather",
+    "GatherNd",
+    "Greater",
+    "GreaterEqual",
+    "HashtableLookup",
+    "InstanceNorm",
+    "LayerNormFusion",
+    "LeakyRelu",
+    "Less",
+    "LessEqual",
+    "Log",
+    "LogGrad",
+    "LogicalAnd",
+    "LogicalNot",
+    "LogicalOr",
+    "LpNormalization",
+    "LRN",
+    "LshProjection",
+    "LSTM",
+    "L2NormalizeFusion",
+    "MatMulFusion",
+    "Maximum",
+    "MaximumGrad",
+    "MaxPoolFusion",
+    "MaxPoolGrad",
+    "SwitchLayer",
+    "Mfcc",
+    "Minimum",
+    "MinimumGrad",
+    "Mod",
+    "MulFusion",
+    "MulGrad",
+    "Neg",
+    "NegGrad",
+    "NotEqual",
+    "NonMaxSuppression",
+    "OneHot",
+    "OnesLike",
+    "PadFusion",
+    "PartialFusion",
+    "PowerGrad",
+    "PowFusion",
+    "PriorBox",
+    "PReLUFusion",
+    "QuantDTypeCast",
+    "Rank",
+    "Range",
+    "Reciprocal",
+    "RealDiv",
+    "ReduceFusion",
+    "Reshape",
+    "Resize",
+    "ReverseSequence",
+    "ReverseV2",
+    "Rfft",
+    "ROIPooling",
+    "Round",
+    "Rsqrt",
+    "ScaleFusion",
+    "ScatterNd",
+    "SGD",
+    "Shape",
+    "SigmoidCrossEntropyWithLogits",
+    "SigmoidCrossEntropyWithLogitsGrad",
+    "Sin",
+    "SkipGram",
+    "SliceFusion",
+    "SmoothL1Loss",
+    "SmoothL1LossGrad",
+    "Softmax",
+    "SoftmaxCrossEntropyWithLogits",
+    "SpaceToBatch",
+    "SpaceToBatchND",
+    "SpaceToDepth",
+    "SparseSoftmaxCrossEntropyWithLogits",
+    "SparseToDense",
+    "Split",
+    "Sqrt",
+    "Squeeze",
+    "Square",
+    "SquaredDifference",
+    "Stack",
+    "StridedSlice",
+    "SubFusion",
+    "SubGrad",
+    "Switch",
+    "TensorListFromTensor",
+    "TensorListGetItem",
+    "TensorListReserve",
+    "TensorListSetItem",
+    "TensorListStack",
+    "TileFusion",
+    "TopKFusion",
+    "Transpose",
+    "Unique",
+    "UnsortedSegmentSum",
+    "Unsqueeze",
+    "Unstack",
+    "LSTMGrad",
+    "Where",
+    "ZerosLike",
+    "Select",
+    "ScatterNdUpdate",
+    "GRU",
+    "NonZero",
+    "InvertPermutation",
+    "Size",
+    "RandomStandardNormal",
+    "CropAndResize",
+    "Erf",
+    "StridedSliceGrad",
+    "IsFinite",
+    "LinSpace",
+    "UniformReal",
+    "AbsGrad",
+    "RsqrtGrad",
+    "SqrtGrad",
+    "LayerNormGrad",
+    "ResizeGrad",
+    "Splice",
+    "LogSoftmax",
+    "Call",
+    "Custom",
+    "CumSum",
+    "SplitWithOverlap",
+    "GenOP",
+    "RaggedRange",
+    "GLU",
+    "TensorArray",
+    "TensorArrayRead",
+    "TensorArrayWrite",
+    "Affine",
+    "AllGather",
+    "ReduceScatter",
+    "DynamicQuant",
+    "LSTMGradData",
+    "LSTMGradWeight",
+    "RandomNormal",
+    "NLLLoss",
+    "NLLLossGrad",
+    "FormatTranspose",
+    "GatherD",
+    "GroupNormFusion",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNamePrimitiveType(PrimitiveType e) {
+  if (flatbuffers::IsOutRange(e, PrimitiveType_NONE, PrimitiveType_GroupNormFusion)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesPrimitiveType()[index];
+}
+
+template<typename T> struct PrimitiveTypeTraits {
+  static const PrimitiveType enum_value = PrimitiveType_NONE;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Abs> {
+  static const PrimitiveType enum_value = PrimitiveType_Abs;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Activation> {
+  static const PrimitiveType enum_value = PrimitiveType_Activation;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ActivationGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_ActivationGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Adam> {
+  static const PrimitiveType enum_value = PrimitiveType_Adam;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AddFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_AddFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AdderFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_AdderFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AddGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_AddGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AddN> {
+  static const PrimitiveType enum_value = PrimitiveType_AddN;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::All> {
+  static const PrimitiveType enum_value = PrimitiveType_All;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ApplyMomentum> {
+  static const PrimitiveType enum_value = PrimitiveType_ApplyMomentum;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ArgMaxFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_ArgMaxFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ArgMinFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_ArgMinFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Assert> {
+  static const PrimitiveType enum_value = PrimitiveType_Assert;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Assign> {
+  static const PrimitiveType enum_value = PrimitiveType_Assign;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AssignAdd> {
+  static const PrimitiveType enum_value = PrimitiveType_AssignAdd;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AudioSpectrogram> {
+  static const PrimitiveType enum_value = PrimitiveType_AudioSpectrogram;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AvgPoolFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_AvgPoolFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AvgPoolGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_AvgPoolGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BatchNorm> {
+  static const PrimitiveType enum_value = PrimitiveType_BatchNorm;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BatchNormGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_BatchNormGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BatchToSpace> {
+  static const PrimitiveType enum_value = PrimitiveType_BatchToSpace;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BatchToSpaceND> {
+  static const PrimitiveType enum_value = PrimitiveType_BatchToSpaceND;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BiasAdd> {
+  static const PrimitiveType enum_value = PrimitiveType_BiasAdd;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BinaryCrossEntropy> {
+  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropy;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BinaryCrossEntropyGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropyGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BiasAddGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_BiasAddGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BroadcastTo> {
+  static const PrimitiveType enum_value = PrimitiveType_BroadcastTo;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Cast> {
+  static const PrimitiveType enum_value = PrimitiveType_Cast;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Ceil> {
+  static const PrimitiveType enum_value = PrimitiveType_Ceil;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Clip> {
+  static const PrimitiveType enum_value = PrimitiveType_Clip;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Concat> {
+  static const PrimitiveType enum_value = PrimitiveType_Concat;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Attention> {
+  static const PrimitiveType enum_value = PrimitiveType_Attention;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2DBackpropFilterFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_Conv2DBackpropFilterFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2DBackpropInputFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_Conv2DBackpropInputFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2DFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_Conv2DFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2dTransposeFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_Conv2dTransposeFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Cos> {
+  static const PrimitiveType enum_value = PrimitiveType_Cos;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ConstantOfShape> {
+  static const PrimitiveType enum_value = PrimitiveType_ConstantOfShape;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Crop> {
+  static const PrimitiveType enum_value = PrimitiveType_Crop;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::CustomExtractFeatures> {
+  static const PrimitiveType enum_value = PrimitiveType_CustomExtractFeatures;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::CustomNormalize> {
+  static const PrimitiveType enum_value = PrimitiveType_CustomNormalize;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::CustomPredict> {
+  static const PrimitiveType enum_value = PrimitiveType_CustomPredict;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DeConv2DGradFilter> {
+  static const PrimitiveType enum_value = PrimitiveType_DeConv2DGradFilter;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Depend> {
+  static const PrimitiveType enum_value = PrimitiveType_Depend;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DepthToSpace> {
+  static const PrimitiveType enum_value = PrimitiveType_DepthToSpace;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DetectionPostProcess> {
+  static const PrimitiveType enum_value = PrimitiveType_DetectionPostProcess;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DivFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_DivFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DivGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_DivGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Dropout> {
+  static const PrimitiveType enum_value = PrimitiveType_Dropout;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DropoutGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_DropoutGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Elu> {
+  static const PrimitiveType enum_value = PrimitiveType_Elu;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Eltwise> {
+  static const PrimitiveType enum_value = PrimitiveType_Eltwise;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Equal> {
+  static const PrimitiveType enum_value = PrimitiveType_Equal;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::EmbeddingLookupFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_EmbeddingLookupFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ExpFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_ExpFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ExpandDims> {
+  static const PrimitiveType enum_value = PrimitiveType_ExpandDims;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FakeQuantWithMinMaxVars> {
+  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxVars;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FakeQuantWithMinMaxVarsPerChannel> {
+  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxVarsPerChannel;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FftReal> {
+  static const PrimitiveType enum_value = PrimitiveType_FftReal;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FftImag> {
+  static const PrimitiveType enum_value = PrimitiveType_FftImag;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Flatten> {
+  static const PrimitiveType enum_value = PrimitiveType_Flatten;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FlattenGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_FlattenGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Floor> {
+  static const PrimitiveType enum_value = PrimitiveType_Floor;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FloorDiv> {
+  static const PrimitiveType enum_value = PrimitiveType_FloorDiv;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FloorMod> {
+  static const PrimitiveType enum_value = PrimitiveType_FloorMod;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Fill> {
+  static const PrimitiveType enum_value = PrimitiveType_Fill;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FullConnection> {
+  static const PrimitiveType enum_value = PrimitiveType_FullConnection;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FusedBatchNorm> {
+  static const PrimitiveType enum_value = PrimitiveType_FusedBatchNorm;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Gather> {
+  static const PrimitiveType enum_value = PrimitiveType_Gather;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GatherNd> {
+  static const PrimitiveType enum_value = PrimitiveType_GatherNd;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Greater> {
+  static const PrimitiveType enum_value = PrimitiveType_Greater;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GreaterEqual> {
+  static const PrimitiveType enum_value = PrimitiveType_GreaterEqual;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::HashtableLookup> {
+  static const PrimitiveType enum_value = PrimitiveType_HashtableLookup;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::InstanceNorm> {
+  static const PrimitiveType enum_value = PrimitiveType_InstanceNorm;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LayerNormFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_LayerNormFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LeakyRelu> {
+  static const PrimitiveType enum_value = PrimitiveType_LeakyRelu;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Less> {
+  static const PrimitiveType enum_value = PrimitiveType_Less;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LessEqual> {
+  static const PrimitiveType enum_value = PrimitiveType_LessEqual;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Log> {
+  static const PrimitiveType enum_value = PrimitiveType_Log;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LogGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_LogGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LogicalAnd> {
+  static const PrimitiveType enum_value = PrimitiveType_LogicalAnd;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LogicalNot> {
+  static const PrimitiveType enum_value = PrimitiveType_LogicalNot;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LogicalOr> {
+  static const PrimitiveType enum_value = PrimitiveType_LogicalOr;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LpNormalization> {
+  static const PrimitiveType enum_value = PrimitiveType_LpNormalization;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LRN> {
+  static const PrimitiveType enum_value = PrimitiveType_LRN;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LshProjection> {
+  static const PrimitiveType enum_value = PrimitiveType_LshProjection;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LSTM> {
+  static const PrimitiveType enum_value = PrimitiveType_LSTM;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::L2NormalizeFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_L2NormalizeFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MatMulFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_MatMulFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Maximum> {
+  static const PrimitiveType enum_value = PrimitiveType_Maximum;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MaximumGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_MaximumGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MaxPoolFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_MaxPoolFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MaxPoolGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_MaxPoolGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SwitchLayer> {
+  static const PrimitiveType enum_value = PrimitiveType_SwitchLayer;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Mfcc> {
+  static const PrimitiveType enum_value = PrimitiveType_Mfcc;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Minimum> {
+  static const PrimitiveType enum_value = PrimitiveType_Minimum;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MinimumGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_MinimumGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Mod> {
+  static const PrimitiveType enum_value = PrimitiveType_Mod;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MulFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_MulFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MulGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_MulGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Neg> {
+  static const PrimitiveType enum_value = PrimitiveType_Neg;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::NegGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_NegGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::NotEqual> {
+  static const PrimitiveType enum_value = PrimitiveType_NotEqual;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::NonMaxSuppression> {
+  static const PrimitiveType enum_value = PrimitiveType_NonMaxSuppression;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::OneHot> {
+  static const PrimitiveType enum_value = PrimitiveType_OneHot;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::OnesLike> {
+  static const PrimitiveType enum_value = PrimitiveType_OnesLike;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::PadFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_PadFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::PartialFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_PartialFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::PowerGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_PowerGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::PowFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_PowFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::PriorBox> {
+  static const PrimitiveType enum_value = PrimitiveType_PriorBox;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::PReLUFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_PReLUFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::QuantDTypeCast> {
+  static const PrimitiveType enum_value = PrimitiveType_QuantDTypeCast;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Rank> {
+  static const PrimitiveType enum_value = PrimitiveType_Rank;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Range> {
+  static const PrimitiveType enum_value = PrimitiveType_Range;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Reciprocal> {
+  static const PrimitiveType enum_value = PrimitiveType_Reciprocal;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::RealDiv> {
+  static const PrimitiveType enum_value = PrimitiveType_RealDiv;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ReduceFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_ReduceFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Reshape> {
+  static const PrimitiveType enum_value = PrimitiveType_Reshape;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Resize> {
+  static const PrimitiveType enum_value = PrimitiveType_Resize;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ReverseSequence> {
+  static const PrimitiveType enum_value = PrimitiveType_ReverseSequence;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ReverseV2> {
+  static const PrimitiveType enum_value = PrimitiveType_ReverseV2;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Rfft> {
+  static const PrimitiveType enum_value = PrimitiveType_Rfft;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ROIPooling> {
+  static const PrimitiveType enum_value = PrimitiveType_ROIPooling;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Round> {
+  static const PrimitiveType enum_value = PrimitiveType_Round;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Rsqrt> {
+  static const PrimitiveType enum_value = PrimitiveType_Rsqrt;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ScaleFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_ScaleFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ScatterNd> {
+  static const PrimitiveType enum_value = PrimitiveType_ScatterNd;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SGD> {
+  static const PrimitiveType enum_value = PrimitiveType_SGD;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Shape> {
+  static const PrimitiveType enum_value = PrimitiveType_Shape;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SigmoidCrossEntropyWithLogits> {
+  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogits;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SigmoidCrossEntropyWithLogitsGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogitsGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Sin> {
+  static const PrimitiveType enum_value = PrimitiveType_Sin;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SkipGram> {
+  static const PrimitiveType enum_value = PrimitiveType_SkipGram;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SliceFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_SliceFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SmoothL1Loss> {
+  static const PrimitiveType enum_value = PrimitiveType_SmoothL1Loss;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SmoothL1LossGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_SmoothL1LossGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Softmax> {
+  static const PrimitiveType enum_value = PrimitiveType_Softmax;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SoftmaxCrossEntropyWithLogits> {
+  static const PrimitiveType enum_value = PrimitiveType_SoftmaxCrossEntropyWithLogits;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SpaceToBatch> {
+  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatch;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SpaceToBatchND> {
+  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatchND;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SpaceToDepth> {
+  static const PrimitiveType enum_value = PrimitiveType_SpaceToDepth;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SparseSoftmaxCrossEntropyWithLogits> {
+  static const PrimitiveType enum_value = PrimitiveType_SparseSoftmaxCrossEntropyWithLogits;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SparseToDense> {
+  static const PrimitiveType enum_value = PrimitiveType_SparseToDense;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Split> {
+  static const PrimitiveType enum_value = PrimitiveType_Split;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Sqrt> {
+  static const PrimitiveType enum_value = PrimitiveType_Sqrt;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Squeeze> {
+  static const PrimitiveType enum_value = PrimitiveType_Squeeze;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Square> {
+  static const PrimitiveType enum_value = PrimitiveType_Square;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SquaredDifference> {
+  static const PrimitiveType enum_value = PrimitiveType_SquaredDifference;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Stack> {
+  static const PrimitiveType enum_value = PrimitiveType_Stack;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::StridedSlice> {
+  static const PrimitiveType enum_value = PrimitiveType_StridedSlice;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SubFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_SubFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SubGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_SubGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Switch> {
+  static const PrimitiveType enum_value = PrimitiveType_Switch;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListFromTensor> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorListFromTensor;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListGetItem> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorListGetItem;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListReserve> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorListReserve;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListSetItem> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorListSetItem;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListStack> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorListStack;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TileFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_TileFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TopKFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_TopKFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Transpose> {
+  static const PrimitiveType enum_value = PrimitiveType_Transpose;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Unique> {
+  static const PrimitiveType enum_value = PrimitiveType_Unique;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::UnsortedSegmentSum> {
+  static const PrimitiveType enum_value = PrimitiveType_UnsortedSegmentSum;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Unsqueeze> {
+  static const PrimitiveType enum_value = PrimitiveType_Unsqueeze;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Unstack> {
+  static const PrimitiveType enum_value = PrimitiveType_Unstack;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LSTMGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_LSTMGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Where> {
+  static const PrimitiveType enum_value = PrimitiveType_Where;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ZerosLike> {
+  static const PrimitiveType enum_value = PrimitiveType_ZerosLike;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Select> {
+  static const PrimitiveType enum_value = PrimitiveType_Select;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ScatterNdUpdate> {
+  static const PrimitiveType enum_value = PrimitiveType_ScatterNdUpdate;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GRU> {
+  static const PrimitiveType enum_value = PrimitiveType_GRU;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::NonZero> {
+  static const PrimitiveType enum_value = PrimitiveType_NonZero;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::InvertPermutation> {
+  static const PrimitiveType enum_value = PrimitiveType_InvertPermutation;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Size> {
+  static const PrimitiveType enum_value = PrimitiveType_Size;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::RandomStandardNormal> {
+  static const PrimitiveType enum_value = PrimitiveType_RandomStandardNormal;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::CropAndResize> {
+  static const PrimitiveType enum_value = PrimitiveType_CropAndResize;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Erf> {
+  static const PrimitiveType enum_value = PrimitiveType_Erf;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::StridedSliceGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_StridedSliceGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::IsFinite> {
+  static const PrimitiveType enum_value = PrimitiveType_IsFinite;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LinSpace> {
+  static const PrimitiveType enum_value = PrimitiveType_LinSpace;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::UniformReal> {
+  static const PrimitiveType enum_value = PrimitiveType_UniformReal;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AbsGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_AbsGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::RsqrtGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_RsqrtGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SqrtGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_SqrtGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LayerNormGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_LayerNormGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ResizeGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_ResizeGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Splice> {
+  static const PrimitiveType enum_value = PrimitiveType_Splice;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LogSoftmax> {
+  static const PrimitiveType enum_value = PrimitiveType_LogSoftmax;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Call> {
+  static const PrimitiveType enum_value = PrimitiveType_Call;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Custom> {
+  static const PrimitiveType enum_value = PrimitiveType_Custom;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::CumSum> {
+  static const PrimitiveType enum_value = PrimitiveType_CumSum;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SplitWithOverlap> {
+  static const PrimitiveType enum_value = PrimitiveType_SplitWithOverlap;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GenOP> {
+  static const PrimitiveType enum_value = PrimitiveType_GenOP;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::RaggedRange> {
+  static const PrimitiveType enum_value = PrimitiveType_RaggedRange;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GLU> {
+  static const PrimitiveType enum_value = PrimitiveType_GLU;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorArray> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorArray;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorArrayRead> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorArrayRead;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorArrayWrite> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorArrayWrite;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Affine> {
+  static const PrimitiveType enum_value = PrimitiveType_Affine;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AllGather> {
+  static const PrimitiveType enum_value = PrimitiveType_AllGather;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ReduceScatter> {
+  static const PrimitiveType enum_value = PrimitiveType_ReduceScatter;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DynamicQuant> {
+  static const PrimitiveType enum_value = PrimitiveType_DynamicQuant;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LSTMGradData> {
+  static const PrimitiveType enum_value = PrimitiveType_LSTMGradData;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LSTMGradWeight> {
+  static const PrimitiveType enum_value = PrimitiveType_LSTMGradWeight;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::RandomNormal> {
+  static const PrimitiveType enum_value = PrimitiveType_RandomNormal;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::NLLLoss> {
+  static const PrimitiveType enum_value = PrimitiveType_NLLLoss;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::NLLLossGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_NLLLossGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FormatTranspose> {
+  static const PrimitiveType enum_value = PrimitiveType_FormatTranspose;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GatherD> {
+  static const PrimitiveType enum_value = PrimitiveType_GatherD;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GroupNormFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_GroupNormFusion;
+};
+
+struct PrimitiveTypeUnion {
+  PrimitiveType type;
+  void *value;
+
+  PrimitiveTypeUnion() : type(PrimitiveType_NONE), value(nullptr) {}
+  PrimitiveTypeUnion(PrimitiveTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
+    type(PrimitiveType_NONE), value(nullptr)
+    { std::swap(type, u.type); std::swap(value, u.value); }
+  PrimitiveTypeUnion(const PrimitiveTypeUnion &);
+  PrimitiveTypeUnion &operator=(const PrimitiveTypeUnion &u)
+    { PrimitiveTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
+  PrimitiveTypeUnion &operator=(PrimitiveTypeUnion &&u) FLATBUFFERS_NOEXCEPT
+    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
+  ~PrimitiveTypeUnion() { Reset(); }
+
+  void Reset();
+
+#ifndef FLATBUFFERS_CPP98_STL
+  template <typename T>
+  void Set(T&& val) {
+    using RT = typename std::remove_reference<T>::type;
+    Reset();
+    type = PrimitiveTypeTraits<typename RT::TableType>::enum_value;
+    if (type != PrimitiveType_NONE) {
+      value = new RT(std::forward<T>(val));
+    }
+  }
+#endif  // FLATBUFFERS_CPP98_STL
+
+  static void *UnPack(const void *obj, PrimitiveType type, const flatbuffers::resolver_function_t *resolver);
+  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;
+
+  mindspore::schema::AbsT *AsAbs() {
+    return type == PrimitiveType_Abs ?
+      reinterpret_cast<mindspore::schema::AbsT *>(value) : nullptr;
+  }
+  const mindspore::schema::AbsT *AsAbs() const {
+    return type == PrimitiveType_Abs ?
+      reinterpret_cast<const mindspore::schema::AbsT *>(value) : nullptr;
+  }
+  mindspore::schema::ActivationT *AsActivation() {
+    return type == PrimitiveType_Activation ?
+      reinterpret_cast<mindspore::schema::ActivationT *>(value) : nullptr;
+  }
+  const mindspore::schema::ActivationT *AsActivation() const {
+    return type == PrimitiveType_Activation ?
+      reinterpret_cast<const mindspore::schema::ActivationT *>(value) : nullptr;
+  }
+  mindspore::schema::ActivationGradT *AsActivationGrad() {
+    return type == PrimitiveType_ActivationGrad ?
+      reinterpret_cast<mindspore::schema::ActivationGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::ActivationGradT *AsActivationGrad() const {
+    return type == PrimitiveType_ActivationGrad ?
+      reinterpret_cast<const mindspore::schema::ActivationGradT *>(value) : nullptr;
+  }
+  mindspore::schema::AdamT *AsAdam() {
+    return type == PrimitiveType_Adam ?
+      reinterpret_cast<mindspore::schema::AdamT *>(value) : nullptr;
+  }
+  const mindspore::schema::AdamT *AsAdam() const {
+    return type == PrimitiveType_Adam ?
+      reinterpret_cast<const mindspore::schema::AdamT *>(value) : nullptr;
+  }
+  mindspore::schema::AddFusionT *AsAddFusion() {
+    return type == PrimitiveType_AddFusion ?
+      reinterpret_cast<mindspore::schema::AddFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::AddFusionT *AsAddFusion() const {
+    return type == PrimitiveType_AddFusion ?
+      reinterpret_cast<const mindspore::schema::AddFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::AdderFusionT *AsAdderFusion() {
+    return type == PrimitiveType_AdderFusion ?
+      reinterpret_cast<mindspore::schema::AdderFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::AdderFusionT *AsAdderFusion() const {
+    return type == PrimitiveType_AdderFusion ?
+      reinterpret_cast<const mindspore::schema::AdderFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::AddGradT *AsAddGrad() {
+    return type == PrimitiveType_AddGrad ?
+      reinterpret_cast<mindspore::schema::AddGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::AddGradT *AsAddGrad() const {
+    return type == PrimitiveType_AddGrad ?
+      reinterpret_cast<const mindspore::schema::AddGradT *>(value) : nullptr;
+  }
+  mindspore::schema::AddNT *AsAddN() {
+    return type == PrimitiveType_AddN ?
+      reinterpret_cast<mindspore::schema::AddNT *>(value) : nullptr;
+  }
+  const mindspore::schema::AddNT *AsAddN() const {
+    return type == PrimitiveType_AddN ?
+      reinterpret_cast<const mindspore::schema::AddNT *>(value) : nullptr;
+  }
+  mindspore::schema::AllT *AsAll() {
+    return type == PrimitiveType_All ?
+      reinterpret_cast<mindspore::schema::AllT *>(value) : nullptr;
+  }
+  const mindspore::schema::AllT *AsAll() const {
+    return type == PrimitiveType_All ?
+      reinterpret_cast<const mindspore::schema::AllT *>(value) : nullptr;
+  }
+  mindspore::schema::ApplyMomentumT *AsApplyMomentum() {
+    return type == PrimitiveType_ApplyMomentum ?
+      reinterpret_cast<mindspore::schema::ApplyMomentumT *>(value) : nullptr;
+  }
+  const mindspore::schema::ApplyMomentumT *AsApplyMomentum() const {
+    return type == PrimitiveType_ApplyMomentum ?
+      reinterpret_cast<const mindspore::schema::ApplyMomentumT *>(value) : nullptr;
+  }
+  mindspore::schema::ArgMaxFusionT *AsArgMaxFusion() {
+    return type == PrimitiveType_ArgMaxFusion ?
+      reinterpret_cast<mindspore::schema::ArgMaxFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::ArgMaxFusionT *AsArgMaxFusion() const {
+    return type == PrimitiveType_ArgMaxFusion ?
+      reinterpret_cast<const mindspore::schema::ArgMaxFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::ArgMinFusionT *AsArgMinFusion() {
+    return type == PrimitiveType_ArgMinFusion ?
+      reinterpret_cast<mindspore::schema::ArgMinFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::ArgMinFusionT *AsArgMinFusion() const {
+    return type == PrimitiveType_ArgMinFusion ?
+      reinterpret_cast<const mindspore::schema::ArgMinFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::AssertT *AsAssert() {
+    return type == PrimitiveType_Assert ?
+      reinterpret_cast<mindspore::schema::AssertT *>(value) : nullptr;
+  }
+  const mindspore::schema::AssertT *AsAssert() const {
+    return type == PrimitiveType_Assert ?
+      reinterpret_cast<const mindspore::schema::AssertT *>(value) : nullptr;
+  }
+  mindspore::schema::AssignT *AsAssign() {
+    return type == PrimitiveType_Assign ?
+      reinterpret_cast<mindspore::schema::AssignT *>(value) : nullptr;
+  }
+  const mindspore::schema::AssignT *AsAssign() const {
+    return type == PrimitiveType_Assign ?
+      reinterpret_cast<const mindspore::schema::AssignT *>(value) : nullptr;
+  }
+  mindspore::schema::AssignAddT *AsAssignAdd() {
+    return type == PrimitiveType_AssignAdd ?
+      reinterpret_cast<mindspore::schema::AssignAddT *>(value) : nullptr;
+  }
+  const mindspore::schema::AssignAddT *AsAssignAdd() const {
+    return type == PrimitiveType_AssignAdd ?
+      reinterpret_cast<const mindspore::schema::AssignAddT *>(value) : nullptr;
+  }
+  mindspore::schema::AudioSpectrogramT *AsAudioSpectrogram() {
+    return type == PrimitiveType_AudioSpectrogram ?
+      reinterpret_cast<mindspore::schema::AudioSpectrogramT *>(value) : nullptr;
+  }
+  const mindspore::schema::AudioSpectrogramT *AsAudioSpectrogram() const {
+    return type == PrimitiveType_AudioSpectrogram ?
+      reinterpret_cast<const mindspore::schema::AudioSpectrogramT *>(value) : nullptr;
+  }
+  mindspore::schema::AvgPoolFusionT *AsAvgPoolFusion() {
+    return type == PrimitiveType_AvgPoolFusion ?
+      reinterpret_cast<mindspore::schema::AvgPoolFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::AvgPoolFusionT *AsAvgPoolFusion() const {
+    return type == PrimitiveType_AvgPoolFusion ?
+      reinterpret_cast<const mindspore::schema::AvgPoolFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::AvgPoolGradT *AsAvgPoolGrad() {
+    return type == PrimitiveType_AvgPoolGrad ?
+      reinterpret_cast<mindspore::schema::AvgPoolGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::AvgPoolGradT *AsAvgPoolGrad() const {
+    return type == PrimitiveType_AvgPoolGrad ?
+      reinterpret_cast<const mindspore::schema::AvgPoolGradT *>(value) : nullptr;
+  }
+  mindspore::schema::BatchNormT *AsBatchNorm() {
+    return type == PrimitiveType_BatchNorm ?
+      reinterpret_cast<mindspore::schema::BatchNormT *>(value) : nullptr;
+  }
+  const mindspore::schema::BatchNormT *AsBatchNorm() const {
+    return type == PrimitiveType_BatchNorm ?
+      reinterpret_cast<const mindspore::schema::BatchNormT *>(value) : nullptr;
+  }
+  mindspore::schema::BatchNormGradT *AsBatchNormGrad() {
+    return type == PrimitiveType_BatchNormGrad ?
+      reinterpret_cast<mindspore::schema::BatchNormGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::BatchNormGradT *AsBatchNormGrad() const {
+    return type == PrimitiveType_BatchNormGrad ?
+      reinterpret_cast<const mindspore::schema::BatchNormGradT *>(value) : nullptr;
+  }
+  mindspore::schema::BatchToSpaceT *AsBatchToSpace() {
+    return type == PrimitiveType_BatchToSpace ?
+      reinterpret_cast<mindspore::schema::BatchToSpaceT *>(value) : nullptr;
+  }
+  const mindspore::schema::BatchToSpaceT *AsBatchToSpace() const {
+    return type == PrimitiveType_BatchToSpace ?
+      reinterpret_cast<const mindspore::schema::BatchToSpaceT *>(value) : nullptr;
+  }
+  mindspore::schema::BatchToSpaceNDT *AsBatchToSpaceND() {
+    return type == PrimitiveType_BatchToSpaceND ?
+      reinterpret_cast<mindspore::schema::BatchToSpaceNDT *>(value) : nullptr;
+  }
+  const mindspore::schema::BatchToSpaceNDT *AsBatchToSpaceND() const {
+    return type == PrimitiveType_BatchToSpaceND ?
+      reinterpret_cast<const mindspore::schema::BatchToSpaceNDT *>(value) : nullptr;
+  }
+  mindspore::schema::BiasAddT *AsBiasAdd() {
+    return type == PrimitiveType_BiasAdd ?
+      reinterpret_cast<mindspore::schema::BiasAddT *>(value) : nullptr;
+  }
+  const mindspore::schema::BiasAddT *AsBiasAdd() const {
+    return type == PrimitiveType_BiasAdd ?
+      reinterpret_cast<const mindspore::schema::BiasAddT *>(value) : nullptr;
+  }
+  mindspore::schema::BinaryCrossEntropyT *AsBinaryCrossEntropy() {
+    return type == PrimitiveType_BinaryCrossEntropy ?
+      reinterpret_cast<mindspore::schema::BinaryCrossEntropyT *>(value) : nullptr;
+  }
+  const mindspore::schema::BinaryCrossEntropyT *AsBinaryCrossEntropy() const {
+    return type == PrimitiveType_BinaryCrossEntropy ?
+      reinterpret_cast<const mindspore::schema::BinaryCrossEntropyT *>(value) : nullptr;
+  }
+  mindspore::schema::BinaryCrossEntropyGradT *AsBinaryCrossEntropyGrad() {
+    return type == PrimitiveType_BinaryCrossEntropyGrad ?
+      reinterpret_cast<mindspore::schema::BinaryCrossEntropyGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::BinaryCrossEntropyGradT *AsBinaryCrossEntropyGrad() const {
+    return type == PrimitiveType_BinaryCrossEntropyGrad ?
+      reinterpret_cast<const mindspore::schema::BinaryCrossEntropyGradT *>(value) : nullptr;
+  }
+  mindspore::schema::BiasAddGradT *AsBiasAddGrad() {
+    return type == PrimitiveType_BiasAddGrad ?
+      reinterpret_cast<mindspore::schema::BiasAddGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::BiasAddGradT *AsBiasAddGrad() const {
+    return type == PrimitiveType_BiasAddGrad ?
+      reinterpret_cast<const mindspore::schema::BiasAddGradT *>(value) : nullptr;
+  }
+  mindspore::schema::BroadcastToT *AsBroadcastTo() {
+    return type == PrimitiveType_BroadcastTo ?
+      reinterpret_cast<mindspore::schema::BroadcastToT *>(value) : nullptr;
+  }
+  const mindspore::schema::BroadcastToT *AsBroadcastTo() const {
+    return type == PrimitiveType_BroadcastTo ?
+      reinterpret_cast<const mindspore::schema::BroadcastToT *>(value) : nullptr;
+  }
+  mindspore::schema::CastT *AsCast() {
+    return type == PrimitiveType_Cast ?
+      reinterpret_cast<mindspore::schema::CastT *>(value) : nullptr;
+  }
+  const mindspore::schema::CastT *AsCast() const {
+    return type == PrimitiveType_Cast ?
+      reinterpret_cast<const mindspore::schema::CastT *>(value) : nullptr;
+  }
+  mindspore::schema::CeilT *AsCeil() {
+    return type == PrimitiveType_Ceil ?
+      reinterpret_cast<mindspore::schema::CeilT *>(value) : nullptr;
+  }
+  const mindspore::schema::CeilT *AsCeil() const {
+    return type == PrimitiveType_Ceil ?
+      reinterpret_cast<const mindspore::schema::CeilT *>(value) : nullptr;
+  }
+  mindspore::schema::ClipT *AsClip() {
+    return type == PrimitiveType_Clip ?
+      reinterpret_cast<mindspore::schema::ClipT *>(value) : nullptr;
+  }
+  const mindspore::schema::ClipT *AsClip() const {
+    return type == PrimitiveType_Clip ?
+      reinterpret_cast<const mindspore::schema::ClipT *>(value) : nullptr;
+  }
+  mindspore::schema::ConcatT *AsConcat() {
+    return type == PrimitiveType_Concat ?
+      reinterpret_cast<mindspore::schema::ConcatT *>(value) : nullptr;
+  }
+  const mindspore::schema::ConcatT *AsConcat() const {
+    return type == PrimitiveType_Concat ?
+      reinterpret_cast<const mindspore::schema::ConcatT *>(value) : nullptr;
+  }
+  mindspore::schema::AttentionT *AsAttention() {
+    return type == PrimitiveType_Attention ?
+      reinterpret_cast<mindspore::schema::AttentionT *>(value) : nullptr;
+  }
+  const mindspore::schema::AttentionT *AsAttention() const {
+    return type == PrimitiveType_Attention ?
+      reinterpret_cast<const mindspore::schema::AttentionT *>(value) : nullptr;
+  }
+  mindspore::schema::Conv2DBackpropFilterFusionT *AsConv2DBackpropFilterFusion() {
+    return type == PrimitiveType_Conv2DBackpropFilterFusion ?
+      reinterpret_cast<mindspore::schema::Conv2DBackpropFilterFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::Conv2DBackpropFilterFusionT *AsConv2DBackpropFilterFusion() const {
+    return type == PrimitiveType_Conv2DBackpropFilterFusion ?
+      reinterpret_cast<const mindspore::schema::Conv2DBackpropFilterFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::Conv2DBackpropInputFusionT *AsConv2DBackpropInputFusion() {
+    return type == PrimitiveType_Conv2DBackpropInputFusion ?
+      reinterpret_cast<mindspore::schema::Conv2DBackpropInputFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::Conv2DBackpropInputFusionT *AsConv2DBackpropInputFusion() const {
+    return type == PrimitiveType_Conv2DBackpropInputFusion ?
+      reinterpret_cast<const mindspore::schema::Conv2DBackpropInputFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::Conv2DFusionT *AsConv2DFusion() {
+    return type == PrimitiveType_Conv2DFusion ?
+      reinterpret_cast<mindspore::schema::Conv2DFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::Conv2DFusionT *AsConv2DFusion() const {
+    return type == PrimitiveType_Conv2DFusion ?
+      reinterpret_cast<const mindspore::schema::Conv2DFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::Conv2dTransposeFusionT *AsConv2dTransposeFusion() {
+    return type == PrimitiveType_Conv2dTransposeFusion ?
+      reinterpret_cast<mindspore::schema::Conv2dTransposeFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::Conv2dTransposeFusionT *AsConv2dTransposeFusion() const {
+    return type == PrimitiveType_Conv2dTransposeFusion ?
+      reinterpret_cast<const mindspore::schema::Conv2dTransposeFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::CosT *AsCos() {
+    return type == PrimitiveType_Cos ?
+      reinterpret_cast<mindspore::schema::CosT *>(value) : nullptr;
+  }
+  const mindspore::schema::CosT *AsCos() const {
+    return type == PrimitiveType_Cos ?
+      reinterpret_cast<const mindspore::schema::CosT *>(value) : nullptr;
+  }
+  mindspore::schema::ConstantOfShapeT *AsConstantOfShape() {
+    return type == PrimitiveType_ConstantOfShape ?
+      reinterpret_cast<mindspore::schema::ConstantOfShapeT *>(value) : nullptr;
+  }
+  const mindspore::schema::ConstantOfShapeT *AsConstantOfShape() const {
+    return type == PrimitiveType_ConstantOfShape ?
+      reinterpret_cast<const mindspore::schema::ConstantOfShapeT *>(value) : nullptr;
+  }
+  mindspore::schema::CropT *AsCrop() {
+    return type == PrimitiveType_Crop ?
+      reinterpret_cast<mindspore::schema::CropT *>(value) : nullptr;
+  }
+  const mindspore::schema::CropT *AsCrop() const {
+    return type == PrimitiveType_Crop ?
+      reinterpret_cast<const mindspore::schema::CropT *>(value) : nullptr;
+  }
+  mindspore::schema::CustomExtractFeaturesT *AsCustomExtractFeatures() {
+    return type == PrimitiveType_CustomExtractFeatures ?
+      reinterpret_cast<mindspore::schema::CustomExtractFeaturesT *>(value) : nullptr;
+  }
+  const mindspore::schema::CustomExtractFeaturesT *AsCustomExtractFeatures() const {
+    return type == PrimitiveType_CustomExtractFeatures ?
+      reinterpret_cast<const mindspore::schema::CustomExtractFeaturesT *>(value) : nullptr;
+  }
+  mindspore::schema::CustomNormalizeT *AsCustomNormalize() {
+    return type == PrimitiveType_CustomNormalize ?
+      reinterpret_cast<mindspore::schema::CustomNormalizeT *>(value) : nullptr;
+  }
+  const mindspore::schema::CustomNormalizeT *AsCustomNormalize() const {
+    return type == PrimitiveType_CustomNormalize ?
+      reinterpret_cast<const mindspore::schema::CustomNormalizeT *>(value) : nullptr;
+  }
+  mindspore::schema::CustomPredictT *AsCustomPredict() {
+    return type == PrimitiveType_CustomPredict ?
+      reinterpret_cast<mindspore::schema::CustomPredictT *>(value) : nullptr;
+  }
+  const mindspore::schema::CustomPredictT *AsCustomPredict() const {
+    return type == PrimitiveType_CustomPredict ?
+      reinterpret_cast<const mindspore::schema::CustomPredictT *>(value) : nullptr;
+  }
+  mindspore::schema::DeConv2DGradFilterT *AsDeConv2DGradFilter() {
+    return type == PrimitiveType_DeConv2DGradFilter ?
+      reinterpret_cast<mindspore::schema::DeConv2DGradFilterT *>(value) : nullptr;
+  }
+  const mindspore::schema::DeConv2DGradFilterT *AsDeConv2DGradFilter() const {
+    return type == PrimitiveType_DeConv2DGradFilter ?
+      reinterpret_cast<const mindspore::schema::DeConv2DGradFilterT *>(value) : nullptr;
+  }
+  mindspore::schema::DependT *AsDepend() {
+    return type == PrimitiveType_Depend ?
+      reinterpret_cast<mindspore::schema::DependT *>(value) : nullptr;
+  }
+  const mindspore::schema::DependT *AsDepend() const {
+    return type == PrimitiveType_Depend ?
+      reinterpret_cast<const mindspore::schema::DependT *>(value) : nullptr;
+  }
+  mindspore::schema::DepthToSpaceT *AsDepthToSpace() {
+    return type == PrimitiveType_DepthToSpace ?
+      reinterpret_cast<mindspore::schema::DepthToSpaceT *>(value) : nullptr;
+  }
+  const mindspore::schema::DepthToSpaceT *AsDepthToSpace() const {
+    return type == PrimitiveType_DepthToSpace ?
+      reinterpret_cast<const mindspore::schema::DepthToSpaceT *>(value) : nullptr;
+  }
+  mindspore::schema::DetectionPostProcessT *AsDetectionPostProcess() {
+    return type == PrimitiveType_DetectionPostProcess ?
+      reinterpret_cast<mindspore::schema::DetectionPostProcessT *>(value) : nullptr;
+  }
+  const mindspore::schema::DetectionPostProcessT *AsDetectionPostProcess() const {
+    return type == PrimitiveType_DetectionPostProcess ?
+      reinterpret_cast<const mindspore::schema::DetectionPostProcessT *>(value) : nullptr;
+  }
+  mindspore::schema::DivFusionT *AsDivFusion() {
+    return type == PrimitiveType_DivFusion ?
+      reinterpret_cast<mindspore::schema::DivFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::DivFusionT *AsDivFusion() const {
+    return type == PrimitiveType_DivFusion ?
+      reinterpret_cast<const mindspore::schema::DivFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::DivGradT *AsDivGrad() {
+    return type == PrimitiveType_DivGrad ?
+      reinterpret_cast<mindspore::schema::DivGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::DivGradT *AsDivGrad() const {
+    return type == PrimitiveType_DivGrad ?
+      reinterpret_cast<const mindspore::schema::DivGradT *>(value) : nullptr;
+  }
+  mindspore::schema::DropoutT *AsDropout() {
+    return type == PrimitiveType_Dropout ?
+      reinterpret_cast<mindspore::schema::DropoutT *>(value) : nullptr;
+  }
+  const mindspore::schema::DropoutT *AsDropout() const {
+    return type == PrimitiveType_Dropout ?
+      reinterpret_cast<const mindspore::schema::DropoutT *>(value) : nullptr;
+  }
+  mindspore::schema::DropoutGradT *AsDropoutGrad() {
+    return type == PrimitiveType_DropoutGrad ?
+      reinterpret_cast<mindspore::schema::DropoutGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::DropoutGradT *AsDropoutGrad() const {
+    return type == PrimitiveType_DropoutGrad ?
+      reinterpret_cast<const mindspore::schema::DropoutGradT *>(value) : nullptr;
+  }
+  mindspore::schema::EluT *AsElu() {
+    return type == PrimitiveType_Elu ?
+      reinterpret_cast<mindspore::schema::EluT *>(value) : nullptr;
+  }
+  const mindspore::schema::EluT *AsElu() const {
+    return type == PrimitiveType_Elu ?
+      reinterpret_cast<const mindspore::schema::EluT *>(value) : nullptr;
+  }
+  mindspore::schema::EltwiseT *AsEltwise() {
+    return type == PrimitiveType_Eltwise ?
+      reinterpret_cast<mindspore::schema::EltwiseT *>(value) : nullptr;
+  }
+  const mindspore::schema::EltwiseT *AsEltwise() const {
+    return type == PrimitiveType_Eltwise ?
+      reinterpret_cast<const mindspore::schema::EltwiseT *>(value) : nullptr;
+  }
+  mindspore::schema::EqualT *AsEqual() {
+    return type == PrimitiveType_Equal ?
+      reinterpret_cast<mindspore::schema::EqualT *>(value) : nullptr;
+  }
+  const mindspore::schema::EqualT *AsEqual() const {
+    return type == PrimitiveType_Equal ?
+      reinterpret_cast<const mindspore::schema::EqualT *>(value) : nullptr;
+  }
+  mindspore::schema::EmbeddingLookupFusionT *AsEmbeddingLookupFusion() {
+    return type == PrimitiveType_EmbeddingLookupFusion ?
+      reinterpret_cast<mindspore::schema::EmbeddingLookupFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::EmbeddingLookupFusionT *AsEmbeddingLookupFusion() const {
+    return type == PrimitiveType_EmbeddingLookupFusion ?
+      reinterpret_cast<const mindspore::schema::EmbeddingLookupFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::ExpFusionT *AsExpFusion() {
+    return type == PrimitiveType_ExpFusion ?
+      reinterpret_cast<mindspore::schema::ExpFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::ExpFusionT *AsExpFusion() const {
+    return type == PrimitiveType_ExpFusion ?
+      reinterpret_cast<const mindspore::schema::ExpFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::ExpandDimsT *AsExpandDims() {
+    return type == PrimitiveType_ExpandDims ?
+      reinterpret_cast<mindspore::schema::ExpandDimsT *>(value) : nullptr;
+  }
+  const mindspore::schema::ExpandDimsT *AsExpandDims() const {
+    return type == PrimitiveType_ExpandDims ?
+      reinterpret_cast<const mindspore::schema::ExpandDimsT *>(value) : nullptr;
+  }
+  mindspore::schema::FakeQuantWithMinMaxVarsT *AsFakeQuantWithMinMaxVars() {
+    return type == PrimitiveType_FakeQuantWithMinMaxVars ?
+      reinterpret_cast<mindspore::schema::FakeQuantWithMinMaxVarsT *>(value) : nullptr;
+  }
+  const mindspore::schema::FakeQuantWithMinMaxVarsT *AsFakeQuantWithMinMaxVars() const {
+    return type == PrimitiveType_FakeQuantWithMinMaxVars ?
+      reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsT *>(value) : nullptr;
+  }
+  mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *AsFakeQuantWithMinMaxVarsPerChannel() {
+    return type == PrimitiveType_FakeQuantWithMinMaxVarsPerChannel ?
+      reinterpret_cast<mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *>(value) : nullptr;
+  }
+  const mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *AsFakeQuantWithMinMaxVarsPerChannel() const {
+    return type == PrimitiveType_FakeQuantWithMinMaxVarsPerChannel ?
+      reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *>(value) : nullptr;
+  }
+  mindspore::schema::FftRealT *AsFftReal() {
+    return type == PrimitiveType_FftReal ?
+      reinterpret_cast<mindspore::schema::FftRealT *>(value) : nullptr;
+  }
+  const mindspore::schema::FftRealT *AsFftReal() const {
+    return type == PrimitiveType_FftReal ?
+      reinterpret_cast<const mindspore::schema::FftRealT *>(value) : nullptr;
+  }
+  mindspore::schema::FftImagT *AsFftImag() {
+    return type == PrimitiveType_FftImag ?
+      reinterpret_cast<mindspore::schema::FftImagT *>(value) : nullptr;
+  }
+  const mindspore::schema::FftImagT *AsFftImag() const {
+    return type == PrimitiveType_FftImag ?
+      reinterpret_cast<const mindspore::schema::FftImagT *>(value) : nullptr;
+  }
+  mindspore::schema::FlattenT *AsFlatten() {
+    return type == PrimitiveType_Flatten ?
+      reinterpret_cast<mindspore::schema::FlattenT *>(value) : nullptr;
+  }
+  const mindspore::schema::FlattenT *AsFlatten() const {
+    return type == PrimitiveType_Flatten ?
+      reinterpret_cast<const mindspore::schema::FlattenT *>(value) : nullptr;
+  }
+  mindspore::schema::FlattenGradT *AsFlattenGrad() {
+    return type == PrimitiveType_FlattenGrad ?
+      reinterpret_cast<mindspore::schema::FlattenGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::FlattenGradT *AsFlattenGrad() const {
+    return type == PrimitiveType_FlattenGrad ?
+      reinterpret_cast<const mindspore::schema::FlattenGradT *>(value) : nullptr;
+  }
+  mindspore::schema::FloorT *AsFloor() {
+    return type == PrimitiveType_Floor ?
+      reinterpret_cast<mindspore::schema::FloorT *>(value) : nullptr;
+  }
+  const mindspore::schema::FloorT *AsFloor() const {
+    return type == PrimitiveType_Floor ?
+      reinterpret_cast<const mindspore::schema::FloorT *>(value) : nullptr;
+  }
+  mindspore::schema::FloorDivT *AsFloorDiv() {
+    return type == PrimitiveType_FloorDiv ?
+      reinterpret_cast<mindspore::schema::FloorDivT *>(value) : nullptr;
+  }
+  const mindspore::schema::FloorDivT *AsFloorDiv() const {
+    return type == PrimitiveType_FloorDiv ?
+      reinterpret_cast<const mindspore::schema::FloorDivT *>(value) : nullptr;
+  }
+  mindspore::schema::FloorModT *AsFloorMod() {
+    return type == PrimitiveType_FloorMod ?
+      reinterpret_cast<mindspore::schema::FloorModT *>(value) : nullptr;
+  }
+  const mindspore::schema::FloorModT *AsFloorMod() const {
+    return type == PrimitiveType_FloorMod ?
+      reinterpret_cast<const mindspore::schema::FloorModT *>(value) : nullptr;
+  }
+  mindspore::schema::FillT *AsFill() {
+    return type == PrimitiveType_Fill ?
+      reinterpret_cast<mindspore::schema::FillT *>(value) : nullptr;
+  }
+  const mindspore::schema::FillT *AsFill() const {
+    return type == PrimitiveType_Fill ?
+      reinterpret_cast<const mindspore::schema::FillT *>(value) : nullptr;
+  }
+  mindspore::schema::FullConnectionT *AsFullConnection() {
+    return type == PrimitiveType_FullConnection ?
+      reinterpret_cast<mindspore::schema::FullConnectionT *>(value) : nullptr;
+  }
+  const mindspore::schema::FullConnectionT *AsFullConnection() const {
+    return type == PrimitiveType_FullConnection ?
+      reinterpret_cast<const mindspore::schema::FullConnectionT *>(value) : nullptr;
+  }
+  mindspore::schema::FusedBatchNormT *AsFusedBatchNorm() {
+    return type == PrimitiveType_FusedBatchNorm ?
+      reinterpret_cast<mindspore::schema::FusedBatchNormT *>(value) : nullptr;
+  }
+  const mindspore::schema::FusedBatchNormT *AsFusedBatchNorm() const {
+    return type == PrimitiveType_FusedBatchNorm ?
+      reinterpret_cast<const mindspore::schema::FusedBatchNormT *>(value) : nullptr;
+  }
+  mindspore::schema::GatherT *AsGather() {
+    return type == PrimitiveType_Gather ?
+      reinterpret_cast<mindspore::schema::GatherT *>(value) : nullptr;
+  }
+  const mindspore::schema::GatherT *AsGather() const {
+    return type == PrimitiveType_Gather ?
+      reinterpret_cast<const mindspore::schema::GatherT *>(value) : nullptr;
+  }
+  mindspore::schema::GatherNdT *AsGatherNd() {
+    return type == PrimitiveType_GatherNd ?
+      reinterpret_cast<mindspore::schema::GatherNdT *>(value) : nullptr;
+  }
+  const mindspore::schema::GatherNdT *AsGatherNd() const {
+    return type == PrimitiveType_GatherNd ?
+      reinterpret_cast<const mindspore::schema::GatherNdT *>(value) : nullptr;
+  }
+  mindspore::schema::GreaterT *AsGreater() {
+    return type == PrimitiveType_Greater ?
+      reinterpret_cast<mindspore::schema::GreaterT *>(value) : nullptr;
+  }
+  const mindspore::schema::GreaterT *AsGreater() const {
+    return type == PrimitiveType_Greater ?
+      reinterpret_cast<const mindspore::schema::GreaterT *>(value) : nullptr;
+  }
+  mindspore::schema::GreaterEqualT *AsGreaterEqual() {
+    return type == PrimitiveType_GreaterEqual ?
+      reinterpret_cast<mindspore::schema::GreaterEqualT *>(value) : nullptr;
+  }
+  const mindspore::schema::GreaterEqualT *AsGreaterEqual() const {
+    return type == PrimitiveType_GreaterEqual ?
+      reinterpret_cast<const mindspore::schema::GreaterEqualT *>(value) : nullptr;
+  }
+  mindspore::schema::HashtableLookupT *AsHashtableLookup() {
+    return type == PrimitiveType_HashtableLookup ?
+      reinterpret_cast<mindspore::schema::HashtableLookupT *>(value) : nullptr;
+  }
+  const mindspore::schema::HashtableLookupT *AsHashtableLookup() const {
+    return type == PrimitiveType_HashtableLookup ?
+      reinterpret_cast<const mindspore::schema::HashtableLookupT *>(value) : nullptr;
+  }
+  mindspore::schema::InstanceNormT *AsInstanceNorm() {
+    return type == PrimitiveType_InstanceNorm ?
+      reinterpret_cast<mindspore::schema::InstanceNormT *>(value) : nullptr;
+  }
+  const mindspore::schema::InstanceNormT *AsInstanceNorm() const {
+    return type == PrimitiveType_InstanceNorm ?
+      reinterpret_cast<const mindspore::schema::InstanceNormT *>(value) : nullptr;
+  }
+  mindspore::schema::LayerNormFusionT *AsLayerNormFusion() {
+    return type == PrimitiveType_LayerNormFusion ?
+      reinterpret_cast<mindspore::schema::LayerNormFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::LayerNormFusionT *AsLayerNormFusion() const {
+    return type == PrimitiveType_LayerNormFusion ?
+      reinterpret_cast<const mindspore::schema::LayerNormFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::LeakyReluT *AsLeakyRelu() {
+    return type == PrimitiveType_LeakyRelu ?
+      reinterpret_cast<mindspore::schema::LeakyReluT *>(value) : nullptr;
+  }
+  const mindspore::schema::LeakyReluT *AsLeakyRelu() const {
+    return type == PrimitiveType_LeakyRelu ?
+      reinterpret_cast<const mindspore::schema::LeakyReluT *>(value) : nullptr;
+  }
+  mindspore::schema::LessT *AsLess() {
+    return type == PrimitiveType_Less ?
+      reinterpret_cast<mindspore::schema::LessT *>(value) : nullptr;
+  }
+  const mindspore::schema::LessT *AsLess() const {
+    return type == PrimitiveType_Less ?
+      reinterpret_cast<const mindspore::schema::LessT *>(value) : nullptr;
+  }
+  mindspore::schema::LessEqualT *AsLessEqual() {
+    return type == PrimitiveType_LessEqual ?
+      reinterpret_cast<mindspore::schema::LessEqualT *>(value) : nullptr;
+  }
+  const mindspore::schema::LessEqualT *AsLessEqual() const {
+    return type == PrimitiveType_LessEqual ?
+      reinterpret_cast<const mindspore::schema::LessEqualT *>(value) : nullptr;
+  }
+  mindspore::schema::LogT *AsLog() {
+    return type == PrimitiveType_Log ?
+      reinterpret_cast<mindspore::schema::LogT *>(value) : nullptr;
+  }
+  const mindspore::schema::LogT *AsLog() const {
+    return type == PrimitiveType_Log ?
+      reinterpret_cast<const mindspore::schema::LogT *>(value) : nullptr;
+  }
+  mindspore::schema::LogGradT *AsLogGrad() {
+    return type == PrimitiveType_LogGrad ?
+      reinterpret_cast<mindspore::schema::LogGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::LogGradT *AsLogGrad() const {
+    return type == PrimitiveType_LogGrad ?
+      reinterpret_cast<const mindspore::schema::LogGradT *>(value) : nullptr;
+  }
+  mindspore::schema::LogicalAndT *AsLogicalAnd() {
+    return type == PrimitiveType_LogicalAnd ?
+      reinterpret_cast<mindspore::schema::LogicalAndT *>(value) : nullptr;
+  }
+  const mindspore::schema::LogicalAndT *AsLogicalAnd() const {
+    return type == PrimitiveType_LogicalAnd ?
+      reinterpret_cast<const mindspore::schema::LogicalAndT *>(value) : nullptr;
+  }
+  mindspore::schema::LogicalNotT *AsLogicalNot() {
+    return type == PrimitiveType_LogicalNot ?
+      reinterpret_cast<mindspore::schema::LogicalNotT *>(value) : nullptr;
+  }
+  const mindspore::schema::LogicalNotT *AsLogicalNot() const {
+    return type == PrimitiveType_LogicalNot ?
+      reinterpret_cast<const mindspore::schema::LogicalNotT *>(value) : nullptr;
+  }
+  mindspore::schema::LogicalOrT *AsLogicalOr() {
+    return type == PrimitiveType_LogicalOr ?
+      reinterpret_cast<mindspore::schema::LogicalOrT *>(value) : nullptr;
+  }
+  const mindspore::schema::LogicalOrT *AsLogicalOr() const {
+    return type == PrimitiveType_LogicalOr ?
+      reinterpret_cast<const mindspore::schema::LogicalOrT *>(value) : nullptr;
+  }
+  mindspore::schema::LpNormalizationT *AsLpNormalization() {
+    return type == PrimitiveType_LpNormalization ?
+      reinterpret_cast<mindspore::schema::LpNormalizationT *>(value) : nullptr;
+  }
+  const mindspore::schema::LpNormalizationT *AsLpNormalization() const {
+    return type == PrimitiveType_LpNormalization ?
+      reinterpret_cast<const mindspore::schema::LpNormalizationT *>(value) : nullptr;
+  }
+  mindspore::schema::LRNT *AsLRN() {
+    return type == PrimitiveType_LRN ?
+      reinterpret_cast<mindspore::schema::LRNT *>(value) : nullptr;
+  }
+  const mindspore::schema::LRNT *AsLRN() const {
+    return type == PrimitiveType_LRN ?
+      reinterpret_cast<const mindspore::schema::LRNT *>(value) : nullptr;
+  }
+  mindspore::schema::LshProjectionT *AsLshProjection() {
+    return type == PrimitiveType_LshProjection ?
+      reinterpret_cast<mindspore::schema::LshProjectionT *>(value) : nullptr;
+  }
+  const mindspore::schema::LshProjectionT *AsLshProjection() const {
+    return type == PrimitiveType_LshProjection ?
+      reinterpret_cast<const mindspore::schema::LshProjectionT *>(value) : nullptr;
+  }
+  mindspore::schema::LSTMT *AsLSTM() {
+    return type == PrimitiveType_LSTM ?
+      reinterpret_cast<mindspore::schema::LSTMT *>(value) : nullptr;
+  }
+  const mindspore::schema::LSTMT *AsLSTM() const {
+    return type == PrimitiveType_LSTM ?
+      reinterpret_cast<const mindspore::schema::LSTMT *>(value) : nullptr;
+  }
+  mindspore::schema::L2NormalizeFusionT *AsL2NormalizeFusion() {
+    return type == PrimitiveType_L2NormalizeFusion ?
+      reinterpret_cast<mindspore::schema::L2NormalizeFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::L2NormalizeFusionT *AsL2NormalizeFusion() const {
+    return type == PrimitiveType_L2NormalizeFusion ?
+      reinterpret_cast<const mindspore::schema::L2NormalizeFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::MatMulFusionT *AsMatMulFusion() {
+    return type == PrimitiveType_MatMulFusion ?
+      reinterpret_cast<mindspore::schema::MatMulFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::MatMulFusionT *AsMatMulFusion() const {
+    return type == PrimitiveType_MatMulFusion ?
+      reinterpret_cast<const mindspore::schema::MatMulFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::MaximumT *AsMaximum() {
+    return type == PrimitiveType_Maximum ?
+      reinterpret_cast<mindspore::schema::MaximumT *>(value) : nullptr;
+  }
+  const mindspore::schema::MaximumT *AsMaximum() const {
+    return type == PrimitiveType_Maximum ?
+      reinterpret_cast<const mindspore::schema::MaximumT *>(value) : nullptr;
+  }
+  mindspore::schema::MaximumGradT *AsMaximumGrad() {
+    return type == PrimitiveType_MaximumGrad ?
+      reinterpret_cast<mindspore::schema::MaximumGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::MaximumGradT *AsMaximumGrad() const {
+    return type == PrimitiveType_MaximumGrad ?
+      reinterpret_cast<const mindspore::schema::MaximumGradT *>(value) : nullptr;
+  }
+  mindspore::schema::MaxPoolFusionT *AsMaxPoolFusion() {
+    return type == PrimitiveType_MaxPoolFusion ?
+      reinterpret_cast<mindspore::schema::MaxPoolFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::MaxPoolFusionT *AsMaxPoolFusion() const {
+    return type == PrimitiveType_MaxPoolFusion ?
+      reinterpret_cast<const mindspore::schema::MaxPoolFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::MaxPoolGradT *AsMaxPoolGrad() {
+    return type == PrimitiveType_MaxPoolGrad ?
+      reinterpret_cast<mindspore::schema::MaxPoolGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::MaxPoolGradT *AsMaxPoolGrad() const {
+    return type == PrimitiveType_MaxPoolGrad ?
+      reinterpret_cast<const mindspore::schema::MaxPoolGradT *>(value) : nullptr;
+  }
+  mindspore::schema::SwitchLayerT *AsSwitchLayer() {
+    return type == PrimitiveType_SwitchLayer ?
+      reinterpret_cast<mindspore::schema::SwitchLayerT *>(value) : nullptr;
+  }
+  const mindspore::schema::SwitchLayerT *AsSwitchLayer() const {
+    return type == PrimitiveType_SwitchLayer ?
+      reinterpret_cast<const mindspore::schema::SwitchLayerT *>(value) : nullptr;
+  }
+  mindspore::schema::MfccT *AsMfcc() {
+    return type == PrimitiveType_Mfcc ?
+      reinterpret_cast<mindspore::schema::MfccT *>(value) : nullptr;
+  }
+  const mindspore::schema::MfccT *AsMfcc() const {
+    return type == PrimitiveType_Mfcc ?
+      reinterpret_cast<const mindspore::schema::MfccT *>(value) : nullptr;
+  }
+  mindspore::schema::MinimumT *AsMinimum() {
+    return type == PrimitiveType_Minimum ?
+      reinterpret_cast<mindspore::schema::MinimumT *>(value) : nullptr;
+  }
+  const mindspore::schema::MinimumT *AsMinimum() const {
+    return type == PrimitiveType_Minimum ?
+      reinterpret_cast<const mindspore::schema::MinimumT *>(value) : nullptr;
+  }
+  mindspore::schema::MinimumGradT *AsMinimumGrad() {
+    return type == PrimitiveType_MinimumGrad ?
+      reinterpret_cast<mindspore::schema::MinimumGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::MinimumGradT *AsMinimumGrad() const {
+    return type == PrimitiveType_MinimumGrad ?
+      reinterpret_cast<const mindspore::schema::MinimumGradT *>(value) : nullptr;
+  }
+  mindspore::schema::ModT *AsMod() {
+    return type == PrimitiveType_Mod ?
+      reinterpret_cast<mindspore::schema::ModT *>(value) : nullptr;
+  }
+  const mindspore::schema::ModT *AsMod() const {
+    return type == PrimitiveType_Mod ?
+      reinterpret_cast<const mindspore::schema::ModT *>(value) : nullptr;
+  }
+  mindspore::schema::MulFusionT *AsMulFusion() {
+    return type == PrimitiveType_MulFusion ?
+      reinterpret_cast<mindspore::schema::MulFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::MulFusionT *AsMulFusion() const {
+    return type == PrimitiveType_MulFusion ?
+      reinterpret_cast<const mindspore::schema::MulFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::MulGradT *AsMulGrad() {
+    return type == PrimitiveType_MulGrad ?
+      reinterpret_cast<mindspore::schema::MulGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::MulGradT *AsMulGrad() const {
+    return type == PrimitiveType_MulGrad ?
+      reinterpret_cast<const mindspore::schema::MulGradT *>(value) : nullptr;
+  }
+  mindspore::schema::NegT *AsNeg() {
+    return type == PrimitiveType_Neg ?
+      reinterpret_cast<mindspore::schema::NegT *>(value) : nullptr;
+  }
+  const mindspore::schema::NegT *AsNeg() const {
+    return type == PrimitiveType_Neg ?
+      reinterpret_cast<const mindspore::schema::NegT *>(value) : nullptr;
+  }
+  mindspore::schema::NegGradT *AsNegGrad() {
+    return type == PrimitiveType_NegGrad ?
+      reinterpret_cast<mindspore::schema::NegGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::NegGradT *AsNegGrad() const {
+    return type == PrimitiveType_NegGrad ?
+      reinterpret_cast<const mindspore::schema::NegGradT *>(value) : nullptr;
+  }
+  mindspore::schema::NotEqualT *AsNotEqual() {
+    return type == PrimitiveType_NotEqual ?
+      reinterpret_cast<mindspore::schema::NotEqualT *>(value) : nullptr;
+  }
+  const mindspore::schema::NotEqualT *AsNotEqual() const {
+    return type == PrimitiveType_NotEqual ?
+      reinterpret_cast<const mindspore::schema::NotEqualT *>(value) : nullptr;
+  }
+  mindspore::schema::NonMaxSuppressionT *AsNonMaxSuppression() {
+    return type == PrimitiveType_NonMaxSuppression ?
+      reinterpret_cast<mindspore::schema::NonMaxSuppressionT *>(value) : nullptr;
+  }
+  const mindspore::schema::NonMaxSuppressionT *AsNonMaxSuppression() const {
+    return type == PrimitiveType_NonMaxSuppression ?
+      reinterpret_cast<const mindspore::schema::NonMaxSuppressionT *>(value) : nullptr;
+  }
+  mindspore::schema::OneHotT *AsOneHot() {
+    return type == PrimitiveType_OneHot ?
+      reinterpret_cast<mindspore::schema::OneHotT *>(value) : nullptr;
+  }
+  const mindspore::schema::OneHotT *AsOneHot() const {
+    return type == PrimitiveType_OneHot ?
+      reinterpret_cast<const mindspore::schema::OneHotT *>(value) : nullptr;
+  }
+  mindspore::schema::OnesLikeT *AsOnesLike() {
+    return type == PrimitiveType_OnesLike ?
+      reinterpret_cast<mindspore::schema::OnesLikeT *>(value) : nullptr;
+  }
+  const mindspore::schema::OnesLikeT *AsOnesLike() const {
+    return type == PrimitiveType_OnesLike ?
+      reinterpret_cast<const mindspore::schema::OnesLikeT *>(value) : nullptr;
+  }
+  mindspore::schema::PadFusionT *AsPadFusion() {
+    return type == PrimitiveType_PadFusion ?
+      reinterpret_cast<mindspore::schema::PadFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::PadFusionT *AsPadFusion() const {
+    return type == PrimitiveType_PadFusion ?
+      reinterpret_cast<const mindspore::schema::PadFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::PartialFusionT *AsPartialFusion() {
+    return type == PrimitiveType_PartialFusion ?
+      reinterpret_cast<mindspore::schema::PartialFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::PartialFusionT *AsPartialFusion() const {
+    return type == PrimitiveType_PartialFusion ?
+      reinterpret_cast<const mindspore::schema::PartialFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::PowerGradT *AsPowerGrad() {
+    return type == PrimitiveType_PowerGrad ?
+      reinterpret_cast<mindspore::schema::PowerGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::PowerGradT *AsPowerGrad() const {
+    return type == PrimitiveType_PowerGrad ?
+      reinterpret_cast<const mindspore::schema::PowerGradT *>(value) : nullptr;
+  }
+  mindspore::schema::PowFusionT *AsPowFusion() {
+    return type == PrimitiveType_PowFusion ?
+      reinterpret_cast<mindspore::schema::PowFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::PowFusionT *AsPowFusion() const {
+    return type == PrimitiveType_PowFusion ?
+      reinterpret_cast<const mindspore::schema::PowFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::PriorBoxT *AsPriorBox() {
+    return type == PrimitiveType_PriorBox ?
+      reinterpret_cast<mindspore::schema::PriorBoxT *>(value) : nullptr;
+  }
+  const mindspore::schema::PriorBoxT *AsPriorBox() const {
+    return type == PrimitiveType_PriorBox ?
+      reinterpret_cast<const mindspore::schema::PriorBoxT *>(value) : nullptr;
+  }
+  mindspore::schema::PReLUFusionT *AsPReLUFusion() {
+    return type == PrimitiveType_PReLUFusion ?
+      reinterpret_cast<mindspore::schema::PReLUFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::PReLUFusionT *AsPReLUFusion() const {
+    return type == PrimitiveType_PReLUFusion ?
+      reinterpret_cast<const mindspore::schema::PReLUFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::QuantDTypeCastT *AsQuantDTypeCast() {
+    return type == PrimitiveType_QuantDTypeCast ?
+      reinterpret_cast<mindspore::schema::QuantDTypeCastT *>(value) : nullptr;
+  }
+  const mindspore::schema::QuantDTypeCastT *AsQuantDTypeCast() const {
+    return type == PrimitiveType_QuantDTypeCast ?
+      reinterpret_cast<const mindspore::schema::QuantDTypeCastT *>(value) : nullptr;
+  }
+  mindspore::schema::RankT *AsRank() {
+    return type == PrimitiveType_Rank ?
+      reinterpret_cast<mindspore::schema::RankT *>(value) : nullptr;
+  }
+  const mindspore::schema::RankT *AsRank() const {
+    return type == PrimitiveType_Rank ?
+      reinterpret_cast<const mindspore::schema::RankT *>(value) : nullptr;
+  }
+  mindspore::schema::RangeT *AsRange() {
+    return type == PrimitiveType_Range ?
+      reinterpret_cast<mindspore::schema::RangeT *>(value) : nullptr;
+  }
+  const mindspore::schema::RangeT *AsRange() const {
+    return type == PrimitiveType_Range ?
+      reinterpret_cast<const mindspore::schema::RangeT *>(value) : nullptr;
+  }
+  mindspore::schema::ReciprocalT *AsReciprocal() {
+    return type == PrimitiveType_Reciprocal ?
+      reinterpret_cast<mindspore::schema::ReciprocalT *>(value) : nullptr;
+  }
+  const mindspore::schema::ReciprocalT *AsReciprocal() const {
+    return type == PrimitiveType_Reciprocal ?
+      reinterpret_cast<const mindspore::schema::ReciprocalT *>(value) : nullptr;
+  }
+  mindspore::schema::RealDivT *AsRealDiv() {
+    return type == PrimitiveType_RealDiv ?
+      reinterpret_cast<mindspore::schema::RealDivT *>(value) : nullptr;
+  }
+  const mindspore::schema::RealDivT *AsRealDiv() const {
+    return type == PrimitiveType_RealDiv ?
+      reinterpret_cast<const mindspore::schema::RealDivT *>(value) : nullptr;
+  }
+  mindspore::schema::ReduceFusionT *AsReduceFusion() {
+    return type == PrimitiveType_ReduceFusion ?
+      reinterpret_cast<mindspore::schema::ReduceFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::ReduceFusionT *AsReduceFusion() const {
+    return type == PrimitiveType_ReduceFusion ?
+      reinterpret_cast<const mindspore::schema::ReduceFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::ReshapeT *AsReshape() {
+    return type == PrimitiveType_Reshape ?
+      reinterpret_cast<mindspore::schema::ReshapeT *>(value) : nullptr;
+  }
+  const mindspore::schema::ReshapeT *AsReshape() const {
+    return type == PrimitiveType_Reshape ?
+      reinterpret_cast<const mindspore::schema::ReshapeT *>(value) : nullptr;
+  }
+  mindspore::schema::ResizeT *AsResize() {
+    return type == PrimitiveType_Resize ?
+      reinterpret_cast<mindspore::schema::ResizeT *>(value) : nullptr;
+  }
+  const mindspore::schema::ResizeT *AsResize() const {
+    return type == PrimitiveType_Resize ?
+      reinterpret_cast<const mindspore::schema::ResizeT *>(value) : nullptr;
+  }
+  mindspore::schema::ReverseSequenceT *AsReverseSequence() {
+    return type == PrimitiveType_ReverseSequence ?
+      reinterpret_cast<mindspore::schema::ReverseSequenceT *>(value) : nullptr;
+  }
+  const mindspore::schema::ReverseSequenceT *AsReverseSequence() const {
+    return type == PrimitiveType_ReverseSequence ?
+      reinterpret_cast<const mindspore::schema::ReverseSequenceT *>(value) : nullptr;
+  }
+  mindspore::schema::ReverseV2T *AsReverseV2() {
+    return type == PrimitiveType_ReverseV2 ?
+      reinterpret_cast<mindspore::schema::ReverseV2T *>(value) : nullptr;
+  }
+  const mindspore::schema::ReverseV2T *AsReverseV2() const {
+    return type == PrimitiveType_ReverseV2 ?
+      reinterpret_cast<const mindspore::schema::ReverseV2T *>(value) : nullptr;
+  }
+  mindspore::schema::RfftT *AsRfft() {
+    return type == PrimitiveType_Rfft ?
+      reinterpret_cast<mindspore::schema::RfftT *>(value) : nullptr;
+  }
+  const mindspore::schema::RfftT *AsRfft() const {
+    return type == PrimitiveType_Rfft ?
+      reinterpret_cast<const mindspore::schema::RfftT *>(value) : nullptr;
+  }
+  mindspore::schema::ROIPoolingT *AsROIPooling() {
+    return type == PrimitiveType_ROIPooling ?
+      reinterpret_cast<mindspore::schema::ROIPoolingT *>(value) : nullptr;
+  }
+  const mindspore::schema::ROIPoolingT *AsROIPooling() const {
+    return type == PrimitiveType_ROIPooling ?
+      reinterpret_cast<const mindspore::schema::ROIPoolingT *>(value) : nullptr;
+  }
+  mindspore::schema::RoundT *AsRound() {
+    return type == PrimitiveType_Round ?
+      reinterpret_cast<mindspore::schema::RoundT *>(value) : nullptr;
+  }
+  const mindspore::schema::RoundT *AsRound() const {
+    return type == PrimitiveType_Round ?
+      reinterpret_cast<const mindspore::schema::RoundT *>(value) : nullptr;
+  }
+  mindspore::schema::RsqrtT *AsRsqrt() {
+    return type == PrimitiveType_Rsqrt ?
+      reinterpret_cast<mindspore::schema::RsqrtT *>(value) : nullptr;
+  }
+  const mindspore::schema::RsqrtT *AsRsqrt() const {
+    return type == PrimitiveType_Rsqrt ?
+      reinterpret_cast<const mindspore::schema::RsqrtT *>(value) : nullptr;
+  }
+  mindspore::schema::ScaleFusionT *AsScaleFusion() {
+    return type == PrimitiveType_ScaleFusion ?
+      reinterpret_cast<mindspore::schema::ScaleFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::ScaleFusionT *AsScaleFusion() const {
+    return type == PrimitiveType_ScaleFusion ?
+      reinterpret_cast<const mindspore::schema::ScaleFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::ScatterNdT *AsScatterNd() {
+    return type == PrimitiveType_ScatterNd ?
+      reinterpret_cast<mindspore::schema::ScatterNdT *>(value) : nullptr;
+  }
+  const mindspore::schema::ScatterNdT *AsScatterNd() const {
+    return type == PrimitiveType_ScatterNd ?
+      reinterpret_cast<const mindspore::schema::ScatterNdT *>(value) : nullptr;
+  }
+  mindspore::schema::SGDT *AsSGD() {
+    return type == PrimitiveType_SGD ?
+      reinterpret_cast<mindspore::schema::SGDT *>(value) : nullptr;
+  }
+  const mindspore::schema::SGDT *AsSGD() const {
+    return type == PrimitiveType_SGD ?
+      reinterpret_cast<const mindspore::schema::SGDT *>(value) : nullptr;
+  }
+  mindspore::schema::ShapeT *AsShape() {
+    return type == PrimitiveType_Shape ?
+      reinterpret_cast<mindspore::schema::ShapeT *>(value) : nullptr;
+  }
+  const mindspore::schema::ShapeT *AsShape() const {
+    return type == PrimitiveType_Shape ?
+      reinterpret_cast<const mindspore::schema::ShapeT *>(value) : nullptr;
+  }
+  mindspore::schema::SigmoidCrossEntropyWithLogitsT *AsSigmoidCrossEntropyWithLogits() {
+    return type == PrimitiveType_SigmoidCrossEntropyWithLogits ?
+      reinterpret_cast<mindspore::schema::SigmoidCrossEntropyWithLogitsT *>(value) : nullptr;
+  }
+  const mindspore::schema::SigmoidCrossEntropyWithLogitsT *AsSigmoidCrossEntropyWithLogits() const {
+    return type == PrimitiveType_SigmoidCrossEntropyWithLogits ?
+      reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsT *>(value) : nullptr;
+  }
+  mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *AsSigmoidCrossEntropyWithLogitsGrad() {
+    return type == PrimitiveType_SigmoidCrossEntropyWithLogitsGrad ?
+      reinterpret_cast<mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *AsSigmoidCrossEntropyWithLogitsGrad() const {
+    return type == PrimitiveType_SigmoidCrossEntropyWithLogitsGrad ?
+      reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *>(value) : nullptr;
+  }
+  mindspore::schema::SinT *AsSin() {
+    return type == PrimitiveType_Sin ?
+      reinterpret_cast<mindspore::schema::SinT *>(value) : nullptr;
+  }
+  const mindspore::schema::SinT *AsSin() const {
+    return type == PrimitiveType_Sin ?
+      reinterpret_cast<const mindspore::schema::SinT *>(value) : nullptr;
+  }
+  mindspore::schema::SkipGramT *AsSkipGram() {
+    return type == PrimitiveType_SkipGram ?
+      reinterpret_cast<mindspore::schema::SkipGramT *>(value) : nullptr;
+  }
+  const mindspore::schema::SkipGramT *AsSkipGram() const {
+    return type == PrimitiveType_SkipGram ?
+      reinterpret_cast<const mindspore::schema::SkipGramT *>(value) : nullptr;
+  }
+  mindspore::schema::SliceFusionT *AsSliceFusion() {
+    return type == PrimitiveType_SliceFusion ?
+      reinterpret_cast<mindspore::schema::SliceFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::SliceFusionT *AsSliceFusion() const {
+    return type == PrimitiveType_SliceFusion ?
+      reinterpret_cast<const mindspore::schema::SliceFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::SmoothL1LossT *AsSmoothL1Loss() {
+    return type == PrimitiveType_SmoothL1Loss ?
+      reinterpret_cast<mindspore::schema::SmoothL1LossT *>(value) : nullptr;
+  }
+  const mindspore::schema::SmoothL1LossT *AsSmoothL1Loss() const {
+    return type == PrimitiveType_SmoothL1Loss ?
+      reinterpret_cast<const mindspore::schema::SmoothL1LossT *>(value) : nullptr;
+  }
+  mindspore::schema::SmoothL1LossGradT *AsSmoothL1LossGrad() {
+    return type == PrimitiveType_SmoothL1LossGrad ?
+      reinterpret_cast<mindspore::schema::SmoothL1LossGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::SmoothL1LossGradT *AsSmoothL1LossGrad() const {
+    return type == PrimitiveType_SmoothL1LossGrad ?
+      reinterpret_cast<const mindspore::schema::SmoothL1LossGradT *>(value) : nullptr;
+  }
+  mindspore::schema::SoftmaxT *AsSoftmax() {
+    return type == PrimitiveType_Softmax ?
+      reinterpret_cast<mindspore::schema::SoftmaxT *>(value) : nullptr;
+  }
+  const mindspore::schema::SoftmaxT *AsSoftmax() const {
+    return type == PrimitiveType_Softmax ?
+      reinterpret_cast<const mindspore::schema::SoftmaxT *>(value) : nullptr;
+  }
+  mindspore::schema::SoftmaxCrossEntropyWithLogitsT *AsSoftmaxCrossEntropyWithLogits() {
+    return type == PrimitiveType_SoftmaxCrossEntropyWithLogits ?
+      reinterpret_cast<mindspore::schema::SoftmaxCrossEntropyWithLogitsT *>(value) : nullptr;
+  }
+  const mindspore::schema::SoftmaxCrossEntropyWithLogitsT *AsSoftmaxCrossEntropyWithLogits() const {
+    return type == PrimitiveType_SoftmaxCrossEntropyWithLogits ?
+      reinterpret_cast<const mindspore::schema::SoftmaxCrossEntropyWithLogitsT *>(value) : nullptr;
+  }
+  mindspore::schema::SpaceToBatchT *AsSpaceToBatch() {
+    return type == PrimitiveType_SpaceToBatch ?
+      reinterpret_cast<mindspore::schema::SpaceToBatchT *>(value) : nullptr;
+  }
+  const mindspore::schema::SpaceToBatchT *AsSpaceToBatch() const {
+    return type == PrimitiveType_SpaceToBatch ?
+      reinterpret_cast<const mindspore::schema::SpaceToBatchT *>(value) : nullptr;
+  }
+  mindspore::schema::SpaceToBatchNDT *AsSpaceToBatchND() {
+    return type == PrimitiveType_SpaceToBatchND ?
+      reinterpret_cast<mindspore::schema::SpaceToBatchNDT *>(value) : nullptr;
+  }
+  const mindspore::schema::SpaceToBatchNDT *AsSpaceToBatchND() const {
+    return type == PrimitiveType_SpaceToBatchND ?
+      reinterpret_cast<const mindspore::schema::SpaceToBatchNDT *>(value) : nullptr;
+  }
+  mindspore::schema::SpaceToDepthT *AsSpaceToDepth() {
+    return type == PrimitiveType_SpaceToDepth ?
+      reinterpret_cast<mindspore::schema::SpaceToDepthT *>(value) : nullptr;
+  }
+  const mindspore::schema::SpaceToDepthT *AsSpaceToDepth() const {
+    return type == PrimitiveType_SpaceToDepth ?
+      reinterpret_cast<const mindspore::schema::SpaceToDepthT *>(value) : nullptr;
+  }
+  mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *AsSparseSoftmaxCrossEntropyWithLogits() {
+    return type == PrimitiveType_SparseSoftmaxCrossEntropyWithLogits ?
+      reinterpret_cast<mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *>(value) : nullptr;
+  }
+  const mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *AsSparseSoftmaxCrossEntropyWithLogits() const {
+    return type == PrimitiveType_SparseSoftmaxCrossEntropyWithLogits ?
+      reinterpret_cast<const mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *>(value) : nullptr;
+  }
+  mindspore::schema::SparseToDenseT *AsSparseToDense() {
+    return type == PrimitiveType_SparseToDense ?
+      reinterpret_cast<mindspore::schema::SparseToDenseT *>(value) : nullptr;
+  }
+  const mindspore::schema::SparseToDenseT *AsSparseToDense() const {
+    return type == PrimitiveType_SparseToDense ?
+      reinterpret_cast<const mindspore::schema::SparseToDenseT *>(value) : nullptr;
+  }
+  mindspore::schema::SplitT *AsSplit() {
+    return type == PrimitiveType_Split ?
+      reinterpret_cast<mindspore::schema::SplitT *>(value) : nullptr;
+  }
+  const mindspore::schema::SplitT *AsSplit() const {
+    return type == PrimitiveType_Split ?
+      reinterpret_cast<const mindspore::schema::SplitT *>(value) : nullptr;
+  }
+  mindspore::schema::SqrtT *AsSqrt() {
+    return type == PrimitiveType_Sqrt ?
+      reinterpret_cast<mindspore::schema::SqrtT *>(value) : nullptr;
+  }
+  const mindspore::schema::SqrtT *AsSqrt() const {
+    return type == PrimitiveType_Sqrt ?
+      reinterpret_cast<const mindspore::schema::SqrtT *>(value) : nullptr;
+  }
+  mindspore::schema::SqueezeT *AsSqueeze() {
+    return type == PrimitiveType_Squeeze ?
+      reinterpret_cast<mindspore::schema::SqueezeT *>(value) : nullptr;
+  }
+  const mindspore::schema::SqueezeT *AsSqueeze() const {
+    return type == PrimitiveType_Squeeze ?
+      reinterpret_cast<const mindspore::schema::SqueezeT *>(value) : nullptr;
+  }
+  mindspore::schema::SquareT *AsSquare() {
+    return type == PrimitiveType_Square ?
+      reinterpret_cast<mindspore::schema::SquareT *>(value) : nullptr;
+  }
+  const mindspore::schema::SquareT *AsSquare() const {
+    return type == PrimitiveType_Square ?
+      reinterpret_cast<const mindspore::schema::SquareT *>(value) : nullptr;
+  }
+  mindspore::schema::SquaredDifferenceT *AsSquaredDifference() {
+    return type == PrimitiveType_SquaredDifference ?
+      reinterpret_cast<mindspore::schema::SquaredDifferenceT *>(value) : nullptr;
+  }
+  const mindspore::schema::SquaredDifferenceT *AsSquaredDifference() const {
+    return type == PrimitiveType_SquaredDifference ?
+      reinterpret_cast<const mindspore::schema::SquaredDifferenceT *>(value) : nullptr;
+  }
+  mindspore::schema::StackT *AsStack() {
+    return type == PrimitiveType_Stack ?
+      reinterpret_cast<mindspore::schema::StackT *>(value) : nullptr;
+  }
+  const mindspore::schema::StackT *AsStack() const {
+    return type == PrimitiveType_Stack ?
+      reinterpret_cast<const mindspore::schema::StackT *>(value) : nullptr;
+  }
+  mindspore::schema::StridedSliceT *AsStridedSlice() {
+    return type == PrimitiveType_StridedSlice ?
+      reinterpret_cast<mindspore::schema::StridedSliceT *>(value) : nullptr;
+  }
+  const mindspore::schema::StridedSliceT *AsStridedSlice() const {
+    return type == PrimitiveType_StridedSlice ?
+      reinterpret_cast<const mindspore::schema::StridedSliceT *>(value) : nullptr;
+  }
+  mindspore::schema::SubFusionT *AsSubFusion() {
+    return type == PrimitiveType_SubFusion ?
+      reinterpret_cast<mindspore::schema::SubFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::SubFusionT *AsSubFusion() const {
+    return type == PrimitiveType_SubFusion ?
+      reinterpret_cast<const mindspore::schema::SubFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::SubGradT *AsSubGrad() {
+    return type == PrimitiveType_SubGrad ?
+      reinterpret_cast<mindspore::schema::SubGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::SubGradT *AsSubGrad() const {
+    return type == PrimitiveType_SubGrad ?
+      reinterpret_cast<const mindspore::schema::SubGradT *>(value) : nullptr;
+  }
+  mindspore::schema::SwitchT *AsSwitch() {
+    return type == PrimitiveType_Switch ?
+      reinterpret_cast<mindspore::schema::SwitchT *>(value) : nullptr;
+  }
+  const mindspore::schema::SwitchT *AsSwitch() const {
+    return type == PrimitiveType_Switch ?
+      reinterpret_cast<const mindspore::schema::SwitchT *>(value) : nullptr;
+  }
+  mindspore::schema::TensorListFromTensorT *AsTensorListFromTensor() {
+    return type == PrimitiveType_TensorListFromTensor ?
+      reinterpret_cast<mindspore::schema::TensorListFromTensorT *>(value) : nullptr;
+  }
+  const mindspore::schema::TensorListFromTensorT *AsTensorListFromTensor() const {
+    return type == PrimitiveType_TensorListFromTensor ?
+      reinterpret_cast<const mindspore::schema::TensorListFromTensorT *>(value) : nullptr;
+  }
+  mindspore::schema::TensorListGetItemT *AsTensorListGetItem() {
+    return type == PrimitiveType_TensorListGetItem ?
+      reinterpret_cast<mindspore::schema::TensorListGetItemT *>(value) : nullptr;
+  }
+  const mindspore::schema::TensorListGetItemT *AsTensorListGetItem() const {
+    return type == PrimitiveType_TensorListGetItem ?
+      reinterpret_cast<const mindspore::schema::TensorListGetItemT *>(value) : nullptr;
+  }
+  mindspore::schema::TensorListReserveT *AsTensorListReserve() {
+    return type == PrimitiveType_TensorListReserve ?
+      reinterpret_cast<mindspore::schema::TensorListReserveT *>(value) : nullptr;
+  }
+  const mindspore::schema::TensorListReserveT *AsTensorListReserve() const {
+    return type == PrimitiveType_TensorListReserve ?
+      reinterpret_cast<const mindspore::schema::TensorListReserveT *>(value) : nullptr;
+  }
+  mindspore::schema::TensorListSetItemT *AsTensorListSetItem() {
+    return type == PrimitiveType_TensorListSetItem ?
+      reinterpret_cast<mindspore::schema::TensorListSetItemT *>(value) : nullptr;
+  }
+  const mindspore::schema::TensorListSetItemT *AsTensorListSetItem() const {
+    return type == PrimitiveType_TensorListSetItem ?
+      reinterpret_cast<const mindspore::schema::TensorListSetItemT *>(value) : nullptr;
+  }
+  mindspore::schema::TensorListStackT *AsTensorListStack() {
+    return type == PrimitiveType_TensorListStack ?
+      reinterpret_cast<mindspore::schema::TensorListStackT *>(value) : nullptr;
+  }
+  const mindspore::schema::TensorListStackT *AsTensorListStack() const {
+    return type == PrimitiveType_TensorListStack ?
+      reinterpret_cast<const mindspore::schema::TensorListStackT *>(value) : nullptr;
+  }
+  mindspore::schema::TileFusionT *AsTileFusion() {
+    return type == PrimitiveType_TileFusion ?
+      reinterpret_cast<mindspore::schema::TileFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::TileFusionT *AsTileFusion() const {
+    return type == PrimitiveType_TileFusion ?
+      reinterpret_cast<const mindspore::schema::TileFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::TopKFusionT *AsTopKFusion() {
+    return type == PrimitiveType_TopKFusion ?
+      reinterpret_cast<mindspore::schema::TopKFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::TopKFusionT *AsTopKFusion() const {
+    return type == PrimitiveType_TopKFusion ?
+      reinterpret_cast<const mindspore::schema::TopKFusionT *>(value) : nullptr;
+  }
+  mindspore::schema::TransposeT *AsTranspose() {
+    return type == PrimitiveType_Transpose ?
+      reinterpret_cast<mindspore::schema::TransposeT *>(value) : nullptr;
+  }
+  const mindspore::schema::TransposeT *AsTranspose() const {
+    return type == PrimitiveType_Transpose ?
+      reinterpret_cast<const mindspore::schema::TransposeT *>(value) : nullptr;
+  }
+  mindspore::schema::UniqueT *AsUnique() {
+    return type == PrimitiveType_Unique ?
+      reinterpret_cast<mindspore::schema::UniqueT *>(value) : nullptr;
+  }
+  const mindspore::schema::UniqueT *AsUnique() const {
+    return type == PrimitiveType_Unique ?
+      reinterpret_cast<const mindspore::schema::UniqueT *>(value) : nullptr;
+  }
+  mindspore::schema::UnsortedSegmentSumT *AsUnsortedSegmentSum() {
+    return type == PrimitiveType_UnsortedSegmentSum ?
+      reinterpret_cast<mindspore::schema::UnsortedSegmentSumT *>(value) : nullptr;
+  }
+  const mindspore::schema::UnsortedSegmentSumT *AsUnsortedSegmentSum() const {
+    return type == PrimitiveType_UnsortedSegmentSum ?
+      reinterpret_cast<const mindspore::schema::UnsortedSegmentSumT *>(value) : nullptr;
+  }
+  mindspore::schema::UnsqueezeT *AsUnsqueeze() {
+    return type == PrimitiveType_Unsqueeze ?
+      reinterpret_cast<mindspore::schema::UnsqueezeT *>(value) : nullptr;
+  }
+  const mindspore::schema::UnsqueezeT *AsUnsqueeze() const {
+    return type == PrimitiveType_Unsqueeze ?
+      reinterpret_cast<const mindspore::schema::UnsqueezeT *>(value) : nullptr;
+  }
+  mindspore::schema::UnstackT *AsUnstack() {
+    return type == PrimitiveType_Unstack ?
+      reinterpret_cast<mindspore::schema::UnstackT *>(value) : nullptr;
+  }
+  const mindspore::schema::UnstackT *AsUnstack() const {
+    return type == PrimitiveType_Unstack ?
+      reinterpret_cast<const mindspore::schema::UnstackT *>(value) : nullptr;
+  }
+  mindspore::schema::LSTMGradT *AsLSTMGrad() {
+    return type == PrimitiveType_LSTMGrad ?
+      reinterpret_cast<mindspore::schema::LSTMGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::LSTMGradT *AsLSTMGrad() const {
+    return type == PrimitiveType_LSTMGrad ?
+      reinterpret_cast<const mindspore::schema::LSTMGradT *>(value) : nullptr;
+  }
+  mindspore::schema::WhereT *AsWhere() {
+    return type == PrimitiveType_Where ?
+      reinterpret_cast<mindspore::schema::WhereT *>(value) : nullptr;
+  }
+  const mindspore::schema::WhereT *AsWhere() const {
+    return type == PrimitiveType_Where ?
+      reinterpret_cast<const mindspore::schema::WhereT *>(value) : nullptr;
+  }
+  mindspore::schema::ZerosLikeT *AsZerosLike() {
+    return type == PrimitiveType_ZerosLike ?
+      reinterpret_cast<mindspore::schema::ZerosLikeT *>(value) : nullptr;
+  }
+  const mindspore::schema::ZerosLikeT *AsZerosLike() const {
+    return type == PrimitiveType_ZerosLike ?
+      reinterpret_cast<const mindspore::schema::ZerosLikeT *>(value) : nullptr;
+  }
+  mindspore::schema::SelectT *AsSelect() {
+    return type == PrimitiveType_Select ?
+      reinterpret_cast<mindspore::schema::SelectT *>(value) : nullptr;
+  }
+  const mindspore::schema::SelectT *AsSelect() const {
+    return type == PrimitiveType_Select ?
+      reinterpret_cast<const mindspore::schema::SelectT *>(value) : nullptr;
+  }
+  mindspore::schema::ScatterNdUpdateT *AsScatterNdUpdate() {
+    return type == PrimitiveType_ScatterNdUpdate ?
+      reinterpret_cast<mindspore::schema::ScatterNdUpdateT *>(value) : nullptr;
+  }
+  const mindspore::schema::ScatterNdUpdateT *AsScatterNdUpdate() const {
+    return type == PrimitiveType_ScatterNdUpdate ?
+      reinterpret_cast<const mindspore::schema::ScatterNdUpdateT *>(value) : nullptr;
+  }
+  mindspore::schema::GRUT *AsGRU() {
+    return type == PrimitiveType_GRU ?
+      reinterpret_cast<mindspore::schema::GRUT *>(value) : nullptr;
+  }
+  const mindspore::schema::GRUT *AsGRU() const {
+    return type == PrimitiveType_GRU ?
+      reinterpret_cast<const mindspore::schema::GRUT *>(value) : nullptr;
+  }
+  mindspore::schema::NonZeroT *AsNonZero() {
+    return type == PrimitiveType_NonZero ?
+      reinterpret_cast<mindspore::schema::NonZeroT *>(value) : nullptr;
+  }
+  const mindspore::schema::NonZeroT *AsNonZero() const {
+    return type == PrimitiveType_NonZero ?
+      reinterpret_cast<const mindspore::schema::NonZeroT *>(value) : nullptr;
+  }
+  mindspore::schema::InvertPermutationT *AsInvertPermutation() {
+    return type == PrimitiveType_InvertPermutation ?
+      reinterpret_cast<mindspore::schema::InvertPermutationT *>(value) : nullptr;
+  }
+  const mindspore::schema::InvertPermutationT *AsInvertPermutation() const {
+    return type == PrimitiveType_InvertPermutation ?
+      reinterpret_cast<const mindspore::schema::InvertPermutationT *>(value) : nullptr;
+  }
+  mindspore::schema::SizeT *AsSize() {
+    return type == PrimitiveType_Size ?
+      reinterpret_cast<mindspore::schema::SizeT *>(value) : nullptr;
+  }
+  const mindspore::schema::SizeT *AsSize() const {
+    return type == PrimitiveType_Size ?
+      reinterpret_cast<const mindspore::schema::SizeT *>(value) : nullptr;
+  }
+  mindspore::schema::RandomStandardNormalT *AsRandomStandardNormal() {
+    return type == PrimitiveType_RandomStandardNormal ?
+      reinterpret_cast<mindspore::schema::RandomStandardNormalT *>(value) : nullptr;
+  }
+  const mindspore::schema::RandomStandardNormalT *AsRandomStandardNormal() const {
+    return type == PrimitiveType_RandomStandardNormal ?
+      reinterpret_cast<const mindspore::schema::RandomStandardNormalT *>(value) : nullptr;
+  }
+  mindspore::schema::CropAndResizeT *AsCropAndResize() {
+    return type == PrimitiveType_CropAndResize ?
+      reinterpret_cast<mindspore::schema::CropAndResizeT *>(value) : nullptr;
+  }
+  const mindspore::schema::CropAndResizeT *AsCropAndResize() const {
+    return type == PrimitiveType_CropAndResize ?
+      reinterpret_cast<const mindspore::schema::CropAndResizeT *>(value) : nullptr;
+  }
+  mindspore::schema::ErfT *AsErf() {
+    return type == PrimitiveType_Erf ?
+      reinterpret_cast<mindspore::schema::ErfT *>(value) : nullptr;
+  }
+  const mindspore::schema::ErfT *AsErf() const {
+    return type == PrimitiveType_Erf ?
+      reinterpret_cast<const mindspore::schema::ErfT *>(value) : nullptr;
+  }
+  mindspore::schema::StridedSliceGradT *AsStridedSliceGrad() {
+    return type == PrimitiveType_StridedSliceGrad ?
+      reinterpret_cast<mindspore::schema::StridedSliceGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::StridedSliceGradT *AsStridedSliceGrad() const {
+    return type == PrimitiveType_StridedSliceGrad ?
+      reinterpret_cast<const mindspore::schema::StridedSliceGradT *>(value) : nullptr;
+  }
+  mindspore::schema::IsFiniteT *AsIsFinite() {
+    return type == PrimitiveType_IsFinite ?
+      reinterpret_cast<mindspore::schema::IsFiniteT *>(value) : nullptr;
+  }
+  const mindspore::schema::IsFiniteT *AsIsFinite() const {
+    return type == PrimitiveType_IsFinite ?
+      reinterpret_cast<const mindspore::schema::IsFiniteT *>(value) : nullptr;
+  }
+  mindspore::schema::LinSpaceT *AsLinSpace() {
+    return type == PrimitiveType_LinSpace ?
+      reinterpret_cast<mindspore::schema::LinSpaceT *>(value) : nullptr;
+  }
+  const mindspore::schema::LinSpaceT *AsLinSpace() const {
+    return type == PrimitiveType_LinSpace ?
+      reinterpret_cast<const mindspore::schema::LinSpaceT *>(value) : nullptr;
+  }
+  mindspore::schema::UniformRealT *AsUniformReal() {
+    return type == PrimitiveType_UniformReal ?
+      reinterpret_cast<mindspore::schema::UniformRealT *>(value) : nullptr;
+  }
+  const mindspore::schema::UniformRealT *AsUniformReal() const {
+    return type == PrimitiveType_UniformReal ?
+      reinterpret_cast<const mindspore::schema::UniformRealT *>(value) : nullptr;
+  }
+  mindspore::schema::AbsGradT *AsAbsGrad() {
+    return type == PrimitiveType_AbsGrad ?
+      reinterpret_cast<mindspore::schema::AbsGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::AbsGradT *AsAbsGrad() const {
+    return type == PrimitiveType_AbsGrad ?
+      reinterpret_cast<const mindspore::schema::AbsGradT *>(value) : nullptr;
+  }
+  mindspore::schema::RsqrtGradT *AsRsqrtGrad() {
+    return type == PrimitiveType_RsqrtGrad ?
+      reinterpret_cast<mindspore::schema::RsqrtGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::RsqrtGradT *AsRsqrtGrad() const {
+    return type == PrimitiveType_RsqrtGrad ?
+      reinterpret_cast<const mindspore::schema::RsqrtGradT *>(value) : nullptr;
+  }
+  mindspore::schema::SqrtGradT *AsSqrtGrad() {
+    return type == PrimitiveType_SqrtGrad ?
+      reinterpret_cast<mindspore::schema::SqrtGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::SqrtGradT *AsSqrtGrad() const {
+    return type == PrimitiveType_SqrtGrad ?
+      reinterpret_cast<const mindspore::schema::SqrtGradT *>(value) : nullptr;
+  }
+  mindspore::schema::LayerNormGradT *AsLayerNormGrad() {
+    return type == PrimitiveType_LayerNormGrad ?
+      reinterpret_cast<mindspore::schema::LayerNormGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::LayerNormGradT *AsLayerNormGrad() const {
+    return type == PrimitiveType_LayerNormGrad ?
+      reinterpret_cast<const mindspore::schema::LayerNormGradT *>(value) : nullptr;
+  }
+  mindspore::schema::ResizeGradT *AsResizeGrad() {
+    return type == PrimitiveType_ResizeGrad ?
+      reinterpret_cast<mindspore::schema::ResizeGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::ResizeGradT *AsResizeGrad() const {
+    return type == PrimitiveType_ResizeGrad ?
+      reinterpret_cast<const mindspore::schema::ResizeGradT *>(value) : nullptr;
+  }
+  mindspore::schema::SpliceT *AsSplice() {
+    return type == PrimitiveType_Splice ?
+      reinterpret_cast<mindspore::schema::SpliceT *>(value) : nullptr;
+  }
+  const mindspore::schema::SpliceT *AsSplice() const {
+    return type == PrimitiveType_Splice ?
+      reinterpret_cast<const mindspore::schema::SpliceT *>(value) : nullptr;
+  }
+  mindspore::schema::LogSoftmaxT *AsLogSoftmax() {
+    return type == PrimitiveType_LogSoftmax ?
+      reinterpret_cast<mindspore::schema::LogSoftmaxT *>(value) : nullptr;
+  }
+  const mindspore::schema::LogSoftmaxT *AsLogSoftmax() const {
+    return type == PrimitiveType_LogSoftmax ?
+      reinterpret_cast<const mindspore::schema::LogSoftmaxT *>(value) : nullptr;
+  }
+  mindspore::schema::CallT *AsCall() {
+    return type == PrimitiveType_Call ?
+      reinterpret_cast<mindspore::schema::CallT *>(value) : nullptr;
+  }
+  const mindspore::schema::CallT *AsCall() const {
+    return type == PrimitiveType_Call ?
+      reinterpret_cast<const mindspore::schema::CallT *>(value) : nullptr;
+  }
+  mindspore::schema::CustomT *AsCustom() {
+    return type == PrimitiveType_Custom ?
+      reinterpret_cast<mindspore::schema::CustomT *>(value) : nullptr;
+  }
+  const mindspore::schema::CustomT *AsCustom() const {
+    return type == PrimitiveType_Custom ?
+      reinterpret_cast<const mindspore::schema::CustomT *>(value) : nullptr;
+  }
+  mindspore::schema::CumSumT *AsCumSum() {
+    return type == PrimitiveType_CumSum ?
+      reinterpret_cast<mindspore::schema::CumSumT *>(value) : nullptr;
+  }
+  const mindspore::schema::CumSumT *AsCumSum() const {
+    return type == PrimitiveType_CumSum ?
+      reinterpret_cast<const mindspore::schema::CumSumT *>(value) : nullptr;
+  }
+  mindspore::schema::SplitWithOverlapT *AsSplitWithOverlap() {
+    return type == PrimitiveType_SplitWithOverlap ?
+      reinterpret_cast<mindspore::schema::SplitWithOverlapT *>(value) : nullptr;
+  }
+  const mindspore::schema::SplitWithOverlapT *AsSplitWithOverlap() const {
+    return type == PrimitiveType_SplitWithOverlap ?
+      reinterpret_cast<const mindspore::schema::SplitWithOverlapT *>(value) : nullptr;
+  }
+  mindspore::schema::GenOPT *AsGenOP() {
+    return type == PrimitiveType_GenOP ?
+      reinterpret_cast<mindspore::schema::GenOPT *>(value) : nullptr;
+  }
+  const mindspore::schema::GenOPT *AsGenOP() const {
+    return type == PrimitiveType_GenOP ?
+      reinterpret_cast<const mindspore::schema::GenOPT *>(value) : nullptr;
+  }
+  mindspore::schema::RaggedRangeT *AsRaggedRange() {
+    return type == PrimitiveType_RaggedRange ?
+      reinterpret_cast<mindspore::schema::RaggedRangeT *>(value) : nullptr;
+  }
+  const mindspore::schema::RaggedRangeT *AsRaggedRange() const {
+    return type == PrimitiveType_RaggedRange ?
+      reinterpret_cast<const mindspore::schema::RaggedRangeT *>(value) : nullptr;
+  }
+  mindspore::schema::GLUT *AsGLU() {
+    return type == PrimitiveType_GLU ?
+      reinterpret_cast<mindspore::schema::GLUT *>(value) : nullptr;
+  }
+  const mindspore::schema::GLUT *AsGLU() const {
+    return type == PrimitiveType_GLU ?
+      reinterpret_cast<const mindspore::schema::GLUT *>(value) : nullptr;
+  }
+  mindspore::schema::TensorArrayT *AsTensorArray() {
+    return type == PrimitiveType_TensorArray ?
+      reinterpret_cast<mindspore::schema::TensorArrayT *>(value) : nullptr;
+  }
+  const mindspore::schema::TensorArrayT *AsTensorArray() const {
+    return type == PrimitiveType_TensorArray ?
+      reinterpret_cast<const mindspore::schema::TensorArrayT *>(value) : nullptr;
+  }
+  mindspore::schema::TensorArrayReadT *AsTensorArrayRead() {
+    return type == PrimitiveType_TensorArrayRead ?
+      reinterpret_cast<mindspore::schema::TensorArrayReadT *>(value) : nullptr;
+  }
+  const mindspore::schema::TensorArrayReadT *AsTensorArrayRead() const {
+    return type == PrimitiveType_TensorArrayRead ?
+      reinterpret_cast<const mindspore::schema::TensorArrayReadT *>(value) : nullptr;
+  }
+  mindspore::schema::TensorArrayWriteT *AsTensorArrayWrite() {
+    return type == PrimitiveType_TensorArrayWrite ?
+      reinterpret_cast<mindspore::schema::TensorArrayWriteT *>(value) : nullptr;
+  }
+  const mindspore::schema::TensorArrayWriteT *AsTensorArrayWrite() const {
+    return type == PrimitiveType_TensorArrayWrite ?
+      reinterpret_cast<const mindspore::schema::TensorArrayWriteT *>(value) : nullptr;
+  }
+  mindspore::schema::AffineT *AsAffine() {
+    return type == PrimitiveType_Affine ?
+      reinterpret_cast<mindspore::schema::AffineT *>(value) : nullptr;
+  }
+  const mindspore::schema::AffineT *AsAffine() const {
+    return type == PrimitiveType_Affine ?
+      reinterpret_cast<const mindspore::schema::AffineT *>(value) : nullptr;
+  }
+  mindspore::schema::AllGatherT *AsAllGather() {
+    return type == PrimitiveType_AllGather ?
+      reinterpret_cast<mindspore::schema::AllGatherT *>(value) : nullptr;
+  }
+  const mindspore::schema::AllGatherT *AsAllGather() const {
+    return type == PrimitiveType_AllGather ?
+      reinterpret_cast<const mindspore::schema::AllGatherT *>(value) : nullptr;
+  }
+  mindspore::schema::ReduceScatterT *AsReduceScatter() {
+    return type == PrimitiveType_ReduceScatter ?
+      reinterpret_cast<mindspore::schema::ReduceScatterT *>(value) : nullptr;
+  }
+  const mindspore::schema::ReduceScatterT *AsReduceScatter() const {
+    return type == PrimitiveType_ReduceScatter ?
+      reinterpret_cast<const mindspore::schema::ReduceScatterT *>(value) : nullptr;
+  }
+  mindspore::schema::DynamicQuantT *AsDynamicQuant() {
+    return type == PrimitiveType_DynamicQuant ?
+      reinterpret_cast<mindspore::schema::DynamicQuantT *>(value) : nullptr;
+  }
+  const mindspore::schema::DynamicQuantT *AsDynamicQuant() const {
+    return type == PrimitiveType_DynamicQuant ?
+      reinterpret_cast<const mindspore::schema::DynamicQuantT *>(value) : nullptr;
+  }
+  mindspore::schema::LSTMGradDataT *AsLSTMGradData() {
+    return type == PrimitiveType_LSTMGradData ?
+      reinterpret_cast<mindspore::schema::LSTMGradDataT *>(value) : nullptr;
+  }
+  const mindspore::schema::LSTMGradDataT *AsLSTMGradData() const {
+    return type == PrimitiveType_LSTMGradData ?
+      reinterpret_cast<const mindspore::schema::LSTMGradDataT *>(value) : nullptr;
+  }
+  mindspore::schema::LSTMGradWeightT *AsLSTMGradWeight() {
+    return type == PrimitiveType_LSTMGradWeight ?
+      reinterpret_cast<mindspore::schema::LSTMGradWeightT *>(value) : nullptr;
+  }
+  const mindspore::schema::LSTMGradWeightT *AsLSTMGradWeight() const {
+    return type == PrimitiveType_LSTMGradWeight ?
+      reinterpret_cast<const mindspore::schema::LSTMGradWeightT *>(value) : nullptr;
+  }
+  mindspore::schema::RandomNormalT *AsRandomNormal() {
+    return type == PrimitiveType_RandomNormal ?
+      reinterpret_cast<mindspore::schema::RandomNormalT *>(value) : nullptr;
+  }
+  const mindspore::schema::RandomNormalT *AsRandomNormal() const {
+    return type == PrimitiveType_RandomNormal ?
+      reinterpret_cast<const mindspore::schema::RandomNormalT *>(value) : nullptr;
+  }
+  mindspore::schema::NLLLossT *AsNLLLoss() {
+    return type == PrimitiveType_NLLLoss ?
+      reinterpret_cast<mindspore::schema::NLLLossT *>(value) : nullptr;
+  }
+  const mindspore::schema::NLLLossT *AsNLLLoss() const {
+    return type == PrimitiveType_NLLLoss ?
+      reinterpret_cast<const mindspore::schema::NLLLossT *>(value) : nullptr;
+  }
+  mindspore::schema::NLLLossGradT *AsNLLLossGrad() {
+    return type == PrimitiveType_NLLLossGrad ?
+      reinterpret_cast<mindspore::schema::NLLLossGradT *>(value) : nullptr;
+  }
+  const mindspore::schema::NLLLossGradT *AsNLLLossGrad() const {
+    return type == PrimitiveType_NLLLossGrad ?
+      reinterpret_cast<const mindspore::schema::NLLLossGradT *>(value) : nullptr;
+  }
+  mindspore::schema::FormatTransposeT *AsFormatTranspose() {
+    return type == PrimitiveType_FormatTranspose ?
+      reinterpret_cast<mindspore::schema::FormatTransposeT *>(value) : nullptr;
+  }
+  const mindspore::schema::FormatTransposeT *AsFormatTranspose() const {
+    return type == PrimitiveType_FormatTranspose ?
+      reinterpret_cast<const mindspore::schema::FormatTransposeT *>(value) : nullptr;
+  }
+  mindspore::schema::GatherDT *AsGatherD() {
+    return type == PrimitiveType_GatherD ?
+      reinterpret_cast<mindspore::schema::GatherDT *>(value) : nullptr;
+  }
+  const mindspore::schema::GatherDT *AsGatherD() const {
+    return type == PrimitiveType_GatherD ?
+      reinterpret_cast<const mindspore::schema::GatherDT *>(value) : nullptr;
+  }
+  mindspore::schema::GroupNormFusionT *AsGroupNormFusion() {
+    return type == PrimitiveType_GroupNormFusion ?
+      reinterpret_cast<mindspore::schema::GroupNormFusionT *>(value) : nullptr;
+  }
+  const mindspore::schema::GroupNormFusionT *AsGroupNormFusion() const {
+    return type == PrimitiveType_GroupNormFusion ?
+      reinterpret_cast<const mindspore::schema::GroupNormFusionT *>(value) : nullptr;
+  }
+};
+
+bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type);
+bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);
+
+struct AbsT : public flatbuffers::NativeTable {
+  typedef Abs TableType;
+};
+
+struct Abs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AbsT NativeTableType;
+  typedef AbsBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AbsTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  AbsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AbsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Abs> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AbsBuilder {
+  typedef Abs Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Abs> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Abs>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Abs> CreateAbs(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AbsBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Abs> CreateAbs(flatbuffers::FlatBufferBuilder &_fbb, const AbsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ActivationT : public flatbuffers::NativeTable {
+  typedef Activation TableType;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+  float alpha = 0.0f;
+  float min_val = 0.0f;
+  float max_val = 0.0f;
+  bool approximate = false;
+};
+
+struct Activation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ActivationT NativeTableType;
+  typedef ActivationBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ActivationTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4,
+    VT_ALPHA = 6,
+    VT_MIN_VAL = 8,
+    VT_MAX_VAL = 10,
+    VT_APPROXIMATE = 12
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  float alpha() const {
+    return GetField<float>(VT_ALPHA, 0.0f);
+  }
+  bool mutate_alpha(float _alpha) {
+    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
+  }
+  float min_val() const {
+    return GetField<float>(VT_MIN_VAL, 0.0f);
+  }
+  bool mutate_min_val(float _min_val) {
+    return SetField<float>(VT_MIN_VAL, _min_val, 0.0f);
+  }
+  float max_val() const {
+    return GetField<float>(VT_MAX_VAL, 0.0f);
+  }
+  bool mutate_max_val(float _max_val) {
+    return SetField<float>(VT_MAX_VAL, _max_val, 0.0f);
+  }
+  bool approximate() const {
+    return GetField<uint8_t>(VT_APPROXIMATE, 0) != 0;
+  }
+  bool mutate_approximate(bool _approximate) {
+    return SetField<uint8_t>(VT_APPROXIMATE, static_cast<uint8_t>(_approximate), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           VerifyField<float>(verifier, VT_ALPHA) &&
+           VerifyField<float>(verifier, VT_MIN_VAL) &&
+           VerifyField<float>(verifier, VT_MAX_VAL) &&
+           VerifyField<uint8_t>(verifier, VT_APPROXIMATE) &&
+           verifier.EndTable();
+  }
+  ActivationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ActivationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Activation> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActivationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ActivationBuilder {
+  typedef Activation Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(Activation::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  void add_alpha(float alpha) {
+    fbb_.AddElement<float>(Activation::VT_ALPHA, alpha, 0.0f);
+  }
+  void add_min_val(float min_val) {
+    fbb_.AddElement<float>(Activation::VT_MIN_VAL, min_val, 0.0f);
+  }
+  void add_max_val(float max_val) {
+    fbb_.AddElement<float>(Activation::VT_MAX_VAL, max_val, 0.0f);
+  }
+  void add_approximate(bool approximate) {
+    fbb_.AddElement<uint8_t>(Activation::VT_APPROXIMATE, static_cast<uint8_t>(approximate), 0);
+  }
+  explicit ActivationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Activation> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Activation>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Activation> CreateActivation(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    float alpha = 0.0f,
+    float min_val = 0.0f,
+    float max_val = 0.0f,
+    bool approximate = false) {
+  ActivationBuilder builder_(_fbb);
+  builder_.add_max_val(max_val);
+  builder_.add_min_val(min_val);
+  builder_.add_alpha(alpha);
+  builder_.add_approximate(approximate);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Activation> CreateActivation(flatbuffers::FlatBufferBuilder &_fbb, const ActivationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ActivationGradT : public flatbuffers::NativeTable {
+  typedef ActivationGrad TableType;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+  float alpha = 0.0f;
+};
+
+struct ActivationGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ActivationGradT NativeTableType;
+  typedef ActivationGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ActivationGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4,
+    VT_ALPHA = 6
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  float alpha() const {
+    return GetField<float>(VT_ALPHA, 0.0f);
+  }
+  bool mutate_alpha(float _alpha) {
+    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           VerifyField<float>(verifier, VT_ALPHA) &&
+           verifier.EndTable();
+  }
+  ActivationGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ActivationGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ActivationGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActivationGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ActivationGradBuilder {
+  typedef ActivationGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(ActivationGrad::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  void add_alpha(float alpha) {
+    fbb_.AddElement<float>(ActivationGrad::VT_ALPHA, alpha, 0.0f);
+  }
+  explicit ActivationGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ActivationGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ActivationGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ActivationGrad> CreateActivationGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    float alpha = 0.0f) {
+  ActivationGradBuilder builder_(_fbb);
+  builder_.add_alpha(alpha);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ActivationGrad> CreateActivationGrad(flatbuffers::FlatBufferBuilder &_fbb, const ActivationGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AdamT : public flatbuffers::NativeTable {
+  typedef Adam TableType;
+  bool use_locking = false;
+  bool use_nesterov = false;
+};
+
+struct Adam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AdamT NativeTableType;
+  typedef AdamBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AdamTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_USE_LOCKING = 4,
+    VT_USE_NESTEROV = 6
+  };
+  bool use_locking() const {
+    return GetField<uint8_t>(VT_USE_LOCKING, 0) != 0;
+  }
+  bool mutate_use_locking(bool _use_locking) {
+    return SetField<uint8_t>(VT_USE_LOCKING, static_cast<uint8_t>(_use_locking), 0);
+  }
+  bool use_nesterov() const {
+    return GetField<uint8_t>(VT_USE_NESTEROV, 0) != 0;
+  }
+  bool mutate_use_nesterov(bool _use_nesterov) {
+    return SetField<uint8_t>(VT_USE_NESTEROV, static_cast<uint8_t>(_use_nesterov), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_USE_LOCKING) &&
+           VerifyField<uint8_t>(verifier, VT_USE_NESTEROV) &&
+           verifier.EndTable();
+  }
+  AdamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AdamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Adam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AdamBuilder {
+  typedef Adam Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_use_locking(bool use_locking) {
+    fbb_.AddElement<uint8_t>(Adam::VT_USE_LOCKING, static_cast<uint8_t>(use_locking), 0);
+  }
+  void add_use_nesterov(bool use_nesterov) {
+    fbb_.AddElement<uint8_t>(Adam::VT_USE_NESTEROV, static_cast<uint8_t>(use_nesterov), 0);
+  }
+  explicit AdamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Adam> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Adam>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Adam> CreateAdam(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool use_locking = false,
+    bool use_nesterov = false) {
+  AdamBuilder builder_(_fbb);
+  builder_.add_use_nesterov(use_nesterov);
+  builder_.add_use_locking(use_locking);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Adam> CreateAdam(flatbuffers::FlatBufferBuilder &_fbb, const AdamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AddFusionT : public flatbuffers::NativeTable {
+  typedef AddFusion TableType;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct AddFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AddFusionT NativeTableType;
+  typedef AddFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AddFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  AddFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AddFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<AddFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AddFusionBuilder {
+  typedef AddFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(AddFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit AddFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AddFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AddFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AddFusion> CreateAddFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  AddFusionBuilder builder_(_fbb);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<AddFusion> CreateAddFusion(flatbuffers::FlatBufferBuilder &_fbb, const AddFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AdderFusionT : public flatbuffers::NativeTable {
+  typedef AdderFusion TableType;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  std::vector<int64_t> kernel_size{};
+  std::vector<int64_t> stride{};
+  std::vector<int64_t> dilation{};
+  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
+  std::vector<int64_t> pad_list{};
+  int64_t group = 0;
+  int64_t in_channel = 0;
+  int64_t out_channel = 0;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct AdderFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AdderFusionT NativeTableType;
+  typedef AdderFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AdderFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_KERNEL_SIZE = 6,
+    VT_STRIDE = 8,
+    VT_DILATION = 10,
+    VT_PAD_MODE = 12,
+    VT_PAD_LIST = 14,
+    VT_GROUP = 16,
+    VT_IN_CHANNEL = 18,
+    VT_OUT_CHANNEL = 20,
+    VT_ACTIVATION_TYPE = 22
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_stride() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  flatbuffers::Vector<int64_t> *mutable_dilation() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
+    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  flatbuffers::Vector<int64_t> *mutable_pad_list() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  bool mutate_group(int64_t _group) {
+    return SetField<int64_t>(VT_GROUP, _group, 0);
+  }
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  bool mutate_in_channel(int64_t _in_channel) {
+    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  bool mutate_out_channel(int64_t _out_channel) {
+    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  AdderFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AdderFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<AdderFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdderFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AdderFusionBuilder {
+  typedef AdderFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(AdderFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(AdderFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(AdderFusion::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(AdderFusion::VT_DILATION, dilation);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(AdderFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(AdderFusion::VT_PAD_LIST, pad_list);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(AdderFusion::VT_GROUP, group, 0);
+  }
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(AdderFusion::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(AdderFusion::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(AdderFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit AdderFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AdderFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AdderFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AdderFusion> CreateAdderFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  AdderFusionBuilder builder_(_fbb);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_group(group);
+  builder_.add_pad_list(pad_list);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_format(format);
+  builder_.add_activation_type(activation_type);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<AdderFusion> CreateAdderFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad_list = nullptr,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  return mindspore::schema::CreateAdderFusion(
+      _fbb,
+      format,
+      kernel_size__,
+      stride__,
+      dilation__,
+      pad_mode,
+      pad_list__,
+      group,
+      in_channel,
+      out_channel,
+      activation_type);
+}
+
+flatbuffers::Offset<AdderFusion> CreateAdderFusion(flatbuffers::FlatBufferBuilder &_fbb, const AdderFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AddGradT : public flatbuffers::NativeTable {
+  typedef AddGrad TableType;
+};
+
+struct AddGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AddGradT NativeTableType;
+  typedef AddGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AddGradTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  AddGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AddGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<AddGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AddGradBuilder {
+  typedef AddGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AddGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AddGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AddGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AddGrad> CreateAddGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AddGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<AddGrad> CreateAddGrad(flatbuffers::FlatBufferBuilder &_fbb, const AddGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AddNT : public flatbuffers::NativeTable {
+  typedef AddN TableType;
+};
+
+struct AddN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AddNT NativeTableType;
+  typedef AddNBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AddNTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  AddNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AddNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<AddN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AddNBuilder {
+  typedef AddN Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AddNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AddN> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AddN>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AddN> CreateAddN(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AddNBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<AddN> CreateAddN(flatbuffers::FlatBufferBuilder &_fbb, const AddNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AllT : public flatbuffers::NativeTable {
+  typedef All TableType;
+  int64_t keep_dims = 0;
+};
+
+struct All FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AllT NativeTableType;
+  typedef AllBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AllTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KEEP_DIMS = 4
+  };
+  int64_t keep_dims() const {
+    return GetField<int64_t>(VT_KEEP_DIMS, 0);
+  }
+  bool mutate_keep_dims(int64_t _keep_dims) {
+    return SetField<int64_t>(VT_KEEP_DIMS, _keep_dims, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_KEEP_DIMS) &&
+           verifier.EndTable();
+  }
+  AllT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AllT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<All> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AllT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AllBuilder {
+  typedef All Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_keep_dims(int64_t keep_dims) {
+    fbb_.AddElement<int64_t>(All::VT_KEEP_DIMS, keep_dims, 0);
+  }
+  explicit AllBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<All> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<All>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<All> CreateAll(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t keep_dims = 0) {
+  AllBuilder builder_(_fbb);
+  builder_.add_keep_dims(keep_dims);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<All> CreateAll(flatbuffers::FlatBufferBuilder &_fbb, const AllT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ApplyMomentumT : public flatbuffers::NativeTable {
+  typedef ApplyMomentum TableType;
+  bool use_nesterov = false;
+  bool use_locking = false;
+  float gradient_scale = 0.0f;
+};
+
+struct ApplyMomentum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ApplyMomentumT NativeTableType;
+  typedef ApplyMomentumBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ApplyMomentumTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_USE_NESTEROV = 4,
+    VT_USE_LOCKING = 6,
+    VT_GRADIENT_SCALE = 8
+  };
+  bool use_nesterov() const {
+    return GetField<uint8_t>(VT_USE_NESTEROV, 0) != 0;
+  }
+  bool mutate_use_nesterov(bool _use_nesterov) {
+    return SetField<uint8_t>(VT_USE_NESTEROV, static_cast<uint8_t>(_use_nesterov), 0);
+  }
+  bool use_locking() const {
+    return GetField<uint8_t>(VT_USE_LOCKING, 0) != 0;
+  }
+  bool mutate_use_locking(bool _use_locking) {
+    return SetField<uint8_t>(VT_USE_LOCKING, static_cast<uint8_t>(_use_locking), 0);
+  }
+  float gradient_scale() const {
+    return GetField<float>(VT_GRADIENT_SCALE, 0.0f);
+  }
+  bool mutate_gradient_scale(float _gradient_scale) {
+    return SetField<float>(VT_GRADIENT_SCALE, _gradient_scale, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_USE_NESTEROV) &&
+           VerifyField<uint8_t>(verifier, VT_USE_LOCKING) &&
+           VerifyField<float>(verifier, VT_GRADIENT_SCALE) &&
+           verifier.EndTable();
+  }
+  ApplyMomentumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ApplyMomentumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ApplyMomentum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ApplyMomentumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ApplyMomentumBuilder {
+  typedef ApplyMomentum Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_use_nesterov(bool use_nesterov) {
+    fbb_.AddElement<uint8_t>(ApplyMomentum::VT_USE_NESTEROV, static_cast<uint8_t>(use_nesterov), 0);
+  }
+  void add_use_locking(bool use_locking) {
+    fbb_.AddElement<uint8_t>(ApplyMomentum::VT_USE_LOCKING, static_cast<uint8_t>(use_locking), 0);
+  }
+  void add_gradient_scale(float gradient_scale) {
+    fbb_.AddElement<float>(ApplyMomentum::VT_GRADIENT_SCALE, gradient_scale, 0.0f);
+  }
+  explicit ApplyMomentumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ApplyMomentum> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ApplyMomentum>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ApplyMomentum> CreateApplyMomentum(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool use_nesterov = false,
+    bool use_locking = false,
+    float gradient_scale = 0.0f) {
+  ApplyMomentumBuilder builder_(_fbb);
+  builder_.add_gradient_scale(gradient_scale);
+  builder_.add_use_locking(use_locking);
+  builder_.add_use_nesterov(use_nesterov);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ApplyMomentum> CreateApplyMomentum(flatbuffers::FlatBufferBuilder &_fbb, const ApplyMomentumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ArgMaxFusionT : public flatbuffers::NativeTable {
+  typedef ArgMaxFusion TableType;
+  int64_t axis = 0;
+  int64_t top_k = 1LL;
+  bool keep_dims = false;
+  bool out_max_value = false;
+};
+
+struct ArgMaxFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ArgMaxFusionT NativeTableType;
+  typedef ArgMaxFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ArgMaxFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4,
+    VT_TOP_K = 6,
+    VT_KEEP_DIMS = 8,
+    VT_OUT_MAX_VALUE = 10
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  int64_t top_k() const {
+    return GetField<int64_t>(VT_TOP_K, 1LL);
+  }
+  bool mutate_top_k(int64_t _top_k) {
+    return SetField<int64_t>(VT_TOP_K, _top_k, 1LL);
+  }
+  bool keep_dims() const {
+    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
+  }
+  bool mutate_keep_dims(bool _keep_dims) {
+    return SetField<uint8_t>(VT_KEEP_DIMS, static_cast<uint8_t>(_keep_dims), 0);
+  }
+  bool out_max_value() const {
+    return GetField<uint8_t>(VT_OUT_MAX_VALUE, 0) != 0;
+  }
+  bool mutate_out_max_value(bool _out_max_value) {
+    return SetField<uint8_t>(VT_OUT_MAX_VALUE, static_cast<uint8_t>(_out_max_value), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_TOP_K) &&
+           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
+           VerifyField<uint8_t>(verifier, VT_OUT_MAX_VALUE) &&
+           verifier.EndTable();
+  }
+  ArgMaxFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ArgMaxFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ArgMaxFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ArgMaxFusionBuilder {
+  typedef ArgMaxFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(ArgMaxFusion::VT_AXIS, axis, 0);
+  }
+  void add_top_k(int64_t top_k) {
+    fbb_.AddElement<int64_t>(ArgMaxFusion::VT_TOP_K, top_k, 1LL);
+  }
+  void add_keep_dims(bool keep_dims) {
+    fbb_.AddElement<uint8_t>(ArgMaxFusion::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
+  }
+  void add_out_max_value(bool out_max_value) {
+    fbb_.AddElement<uint8_t>(ArgMaxFusion::VT_OUT_MAX_VALUE, static_cast<uint8_t>(out_max_value), 0);
+  }
+  explicit ArgMaxFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ArgMaxFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ArgMaxFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ArgMaxFusion> CreateArgMaxFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0,
+    int64_t top_k = 1LL,
+    bool keep_dims = false,
+    bool out_max_value = false) {
+  ArgMaxFusionBuilder builder_(_fbb);
+  builder_.add_top_k(top_k);
+  builder_.add_axis(axis);
+  builder_.add_out_max_value(out_max_value);
+  builder_.add_keep_dims(keep_dims);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ArgMaxFusion> CreateArgMaxFusion(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ArgMinFusionT : public flatbuffers::NativeTable {
+  typedef ArgMinFusion TableType;
+  int64_t axis = 0;
+  int64_t top_k = 0;
+  bool keep_dims = false;
+  bool out_max_value = false;
+};
+
+struct ArgMinFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ArgMinFusionT NativeTableType;
+  typedef ArgMinFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ArgMinFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4,
+    VT_TOP_K = 6,
+    VT_KEEP_DIMS = 8,
+    VT_OUT_MAX_VALUE = 10
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  int64_t top_k() const {
+    return GetField<int64_t>(VT_TOP_K, 0);
+  }
+  bool mutate_top_k(int64_t _top_k) {
+    return SetField<int64_t>(VT_TOP_K, _top_k, 0);
+  }
+  bool keep_dims() const {
+    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
+  }
+  bool mutate_keep_dims(bool _keep_dims) {
+    return SetField<uint8_t>(VT_KEEP_DIMS, static_cast<uint8_t>(_keep_dims), 0);
+  }
+  bool out_max_value() const {
+    return GetField<uint8_t>(VT_OUT_MAX_VALUE, 0) != 0;
+  }
+  bool mutate_out_max_value(bool _out_max_value) {
+    return SetField<uint8_t>(VT_OUT_MAX_VALUE, static_cast<uint8_t>(_out_max_value), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_TOP_K) &&
+           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
+           VerifyField<uint8_t>(verifier, VT_OUT_MAX_VALUE) &&
+           verifier.EndTable();
+  }
+  ArgMinFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ArgMinFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ArgMinFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ArgMinFusionBuilder {
+  typedef ArgMinFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(ArgMinFusion::VT_AXIS, axis, 0);
+  }
+  void add_top_k(int64_t top_k) {
+    fbb_.AddElement<int64_t>(ArgMinFusion::VT_TOP_K, top_k, 0);
+  }
+  void add_keep_dims(bool keep_dims) {
+    fbb_.AddElement<uint8_t>(ArgMinFusion::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
+  }
+  void add_out_max_value(bool out_max_value) {
+    fbb_.AddElement<uint8_t>(ArgMinFusion::VT_OUT_MAX_VALUE, static_cast<uint8_t>(out_max_value), 0);
+  }
+  explicit ArgMinFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ArgMinFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ArgMinFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ArgMinFusion> CreateArgMinFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0,
+    int64_t top_k = 0,
+    bool keep_dims = false,
+    bool out_max_value = false) {
+  ArgMinFusionBuilder builder_(_fbb);
+  builder_.add_top_k(top_k);
+  builder_.add_axis(axis);
+  builder_.add_out_max_value(out_max_value);
+  builder_.add_keep_dims(keep_dims);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ArgMinFusion> CreateArgMinFusion(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AssertT : public flatbuffers::NativeTable {
+  typedef Assert TableType;
+  int64_t summarize = 0;
+};
+
+struct Assert FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AssertT NativeTableType;
+  typedef AssertBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AssertTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SUMMARIZE = 4
+  };
+  int64_t summarize() const {
+    return GetField<int64_t>(VT_SUMMARIZE, 0);
+  }
+  bool mutate_summarize(int64_t _summarize) {
+    return SetField<int64_t>(VT_SUMMARIZE, _summarize, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SUMMARIZE) &&
+           verifier.EndTable();
+  }
+  AssertT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AssertT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Assert> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssertT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AssertBuilder {
+  typedef Assert Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_summarize(int64_t summarize) {
+    fbb_.AddElement<int64_t>(Assert::VT_SUMMARIZE, summarize, 0);
+  }
+  explicit AssertBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Assert> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Assert>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Assert> CreateAssert(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t summarize = 0) {
+  AssertBuilder builder_(_fbb);
+  builder_.add_summarize(summarize);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Assert> CreateAssert(flatbuffers::FlatBufferBuilder &_fbb, const AssertT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AssignT : public flatbuffers::NativeTable {
+  typedef Assign TableType;
+};
+
+struct Assign FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AssignT NativeTableType;
+  typedef AssignBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AssignTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  AssignT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AssignT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Assign> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AssignBuilder {
+  typedef Assign Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AssignBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Assign> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Assign>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Assign> CreateAssign(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AssignBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Assign> CreateAssign(flatbuffers::FlatBufferBuilder &_fbb, const AssignT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AssignAddT : public flatbuffers::NativeTable {
+  typedef AssignAdd TableType;
+};
+
+struct AssignAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AssignAddT NativeTableType;
+  typedef AssignAddBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AssignAddTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  AssignAddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AssignAddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<AssignAdd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignAddT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AssignAddBuilder {
+  typedef AssignAdd Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AssignAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AssignAdd> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AssignAdd>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AssignAdd> CreateAssignAdd(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AssignAddBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<AssignAdd> CreateAssignAdd(flatbuffers::FlatBufferBuilder &_fbb, const AssignAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AudioSpectrogramT : public flatbuffers::NativeTable {
+  typedef AudioSpectrogram TableType;
+  int64_t window_size = 0;
+  int64_t stride = 0;
+  bool mag_square = false;
+};
+
+struct AudioSpectrogram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AudioSpectrogramT NativeTableType;
+  typedef AudioSpectrogramBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AudioSpectrogramTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_WINDOW_SIZE = 4,
+    VT_STRIDE = 6,
+    VT_MAG_SQUARE = 8
+  };
+  int64_t window_size() const {
+    return GetField<int64_t>(VT_WINDOW_SIZE, 0);
+  }
+  bool mutate_window_size(int64_t _window_size) {
+    return SetField<int64_t>(VT_WINDOW_SIZE, _window_size, 0);
+  }
+  int64_t stride() const {
+    return GetField<int64_t>(VT_STRIDE, 0);
+  }
+  bool mutate_stride(int64_t _stride) {
+    return SetField<int64_t>(VT_STRIDE, _stride, 0);
+  }
+  bool mag_square() const {
+    return GetField<uint8_t>(VT_MAG_SQUARE, 0) != 0;
+  }
+  bool mutate_mag_square(bool _mag_square) {
+    return SetField<uint8_t>(VT_MAG_SQUARE, static_cast<uint8_t>(_mag_square), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_WINDOW_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_STRIDE) &&
+           VerifyField<uint8_t>(verifier, VT_MAG_SQUARE) &&
+           verifier.EndTable();
+  }
+  AudioSpectrogramT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AudioSpectrogramT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<AudioSpectrogram> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioSpectrogramT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AudioSpectrogramBuilder {
+  typedef AudioSpectrogram Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_window_size(int64_t window_size) {
+    fbb_.AddElement<int64_t>(AudioSpectrogram::VT_WINDOW_SIZE, window_size, 0);
+  }
+  void add_stride(int64_t stride) {
+    fbb_.AddElement<int64_t>(AudioSpectrogram::VT_STRIDE, stride, 0);
+  }
+  void add_mag_square(bool mag_square) {
+    fbb_.AddElement<uint8_t>(AudioSpectrogram::VT_MAG_SQUARE, static_cast<uint8_t>(mag_square), 0);
+  }
+  explicit AudioSpectrogramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AudioSpectrogram> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AudioSpectrogram>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AudioSpectrogram> CreateAudioSpectrogram(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t window_size = 0,
+    int64_t stride = 0,
+    bool mag_square = false) {
+  AudioSpectrogramBuilder builder_(_fbb);
+  builder_.add_stride(stride);
+  builder_.add_window_size(window_size);
+  builder_.add_mag_square(mag_square);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<AudioSpectrogram> CreateAudioSpectrogram(flatbuffers::FlatBufferBuilder &_fbb, const AudioSpectrogramT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AvgPoolFusionT : public flatbuffers::NativeTable {
+  typedef AvgPoolFusion TableType;
+  std::vector<int64_t> kernel_size{};
+  std::vector<int64_t> strides{};
+  std::vector<int64_t> pad{};
+  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
+  mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  bool global = false;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct AvgPoolFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AvgPoolFusionT NativeTableType;
+  typedef AvgPoolFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AvgPoolFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KERNEL_SIZE = 4,
+    VT_STRIDES = 6,
+    VT_PAD = 8,
+    VT_PAD_MODE = 10,
+    VT_ROUND_MODE = 12,
+    VT_FORMAT = 14,
+    VT_GLOBAL = 16,
+    VT_ACTIVATION_TYPE = 18
+  };
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *strides() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
+  }
+  flatbuffers::Vector<int64_t> *mutable_strides() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDES);
+  }
+  const flatbuffers::Vector<int64_t> *pad() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  flatbuffers::Vector<int64_t> *mutable_pad() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
+    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
+  }
+  mindspore::schema::RoundMode round_mode() const {
+    return static_cast<mindspore::schema::RoundMode>(GetField<int8_t>(VT_ROUND_MODE, 0));
+  }
+  bool mutate_round_mode(mindspore::schema::RoundMode _round_mode) {
+    return SetField<int8_t>(VT_ROUND_MODE, static_cast<int8_t>(_round_mode), 0);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  bool global() const {
+    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
+  }
+  bool mutate_global(bool _global) {
+    return SetField<uint8_t>(VT_GLOBAL, static_cast<uint8_t>(_global), 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDES) &&
+           verifier.VerifyVector(strides()) &&
+           VerifyOffset(verifier, VT_PAD) &&
+           verifier.VerifyVector(pad()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyField<int8_t>(verifier, VT_ROUND_MODE) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  AvgPoolFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AvgPoolFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<AvgPoolFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AvgPoolFusionBuilder {
+  typedef AvgPoolFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(AvgPoolFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
+    fbb_.AddOffset(AvgPoolFusion::VT_STRIDES, strides);
+  }
+  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
+    fbb_.AddOffset(AvgPoolFusion::VT_PAD, pad);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(AvgPoolFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_round_mode(mindspore::schema::RoundMode round_mode) {
+    fbb_.AddElement<int8_t>(AvgPoolFusion::VT_ROUND_MODE, static_cast<int8_t>(round_mode), 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(AvgPoolFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_global(bool global) {
+    fbb_.AddElement<uint8_t>(AvgPoolFusion::VT_GLOBAL, static_cast<uint8_t>(global), 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(AvgPoolFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit AvgPoolFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AvgPoolFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AvgPoolFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AvgPoolFusion> CreateAvgPoolFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    bool global = false,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  AvgPoolFusionBuilder builder_(_fbb);
+  builder_.add_format(format);
+  builder_.add_pad(pad);
+  builder_.add_strides(strides);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_activation_type(activation_type);
+  builder_.add_global(global);
+  builder_.add_round_mode(round_mode);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<AvgPoolFusion> CreateAvgPoolFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *strides = nullptr,
+    const std::vector<int64_t> *pad = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    bool global = false,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
+  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
+  return mindspore::schema::CreateAvgPoolFusion(
+      _fbb,
+      kernel_size__,
+      strides__,
+      pad__,
+      pad_mode,
+      round_mode,
+      format,
+      global,
+      activation_type);
+}
+
+flatbuffers::Offset<AvgPoolFusion> CreateAvgPoolFusion(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AvgPoolGradT : public flatbuffers::NativeTable {
+  typedef AvgPoolGrad TableType;
+  std::vector<int64_t> kernel_size{};
+  std::vector<int64_t> strides{};
+  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+};
+
+struct AvgPoolGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AvgPoolGradT NativeTableType;
+  typedef AvgPoolGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AvgPoolGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KERNEL_SIZE = 4,
+    VT_STRIDES = 6,
+    VT_PAD_MODE = 8,
+    VT_FORMAT = 10
+  };
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *strides() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
+  }
+  flatbuffers::Vector<int64_t> *mutable_strides() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDES);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
+    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDES) &&
+           verifier.VerifyVector(strides()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           verifier.EndTable();
+  }
+  AvgPoolGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AvgPoolGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<AvgPoolGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AvgPoolGradBuilder {
+  typedef AvgPoolGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(AvgPoolGrad::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
+    fbb_.AddOffset(AvgPoolGrad::VT_STRIDES, strides);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(AvgPoolGrad::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(AvgPoolGrad::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  explicit AvgPoolGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AvgPoolGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AvgPoolGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AvgPoolGrad> CreateAvgPoolGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  AvgPoolGradBuilder builder_(_fbb);
+  builder_.add_format(format);
+  builder_.add_strides(strides);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<AvgPoolGrad> CreateAvgPoolGradDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *strides = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
+  return mindspore::schema::CreateAvgPoolGrad(
+      _fbb,
+      kernel_size__,
+      strides__,
+      pad_mode,
+      format);
+}
+
+flatbuffers::Offset<AvgPoolGrad> CreateAvgPoolGrad(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct BatchNormT : public flatbuffers::NativeTable {
+  typedef BatchNorm TableType;
+  float epsilon = 0.0f;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  bool is_training = false;
+};
+
+struct BatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BatchNormT NativeTableType;
+  typedef BatchNormBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return BatchNormTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_EPSILON = 4,
+    VT_FORMAT = 6,
+    VT_IS_TRAINING = 8
+  };
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.0f);
+  }
+  bool mutate_epsilon(float _epsilon) {
+    return SetField<float>(VT_EPSILON, _epsilon, 0.0f);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  bool is_training() const {
+    return GetField<uint8_t>(VT_IS_TRAINING, 0) != 0;
+  }
+  bool mutate_is_training(bool _is_training) {
+    return SetField<uint8_t>(VT_IS_TRAINING, static_cast<uint8_t>(_is_training), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<uint8_t>(verifier, VT_IS_TRAINING) &&
+           verifier.EndTable();
+  }
+  BatchNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BatchNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BatchNormBuilder {
+  typedef BatchNorm Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(BatchNorm::VT_EPSILON, epsilon, 0.0f);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(BatchNorm::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_is_training(bool is_training) {
+    fbb_.AddElement<uint8_t>(BatchNorm::VT_IS_TRAINING, static_cast<uint8_t>(is_training), 0);
+  }
+  explicit BatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BatchNorm> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BatchNorm>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float epsilon = 0.0f,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    bool is_training = false) {
+  BatchNormBuilder builder_(_fbb);
+  builder_.add_format(format);
+  builder_.add_epsilon(epsilon);
+  builder_.add_is_training(is_training);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct BatchNormGradT : public flatbuffers::NativeTable {
+  typedef BatchNormGrad TableType;
+  float epsilon = 0.0f;
+  bool is_training = false;
+};
+
+struct BatchNormGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BatchNormGradT NativeTableType;
+  typedef BatchNormGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return BatchNormGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_EPSILON = 4,
+    VT_IS_TRAINING = 6
+  };
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.0f);
+  }
+  bool mutate_epsilon(float _epsilon) {
+    return SetField<float>(VT_EPSILON, _epsilon, 0.0f);
+  }
+  bool is_training() const {
+    return GetField<uint8_t>(VT_IS_TRAINING, 0) != 0;
+  }
+  bool mutate_is_training(bool _is_training) {
+    return SetField<uint8_t>(VT_IS_TRAINING, static_cast<uint8_t>(_is_training), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<uint8_t>(verifier, VT_IS_TRAINING) &&
+           verifier.EndTable();
+  }
+  BatchNormGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BatchNormGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BatchNormGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BatchNormGradBuilder {
+  typedef BatchNormGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(BatchNormGrad::VT_EPSILON, epsilon, 0.0f);
+  }
+  void add_is_training(bool is_training) {
+    fbb_.AddElement<uint8_t>(BatchNormGrad::VT_IS_TRAINING, static_cast<uint8_t>(is_training), 0);
+  }
+  explicit BatchNormGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BatchNormGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BatchNormGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BatchNormGrad> CreateBatchNormGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float epsilon = 0.0f,
+    bool is_training = false) {
+  BatchNormGradBuilder builder_(_fbb);
+  builder_.add_epsilon(epsilon);
+  builder_.add_is_training(is_training);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<BatchNormGrad> CreateBatchNormGrad(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct BatchToSpaceT : public flatbuffers::NativeTable {
+  typedef BatchToSpace TableType;
+  std::vector<int64_t> block_size{};
+  std::unique_ptr<mindspore::schema::Vec2DT> crops{};
+};
+
+struct BatchToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BatchToSpaceT NativeTableType;
+  typedef BatchToSpaceBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return BatchToSpaceTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BLOCK_SIZE = 4,
+    VT_CROPS = 6
+  };
+  const flatbuffers::Vector<int64_t> *block_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_block_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_BLOCK_SIZE);
+  }
+  const mindspore::schema::Vec2D *crops() const {
+    return GetPointer<const mindspore::schema::Vec2D *>(VT_CROPS);
+  }
+  mindspore::schema::Vec2D *mutable_crops() {
+    return GetPointer<mindspore::schema::Vec2D *>(VT_CROPS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_BLOCK_SIZE) &&
+           verifier.VerifyVector(block_size()) &&
+           VerifyOffset(verifier, VT_CROPS) &&
+           verifier.VerifyTable(crops()) &&
+           verifier.EndTable();
+  }
+  BatchToSpaceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BatchToSpaceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BatchToSpace> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BatchToSpaceBuilder {
+  typedef BatchToSpace Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_block_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size) {
+    fbb_.AddOffset(BatchToSpace::VT_BLOCK_SIZE, block_size);
+  }
+  void add_crops(flatbuffers::Offset<mindspore::schema::Vec2D> crops) {
+    fbb_.AddOffset(BatchToSpace::VT_CROPS, crops);
+  }
+  explicit BatchToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BatchToSpace> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BatchToSpace>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size = 0,
+    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
+  BatchToSpaceBuilder builder_(_fbb);
+  builder_.add_crops(crops);
+  builder_.add_block_size(block_size);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpaceDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *block_size = nullptr,
+    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
+  auto block_size__ = block_size ? _fbb.CreateVector<int64_t>(*block_size) : 0;
+  return mindspore::schema::CreateBatchToSpace(
+      _fbb,
+      block_size__,
+      crops);
+}
+
+flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct BatchToSpaceNDT : public flatbuffers::NativeTable {
+  typedef BatchToSpaceND TableType;
+  std::vector<int64_t> block_shape{};
+  std::unique_ptr<mindspore::schema::Vec2DT> crops{};
+};
+
+struct BatchToSpaceND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BatchToSpaceNDT NativeTableType;
+  typedef BatchToSpaceNDBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return BatchToSpaceNDTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BLOCK_SHAPE = 4,
+    VT_CROPS = 6
+  };
+  const flatbuffers::Vector<int64_t> *block_shape() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SHAPE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_block_shape() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_BLOCK_SHAPE);
+  }
+  const mindspore::schema::Vec2D *crops() const {
+    return GetPointer<const mindspore::schema::Vec2D *>(VT_CROPS);
+  }
+  mindspore::schema::Vec2D *mutable_crops() {
+    return GetPointer<mindspore::schema::Vec2D *>(VT_CROPS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_BLOCK_SHAPE) &&
+           verifier.VerifyVector(block_shape()) &&
+           VerifyOffset(verifier, VT_CROPS) &&
+           verifier.VerifyTable(crops()) &&
+           verifier.EndTable();
+  }
+  BatchToSpaceNDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BatchToSpaceNDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BatchToSpaceND> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BatchToSpaceNDBuilder {
+  typedef BatchToSpaceND Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_block_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape) {
+    fbb_.AddOffset(BatchToSpaceND::VT_BLOCK_SHAPE, block_shape);
+  }
+  void add_crops(flatbuffers::Offset<mindspore::schema::Vec2D> crops) {
+    fbb_.AddOffset(BatchToSpaceND::VT_CROPS, crops);
+  }
+  explicit BatchToSpaceNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BatchToSpaceND> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BatchToSpaceND>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceND(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape = 0,
+    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
+  BatchToSpaceNDBuilder builder_(_fbb);
+  builder_.add_crops(crops);
+  builder_.add_block_shape(block_shape);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceNDDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *block_shape = nullptr,
+    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
+  auto block_shape__ = block_shape ? _fbb.CreateVector<int64_t>(*block_shape) : 0;
+  return mindspore::schema::CreateBatchToSpaceND(
+      _fbb,
+      block_shape__,
+      crops);
+}
+
+flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceND(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct BiasAddT : public flatbuffers::NativeTable {
+  typedef BiasAdd TableType;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+};
+
+struct BiasAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BiasAddT NativeTableType;
+  typedef BiasAddBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return BiasAddTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           verifier.EndTable();
+  }
+  BiasAddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BiasAddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BiasAdd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BiasAddBuilder {
+  typedef BiasAdd Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(BiasAdd::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  explicit BiasAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BiasAdd> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BiasAdd>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BiasAdd> CreateBiasAdd(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  BiasAddBuilder builder_(_fbb);
+  builder_.add_format(format);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<BiasAdd> CreateBiasAdd(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct BinaryCrossEntropyT : public flatbuffers::NativeTable {
+  typedef BinaryCrossEntropy TableType;
+  mindspore::schema::Reduction reduction = mindspore::schema::Reduction_REDUCTION_SUM;
+};
+
+struct BinaryCrossEntropy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BinaryCrossEntropyT NativeTableType;
+  typedef BinaryCrossEntropyBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return BinaryCrossEntropyTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_REDUCTION = 4
+  };
+  mindspore::schema::Reduction reduction() const {
+    return static_cast<mindspore::schema::Reduction>(GetField<int8_t>(VT_REDUCTION, 0));
+  }
+  bool mutate_reduction(mindspore::schema::Reduction _reduction) {
+    return SetField<int8_t>(VT_REDUCTION, static_cast<int8_t>(_reduction), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_REDUCTION) &&
+           verifier.EndTable();
+  }
+  BinaryCrossEntropyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BinaryCrossEntropyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BinaryCrossEntropy> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BinaryCrossEntropyBuilder {
+  typedef BinaryCrossEntropy Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_reduction(mindspore::schema::Reduction reduction) {
+    fbb_.AddElement<int8_t>(BinaryCrossEntropy::VT_REDUCTION, static_cast<int8_t>(reduction), 0);
+  }
+  explicit BinaryCrossEntropyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BinaryCrossEntropy> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BinaryCrossEntropy>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BinaryCrossEntropy> CreateBinaryCrossEntropy(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Reduction reduction = mindspore::schema::Reduction_REDUCTION_SUM) {
+  BinaryCrossEntropyBuilder builder_(_fbb);
+  builder_.add_reduction(reduction);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<BinaryCrossEntropy> CreateBinaryCrossEntropy(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct BinaryCrossEntropyGradT : public flatbuffers::NativeTable {
+  typedef BinaryCrossEntropyGrad TableType;
+  mindspore::schema::Reduction reduction = mindspore::schema::Reduction_MEAN;
+};
+
+struct BinaryCrossEntropyGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BinaryCrossEntropyGradT NativeTableType;
+  typedef BinaryCrossEntropyGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return BinaryCrossEntropyGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_REDUCTION = 4
+  };
+  mindspore::schema::Reduction reduction() const {
+    return static_cast<mindspore::schema::Reduction>(GetField<int8_t>(VT_REDUCTION, 1));
+  }
+  bool mutate_reduction(mindspore::schema::Reduction _reduction) {
+    return SetField<int8_t>(VT_REDUCTION, static_cast<int8_t>(_reduction), 1);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_REDUCTION) &&
+           verifier.EndTable();
+  }
+  BinaryCrossEntropyGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BinaryCrossEntropyGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BinaryCrossEntropyGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BinaryCrossEntropyGradBuilder {
+  typedef BinaryCrossEntropyGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_reduction(mindspore::schema::Reduction reduction) {
+    fbb_.AddElement<int8_t>(BinaryCrossEntropyGrad::VT_REDUCTION, static_cast<int8_t>(reduction), 1);
+  }
+  explicit BinaryCrossEntropyGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BinaryCrossEntropyGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BinaryCrossEntropyGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BinaryCrossEntropyGrad> CreateBinaryCrossEntropyGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Reduction reduction = mindspore::schema::Reduction_MEAN) {
+  BinaryCrossEntropyGradBuilder builder_(_fbb);
+  builder_.add_reduction(reduction);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<BinaryCrossEntropyGrad> CreateBinaryCrossEntropyGrad(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct BiasAddGradT : public flatbuffers::NativeTable {
+  typedef BiasAddGrad TableType;
+};
+
+struct BiasAddGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BiasAddGradT NativeTableType;
+  typedef BiasAddGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return BiasAddGradTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  BiasAddGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BiasAddGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BiasAddGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BiasAddGradBuilder {
+  typedef BiasAddGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit BiasAddGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BiasAddGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BiasAddGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BiasAddGrad> CreateBiasAddGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  BiasAddGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<BiasAddGrad> CreateBiasAddGrad(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct BroadcastToT : public flatbuffers::NativeTable {
+  typedef BroadcastTo TableType;
+  std::vector<int64_t> shape{};
+};
+
+struct BroadcastTo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BroadcastToT NativeTableType;
+  typedef BroadcastToBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return BroadcastToTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SHAPE = 4
+  };
+  const flatbuffers::Vector<int64_t> *shape() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SHAPE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_shape() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_SHAPE);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_SHAPE) &&
+           verifier.VerifyVector(shape()) &&
+           verifier.EndTable();
+  }
+  BroadcastToT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(BroadcastToT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<BroadcastTo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct BroadcastToBuilder {
+  typedef BroadcastTo Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape) {
+    fbb_.AddOffset(BroadcastTo::VT_SHAPE, shape);
+  }
+  explicit BroadcastToBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BroadcastTo> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BroadcastTo>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape = 0) {
+  BroadcastToBuilder builder_(_fbb);
+  builder_.add_shape(shape);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<BroadcastTo> CreateBroadcastToDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *shape = nullptr) {
+  auto shape__ = shape ? _fbb.CreateVector<int64_t>(*shape) : 0;
+  return mindspore::schema::CreateBroadcastTo(
+      _fbb,
+      shape__);
+}
+
+flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct CastT : public flatbuffers::NativeTable {
+  typedef Cast TableType;
+};
+
+struct Cast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CastT NativeTableType;
+  typedef CastBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return CastTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  CastT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(CastT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Cast> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct CastBuilder {
+  typedef Cast Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit CastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Cast> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Cast>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Cast> CreateCast(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  CastBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Cast> CreateCast(flatbuffers::FlatBufferBuilder &_fbb, const CastT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct CeilT : public flatbuffers::NativeTable {
+  typedef Ceil TableType;
+};
+
+struct Ceil FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CeilT NativeTableType;
+  typedef CeilBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return CeilTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  CeilT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(CeilT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Ceil> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CeilT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct CeilBuilder {
+  typedef Ceil Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit CeilBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Ceil> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Ceil>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Ceil> CreateCeil(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  CeilBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Ceil> CreateCeil(flatbuffers::FlatBufferBuilder &_fbb, const CeilT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ClipT : public flatbuffers::NativeTable {
+  typedef Clip TableType;
+  float max = 0.0f;
+  float min = 0.0f;
+};
+
+struct Clip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ClipT NativeTableType;
+  typedef ClipBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ClipTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_MAX = 4,
+    VT_MIN = 6
+  };
+  float max() const {
+    return GetField<float>(VT_MAX, 0.0f);
+  }
+  bool mutate_max(float _max) {
+    return SetField<float>(VT_MAX, _max, 0.0f);
+  }
+  float min() const {
+    return GetField<float>(VT_MIN, 0.0f);
+  }
+  bool mutate_min(float _min) {
+    return SetField<float>(VT_MIN, _min, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_MAX) &&
+           VerifyField<float>(verifier, VT_MIN) &&
+           verifier.EndTable();
+  }
+  ClipT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ClipT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Clip> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ClipBuilder {
+  typedef Clip Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_max(float max) {
+    fbb_.AddElement<float>(Clip::VT_MAX, max, 0.0f);
+  }
+  void add_min(float min) {
+    fbb_.AddElement<float>(Clip::VT_MIN, min, 0.0f);
+  }
+  explicit ClipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Clip> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Clip>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Clip> CreateClip(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float max = 0.0f,
+    float min = 0.0f) {
+  ClipBuilder builder_(_fbb);
+  builder_.add_min(min);
+  builder_.add_max(max);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Clip> CreateClip(flatbuffers::FlatBufferBuilder &_fbb, const ClipT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ConcatT : public flatbuffers::NativeTable {
+  typedef Concat TableType;
+  int64_t axis = 0;
+};
+
+struct Concat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ConcatT NativeTableType;
+  typedef ConcatBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ConcatTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+  ConcatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ConcatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Concat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ConcatBuilder {
+  typedef Concat Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(Concat::VT_AXIS, axis, 0);
+  }
+  explicit ConcatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Concat> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Concat>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Concat> CreateConcat(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0) {
+  ConcatBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Concat> CreateConcat(flatbuffers::FlatBufferBuilder &_fbb, const ConcatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AttentionT : public flatbuffers::NativeTable {
+  typedef Attention TableType;
+};
+
+struct Attention FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AttentionT NativeTableType;
+  typedef AttentionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AttentionTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  AttentionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AttentionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Attention> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttentionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AttentionBuilder {
+  typedef Attention Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AttentionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Attention> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Attention>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Attention> CreateAttention(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AttentionBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Attention> CreateAttention(flatbuffers::FlatBufferBuilder &_fbb, const AttentionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct Conv2DBackpropFilterFusionT : public flatbuffers::NativeTable {
+  typedef Conv2DBackpropFilterFusion TableType;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  std::vector<int64_t> kernel_size{};
+  std::vector<int64_t> stride{};
+  std::vector<int64_t> dilation{};
+  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
+  std::vector<int64_t> pad_list{};
+  int64_t mode = 0;
+  int64_t group = 0;
+  int64_t in_channel = 0;
+  int64_t out_channel = 0;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct Conv2DBackpropFilterFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef Conv2DBackpropFilterFusionT NativeTableType;
+  typedef Conv2DBackpropFilterFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return Conv2DBackpropFilterFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_KERNEL_SIZE = 6,
+    VT_STRIDE = 8,
+    VT_DILATION = 10,
+    VT_PAD_MODE = 12,
+    VT_PAD_LIST = 14,
+    VT_MODE = 16,
+    VT_GROUP = 18,
+    VT_IN_CHANNEL = 20,
+    VT_OUT_CHANNEL = 22,
+    VT_ACTIVATION_TYPE = 24
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_stride() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  flatbuffers::Vector<int64_t> *mutable_dilation() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
+    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  flatbuffers::Vector<int64_t> *mutable_pad_list() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  int64_t mode() const {
+    return GetField<int64_t>(VT_MODE, 0);
+  }
+  bool mutate_mode(int64_t _mode) {
+    return SetField<int64_t>(VT_MODE, _mode, 0);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  bool mutate_group(int64_t _group) {
+    return SetField<int64_t>(VT_GROUP, _group, 0);
+  }
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  bool mutate_in_channel(int64_t _in_channel) {
+    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  bool mutate_out_channel(int64_t _out_channel) {
+    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyField<int64_t>(verifier, VT_MODE) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  Conv2DBackpropFilterFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(Conv2DBackpropFilterFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Conv2DBackpropFilterFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropFilterFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct Conv2DBackpropFilterFusionBuilder {
+  typedef Conv2DBackpropFilterFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(Conv2DBackpropFilterFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_DILATION, dilation);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(Conv2DBackpropFilterFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_PAD_LIST, pad_list);
+  }
+  void add_mode(int64_t mode) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_MODE, mode, 0);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_GROUP, group, 0);
+  }
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(Conv2DBackpropFilterFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit Conv2DBackpropFilterFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Conv2DBackpropFilterFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Conv2DBackpropFilterFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Conv2DBackpropFilterFusion> CreateConv2DBackpropFilterFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  Conv2DBackpropFilterFusionBuilder builder_(_fbb);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_group(group);
+  builder_.add_mode(mode);
+  builder_.add_pad_list(pad_list);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_format(format);
+  builder_.add_activation_type(activation_type);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Conv2DBackpropFilterFusion> CreateConv2DBackpropFilterFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad_list = nullptr,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  return mindspore::schema::CreateConv2DBackpropFilterFusion(
+      _fbb,
+      format,
+      kernel_size__,
+      stride__,
+      dilation__,
+      pad_mode,
+      pad_list__,
+      mode,
+      group,
+      in_channel,
+      out_channel,
+      activation_type);
+}
+
+flatbuffers::Offset<Conv2DBackpropFilterFusion> CreateConv2DBackpropFilterFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropFilterFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct Conv2DBackpropInputFusionT : public flatbuffers::NativeTable {
+  typedef Conv2DBackpropInputFusion TableType;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  std::vector<int64_t> kernel_size{};
+  std::vector<int64_t> stride{};
+  std::vector<int64_t> dilation{};
+  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
+  std::vector<int64_t> pad{};
+  std::vector<int64_t> pad_list{};
+  int64_t mode = 0;
+  int64_t group = 0;
+  int64_t in_channel = 0;
+  int64_t out_channel = 0;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct Conv2DBackpropInputFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef Conv2DBackpropInputFusionT NativeTableType;
+  typedef Conv2DBackpropInputFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return Conv2DBackpropInputFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_KERNEL_SIZE = 6,
+    VT_STRIDE = 8,
+    VT_DILATION = 10,
+    VT_PAD_MODE = 12,
+    VT_PAD = 14,
+    VT_PAD_LIST = 16,
+    VT_MODE = 18,
+    VT_GROUP = 20,
+    VT_IN_CHANNEL = 22,
+    VT_OUT_CHANNEL = 24,
+    VT_ACTIVATION_TYPE = 26
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_stride() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  flatbuffers::Vector<int64_t> *mutable_dilation() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
+    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
+  }
+  const flatbuffers::Vector<int64_t> *pad() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  flatbuffers::Vector<int64_t> *mutable_pad() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  flatbuffers::Vector<int64_t> *mutable_pad_list() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  int64_t mode() const {
+    return GetField<int64_t>(VT_MODE, 0);
+  }
+  bool mutate_mode(int64_t _mode) {
+    return SetField<int64_t>(VT_MODE, _mode, 0);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  bool mutate_group(int64_t _group) {
+    return SetField<int64_t>(VT_GROUP, _group, 0);
+  }
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  bool mutate_in_channel(int64_t _in_channel) {
+    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  bool mutate_out_channel(int64_t _out_channel) {
+    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD) &&
+           verifier.VerifyVector(pad()) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyField<int64_t>(verifier, VT_MODE) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  Conv2DBackpropInputFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(Conv2DBackpropInputFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Conv2DBackpropInputFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropInputFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct Conv2DBackpropInputFusionBuilder {
+  typedef Conv2DBackpropInputFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(Conv2DBackpropInputFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_DILATION, dilation);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(Conv2DBackpropInputFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
+    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_PAD, pad);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_PAD_LIST, pad_list);
+  }
+  void add_mode(int64_t mode) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_MODE, mode, 0);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_GROUP, group, 0);
+  }
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(Conv2DBackpropInputFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit Conv2DBackpropInputFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Conv2DBackpropInputFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Conv2DBackpropInputFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Conv2DBackpropInputFusion> CreateConv2DBackpropInputFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  Conv2DBackpropInputFusionBuilder builder_(_fbb);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_group(group);
+  builder_.add_mode(mode);
+  builder_.add_pad_list(pad_list);
+  builder_.add_pad(pad);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_format(format);
+  builder_.add_activation_type(activation_type);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Conv2DBackpropInputFusion> CreateConv2DBackpropInputFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad = nullptr,
+    const std::vector<int64_t> *pad_list = nullptr,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  return mindspore::schema::CreateConv2DBackpropInputFusion(
+      _fbb,
+      format,
+      kernel_size__,
+      stride__,
+      dilation__,
+      pad_mode,
+      pad__,
+      pad_list__,
+      mode,
+      group,
+      in_channel,
+      out_channel,
+      activation_type);
+}
+
+flatbuffers::Offset<Conv2DBackpropInputFusion> CreateConv2DBackpropInputFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropInputFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct Conv2DFusionT : public flatbuffers::NativeTable {
+  typedef Conv2DFusion TableType;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  std::vector<int64_t> kernel_size{};
+  std::vector<int64_t> stride{};
+  std::vector<int64_t> dilation{};
+  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
+  std::vector<int64_t> pad_list{};
+  int64_t mode = 0;
+  int64_t group = 0;
+  int64_t in_channel = 0;
+  int64_t out_channel = 0;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct Conv2DFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef Conv2DFusionT NativeTableType;
+  typedef Conv2DFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return Conv2DFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_KERNEL_SIZE = 6,
+    VT_STRIDE = 8,
+    VT_DILATION = 10,
+    VT_PAD_MODE = 12,
+    VT_PAD_LIST = 14,
+    VT_MODE = 16,
+    VT_GROUP = 18,
+    VT_IN_CHANNEL = 20,
+    VT_OUT_CHANNEL = 22,
+    VT_ACTIVATION_TYPE = 24
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_stride() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  flatbuffers::Vector<int64_t> *mutable_dilation() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
+    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  flatbuffers::Vector<int64_t> *mutable_pad_list() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  int64_t mode() const {
+    return GetField<int64_t>(VT_MODE, 0);
+  }
+  bool mutate_mode(int64_t _mode) {
+    return SetField<int64_t>(VT_MODE, _mode, 0);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  bool mutate_group(int64_t _group) {
+    return SetField<int64_t>(VT_GROUP, _group, 0);
+  }
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  bool mutate_in_channel(int64_t _in_channel) {
+    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  bool mutate_out_channel(int64_t _out_channel) {
+    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyField<int64_t>(verifier, VT_MODE) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  Conv2DFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(Conv2DFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Conv2DFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct Conv2DFusionBuilder {
+  typedef Conv2DFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(Conv2DFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(Conv2DFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(Conv2DFusion::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(Conv2DFusion::VT_DILATION, dilation);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(Conv2DFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(Conv2DFusion::VT_PAD_LIST, pad_list);
+  }
+  void add_mode(int64_t mode) {
+    fbb_.AddElement<int64_t>(Conv2DFusion::VT_MODE, mode, 0);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(Conv2DFusion::VT_GROUP, group, 0);
+  }
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(Conv2DFusion::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(Conv2DFusion::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(Conv2DFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit Conv2DFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Conv2DFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Conv2DFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Conv2DFusion> CreateConv2DFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  Conv2DFusionBuilder builder_(_fbb);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_group(group);
+  builder_.add_mode(mode);
+  builder_.add_pad_list(pad_list);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_format(format);
+  builder_.add_activation_type(activation_type);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Conv2DFusion> CreateConv2DFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad_list = nullptr,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  return mindspore::schema::CreateConv2DFusion(
+      _fbb,
+      format,
+      kernel_size__,
+      stride__,
+      dilation__,
+      pad_mode,
+      pad_list__,
+      mode,
+      group,
+      in_channel,
+      out_channel,
+      activation_type);
+}
+
+flatbuffers::Offset<Conv2DFusion> CreateConv2DFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct Conv2dTransposeFusionT : public flatbuffers::NativeTable {
+  typedef Conv2dTransposeFusion TableType;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  std::vector<int64_t> kernel_size{};
+  std::vector<int64_t> stride{};
+  std::vector<int64_t> dilation{};
+  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
+  std::vector<int64_t> pad{};
+  std::vector<int64_t> pad_list{};
+  int64_t mode = 0;
+  int64_t group = 0;
+  int64_t in_channel = 0;
+  int64_t out_channel = 0;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+  std::vector<int64_t> output_paddings{};
+};
+
+struct Conv2dTransposeFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef Conv2dTransposeFusionT NativeTableType;
+  typedef Conv2dTransposeFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return Conv2dTransposeFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_KERNEL_SIZE = 6,
+    VT_STRIDE = 8,
+    VT_DILATION = 10,
+    VT_PAD_MODE = 12,
+    VT_PAD = 14,
+    VT_PAD_LIST = 16,
+    VT_MODE = 18,
+    VT_GROUP = 20,
+    VT_IN_CHANNEL = 22,
+    VT_OUT_CHANNEL = 24,
+    VT_ACTIVATION_TYPE = 26,
+    VT_OUTPUT_PADDINGS = 28
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_stride() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  flatbuffers::Vector<int64_t> *mutable_dilation() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
+    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
+  }
+  const flatbuffers::Vector<int64_t> *pad() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  flatbuffers::Vector<int64_t> *mutable_pad() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  flatbuffers::Vector<int64_t> *mutable_pad_list() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  int64_t mode() const {
+    return GetField<int64_t>(VT_MODE, 0);
+  }
+  bool mutate_mode(int64_t _mode) {
+    return SetField<int64_t>(VT_MODE, _mode, 0);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  bool mutate_group(int64_t _group) {
+    return SetField<int64_t>(VT_GROUP, _group, 0);
+  }
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  bool mutate_in_channel(int64_t _in_channel) {
+    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  bool mutate_out_channel(int64_t _out_channel) {
+    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  const flatbuffers::Vector<int64_t> *output_paddings() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OUTPUT_PADDINGS);
+  }
+  flatbuffers::Vector<int64_t> *mutable_output_paddings() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_OUTPUT_PADDINGS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD) &&
+           verifier.VerifyVector(pad()) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyField<int64_t>(verifier, VT_MODE) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           VerifyOffset(verifier, VT_OUTPUT_PADDINGS) &&
+           verifier.VerifyVector(output_paddings()) &&
+           verifier.EndTable();
+  }
+  Conv2dTransposeFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(Conv2dTransposeFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Conv2dTransposeFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2dTransposeFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct Conv2dTransposeFusionBuilder {
+  typedef Conv2dTransposeFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(Conv2dTransposeFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(Conv2dTransposeFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(Conv2dTransposeFusion::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(Conv2dTransposeFusion::VT_DILATION, dilation);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(Conv2dTransposeFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
+    fbb_.AddOffset(Conv2dTransposeFusion::VT_PAD, pad);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(Conv2dTransposeFusion::VT_PAD_LIST, pad_list);
+  }
+  void add_mode(int64_t mode) {
+    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_MODE, mode, 0);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_GROUP, group, 0);
+  }
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(Conv2dTransposeFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  void add_output_paddings(flatbuffers::Offset<flatbuffers::Vector<int64_t>> output_paddings) {
+    fbb_.AddOffset(Conv2dTransposeFusion::VT_OUTPUT_PADDINGS, output_paddings);
+  }
+  explicit Conv2dTransposeFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Conv2dTransposeFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Conv2dTransposeFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Conv2dTransposeFusion> CreateConv2dTransposeFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> output_paddings = 0) {
+  Conv2dTransposeFusionBuilder builder_(_fbb);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_group(group);
+  builder_.add_mode(mode);
+  builder_.add_output_paddings(output_paddings);
+  builder_.add_pad_list(pad_list);
+  builder_.add_pad(pad);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_format(format);
+  builder_.add_activation_type(activation_type);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Conv2dTransposeFusion> CreateConv2dTransposeFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad = nullptr,
+    const std::vector<int64_t> *pad_list = nullptr,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    const std::vector<int64_t> *output_paddings = nullptr) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  auto output_paddings__ = output_paddings ? _fbb.CreateVector<int64_t>(*output_paddings) : 0;
+  return mindspore::schema::CreateConv2dTransposeFusion(
+      _fbb,
+      format,
+      kernel_size__,
+      stride__,
+      dilation__,
+      pad_mode,
+      pad__,
+      pad_list__,
+      mode,
+      group,
+      in_channel,
+      out_channel,
+      activation_type,
+      output_paddings__);
+}
+
+flatbuffers::Offset<Conv2dTransposeFusion> CreateConv2dTransposeFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2dTransposeFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct CosT : public flatbuffers::NativeTable {
+  typedef Cos TableType;
+};
+
+struct Cos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CosT NativeTableType;
+  typedef CosBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return CosTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  CosT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(CosT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Cos> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct CosBuilder {
+  typedef Cos Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit CosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Cos> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Cos>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Cos> CreateCos(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  CosBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Cos> CreateCos(flatbuffers::FlatBufferBuilder &_fbb, const CosT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ConstantOfShapeT : public flatbuffers::NativeTable {
+  typedef ConstantOfShape TableType;
+  int64_t data_type = 0;
+  std::vector<float> value{};
+};
+
+struct ConstantOfShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ConstantOfShapeT NativeTableType;
+  typedef ConstantOfShapeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ConstantOfShapeTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DATA_TYPE = 4,
+    VT_VALUE = 6
+  };
+  int64_t data_type() const {
+    return GetField<int64_t>(VT_DATA_TYPE, 0);
+  }
+  bool mutate_data_type(int64_t _data_type) {
+    return SetField<int64_t>(VT_DATA_TYPE, _data_type, 0);
+  }
+  const flatbuffers::Vector<float> *value() const {
+    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUE);
+  }
+  flatbuffers::Vector<float> *mutable_value() {
+    return GetPointer<flatbuffers::Vector<float> *>(VT_VALUE);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_DATA_TYPE) &&
+           VerifyOffset(verifier, VT_VALUE) &&
+           verifier.VerifyVector(value()) &&
+           verifier.EndTable();
+  }
+  ConstantOfShapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ConstantOfShapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ConstantOfShape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstantOfShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ConstantOfShapeBuilder {
+  typedef ConstantOfShape Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_data_type(int64_t data_type) {
+    fbb_.AddElement<int64_t>(ConstantOfShape::VT_DATA_TYPE, data_type, 0);
+  }
+  void add_value(flatbuffers::Offset<flatbuffers::Vector<float>> value) {
+    fbb_.AddOffset(ConstantOfShape::VT_VALUE, value);
+  }
+  explicit ConstantOfShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ConstantOfShape> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ConstantOfShape>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShape(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t data_type = 0,
+    flatbuffers::Offset<flatbuffers::Vector<float>> value = 0) {
+  ConstantOfShapeBuilder builder_(_fbb);
+  builder_.add_data_type(data_type);
+  builder_.add_value(value);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShapeDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t data_type = 0,
+    const std::vector<float> *value = nullptr) {
+  auto value__ = value ? _fbb.CreateVector<float>(*value) : 0;
+  return mindspore::schema::CreateConstantOfShape(
+      _fbb,
+      data_type,
+      value__);
+}
+
+flatbuffers::Offset<ConstantOfShape> CreateConstantOfShape(flatbuffers::FlatBufferBuilder &_fbb, const ConstantOfShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct CropT : public flatbuffers::NativeTable {
+  typedef Crop TableType;
+  int64_t axis = 0;
+  std::vector<int64_t> offsets{};
+};
+
+struct Crop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CropT NativeTableType;
+  typedef CropBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return CropTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4,
+    VT_OFFSETS = 6
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  const flatbuffers::Vector<int64_t> *offsets() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OFFSETS);
+  }
+  flatbuffers::Vector<int64_t> *mutable_offsets() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_OFFSETS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyOffset(verifier, VT_OFFSETS) &&
+           verifier.VerifyVector(offsets()) &&
+           verifier.EndTable();
+  }
+  CropT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(CropT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Crop> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct CropBuilder {
+  typedef Crop Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(Crop::VT_AXIS, axis, 0);
+  }
+  void add_offsets(flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets) {
+    fbb_.AddOffset(Crop::VT_OFFSETS, offsets);
+  }
+  explicit CropBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Crop> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Crop>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Crop> CreateCrop(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets = 0) {
+  CropBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  builder_.add_offsets(offsets);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Crop> CreateCropDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0,
+    const std::vector<int64_t> *offsets = nullptr) {
+  auto offsets__ = offsets ? _fbb.CreateVector<int64_t>(*offsets) : 0;
+  return mindspore::schema::CreateCrop(
+      _fbb,
+      axis,
+      offsets__);
+}
+
+flatbuffers::Offset<Crop> CreateCrop(flatbuffers::FlatBufferBuilder &_fbb, const CropT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct CustomExtractFeaturesT : public flatbuffers::NativeTable {
+  typedef CustomExtractFeatures TableType;
+};
+
+struct CustomExtractFeatures FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CustomExtractFeaturesT NativeTableType;
+  typedef CustomExtractFeaturesBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return CustomExtractFeaturesTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  CustomExtractFeaturesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(CustomExtractFeaturesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<CustomExtractFeatures> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomExtractFeaturesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct CustomExtractFeaturesBuilder {
+  typedef CustomExtractFeatures Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit CustomExtractFeaturesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<CustomExtractFeatures> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<CustomExtractFeatures>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<CustomExtractFeatures> CreateCustomExtractFeatures(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  CustomExtractFeaturesBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<CustomExtractFeatures> CreateCustomExtractFeatures(flatbuffers::FlatBufferBuilder &_fbb, const CustomExtractFeaturesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct CustomNormalizeT : public flatbuffers::NativeTable {
+  typedef CustomNormalize TableType;
+};
+
+struct CustomNormalize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CustomNormalizeT NativeTableType;
+  typedef CustomNormalizeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return CustomNormalizeTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  CustomNormalizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(CustomNormalizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<CustomNormalize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomNormalizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct CustomNormalizeBuilder {
+  typedef CustomNormalize Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit CustomNormalizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<CustomNormalize> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<CustomNormalize>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<CustomNormalize> CreateCustomNormalize(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  CustomNormalizeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<CustomNormalize> CreateCustomNormalize(flatbuffers::FlatBufferBuilder &_fbb, const CustomNormalizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct CustomPredictT : public flatbuffers::NativeTable {
+  typedef CustomPredict TableType;
+  int64_t output_num = 0;
+  float weight_threshold = 0.0f;
+};
+
+struct CustomPredict FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CustomPredictT NativeTableType;
+  typedef CustomPredictBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return CustomPredictTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_OUTPUT_NUM = 4,
+    VT_WEIGHT_THRESHOLD = 6
+  };
+  int64_t output_num() const {
+    return GetField<int64_t>(VT_OUTPUT_NUM, 0);
+  }
+  bool mutate_output_num(int64_t _output_num) {
+    return SetField<int64_t>(VT_OUTPUT_NUM, _output_num, 0);
+  }
+  float weight_threshold() const {
+    return GetField<float>(VT_WEIGHT_THRESHOLD, 0.0f);
+  }
+  bool mutate_weight_threshold(float _weight_threshold) {
+    return SetField<float>(VT_WEIGHT_THRESHOLD, _weight_threshold, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_OUTPUT_NUM) &&
+           VerifyField<float>(verifier, VT_WEIGHT_THRESHOLD) &&
+           verifier.EndTable();
+  }
+  CustomPredictT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(CustomPredictT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<CustomPredict> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomPredictT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct CustomPredictBuilder {
+  typedef CustomPredict Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_output_num(int64_t output_num) {
+    fbb_.AddElement<int64_t>(CustomPredict::VT_OUTPUT_NUM, output_num, 0);
+  }
+  void add_weight_threshold(float weight_threshold) {
+    fbb_.AddElement<float>(CustomPredict::VT_WEIGHT_THRESHOLD, weight_threshold, 0.0f);
+  }
+  explicit CustomPredictBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<CustomPredict> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<CustomPredict>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<CustomPredict> CreateCustomPredict(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t output_num = 0,
+    float weight_threshold = 0.0f) {
+  CustomPredictBuilder builder_(_fbb);
+  builder_.add_output_num(output_num);
+  builder_.add_weight_threshold(weight_threshold);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<CustomPredict> CreateCustomPredict(flatbuffers::FlatBufferBuilder &_fbb, const CustomPredictT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct DeConv2DGradFilterT : public flatbuffers::NativeTable {
+  typedef DeConv2DGradFilter TableType;
+  int64_t in_channel = 0;
+  int64_t out_channel = 0;
+  std::vector<int64_t> kernel_size{};
+  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
+  std::vector<int64_t> pad_list{};
+  std::vector<int64_t> stride{};
+  std::vector<int64_t> dilation{};
+  int64_t group = 0;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct DeConv2DGradFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DeConv2DGradFilterT NativeTableType;
+  typedef DeConv2DGradFilterBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return DeConv2DGradFilterTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_IN_CHANNEL = 4,
+    VT_OUT_CHANNEL = 6,
+    VT_KERNEL_SIZE = 8,
+    VT_PAD_MODE = 10,
+    VT_PAD_LIST = 12,
+    VT_STRIDE = 14,
+    VT_DILATION = 16,
+    VT_GROUP = 18,
+    VT_FORMAT = 20,
+    VT_ACTIVATION_TYPE = 22
+  };
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  bool mutate_in_channel(int64_t _in_channel) {
+    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  bool mutate_out_channel(int64_t _out_channel) {
+    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
+    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  flatbuffers::Vector<int64_t> *mutable_pad_list() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_stride() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  flatbuffers::Vector<int64_t> *mutable_dilation() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  bool mutate_group(int64_t _group) {
+    return SetField<int64_t>(VT_GROUP, _group, 0);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  DeConv2DGradFilterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(DeConv2DGradFilterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<DeConv2DGradFilter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DGradFilterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct DeConv2DGradFilterBuilder {
+  typedef DeConv2DGradFilter Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(DeConv2DGradFilter::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(DeConv2DGradFilter::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(DeConv2DGradFilter::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(DeConv2DGradFilter::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(DeConv2DGradFilter::VT_PAD_LIST, pad_list);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(DeConv2DGradFilter::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(DeConv2DGradFilter::VT_DILATION, dilation);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(DeConv2DGradFilter::VT_GROUP, group, 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(DeConv2DGradFilter::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit DeConv2DGradFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DeConv2DGradFilter> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DeConv2DGradFilter>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilter(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    int64_t group = 0,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  DeConv2DGradFilterBuilder builder_(_fbb);
+  builder_.add_group(group);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_format(format);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_pad_list(pad_list);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_activation_type(activation_type);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilterDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad_list = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    int64_t group = 0,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  return mindspore::schema::CreateDeConv2DGradFilter(
+      _fbb,
+      in_channel,
+      out_channel,
+      kernel_size__,
+      pad_mode,
+      pad_list__,
+      stride__,
+      dilation__,
+      group,
+      format,
+      activation_type);
+}
+
+flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilter(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DGradFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct DependT : public flatbuffers::NativeTable {
+  typedef Depend TableType;
+};
+
+struct Depend FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DependT NativeTableType;
+  typedef DependBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return DependTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  DependT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(DependT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Depend> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DependT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct DependBuilder {
+  typedef Depend Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit DependBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Depend> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Depend>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Depend> CreateDepend(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  DependBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Depend> CreateDepend(flatbuffers::FlatBufferBuilder &_fbb, const DependT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct DepthToSpaceT : public flatbuffers::NativeTable {
+  typedef DepthToSpace TableType;
+  int64_t block_size = 0;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+};
+
+struct DepthToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DepthToSpaceT NativeTableType;
+  typedef DepthToSpaceBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return DepthToSpaceTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BLOCK_SIZE = 4,
+    VT_FORMAT = 6
+  };
+  int64_t block_size() const {
+    return GetField<int64_t>(VT_BLOCK_SIZE, 0);
+  }
+  bool mutate_block_size(int64_t _block_size) {
+    return SetField<int64_t>(VT_BLOCK_SIZE, _block_size, 0);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_BLOCK_SIZE) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           verifier.EndTable();
+  }
+  DepthToSpaceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(DepthToSpaceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<DepthToSpace> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct DepthToSpaceBuilder {
+  typedef DepthToSpace Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_block_size(int64_t block_size) {
+    fbb_.AddElement<int64_t>(DepthToSpace::VT_BLOCK_SIZE, block_size, 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(DepthToSpace::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  explicit DepthToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DepthToSpace> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DepthToSpace>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t block_size = 0,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  DepthToSpaceBuilder builder_(_fbb);
+  builder_.add_block_size(block_size);
+  builder_.add_format(format);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct DetectionPostProcessT : public flatbuffers::NativeTable {
+  typedef DetectionPostProcess TableType;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  int64_t input_size = 0;
+  std::vector<float> scale{};
+  float nms_iou_threshold = 0.0f;
+  float nms_score_threshold = 0.0f;
+  int64_t max_detections = 0;
+  int64_t detections_per_class = 0;
+  int64_t max_classes_per_detection = 0;
+  int64_t num_classes = 0;
+  bool use_regular_nms = false;
+  bool out_quantized = false;
+};
+
+struct DetectionPostProcess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DetectionPostProcessT NativeTableType;
+  typedef DetectionPostProcessBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return DetectionPostProcessTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_INPUT_SIZE = 6,
+    VT_SCALE = 8,
+    VT_NMS_IOU_THRESHOLD = 10,
+    VT_NMS_SCORE_THRESHOLD = 12,
+    VT_MAX_DETECTIONS = 14,
+    VT_DETECTIONS_PER_CLASS = 16,
+    VT_MAX_CLASSES_PER_DETECTION = 18,
+    VT_NUM_CLASSES = 20,
+    VT_USE_REGULAR_NMS = 22,
+    VT_OUT_QUANTIZED = 24
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  int64_t input_size() const {
+    return GetField<int64_t>(VT_INPUT_SIZE, 0);
+  }
+  bool mutate_input_size(int64_t _input_size) {
+    return SetField<int64_t>(VT_INPUT_SIZE, _input_size, 0);
+  }
+  const flatbuffers::Vector<float> *scale() const {
+    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
+  }
+  flatbuffers::Vector<float> *mutable_scale() {
+    return GetPointer<flatbuffers::Vector<float> *>(VT_SCALE);
+  }
+  float nms_iou_threshold() const {
+    return GetField<float>(VT_NMS_IOU_THRESHOLD, 0.0f);
+  }
+  bool mutate_nms_iou_threshold(float _nms_iou_threshold) {
+    return SetField<float>(VT_NMS_IOU_THRESHOLD, _nms_iou_threshold, 0.0f);
+  }
+  float nms_score_threshold() const {
+    return GetField<float>(VT_NMS_SCORE_THRESHOLD, 0.0f);
+  }
+  bool mutate_nms_score_threshold(float _nms_score_threshold) {
+    return SetField<float>(VT_NMS_SCORE_THRESHOLD, _nms_score_threshold, 0.0f);
+  }
+  int64_t max_detections() const {
+    return GetField<int64_t>(VT_MAX_DETECTIONS, 0);
+  }
+  bool mutate_max_detections(int64_t _max_detections) {
+    return SetField<int64_t>(VT_MAX_DETECTIONS, _max_detections, 0);
+  }
+  int64_t detections_per_class() const {
+    return GetField<int64_t>(VT_DETECTIONS_PER_CLASS, 0);
+  }
+  bool mutate_detections_per_class(int64_t _detections_per_class) {
+    return SetField<int64_t>(VT_DETECTIONS_PER_CLASS, _detections_per_class, 0);
+  }
+  int64_t max_classes_per_detection() const {
+    return GetField<int64_t>(VT_MAX_CLASSES_PER_DETECTION, 0);
+  }
+  bool mutate_max_classes_per_detection(int64_t _max_classes_per_detection) {
+    return SetField<int64_t>(VT_MAX_CLASSES_PER_DETECTION, _max_classes_per_detection, 0);
+  }
+  int64_t num_classes() const {
+    return GetField<int64_t>(VT_NUM_CLASSES, 0);
+  }
+  bool mutate_num_classes(int64_t _num_classes) {
+    return SetField<int64_t>(VT_NUM_CLASSES, _num_classes, 0);
+  }
+  bool use_regular_nms() const {
+    return GetField<uint8_t>(VT_USE_REGULAR_NMS, 0) != 0;
+  }
+  bool mutate_use_regular_nms(bool _use_regular_nms) {
+    return SetField<uint8_t>(VT_USE_REGULAR_NMS, static_cast<uint8_t>(_use_regular_nms), 0);
+  }
+  bool out_quantized() const {
+    return GetField<uint8_t>(VT_OUT_QUANTIZED, 0) != 0;
+  }
+  bool mutate_out_quantized(bool _out_quantized) {
+    return SetField<uint8_t>(VT_OUT_QUANTIZED, static_cast<uint8_t>(_out_quantized), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
+           VerifyOffset(verifier, VT_SCALE) &&
+           verifier.VerifyVector(scale()) &&
+           VerifyField<float>(verifier, VT_NMS_IOU_THRESHOLD) &&
+           VerifyField<float>(verifier, VT_NMS_SCORE_THRESHOLD) &&
+           VerifyField<int64_t>(verifier, VT_MAX_DETECTIONS) &&
+           VerifyField<int64_t>(verifier, VT_DETECTIONS_PER_CLASS) &&
+           VerifyField<int64_t>(verifier, VT_MAX_CLASSES_PER_DETECTION) &&
+           VerifyField<int64_t>(verifier, VT_NUM_CLASSES) &&
+           VerifyField<uint8_t>(verifier, VT_USE_REGULAR_NMS) &&
+           VerifyField<uint8_t>(verifier, VT_OUT_QUANTIZED) &&
+           verifier.EndTable();
+  }
+  DetectionPostProcessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(DetectionPostProcessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<DetectionPostProcess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct DetectionPostProcessBuilder {
+  typedef DetectionPostProcess Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(DetectionPostProcess::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_input_size(int64_t input_size) {
+    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_INPUT_SIZE, input_size, 0);
+  }
+  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
+    fbb_.AddOffset(DetectionPostProcess::VT_SCALE, scale);
+  }
+  void add_nms_iou_threshold(float nms_iou_threshold) {
+    fbb_.AddElement<float>(DetectionPostProcess::VT_NMS_IOU_THRESHOLD, nms_iou_threshold, 0.0f);
+  }
+  void add_nms_score_threshold(float nms_score_threshold) {
+    fbb_.AddElement<float>(DetectionPostProcess::VT_NMS_SCORE_THRESHOLD, nms_score_threshold, 0.0f);
+  }
+  void add_max_detections(int64_t max_detections) {
+    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAX_DETECTIONS, max_detections, 0);
+  }
+  void add_detections_per_class(int64_t detections_per_class) {
+    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_DETECTIONS_PER_CLASS, detections_per_class, 0);
+  }
+  void add_max_classes_per_detection(int64_t max_classes_per_detection) {
+    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAX_CLASSES_PER_DETECTION, max_classes_per_detection, 0);
+  }
+  void add_num_classes(int64_t num_classes) {
+    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_NUM_CLASSES, num_classes, 0);
+  }
+  void add_use_regular_nms(bool use_regular_nms) {
+    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_USE_REGULAR_NMS, static_cast<uint8_t>(use_regular_nms), 0);
+  }
+  void add_out_quantized(bool out_quantized) {
+    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_OUT_QUANTIZED, static_cast<uint8_t>(out_quantized), 0);
+  }
+  explicit DetectionPostProcessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DetectionPostProcess> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DetectionPostProcess>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    int64_t input_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
+    float nms_iou_threshold = 0.0f,
+    float nms_score_threshold = 0.0f,
+    int64_t max_detections = 0,
+    int64_t detections_per_class = 0,
+    int64_t max_classes_per_detection = 0,
+    int64_t num_classes = 0,
+    bool use_regular_nms = false,
+    bool out_quantized = false) {
+  DetectionPostProcessBuilder builder_(_fbb);
+  builder_.add_num_classes(num_classes);
+  builder_.add_max_classes_per_detection(max_classes_per_detection);
+  builder_.add_detections_per_class(detections_per_class);
+  builder_.add_max_detections(max_detections);
+  builder_.add_input_size(input_size);
+  builder_.add_nms_score_threshold(nms_score_threshold);
+  builder_.add_nms_iou_threshold(nms_iou_threshold);
+  builder_.add_scale(scale);
+  builder_.add_format(format);
+  builder_.add_out_quantized(out_quantized);
+  builder_.add_use_regular_nms(use_regular_nms);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcessDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    int64_t input_size = 0,
+    const std::vector<float> *scale = nullptr,
+    float nms_iou_threshold = 0.0f,
+    float nms_score_threshold = 0.0f,
+    int64_t max_detections = 0,
+    int64_t detections_per_class = 0,
+    int64_t max_classes_per_detection = 0,
+    int64_t num_classes = 0,
+    bool use_regular_nms = false,
+    bool out_quantized = false) {
+  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
+  return mindspore::schema::CreateDetectionPostProcess(
+      _fbb,
+      format,
+      input_size,
+      scale__,
+      nms_iou_threshold,
+      nms_score_threshold,
+      max_detections,
+      detections_per_class,
+      max_classes_per_detection,
+      num_classes,
+      use_regular_nms,
+      out_quantized);
+}
+
+flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct DivFusionT : public flatbuffers::NativeTable {
+  typedef DivFusion TableType;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct DivFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DivFusionT NativeTableType;
+  typedef DivFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return DivFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  DivFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(DivFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<DivFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct DivFusionBuilder {
+  typedef DivFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(DivFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit DivFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DivFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DivFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DivFusion> CreateDivFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  DivFusionBuilder builder_(_fbb);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<DivFusion> CreateDivFusion(flatbuffers::FlatBufferBuilder &_fbb, const DivFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct DivGradT : public flatbuffers::NativeTable {
+  typedef DivGrad TableType;
+};
+
+struct DivGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DivGradT NativeTableType;
+  typedef DivGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return DivGradTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  DivGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(DivGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<DivGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct DivGradBuilder {
+  typedef DivGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit DivGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DivGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DivGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DivGrad> CreateDivGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  DivGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<DivGrad> CreateDivGrad(flatbuffers::FlatBufferBuilder &_fbb, const DivGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct DropoutT : public flatbuffers::NativeTable {
+  typedef Dropout TableType;
+  float keep_prob = 0.5f;
+};
+
+struct Dropout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DropoutT NativeTableType;
+  typedef DropoutBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return DropoutTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KEEP_PROB = 4
+  };
+  float keep_prob() const {
+    return GetField<float>(VT_KEEP_PROB, 0.5f);
+  }
+  bool mutate_keep_prob(float _keep_prob) {
+    return SetField<float>(VT_KEEP_PROB, _keep_prob, 0.5f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_KEEP_PROB) &&
+           verifier.EndTable();
+  }
+  DropoutT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(DropoutT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Dropout> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DropoutT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct DropoutBuilder {
+  typedef Dropout Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_keep_prob(float keep_prob) {
+    fbb_.AddElement<float>(Dropout::VT_KEEP_PROB, keep_prob, 0.5f);
+  }
+  explicit DropoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Dropout> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Dropout>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Dropout> CreateDropout(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float keep_prob = 0.5f) {
+  DropoutBuilder builder_(_fbb);
+  builder_.add_keep_prob(keep_prob);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Dropout> CreateDropout(flatbuffers::FlatBufferBuilder &_fbb, const DropoutT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct DropoutGradT : public flatbuffers::NativeTable {
+  typedef DropoutGrad TableType;
+  float keep_prob = 0.0f;
+};
+
+struct DropoutGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DropoutGradT NativeTableType;
+  typedef DropoutGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return DropoutGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KEEP_PROB = 4
+  };
+  float keep_prob() const {
+    return GetField<float>(VT_KEEP_PROB, 0.0f);
+  }
+  bool mutate_keep_prob(float _keep_prob) {
+    return SetField<float>(VT_KEEP_PROB, _keep_prob, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_KEEP_PROB) &&
+           verifier.EndTable();
+  }
+  DropoutGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(DropoutGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<DropoutGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DropoutGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct DropoutGradBuilder {
+  typedef DropoutGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_keep_prob(float keep_prob) {
+    fbb_.AddElement<float>(DropoutGrad::VT_KEEP_PROB, keep_prob, 0.0f);
+  }
+  explicit DropoutGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DropoutGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DropoutGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DropoutGrad> CreateDropoutGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float keep_prob = 0.0f) {
+  DropoutGradBuilder builder_(_fbb);
+  builder_.add_keep_prob(keep_prob);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<DropoutGrad> CreateDropoutGrad(flatbuffers::FlatBufferBuilder &_fbb, const DropoutGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct EluT : public flatbuffers::NativeTable {
+  typedef Elu TableType;
+  float alpha = 0.0f;
+};
+
+struct Elu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef EluT NativeTableType;
+  typedef EluBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return EluTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ALPHA = 4
+  };
+  float alpha() const {
+    return GetField<float>(VT_ALPHA, 0.0f);
+  }
+  bool mutate_alpha(float _alpha) {
+    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_ALPHA) &&
+           verifier.EndTable();
+  }
+  EluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(EluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Elu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct EluBuilder {
+  typedef Elu Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_alpha(float alpha) {
+    fbb_.AddElement<float>(Elu::VT_ALPHA, alpha, 0.0f);
+  }
+  explicit EluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Elu> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Elu>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Elu> CreateElu(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float alpha = 0.0f) {
+  EluBuilder builder_(_fbb);
+  builder_.add_alpha(alpha);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Elu> CreateElu(flatbuffers::FlatBufferBuilder &_fbb, const EluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct EltwiseT : public flatbuffers::NativeTable {
+  typedef Eltwise TableType;
+  mindspore::schema::EltwiseMode mode = mindspore::schema::EltwiseMode_PROD;
+};
+
+struct Eltwise FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef EltwiseT NativeTableType;
+  typedef EltwiseBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return EltwiseTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_MODE = 4
+  };
+  mindspore::schema::EltwiseMode mode() const {
+    return static_cast<mindspore::schema::EltwiseMode>(GetField<int8_t>(VT_MODE, 0));
+  }
+  bool mutate_mode(mindspore::schema::EltwiseMode _mode) {
+    return SetField<int8_t>(VT_MODE, static_cast<int8_t>(_mode), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_MODE) &&
+           verifier.EndTable();
+  }
+  EltwiseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Eltwise> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct EltwiseBuilder {
+  typedef Eltwise Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_mode(mindspore::schema::EltwiseMode mode) {
+    fbb_.AddElement<int8_t>(Eltwise::VT_MODE, static_cast<int8_t>(mode), 0);
+  }
+  explicit EltwiseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Eltwise> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Eltwise>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Eltwise> CreateEltwise(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::EltwiseMode mode = mindspore::schema::EltwiseMode_PROD) {
+  EltwiseBuilder builder_(_fbb);
+  builder_.add_mode(mode);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct EqualT : public flatbuffers::NativeTable {
+  typedef Equal TableType;
+};
+
+struct Equal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef EqualT NativeTableType;
+  typedef EqualBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return EqualTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  EqualT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(EqualT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Equal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct EqualBuilder {
+  typedef Equal Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit EqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Equal> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Equal>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Equal> CreateEqual(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  EqualBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Equal> CreateEqual(flatbuffers::FlatBufferBuilder &_fbb, const EqualT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct EmbeddingLookupFusionT : public flatbuffers::NativeTable {
+  typedef EmbeddingLookupFusion TableType;
+  float max_norm = 0.0f;
+};
+
+struct EmbeddingLookupFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef EmbeddingLookupFusionT NativeTableType;
+  typedef EmbeddingLookupFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return EmbeddingLookupFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_MAX_NORM = 4
+  };
+  float max_norm() const {
+    return GetField<float>(VT_MAX_NORM, 0.0f);
+  }
+  bool mutate_max_norm(float _max_norm) {
+    return SetField<float>(VT_MAX_NORM, _max_norm, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_MAX_NORM) &&
+           verifier.EndTable();
+  }
+  EmbeddingLookupFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(EmbeddingLookupFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<EmbeddingLookupFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct EmbeddingLookupFusionBuilder {
+  typedef EmbeddingLookupFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_max_norm(float max_norm) {
+    fbb_.AddElement<float>(EmbeddingLookupFusion::VT_MAX_NORM, max_norm, 0.0f);
+  }
+  explicit EmbeddingLookupFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<EmbeddingLookupFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<EmbeddingLookupFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<EmbeddingLookupFusion> CreateEmbeddingLookupFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float max_norm = 0.0f) {
+  EmbeddingLookupFusionBuilder builder_(_fbb);
+  builder_.add_max_norm(max_norm);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<EmbeddingLookupFusion> CreateEmbeddingLookupFusion(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ExpFusionT : public flatbuffers::NativeTable {
+  typedef ExpFusion TableType;
+  float base = -1.0f;
+  float scale = 1.0f;
+  float shift = 0.0f;
+};
+
+struct ExpFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ExpFusionT NativeTableType;
+  typedef ExpFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ExpFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BASE = 4,
+    VT_SCALE = 6,
+    VT_SHIFT = 8
+  };
+  float base() const {
+    return GetField<float>(VT_BASE, -1.0f);
+  }
+  bool mutate_base(float _base) {
+    return SetField<float>(VT_BASE, _base, -1.0f);
+  }
+  float scale() const {
+    return GetField<float>(VT_SCALE, 1.0f);
+  }
+  bool mutate_scale(float _scale) {
+    return SetField<float>(VT_SCALE, _scale, 1.0f);
+  }
+  float shift() const {
+    return GetField<float>(VT_SHIFT, 0.0f);
+  }
+  bool mutate_shift(float _shift) {
+    return SetField<float>(VT_SHIFT, _shift, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_BASE) &&
+           VerifyField<float>(verifier, VT_SCALE) &&
+           VerifyField<float>(verifier, VT_SHIFT) &&
+           verifier.EndTable();
+  }
+  ExpFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ExpFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ExpFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ExpFusionBuilder {
+  typedef ExpFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_base(float base) {
+    fbb_.AddElement<float>(ExpFusion::VT_BASE, base, -1.0f);
+  }
+  void add_scale(float scale) {
+    fbb_.AddElement<float>(ExpFusion::VT_SCALE, scale, 1.0f);
+  }
+  void add_shift(float shift) {
+    fbb_.AddElement<float>(ExpFusion::VT_SHIFT, shift, 0.0f);
+  }
+  explicit ExpFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ExpFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ExpFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ExpFusion> CreateExpFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float base = -1.0f,
+    float scale = 1.0f,
+    float shift = 0.0f) {
+  ExpFusionBuilder builder_(_fbb);
+  builder_.add_shift(shift);
+  builder_.add_scale(scale);
+  builder_.add_base(base);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ExpFusion> CreateExpFusion(flatbuffers::FlatBufferBuilder &_fbb, const ExpFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ExpandDimsT : public flatbuffers::NativeTable {
+  typedef ExpandDims TableType;
+};
+
+struct ExpandDims FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ExpandDimsT NativeTableType;
+  typedef ExpandDimsBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ExpandDimsTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  ExpandDimsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ExpandDimsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ExpandDims> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ExpandDimsBuilder {
+  typedef ExpandDims Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ExpandDimsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ExpandDims> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ExpandDims>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ExpandDims> CreateExpandDims(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ExpandDimsBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ExpandDims> CreateExpandDims(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FakeQuantWithMinMaxVarsT : public flatbuffers::NativeTable {
+  typedef FakeQuantWithMinMaxVars TableType;
+  int64_t num_bits = 0;
+  bool narrow_range = false;
+};
+
+struct FakeQuantWithMinMaxVars FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FakeQuantWithMinMaxVarsT NativeTableType;
+  typedef FakeQuantWithMinMaxVarsBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FakeQuantWithMinMaxVarsTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUM_BITS = 4,
+    VT_NARROW_RANGE = 6
+  };
+  int64_t num_bits() const {
+    return GetField<int64_t>(VT_NUM_BITS, 0);
+  }
+  bool mutate_num_bits(int64_t _num_bits) {
+    return SetField<int64_t>(VT_NUM_BITS, _num_bits, 0);
+  }
+  bool narrow_range() const {
+    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
+  }
+  bool mutate_narrow_range(bool _narrow_range) {
+    return SetField<uint8_t>(VT_NARROW_RANGE, static_cast<uint8_t>(_narrow_range), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_NUM_BITS) &&
+           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
+           verifier.EndTable();
+  }
+  FakeQuantWithMinMaxVarsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FakeQuantWithMinMaxVarsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<FakeQuantWithMinMaxVars> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FakeQuantWithMinMaxVarsBuilder {
+  typedef FakeQuantWithMinMaxVars Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_num_bits(int64_t num_bits) {
+    fbb_.AddElement<int64_t>(FakeQuantWithMinMaxVars::VT_NUM_BITS, num_bits, 0);
+  }
+  void add_narrow_range(bool narrow_range) {
+    fbb_.AddElement<uint8_t>(FakeQuantWithMinMaxVars::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
+  }
+  explicit FakeQuantWithMinMaxVarsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FakeQuantWithMinMaxVars> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FakeQuantWithMinMaxVars>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t num_bits = 0,
+    bool narrow_range = false) {
+  FakeQuantWithMinMaxVarsBuilder builder_(_fbb);
+  builder_.add_num_bits(num_bits);
+  builder_.add_narrow_range(narrow_range);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FakeQuantWithMinMaxVarsPerChannelT : public flatbuffers::NativeTable {
+  typedef FakeQuantWithMinMaxVarsPerChannel TableType;
+  int64_t num_bits = 0;
+  bool narrow_range = false;
+};
+
+struct FakeQuantWithMinMaxVarsPerChannel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FakeQuantWithMinMaxVarsPerChannelT NativeTableType;
+  typedef FakeQuantWithMinMaxVarsPerChannelBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FakeQuantWithMinMaxVarsPerChannelTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUM_BITS = 4,
+    VT_NARROW_RANGE = 6
+  };
+  int64_t num_bits() const {
+    return GetField<int64_t>(VT_NUM_BITS, 0);
+  }
+  bool mutate_num_bits(int64_t _num_bits) {
+    return SetField<int64_t>(VT_NUM_BITS, _num_bits, 0);
+  }
+  bool narrow_range() const {
+    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
+  }
+  bool mutate_narrow_range(bool _narrow_range) {
+    return SetField<uint8_t>(VT_NARROW_RANGE, static_cast<uint8_t>(_narrow_range), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_NUM_BITS) &&
+           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
+           verifier.EndTable();
+  }
+  FakeQuantWithMinMaxVarsPerChannelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FakeQuantWithMinMaxVarsPerChannelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsPerChannelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FakeQuantWithMinMaxVarsPerChannelBuilder {
+  typedef FakeQuantWithMinMaxVarsPerChannel Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_num_bits(int64_t num_bits) {
+    fbb_.AddElement<int64_t>(FakeQuantWithMinMaxVarsPerChannel::VT_NUM_BITS, num_bits, 0);
+  }
+  void add_narrow_range(bool narrow_range) {
+    fbb_.AddElement<uint8_t>(FakeQuantWithMinMaxVarsPerChannel::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
+  }
+  explicit FakeQuantWithMinMaxVarsPerChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> CreateFakeQuantWithMinMaxVarsPerChannel(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t num_bits = 0,
+    bool narrow_range = false) {
+  FakeQuantWithMinMaxVarsPerChannelBuilder builder_(_fbb);
+  builder_.add_num_bits(num_bits);
+  builder_.add_narrow_range(narrow_range);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> CreateFakeQuantWithMinMaxVarsPerChannel(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsPerChannelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FftRealT : public flatbuffers::NativeTable {
+  typedef FftReal TableType;
+};
+
+struct FftReal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FftRealT NativeTableType;
+  typedef FftRealBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FftRealTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  FftRealT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FftRealT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<FftReal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FftRealT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FftRealBuilder {
+  typedef FftReal Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FftRealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FftReal> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FftReal>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FftReal> CreateFftReal(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FftRealBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<FftReal> CreateFftReal(flatbuffers::FlatBufferBuilder &_fbb, const FftRealT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FftImagT : public flatbuffers::NativeTable {
+  typedef FftImag TableType;
+};
+
+struct FftImag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FftImagT NativeTableType;
+  typedef FftImagBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FftImagTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  FftImagT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FftImagT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<FftImag> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FftImagT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FftImagBuilder {
+  typedef FftImag Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FftImagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FftImag> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FftImag>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FftImag> CreateFftImag(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FftImagBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<FftImag> CreateFftImag(flatbuffers::FlatBufferBuilder &_fbb, const FftImagT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FlattenT : public flatbuffers::NativeTable {
+  typedef Flatten TableType;
+  int64_t axis = 1LL;
+};
+
+struct Flatten FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FlattenT NativeTableType;
+  typedef FlattenBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FlattenTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 1LL);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 1LL);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+  FlattenT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Flatten> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FlattenBuilder {
+  typedef Flatten Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(Flatten::VT_AXIS, axis, 1LL);
+  }
+  explicit FlattenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Flatten> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Flatten>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Flatten> CreateFlatten(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 1LL) {
+  FlattenBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FlattenGradT : public flatbuffers::NativeTable {
+  typedef FlattenGrad TableType;
+};
+
+struct FlattenGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FlattenGradT NativeTableType;
+  typedef FlattenGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FlattenGradTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  FlattenGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FlattenGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<FlattenGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FlattenGradBuilder {
+  typedef FlattenGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FlattenGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FlattenGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FlattenGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FlattenGrad> CreateFlattenGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FlattenGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<FlattenGrad> CreateFlattenGrad(flatbuffers::FlatBufferBuilder &_fbb, const FlattenGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FloorT : public flatbuffers::NativeTable {
+  typedef Floor TableType;
+};
+
+struct Floor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FloorT NativeTableType;
+  typedef FloorBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FloorTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  FloorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FloorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Floor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FloorBuilder {
+  typedef Floor Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FloorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Floor> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Floor>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Floor> CreateFloor(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FloorBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Floor> CreateFloor(flatbuffers::FlatBufferBuilder &_fbb, const FloorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FloorDivT : public flatbuffers::NativeTable {
+  typedef FloorDiv TableType;
+};
+
+struct FloorDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FloorDivT NativeTableType;
+  typedef FloorDivBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FloorDivTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  FloorDivT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FloorDivT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<FloorDiv> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FloorDivBuilder {
+  typedef FloorDiv Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FloorDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FloorDiv> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FloorDiv>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FloorDiv> CreateFloorDiv(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FloorDivBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<FloorDiv> CreateFloorDiv(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FloorModT : public flatbuffers::NativeTable {
+  typedef FloorMod TableType;
+};
+
+struct FloorMod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FloorModT NativeTableType;
+  typedef FloorModBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FloorModTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  FloorModT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FloorModT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<FloorMod> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FloorModBuilder {
+  typedef FloorMod Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FloorModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FloorMod> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FloorMod>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FloorMod> CreateFloorMod(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FloorModBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<FloorMod> CreateFloorMod(flatbuffers::FlatBufferBuilder &_fbb, const FloorModT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FillT : public flatbuffers::NativeTable {
+  typedef Fill TableType;
+};
+
+struct Fill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FillT NativeTableType;
+  typedef FillBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FillTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  FillT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FillT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Fill> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FillBuilder {
+  typedef Fill Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Fill> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Fill>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Fill> CreateFill(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FillBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Fill> CreateFill(flatbuffers::FlatBufferBuilder &_fbb, const FillT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FullConnectionT : public flatbuffers::NativeTable {
+  typedef FullConnection TableType;
+  bool has_bias = false;
+  bool use_axis = false;
+  int64_t axis = 0;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct FullConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FullConnectionT NativeTableType;
+  typedef FullConnectionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FullConnectionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_HAS_BIAS = 4,
+    VT_USE_AXIS = 6,
+    VT_AXIS = 8,
+    VT_ACTIVATION_TYPE = 10
+  };
+  bool has_bias() const {
+    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
+  }
+  bool mutate_has_bias(bool _has_bias) {
+    return SetField<uint8_t>(VT_HAS_BIAS, static_cast<uint8_t>(_has_bias), 0);
+  }
+  bool use_axis() const {
+    return GetField<uint8_t>(VT_USE_AXIS, 0) != 0;
+  }
+  bool mutate_use_axis(bool _use_axis) {
+    return SetField<uint8_t>(VT_USE_AXIS, static_cast<uint8_t>(_use_axis), 0);
+  }
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
+           VerifyField<uint8_t>(verifier, VT_USE_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  FullConnectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FullConnectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<FullConnection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullConnectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FullConnectionBuilder {
+  typedef FullConnection Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_has_bias(bool has_bias) {
+    fbb_.AddElement<uint8_t>(FullConnection::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
+  }
+  void add_use_axis(bool use_axis) {
+    fbb_.AddElement<uint8_t>(FullConnection::VT_USE_AXIS, static_cast<uint8_t>(use_axis), 0);
+  }
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(FullConnection::VT_AXIS, axis, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(FullConnection::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit FullConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FullConnection> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FullConnection>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FullConnection> CreateFullConnection(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool has_bias = false,
+    bool use_axis = false,
+    int64_t axis = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  FullConnectionBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  builder_.add_activation_type(activation_type);
+  builder_.add_use_axis(use_axis);
+  builder_.add_has_bias(has_bias);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<FullConnection> CreateFullConnection(flatbuffers::FlatBufferBuilder &_fbb, const FullConnectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FusedBatchNormT : public flatbuffers::NativeTable {
+  typedef FusedBatchNorm TableType;
+  float epsilon = 0.0001f;
+  float momentum = 0.9f;
+  int64_t mode = 0;
+};
+
+struct FusedBatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FusedBatchNormT NativeTableType;
+  typedef FusedBatchNormBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FusedBatchNormTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_EPSILON = 4,
+    VT_MOMENTUM = 6,
+    VT_MODE = 8
+  };
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.0001f);
+  }
+  bool mutate_epsilon(float _epsilon) {
+    return SetField<float>(VT_EPSILON, _epsilon, 0.0001f);
+  }
+  float momentum() const {
+    return GetField<float>(VT_MOMENTUM, 0.9f);
+  }
+  bool mutate_momentum(float _momentum) {
+    return SetField<float>(VT_MOMENTUM, _momentum, 0.9f);
+  }
+  int64_t mode() const {
+    return GetField<int64_t>(VT_MODE, 0);
+  }
+  bool mutate_mode(int64_t _mode) {
+    return SetField<int64_t>(VT_MODE, _mode, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<float>(verifier, VT_MOMENTUM) &&
+           VerifyField<int64_t>(verifier, VT_MODE) &&
+           verifier.EndTable();
+  }
+  FusedBatchNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FusedBatchNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<FusedBatchNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FusedBatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FusedBatchNormBuilder {
+  typedef FusedBatchNorm Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(FusedBatchNorm::VT_EPSILON, epsilon, 0.0001f);
+  }
+  void add_momentum(float momentum) {
+    fbb_.AddElement<float>(FusedBatchNorm::VT_MOMENTUM, momentum, 0.9f);
+  }
+  void add_mode(int64_t mode) {
+    fbb_.AddElement<int64_t>(FusedBatchNorm::VT_MODE, mode, 0);
+  }
+  explicit FusedBatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FusedBatchNorm> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FusedBatchNorm>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float epsilon = 0.0001f,
+    float momentum = 0.9f,
+    int64_t mode = 0) {
+  FusedBatchNormBuilder builder_(_fbb);
+  builder_.add_mode(mode);
+  builder_.add_momentum(momentum);
+  builder_.add_epsilon(epsilon);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const FusedBatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct GatherT : public flatbuffers::NativeTable {
+  typedef Gather TableType;
+};
+
+struct Gather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GatherT NativeTableType;
+  typedef GatherBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return GatherTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  GatherT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(GatherT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Gather> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct GatherBuilder {
+  typedef Gather Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit GatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Gather> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Gather>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Gather> CreateGather(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  GatherBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Gather> CreateGather(flatbuffers::FlatBufferBuilder &_fbb, const GatherT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct GatherNdT : public flatbuffers::NativeTable {
+  typedef GatherNd TableType;
+};
+
+struct GatherNd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GatherNdT NativeTableType;
+  typedef GatherNdBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return GatherNdTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  GatherNdT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(GatherNdT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<GatherNd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct GatherNdBuilder {
+  typedef GatherNd Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit GatherNdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GatherNd> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GatherNd>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GatherNd> CreateGatherNd(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  GatherNdBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<GatherNd> CreateGatherNd(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct GreaterT : public flatbuffers::NativeTable {
+  typedef Greater TableType;
+};
+
+struct Greater FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GreaterT NativeTableType;
+  typedef GreaterBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return GreaterTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  GreaterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(GreaterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Greater> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct GreaterBuilder {
+  typedef Greater Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit GreaterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Greater> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Greater>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Greater> CreateGreater(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  GreaterBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Greater> CreateGreater(flatbuffers::FlatBufferBuilder &_fbb, const GreaterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct GreaterEqualT : public flatbuffers::NativeTable {
+  typedef GreaterEqual TableType;
+};
+
+struct GreaterEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GreaterEqualT NativeTableType;
+  typedef GreaterEqualBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return GreaterEqualTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  GreaterEqualT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(GreaterEqualT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<GreaterEqual> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct GreaterEqualBuilder {
+  typedef GreaterEqual Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit GreaterEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GreaterEqual> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GreaterEqual>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  GreaterEqualBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct HashtableLookupT : public flatbuffers::NativeTable {
+  typedef HashtableLookup TableType;
+};
+
+struct HashtableLookup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef HashtableLookupT NativeTableType;
+  typedef HashtableLookupBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return HashtableLookupTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  HashtableLookupT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(HashtableLookupT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<HashtableLookup> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableLookupT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct HashtableLookupBuilder {
+  typedef HashtableLookup Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit HashtableLookupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<HashtableLookup> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<HashtableLookup>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<HashtableLookup> CreateHashtableLookup(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  HashtableLookupBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<HashtableLookup> CreateHashtableLookup(flatbuffers::FlatBufferBuilder &_fbb, const HashtableLookupT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct InstanceNormT : public flatbuffers::NativeTable {
+  typedef InstanceNorm TableType;
+  float epsilon = 0.0f;
+};
+
+struct InstanceNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef InstanceNormT NativeTableType;
+  typedef InstanceNormBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return InstanceNormTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_EPSILON = 4
+  };
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.0f);
+  }
+  bool mutate_epsilon(float _epsilon) {
+    return SetField<float>(VT_EPSILON, _epsilon, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           verifier.EndTable();
+  }
+  InstanceNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(InstanceNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<InstanceNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct InstanceNormBuilder {
+  typedef InstanceNorm Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(InstanceNorm::VT_EPSILON, epsilon, 0.0f);
+  }
+  explicit InstanceNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<InstanceNorm> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<InstanceNorm>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<InstanceNorm> CreateInstanceNorm(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float epsilon = 0.0f) {
+  InstanceNormBuilder builder_(_fbb);
+  builder_.add_epsilon(epsilon);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<InstanceNorm> CreateInstanceNorm(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LayerNormFusionT : public flatbuffers::NativeTable {
+  typedef LayerNormFusion TableType;
+  int64_t begin_norm_axis = 0;
+  float epsilon = 0.00001f;
+  bool elementwise_affine = false;
+  int64_t begin_params_axis = 0;
+};
+
+struct LayerNormFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LayerNormFusionT NativeTableType;
+  typedef LayerNormFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LayerNormFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BEGIN_NORM_AXIS = 4,
+    VT_EPSILON = 6,
+    VT_ELEMENTWISE_AFFINE = 8,
+    VT_BEGIN_PARAMS_AXIS = 10
+  };
+  int64_t begin_norm_axis() const {
+    return GetField<int64_t>(VT_BEGIN_NORM_AXIS, 0);
+  }
+  bool mutate_begin_norm_axis(int64_t _begin_norm_axis) {
+    return SetField<int64_t>(VT_BEGIN_NORM_AXIS, _begin_norm_axis, 0);
+  }
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.00001f);
+  }
+  bool mutate_epsilon(float _epsilon) {
+    return SetField<float>(VT_EPSILON, _epsilon, 0.00001f);
+  }
+  bool elementwise_affine() const {
+    return GetField<uint8_t>(VT_ELEMENTWISE_AFFINE, 0) != 0;
+  }
+  bool mutate_elementwise_affine(bool _elementwise_affine) {
+    return SetField<uint8_t>(VT_ELEMENTWISE_AFFINE, static_cast<uint8_t>(_elementwise_affine), 0);
+  }
+  int64_t begin_params_axis() const {
+    return GetField<int64_t>(VT_BEGIN_PARAMS_AXIS, 0);
+  }
+  bool mutate_begin_params_axis(int64_t _begin_params_axis) {
+    return SetField<int64_t>(VT_BEGIN_PARAMS_AXIS, _begin_params_axis, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_BEGIN_NORM_AXIS) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<uint8_t>(verifier, VT_ELEMENTWISE_AFFINE) &&
+           VerifyField<int64_t>(verifier, VT_BEGIN_PARAMS_AXIS) &&
+           verifier.EndTable();
+  }
+  LayerNormFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LayerNormFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LayerNormFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LayerNormFusionBuilder {
+  typedef LayerNormFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_begin_norm_axis(int64_t begin_norm_axis) {
+    fbb_.AddElement<int64_t>(LayerNormFusion::VT_BEGIN_NORM_AXIS, begin_norm_axis, 0);
+  }
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(LayerNormFusion::VT_EPSILON, epsilon, 0.00001f);
+  }
+  void add_elementwise_affine(bool elementwise_affine) {
+    fbb_.AddElement<uint8_t>(LayerNormFusion::VT_ELEMENTWISE_AFFINE, static_cast<uint8_t>(elementwise_affine), 0);
+  }
+  void add_begin_params_axis(int64_t begin_params_axis) {
+    fbb_.AddElement<int64_t>(LayerNormFusion::VT_BEGIN_PARAMS_AXIS, begin_params_axis, 0);
+  }
+  explicit LayerNormFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LayerNormFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LayerNormFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LayerNormFusion> CreateLayerNormFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t begin_norm_axis = 0,
+    float epsilon = 0.00001f,
+    bool elementwise_affine = false,
+    int64_t begin_params_axis = 0) {
+  LayerNormFusionBuilder builder_(_fbb);
+  builder_.add_begin_params_axis(begin_params_axis);
+  builder_.add_begin_norm_axis(begin_norm_axis);
+  builder_.add_epsilon(epsilon);
+  builder_.add_elementwise_affine(elementwise_affine);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LayerNormFusion> CreateLayerNormFusion(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LeakyReluT : public flatbuffers::NativeTable {
+  typedef LeakyRelu TableType;
+  float negative_slope = 0.0f;
+};
+
+struct LeakyRelu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LeakyReluT NativeTableType;
+  typedef LeakyReluBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LeakyReluTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NEGATIVE_SLOPE = 4
+  };
+  float negative_slope() const {
+    return GetField<float>(VT_NEGATIVE_SLOPE, 0.0f);
+  }
+  bool mutate_negative_slope(float _negative_slope) {
+    return SetField<float>(VT_NEGATIVE_SLOPE, _negative_slope, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_NEGATIVE_SLOPE) &&
+           verifier.EndTable();
+  }
+  LeakyReluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LeakyReluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LeakyRelu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LeakyReluBuilder {
+  typedef LeakyRelu Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_negative_slope(float negative_slope) {
+    fbb_.AddElement<float>(LeakyRelu::VT_NEGATIVE_SLOPE, negative_slope, 0.0f);
+  }
+  explicit LeakyReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LeakyRelu> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LeakyRelu>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LeakyRelu> CreateLeakyRelu(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float negative_slope = 0.0f) {
+  LeakyReluBuilder builder_(_fbb);
+  builder_.add_negative_slope(negative_slope);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LeakyRelu> CreateLeakyRelu(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LessT : public flatbuffers::NativeTable {
+  typedef Less TableType;
+};
+
+struct Less FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LessT NativeTableType;
+  typedef LessBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LessTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  LessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Less> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LessBuilder {
+  typedef Less Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Less> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Less>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Less> CreateLess(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LessBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Less> CreateLess(flatbuffers::FlatBufferBuilder &_fbb, const LessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LessEqualT : public flatbuffers::NativeTable {
+  typedef LessEqual TableType;
+};
+
+struct LessEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LessEqualT NativeTableType;
+  typedef LessEqualBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LessEqualTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  LessEqualT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LessEqualT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LessEqual> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LessEqualBuilder {
+  typedef LessEqual Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LessEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LessEqual> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LessEqual>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LessEqual> CreateLessEqual(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LessEqualBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LessEqual> CreateLessEqual(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LogT : public flatbuffers::NativeTable {
+  typedef Log TableType;
+};
+
+struct Log FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LogT NativeTableType;
+  typedef LogBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LogTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  LogT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LogT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Log> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LogBuilder {
+  typedef Log Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Log> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Log>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Log> CreateLog(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LogBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Log> CreateLog(flatbuffers::FlatBufferBuilder &_fbb, const LogT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LogGradT : public flatbuffers::NativeTable {
+  typedef LogGrad TableType;
+};
+
+struct LogGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LogGradT NativeTableType;
+  typedef LogGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LogGradTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  LogGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LogGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LogGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LogGradBuilder {
+  typedef LogGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LogGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LogGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LogGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LogGrad> CreateLogGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LogGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LogGrad> CreateLogGrad(flatbuffers::FlatBufferBuilder &_fbb, const LogGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LogicalAndT : public flatbuffers::NativeTable {
+  typedef LogicalAnd TableType;
+};
+
+struct LogicalAnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LogicalAndT NativeTableType;
+  typedef LogicalAndBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LogicalAndTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  LogicalAndT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LogicalAndT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LogicalAnd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LogicalAndBuilder {
+  typedef LogicalAnd Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LogicalAndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LogicalAnd> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LogicalAnd>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LogicalAndBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LogicalNotT : public flatbuffers::NativeTable {
+  typedef LogicalNot TableType;
+};
+
+struct LogicalNot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LogicalNotT NativeTableType;
+  typedef LogicalNotBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LogicalNotTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  LogicalNotT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LogicalNotT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LogicalNot> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LogicalNotBuilder {
+  typedef LogicalNot Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LogicalNotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LogicalNot> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LogicalNot>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LogicalNot> CreateLogicalNot(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LogicalNotBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LogicalNot> CreateLogicalNot(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LogicalOrT : public flatbuffers::NativeTable {
+  typedef LogicalOr TableType;
+};
+
+struct LogicalOr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LogicalOrT NativeTableType;
+  typedef LogicalOrBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LogicalOrTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  LogicalOrT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LogicalOrT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LogicalOr> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LogicalOrBuilder {
+  typedef LogicalOr Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LogicalOrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LogicalOr> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LogicalOr>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LogicalOr> CreateLogicalOr(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LogicalOrBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LogicalOr> CreateLogicalOr(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LpNormalizationT : public flatbuffers::NativeTable {
+  typedef LpNormalization TableType;
+  int64_t axis = 0;
+  int64_t p = 0;
+};
+
+struct LpNormalization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LpNormalizationT NativeTableType;
+  typedef LpNormalizationBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LpNormalizationTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4,
+    VT_P = 6
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  int64_t p() const {
+    return GetField<int64_t>(VT_P, 0);
+  }
+  bool mutate_p(int64_t _p) {
+    return SetField<int64_t>(VT_P, _p, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_P) &&
+           verifier.EndTable();
+  }
+  LpNormalizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LpNormalizationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LpNormalization> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LpNormalizationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LpNormalizationBuilder {
+  typedef LpNormalization Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(LpNormalization::VT_AXIS, axis, 0);
+  }
+  void add_p(int64_t p) {
+    fbb_.AddElement<int64_t>(LpNormalization::VT_P, p, 0);
+  }
+  explicit LpNormalizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LpNormalization> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LpNormalization>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LpNormalization> CreateLpNormalization(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0,
+    int64_t p = 0) {
+  LpNormalizationBuilder builder_(_fbb);
+  builder_.add_p(p);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LpNormalization> CreateLpNormalization(flatbuffers::FlatBufferBuilder &_fbb, const LpNormalizationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LRNT : public flatbuffers::NativeTable {
+  typedef LRN TableType;
+  int64_t depth_radius = 0;
+  float bias = 0.0f;
+  float alpha = 0.0f;
+  float beta = 0.0f;
+  std::string norm_region{};
+};
+
+struct LRN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LRNT NativeTableType;
+  typedef LRNBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LRNTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DEPTH_RADIUS = 4,
+    VT_BIAS = 6,
+    VT_ALPHA = 8,
+    VT_BETA = 10,
+    VT_NORM_REGION = 12
+  };
+  int64_t depth_radius() const {
+    return GetField<int64_t>(VT_DEPTH_RADIUS, 0);
+  }
+  bool mutate_depth_radius(int64_t _depth_radius) {
+    return SetField<int64_t>(VT_DEPTH_RADIUS, _depth_radius, 0);
+  }
+  float bias() const {
+    return GetField<float>(VT_BIAS, 0.0f);
+  }
+  bool mutate_bias(float _bias) {
+    return SetField<float>(VT_BIAS, _bias, 0.0f);
+  }
+  float alpha() const {
+    return GetField<float>(VT_ALPHA, 0.0f);
+  }
+  bool mutate_alpha(float _alpha) {
+    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
+  }
+  float beta() const {
+    return GetField<float>(VT_BETA, 0.0f);
+  }
+  bool mutate_beta(float _beta) {
+    return SetField<float>(VT_BETA, _beta, 0.0f);
+  }
+  const flatbuffers::String *norm_region() const {
+    return GetPointer<const flatbuffers::String *>(VT_NORM_REGION);
+  }
+  flatbuffers::String *mutable_norm_region() {
+    return GetPointer<flatbuffers::String *>(VT_NORM_REGION);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_DEPTH_RADIUS) &&
+           VerifyField<float>(verifier, VT_BIAS) &&
+           VerifyField<float>(verifier, VT_ALPHA) &&
+           VerifyField<float>(verifier, VT_BETA) &&
+           VerifyOffset(verifier, VT_NORM_REGION) &&
+           verifier.VerifyString(norm_region()) &&
+           verifier.EndTable();
+  }
+  LRNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LRNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LRN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LRNBuilder {
+  typedef LRN Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_depth_radius(int64_t depth_radius) {
+    fbb_.AddElement<int64_t>(LRN::VT_DEPTH_RADIUS, depth_radius, 0);
+  }
+  void add_bias(float bias) {
+    fbb_.AddElement<float>(LRN::VT_BIAS, bias, 0.0f);
+  }
+  void add_alpha(float alpha) {
+    fbb_.AddElement<float>(LRN::VT_ALPHA, alpha, 0.0f);
+  }
+  void add_beta(float beta) {
+    fbb_.AddElement<float>(LRN::VT_BETA, beta, 0.0f);
+  }
+  void add_norm_region(flatbuffers::Offset<flatbuffers::String> norm_region) {
+    fbb_.AddOffset(LRN::VT_NORM_REGION, norm_region);
+  }
+  explicit LRNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LRN> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LRN>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LRN> CreateLRN(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t depth_radius = 0,
+    float bias = 0.0f,
+    float alpha = 0.0f,
+    float beta = 0.0f,
+    flatbuffers::Offset<flatbuffers::String> norm_region = 0) {
+  LRNBuilder builder_(_fbb);
+  builder_.add_depth_radius(depth_radius);
+  builder_.add_norm_region(norm_region);
+  builder_.add_beta(beta);
+  builder_.add_alpha(alpha);
+  builder_.add_bias(bias);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<LRN> CreateLRNDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t depth_radius = 0,
+    float bias = 0.0f,
+    float alpha = 0.0f,
+    float beta = 0.0f,
+    const char *norm_region = nullptr) {
+  auto norm_region__ = norm_region ? _fbb.CreateString(norm_region) : 0;
+  return mindspore::schema::CreateLRN(
+      _fbb,
+      depth_radius,
+      bias,
+      alpha,
+      beta,
+      norm_region__);
+}
+
+flatbuffers::Offset<LRN> CreateLRN(flatbuffers::FlatBufferBuilder &_fbb, const LRNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LshProjectionT : public flatbuffers::NativeTable {
+  typedef LshProjection TableType;
+  mindspore::schema::LshProjectionType type = mindspore::schema::LshProjectionType_UNKNOWN;
+};
+
+struct LshProjection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LshProjectionT NativeTableType;
+  typedef LshProjectionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LshProjectionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_TYPE = 4
+  };
+  mindspore::schema::LshProjectionType type() const {
+    return static_cast<mindspore::schema::LshProjectionType>(GetField<int8_t>(VT_TYPE, 0));
+  }
+  bool mutate_type(mindspore::schema::LshProjectionType _type) {
+    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_TYPE) &&
+           verifier.EndTable();
+  }
+  LshProjectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LshProjectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LshProjection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LshProjectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LshProjectionBuilder {
+  typedef LshProjection Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_type(mindspore::schema::LshProjectionType type) {
+    fbb_.AddElement<int8_t>(LshProjection::VT_TYPE, static_cast<int8_t>(type), 0);
+  }
+  explicit LshProjectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LshProjection> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LshProjection>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LshProjection> CreateLshProjection(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::LshProjectionType type = mindspore::schema::LshProjectionType_UNKNOWN) {
+  LshProjectionBuilder builder_(_fbb);
+  builder_.add_type(type);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LshProjection> CreateLshProjection(flatbuffers::FlatBufferBuilder &_fbb, const LshProjectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LSTMT : public flatbuffers::NativeTable {
+  typedef LSTM TableType;
+  bool bidirectional = false;
+  bool has_bias = false;
+  int64_t input_size = 0;
+  int64_t hidden_size = 0;
+  int64_t num_layers = 0;
+  int64_t num_directions = 0;
+  float dropout = 0.0f;
+  float zoneout_cell = 0.0f;
+  float zoneout_hidden = 0.0f;
+};
+
+struct LSTM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LSTMT NativeTableType;
+  typedef LSTMBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LSTMTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BIDIRECTIONAL = 4,
+    VT_HAS_BIAS = 6,
+    VT_INPUT_SIZE = 8,
+    VT_HIDDEN_SIZE = 10,
+    VT_NUM_LAYERS = 12,
+    VT_NUM_DIRECTIONS = 14,
+    VT_DROPOUT = 16,
+    VT_ZONEOUT_CELL = 18,
+    VT_ZONEOUT_HIDDEN = 20
+  };
+  bool bidirectional() const {
+    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
+  }
+  bool mutate_bidirectional(bool _bidirectional) {
+    return SetField<uint8_t>(VT_BIDIRECTIONAL, static_cast<uint8_t>(_bidirectional), 0);
+  }
+  bool has_bias() const {
+    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
+  }
+  bool mutate_has_bias(bool _has_bias) {
+    return SetField<uint8_t>(VT_HAS_BIAS, static_cast<uint8_t>(_has_bias), 0);
+  }
+  int64_t input_size() const {
+    return GetField<int64_t>(VT_INPUT_SIZE, 0);
+  }
+  bool mutate_input_size(int64_t _input_size) {
+    return SetField<int64_t>(VT_INPUT_SIZE, _input_size, 0);
+  }
+  int64_t hidden_size() const {
+    return GetField<int64_t>(VT_HIDDEN_SIZE, 0);
+  }
+  bool mutate_hidden_size(int64_t _hidden_size) {
+    return SetField<int64_t>(VT_HIDDEN_SIZE, _hidden_size, 0);
+  }
+  int64_t num_layers() const {
+    return GetField<int64_t>(VT_NUM_LAYERS, 0);
+  }
+  bool mutate_num_layers(int64_t _num_layers) {
+    return SetField<int64_t>(VT_NUM_LAYERS, _num_layers, 0);
+  }
+  int64_t num_directions() const {
+    return GetField<int64_t>(VT_NUM_DIRECTIONS, 0);
+  }
+  bool mutate_num_directions(int64_t _num_directions) {
+    return SetField<int64_t>(VT_NUM_DIRECTIONS, _num_directions, 0);
+  }
+  float dropout() const {
+    return GetField<float>(VT_DROPOUT, 0.0f);
+  }
+  bool mutate_dropout(float _dropout) {
+    return SetField<float>(VT_DROPOUT, _dropout, 0.0f);
+  }
+  float zoneout_cell() const {
+    return GetField<float>(VT_ZONEOUT_CELL, 0.0f);
+  }
+  bool mutate_zoneout_cell(float _zoneout_cell) {
+    return SetField<float>(VT_ZONEOUT_CELL, _zoneout_cell, 0.0f);
+  }
+  float zoneout_hidden() const {
+    return GetField<float>(VT_ZONEOUT_HIDDEN, 0.0f);
+  }
+  bool mutate_zoneout_hidden(float _zoneout_hidden) {
+    return SetField<float>(VT_ZONEOUT_HIDDEN, _zoneout_hidden, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
+           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_HIDDEN_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_NUM_LAYERS) &&
+           VerifyField<int64_t>(verifier, VT_NUM_DIRECTIONS) &&
+           VerifyField<float>(verifier, VT_DROPOUT) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_CELL) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_HIDDEN) &&
+           verifier.EndTable();
+  }
+  LSTMT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LSTMT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LSTM> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LSTMBuilder {
+  typedef LSTM Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_bidirectional(bool bidirectional) {
+    fbb_.AddElement<uint8_t>(LSTM::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
+  }
+  void add_has_bias(bool has_bias) {
+    fbb_.AddElement<uint8_t>(LSTM::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
+  }
+  void add_input_size(int64_t input_size) {
+    fbb_.AddElement<int64_t>(LSTM::VT_INPUT_SIZE, input_size, 0);
+  }
+  void add_hidden_size(int64_t hidden_size) {
+    fbb_.AddElement<int64_t>(LSTM::VT_HIDDEN_SIZE, hidden_size, 0);
+  }
+  void add_num_layers(int64_t num_layers) {
+    fbb_.AddElement<int64_t>(LSTM::VT_NUM_LAYERS, num_layers, 0);
+  }
+  void add_num_directions(int64_t num_directions) {
+    fbb_.AddElement<int64_t>(LSTM::VT_NUM_DIRECTIONS, num_directions, 0);
+  }
+  void add_dropout(float dropout) {
+    fbb_.AddElement<float>(LSTM::VT_DROPOUT, dropout, 0.0f);
+  }
+  void add_zoneout_cell(float zoneout_cell) {
+    fbb_.AddElement<float>(LSTM::VT_ZONEOUT_CELL, zoneout_cell, 0.0f);
+  }
+  void add_zoneout_hidden(float zoneout_hidden) {
+    fbb_.AddElement<float>(LSTM::VT_ZONEOUT_HIDDEN, zoneout_hidden, 0.0f);
+  }
+  explicit LSTMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LSTM> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LSTM>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LSTM> CreateLSTM(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool bidirectional = false,
+    bool has_bias = false,
+    int64_t input_size = 0,
+    int64_t hidden_size = 0,
+    int64_t num_layers = 0,
+    int64_t num_directions = 0,
+    float dropout = 0.0f,
+    float zoneout_cell = 0.0f,
+    float zoneout_hidden = 0.0f) {
+  LSTMBuilder builder_(_fbb);
+  builder_.add_num_directions(num_directions);
+  builder_.add_num_layers(num_layers);
+  builder_.add_hidden_size(hidden_size);
+  builder_.add_input_size(input_size);
+  builder_.add_zoneout_hidden(zoneout_hidden);
+  builder_.add_zoneout_cell(zoneout_cell);
+  builder_.add_dropout(dropout);
+  builder_.add_has_bias(has_bias);
+  builder_.add_bidirectional(bidirectional);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LSTM> CreateLSTM(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LSTMGradT : public flatbuffers::NativeTable {
+  typedef LSTMGrad TableType;
+  bool bidirectional = false;
+  bool has_bias = false;
+  int64_t input_size = 0;
+  int64_t hidden_size = 0;
+  int64_t num_layers = 0;
+  int64_t num_directions = 0;
+  float dropout = 0.0f;
+  float zoneout_cell = 0.0f;
+  float zoneout_hidden = 0.0f;
+};
+
+struct LSTMGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LSTMGradT NativeTableType;
+  typedef LSTMGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LSTMGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BIDIRECTIONAL = 4,
+    VT_HAS_BIAS = 6,
+    VT_INPUT_SIZE = 8,
+    VT_HIDDEN_SIZE = 10,
+    VT_NUM_LAYERS = 12,
+    VT_NUM_DIRECTIONS = 14,
+    VT_DROPOUT = 16,
+    VT_ZONEOUT_CELL = 18,
+    VT_ZONEOUT_HIDDEN = 20
+  };
+  bool bidirectional() const {
+    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
+  }
+  bool mutate_bidirectional(bool _bidirectional) {
+    return SetField<uint8_t>(VT_BIDIRECTIONAL, static_cast<uint8_t>(_bidirectional), 0);
+  }
+  bool has_bias() const {
+    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
+  }
+  bool mutate_has_bias(bool _has_bias) {
+    return SetField<uint8_t>(VT_HAS_BIAS, static_cast<uint8_t>(_has_bias), 0);
+  }
+  int64_t input_size() const {
+    return GetField<int64_t>(VT_INPUT_SIZE, 0);
+  }
+  bool mutate_input_size(int64_t _input_size) {
+    return SetField<int64_t>(VT_INPUT_SIZE, _input_size, 0);
+  }
+  int64_t hidden_size() const {
+    return GetField<int64_t>(VT_HIDDEN_SIZE, 0);
+  }
+  bool mutate_hidden_size(int64_t _hidden_size) {
+    return SetField<int64_t>(VT_HIDDEN_SIZE, _hidden_size, 0);
+  }
+  int64_t num_layers() const {
+    return GetField<int64_t>(VT_NUM_LAYERS, 0);
+  }
+  bool mutate_num_layers(int64_t _num_layers) {
+    return SetField<int64_t>(VT_NUM_LAYERS, _num_layers, 0);
+  }
+  int64_t num_directions() const {
+    return GetField<int64_t>(VT_NUM_DIRECTIONS, 0);
+  }
+  bool mutate_num_directions(int64_t _num_directions) {
+    return SetField<int64_t>(VT_NUM_DIRECTIONS, _num_directions, 0);
+  }
+  float dropout() const {
+    return GetField<float>(VT_DROPOUT, 0.0f);
+  }
+  bool mutate_dropout(float _dropout) {
+    return SetField<float>(VT_DROPOUT, _dropout, 0.0f);
+  }
+  float zoneout_cell() const {
+    return GetField<float>(VT_ZONEOUT_CELL, 0.0f);
+  }
+  bool mutate_zoneout_cell(float _zoneout_cell) {
+    return SetField<float>(VT_ZONEOUT_CELL, _zoneout_cell, 0.0f);
+  }
+  float zoneout_hidden() const {
+    return GetField<float>(VT_ZONEOUT_HIDDEN, 0.0f);
+  }
+  bool mutate_zoneout_hidden(float _zoneout_hidden) {
+    return SetField<float>(VT_ZONEOUT_HIDDEN, _zoneout_hidden, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
+           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_HIDDEN_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_NUM_LAYERS) &&
+           VerifyField<int64_t>(verifier, VT_NUM_DIRECTIONS) &&
+           VerifyField<float>(verifier, VT_DROPOUT) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_CELL) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_HIDDEN) &&
+           verifier.EndTable();
+  }
+  LSTMGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LSTMGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LSTMGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LSTMGradBuilder {
+  typedef LSTMGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_bidirectional(bool bidirectional) {
+    fbb_.AddElement<uint8_t>(LSTMGrad::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
+  }
+  void add_has_bias(bool has_bias) {
+    fbb_.AddElement<uint8_t>(LSTMGrad::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
+  }
+  void add_input_size(int64_t input_size) {
+    fbb_.AddElement<int64_t>(LSTMGrad::VT_INPUT_SIZE, input_size, 0);
+  }
+  void add_hidden_size(int64_t hidden_size) {
+    fbb_.AddElement<int64_t>(LSTMGrad::VT_HIDDEN_SIZE, hidden_size, 0);
+  }
+  void add_num_layers(int64_t num_layers) {
+    fbb_.AddElement<int64_t>(LSTMGrad::VT_NUM_LAYERS, num_layers, 0);
+  }
+  void add_num_directions(int64_t num_directions) {
+    fbb_.AddElement<int64_t>(LSTMGrad::VT_NUM_DIRECTIONS, num_directions, 0);
+  }
+  void add_dropout(float dropout) {
+    fbb_.AddElement<float>(LSTMGrad::VT_DROPOUT, dropout, 0.0f);
+  }
+  void add_zoneout_cell(float zoneout_cell) {
+    fbb_.AddElement<float>(LSTMGrad::VT_ZONEOUT_CELL, zoneout_cell, 0.0f);
+  }
+  void add_zoneout_hidden(float zoneout_hidden) {
+    fbb_.AddElement<float>(LSTMGrad::VT_ZONEOUT_HIDDEN, zoneout_hidden, 0.0f);
+  }
+  explicit LSTMGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LSTMGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LSTMGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LSTMGrad> CreateLSTMGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool bidirectional = false,
+    bool has_bias = false,
+    int64_t input_size = 0,
+    int64_t hidden_size = 0,
+    int64_t num_layers = 0,
+    int64_t num_directions = 0,
+    float dropout = 0.0f,
+    float zoneout_cell = 0.0f,
+    float zoneout_hidden = 0.0f) {
+  LSTMGradBuilder builder_(_fbb);
+  builder_.add_num_directions(num_directions);
+  builder_.add_num_layers(num_layers);
+  builder_.add_hidden_size(hidden_size);
+  builder_.add_input_size(input_size);
+  builder_.add_zoneout_hidden(zoneout_hidden);
+  builder_.add_zoneout_cell(zoneout_cell);
+  builder_.add_dropout(dropout);
+  builder_.add_has_bias(has_bias);
+  builder_.add_bidirectional(bidirectional);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LSTMGrad> CreateLSTMGrad(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct L2NormalizeFusionT : public flatbuffers::NativeTable {
+  typedef L2NormalizeFusion TableType;
+  std::vector<int64_t> axis{};
+  float epsilon = 0.0f;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct L2NormalizeFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef L2NormalizeFusionT NativeTableType;
+  typedef L2NormalizeFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return L2NormalizeFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4,
+    VT_EPSILON = 6,
+    VT_ACTIVATION_TYPE = 8
+  };
+  const flatbuffers::Vector<int64_t> *axis() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  flatbuffers::Vector<int64_t> *mutable_axis() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.0f);
+  }
+  bool mutate_epsilon(float _epsilon) {
+    return SetField<float>(VT_EPSILON, _epsilon, 0.0f);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_AXIS) &&
+           verifier.VerifyVector(axis()) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  L2NormalizeFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(L2NormalizeFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<L2NormalizeFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormalizeFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct L2NormalizeFusionBuilder {
+  typedef L2NormalizeFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
+    fbb_.AddOffset(L2NormalizeFusion::VT_AXIS, axis);
+  }
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(L2NormalizeFusion::VT_EPSILON, epsilon, 0.0f);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(L2NormalizeFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit L2NormalizeFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<L2NormalizeFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<L2NormalizeFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<L2NormalizeFusion> CreateL2NormalizeFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0,
+    float epsilon = 0.0f,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  L2NormalizeFusionBuilder builder_(_fbb);
+  builder_.add_epsilon(epsilon);
+  builder_.add_axis(axis);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<L2NormalizeFusion> CreateL2NormalizeFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *axis = nullptr,
+    float epsilon = 0.0f,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
+  return mindspore::schema::CreateL2NormalizeFusion(
+      _fbb,
+      axis__,
+      epsilon,
+      activation_type);
+}
+
+flatbuffers::Offset<L2NormalizeFusion> CreateL2NormalizeFusion(flatbuffers::FlatBufferBuilder &_fbb, const L2NormalizeFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct MatMulFusionT : public flatbuffers::NativeTable {
+  typedef MatMulFusion TableType;
+  bool transpose_a = false;
+  bool transpose_b = false;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct MatMulFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MatMulFusionT NativeTableType;
+  typedef MatMulFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return MatMulFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_TRANSPOSE_A = 4,
+    VT_TRANSPOSE_B = 6,
+    VT_ACTIVATION_TYPE = 8
+  };
+  bool transpose_a() const {
+    return GetField<uint8_t>(VT_TRANSPOSE_A, 0) != 0;
+  }
+  bool mutate_transpose_a(bool _transpose_a) {
+    return SetField<uint8_t>(VT_TRANSPOSE_A, static_cast<uint8_t>(_transpose_a), 0);
+  }
+  bool transpose_b() const {
+    return GetField<uint8_t>(VT_TRANSPOSE_B, 0) != 0;
+  }
+  bool mutate_transpose_b(bool _transpose_b) {
+    return SetField<uint8_t>(VT_TRANSPOSE_B, static_cast<uint8_t>(_transpose_b), 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_A) &&
+           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_B) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  MatMulFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(MatMulFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<MatMulFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatMulFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct MatMulFusionBuilder {
+  typedef MatMulFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_transpose_a(bool transpose_a) {
+    fbb_.AddElement<uint8_t>(MatMulFusion::VT_TRANSPOSE_A, static_cast<uint8_t>(transpose_a), 0);
+  }
+  void add_transpose_b(bool transpose_b) {
+    fbb_.AddElement<uint8_t>(MatMulFusion::VT_TRANSPOSE_B, static_cast<uint8_t>(transpose_b), 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(MatMulFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit MatMulFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MatMulFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MatMulFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MatMulFusion> CreateMatMulFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool transpose_a = false,
+    bool transpose_b = false,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  MatMulFusionBuilder builder_(_fbb);
+  builder_.add_activation_type(activation_type);
+  builder_.add_transpose_b(transpose_b);
+  builder_.add_transpose_a(transpose_a);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<MatMulFusion> CreateMatMulFusion(flatbuffers::FlatBufferBuilder &_fbb, const MatMulFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct MaximumT : public flatbuffers::NativeTable {
+  typedef Maximum TableType;
+};
+
+struct Maximum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MaximumT NativeTableType;
+  typedef MaximumBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return MaximumTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  MaximumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(MaximumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Maximum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct MaximumBuilder {
+  typedef Maximum Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit MaximumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Maximum> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Maximum>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Maximum> CreateMaximum(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  MaximumBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Maximum> CreateMaximum(flatbuffers::FlatBufferBuilder &_fbb, const MaximumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct MaximumGradT : public flatbuffers::NativeTable {
+  typedef MaximumGrad TableType;
+  bool grad_x = false;
+  bool grad_y = false;
+};
+
+struct MaximumGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MaximumGradT NativeTableType;
+  typedef MaximumGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return MaximumGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_GRAD_X = 4,
+    VT_GRAD_Y = 6
+  };
+  bool grad_x() const {
+    return GetField<uint8_t>(VT_GRAD_X, 0) != 0;
+  }
+  bool mutate_grad_x(bool _grad_x) {
+    return SetField<uint8_t>(VT_GRAD_X, static_cast<uint8_t>(_grad_x), 0);
+  }
+  bool grad_y() const {
+    return GetField<uint8_t>(VT_GRAD_Y, 0) != 0;
+  }
+  bool mutate_grad_y(bool _grad_y) {
+    return SetField<uint8_t>(VT_GRAD_Y, static_cast<uint8_t>(_grad_y), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_GRAD_X) &&
+           VerifyField<uint8_t>(verifier, VT_GRAD_Y) &&
+           verifier.EndTable();
+  }
+  MaximumGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(MaximumGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<MaximumGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct MaximumGradBuilder {
+  typedef MaximumGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_grad_x(bool grad_x) {
+    fbb_.AddElement<uint8_t>(MaximumGrad::VT_GRAD_X, static_cast<uint8_t>(grad_x), 0);
+  }
+  void add_grad_y(bool grad_y) {
+    fbb_.AddElement<uint8_t>(MaximumGrad::VT_GRAD_Y, static_cast<uint8_t>(grad_y), 0);
+  }
+  explicit MaximumGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MaximumGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MaximumGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MaximumGrad> CreateMaximumGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool grad_x = false,
+    bool grad_y = false) {
+  MaximumGradBuilder builder_(_fbb);
+  builder_.add_grad_y(grad_y);
+  builder_.add_grad_x(grad_x);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<MaximumGrad> CreateMaximumGrad(flatbuffers::FlatBufferBuilder &_fbb, const MaximumGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct MaxPoolFusionT : public flatbuffers::NativeTable {
+  typedef MaxPoolFusion TableType;
+  std::vector<int64_t> kernel_size{};
+  std::vector<int64_t> strides{};
+  std::vector<int64_t> pad{};
+  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
+  mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  bool global = false;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct MaxPoolFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MaxPoolFusionT NativeTableType;
+  typedef MaxPoolFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return MaxPoolFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KERNEL_SIZE = 4,
+    VT_STRIDES = 6,
+    VT_PAD = 8,
+    VT_PAD_MODE = 10,
+    VT_ROUND_MODE = 12,
+    VT_FORMAT = 14,
+    VT_GLOBAL = 16,
+    VT_ACTIVATION_TYPE = 18
+  };
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *strides() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
+  }
+  flatbuffers::Vector<int64_t> *mutable_strides() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDES);
+  }
+  const flatbuffers::Vector<int64_t> *pad() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  flatbuffers::Vector<int64_t> *mutable_pad() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
+    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
+  }
+  mindspore::schema::RoundMode round_mode() const {
+    return static_cast<mindspore::schema::RoundMode>(GetField<int8_t>(VT_ROUND_MODE, 0));
+  }
+  bool mutate_round_mode(mindspore::schema::RoundMode _round_mode) {
+    return SetField<int8_t>(VT_ROUND_MODE, static_cast<int8_t>(_round_mode), 0);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  bool global() const {
+    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
+  }
+  bool mutate_global(bool _global) {
+    return SetField<uint8_t>(VT_GLOBAL, static_cast<uint8_t>(_global), 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDES) &&
+           verifier.VerifyVector(strides()) &&
+           VerifyOffset(verifier, VT_PAD) &&
+           verifier.VerifyVector(pad()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyField<int8_t>(verifier, VT_ROUND_MODE) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  MaxPoolFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(MaxPoolFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<MaxPoolFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct MaxPoolFusionBuilder {
+  typedef MaxPoolFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(MaxPoolFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
+    fbb_.AddOffset(MaxPoolFusion::VT_STRIDES, strides);
+  }
+  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
+    fbb_.AddOffset(MaxPoolFusion::VT_PAD, pad);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(MaxPoolFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_round_mode(mindspore::schema::RoundMode round_mode) {
+    fbb_.AddElement<int8_t>(MaxPoolFusion::VT_ROUND_MODE, static_cast<int8_t>(round_mode), 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(MaxPoolFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_global(bool global) {
+    fbb_.AddElement<uint8_t>(MaxPoolFusion::VT_GLOBAL, static_cast<uint8_t>(global), 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(MaxPoolFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit MaxPoolFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MaxPoolFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MaxPoolFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MaxPoolFusion> CreateMaxPoolFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    bool global = false,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  MaxPoolFusionBuilder builder_(_fbb);
+  builder_.add_format(format);
+  builder_.add_pad(pad);
+  builder_.add_strides(strides);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_activation_type(activation_type);
+  builder_.add_global(global);
+  builder_.add_round_mode(round_mode);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<MaxPoolFusion> CreateMaxPoolFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *strides = nullptr,
+    const std::vector<int64_t> *pad = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    bool global = false,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
+  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
+  return mindspore::schema::CreateMaxPoolFusion(
+      _fbb,
+      kernel_size__,
+      strides__,
+      pad__,
+      pad_mode,
+      round_mode,
+      format,
+      global,
+      activation_type);
+}
+
+flatbuffers::Offset<MaxPoolFusion> CreateMaxPoolFusion(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct MaxPoolGradT : public flatbuffers::NativeTable {
+  typedef MaxPoolGrad TableType;
+  std::vector<int64_t> kernel_size{};
+  std::vector<int64_t> strides{};
+  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+};
+
+struct MaxPoolGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MaxPoolGradT NativeTableType;
+  typedef MaxPoolGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return MaxPoolGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KERNEL_SIZE = 4,
+    VT_STRIDES = 6,
+    VT_PAD_MODE = 8,
+    VT_FORMAT = 10
+  };
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *strides() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
+  }
+  flatbuffers::Vector<int64_t> *mutable_strides() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDES);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
+    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDES) &&
+           verifier.VerifyVector(strides()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           verifier.EndTable();
+  }
+  MaxPoolGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(MaxPoolGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<MaxPoolGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct MaxPoolGradBuilder {
+  typedef MaxPoolGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(MaxPoolGrad::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
+    fbb_.AddOffset(MaxPoolGrad::VT_STRIDES, strides);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(MaxPoolGrad::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(MaxPoolGrad::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  explicit MaxPoolGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MaxPoolGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MaxPoolGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MaxPoolGrad> CreateMaxPoolGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  MaxPoolGradBuilder builder_(_fbb);
+  builder_.add_format(format);
+  builder_.add_strides(strides);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<MaxPoolGrad> CreateMaxPoolGradDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *strides = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
+  return mindspore::schema::CreateMaxPoolGrad(
+      _fbb,
+      kernel_size__,
+      strides__,
+      pad_mode,
+      format);
+}
+
+flatbuffers::Offset<MaxPoolGrad> CreateMaxPoolGrad(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SwitchLayerT : public flatbuffers::NativeTable {
+  typedef SwitchLayer TableType;
+};
+
+struct SwitchLayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SwitchLayerT NativeTableType;
+  typedef SwitchLayerBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SwitchLayerTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SwitchLayerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SwitchLayerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SwitchLayer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwitchLayerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SwitchLayerBuilder {
+  typedef SwitchLayer Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SwitchLayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SwitchLayer> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SwitchLayer>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SwitchLayer> CreateSwitchLayer(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SwitchLayerBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SwitchLayer> CreateSwitchLayer(flatbuffers::FlatBufferBuilder &_fbb, const SwitchLayerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct MfccT : public flatbuffers::NativeTable {
+  typedef Mfcc TableType;
+  float freq_upper_limit = 0.0f;
+  float freq_lower_limit = 0.0f;
+  int64_t filter_bank_channel_num = 0;
+  int64_t dct_coeff_num = 0;
+};
+
+struct Mfcc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MfccT NativeTableType;
+  typedef MfccBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return MfccTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FREQ_UPPER_LIMIT = 4,
+    VT_FREQ_LOWER_LIMIT = 6,
+    VT_FILTER_BANK_CHANNEL_NUM = 8,
+    VT_DCT_COEFF_NUM = 10
+  };
+  float freq_upper_limit() const {
+    return GetField<float>(VT_FREQ_UPPER_LIMIT, 0.0f);
+  }
+  bool mutate_freq_upper_limit(float _freq_upper_limit) {
+    return SetField<float>(VT_FREQ_UPPER_LIMIT, _freq_upper_limit, 0.0f);
+  }
+  float freq_lower_limit() const {
+    return GetField<float>(VT_FREQ_LOWER_LIMIT, 0.0f);
+  }
+  bool mutate_freq_lower_limit(float _freq_lower_limit) {
+    return SetField<float>(VT_FREQ_LOWER_LIMIT, _freq_lower_limit, 0.0f);
+  }
+  int64_t filter_bank_channel_num() const {
+    return GetField<int64_t>(VT_FILTER_BANK_CHANNEL_NUM, 0);
+  }
+  bool mutate_filter_bank_channel_num(int64_t _filter_bank_channel_num) {
+    return SetField<int64_t>(VT_FILTER_BANK_CHANNEL_NUM, _filter_bank_channel_num, 0);
+  }
+  int64_t dct_coeff_num() const {
+    return GetField<int64_t>(VT_DCT_COEFF_NUM, 0);
+  }
+  bool mutate_dct_coeff_num(int64_t _dct_coeff_num) {
+    return SetField<int64_t>(VT_DCT_COEFF_NUM, _dct_coeff_num, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_FREQ_UPPER_LIMIT) &&
+           VerifyField<float>(verifier, VT_FREQ_LOWER_LIMIT) &&
+           VerifyField<int64_t>(verifier, VT_FILTER_BANK_CHANNEL_NUM) &&
+           VerifyField<int64_t>(verifier, VT_DCT_COEFF_NUM) &&
+           verifier.EndTable();
+  }
+  MfccT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(MfccT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Mfcc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MfccT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct MfccBuilder {
+  typedef Mfcc Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_freq_upper_limit(float freq_upper_limit) {
+    fbb_.AddElement<float>(Mfcc::VT_FREQ_UPPER_LIMIT, freq_upper_limit, 0.0f);
+  }
+  void add_freq_lower_limit(float freq_lower_limit) {
+    fbb_.AddElement<float>(Mfcc::VT_FREQ_LOWER_LIMIT, freq_lower_limit, 0.0f);
+  }
+  void add_filter_bank_channel_num(int64_t filter_bank_channel_num) {
+    fbb_.AddElement<int64_t>(Mfcc::VT_FILTER_BANK_CHANNEL_NUM, filter_bank_channel_num, 0);
+  }
+  void add_dct_coeff_num(int64_t dct_coeff_num) {
+    fbb_.AddElement<int64_t>(Mfcc::VT_DCT_COEFF_NUM, dct_coeff_num, 0);
+  }
+  explicit MfccBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Mfcc> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Mfcc>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Mfcc> CreateMfcc(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float freq_upper_limit = 0.0f,
+    float freq_lower_limit = 0.0f,
+    int64_t filter_bank_channel_num = 0,
+    int64_t dct_coeff_num = 0) {
+  MfccBuilder builder_(_fbb);
+  builder_.add_dct_coeff_num(dct_coeff_num);
+  builder_.add_filter_bank_channel_num(filter_bank_channel_num);
+  builder_.add_freq_lower_limit(freq_lower_limit);
+  builder_.add_freq_upper_limit(freq_upper_limit);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Mfcc> CreateMfcc(flatbuffers::FlatBufferBuilder &_fbb, const MfccT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct MinimumT : public flatbuffers::NativeTable {
+  typedef Minimum TableType;
+};
+
+struct Minimum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MinimumT NativeTableType;
+  typedef MinimumBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return MinimumTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  MinimumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(MinimumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Minimum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinimumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct MinimumBuilder {
+  typedef Minimum Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit MinimumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Minimum> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Minimum>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Minimum> CreateMinimum(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  MinimumBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Minimum> CreateMinimum(flatbuffers::FlatBufferBuilder &_fbb, const MinimumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct MinimumGradT : public flatbuffers::NativeTable {
+  typedef MinimumGrad TableType;
+  bool grad_x = false;
+  bool grad_y = false;
+};
+
+struct MinimumGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MinimumGradT NativeTableType;
+  typedef MinimumGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return MinimumGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_GRAD_X = 4,
+    VT_GRAD_Y = 6
+  };
+  bool grad_x() const {
+    return GetField<uint8_t>(VT_GRAD_X, 0) != 0;
+  }
+  bool mutate_grad_x(bool _grad_x) {
+    return SetField<uint8_t>(VT_GRAD_X, static_cast<uint8_t>(_grad_x), 0);
+  }
+  bool grad_y() const {
+    return GetField<uint8_t>(VT_GRAD_Y, 0) != 0;
+  }
+  bool mutate_grad_y(bool _grad_y) {
+    return SetField<uint8_t>(VT_GRAD_Y, static_cast<uint8_t>(_grad_y), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_GRAD_X) &&
+           VerifyField<uint8_t>(verifier, VT_GRAD_Y) &&
+           verifier.EndTable();
+  }
+  MinimumGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(MinimumGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<MinimumGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinimumGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct MinimumGradBuilder {
+  typedef MinimumGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_grad_x(bool grad_x) {
+    fbb_.AddElement<uint8_t>(MinimumGrad::VT_GRAD_X, static_cast<uint8_t>(grad_x), 0);
+  }
+  void add_grad_y(bool grad_y) {
+    fbb_.AddElement<uint8_t>(MinimumGrad::VT_GRAD_Y, static_cast<uint8_t>(grad_y), 0);
+  }
+  explicit MinimumGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MinimumGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MinimumGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MinimumGrad> CreateMinimumGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool grad_x = false,
+    bool grad_y = false) {
+  MinimumGradBuilder builder_(_fbb);
+  builder_.add_grad_y(grad_y);
+  builder_.add_grad_x(grad_x);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<MinimumGrad> CreateMinimumGrad(flatbuffers::FlatBufferBuilder &_fbb, const MinimumGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ModT : public flatbuffers::NativeTable {
+  typedef Mod TableType;
+};
+
+struct Mod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ModT NativeTableType;
+  typedef ModBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ModTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  ModT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ModT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Mod> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ModBuilder {
+  typedef Mod Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Mod> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Mod>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Mod> CreateMod(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ModBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Mod> CreateMod(flatbuffers::FlatBufferBuilder &_fbb, const ModT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct MulFusionT : public flatbuffers::NativeTable {
+  typedef MulFusion TableType;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct MulFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MulFusionT NativeTableType;
+  typedef MulFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return MulFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  MulFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(MulFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<MulFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct MulFusionBuilder {
+  typedef MulFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(MulFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit MulFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MulFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MulFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MulFusion> CreateMulFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  MulFusionBuilder builder_(_fbb);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<MulFusion> CreateMulFusion(flatbuffers::FlatBufferBuilder &_fbb, const MulFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct MulGradT : public flatbuffers::NativeTable {
+  typedef MulGrad TableType;
+};
+
+struct MulGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MulGradT NativeTableType;
+  typedef MulGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return MulGradTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  MulGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(MulGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<MulGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct MulGradBuilder {
+  typedef MulGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit MulGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MulGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MulGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MulGrad> CreateMulGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  MulGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<MulGrad> CreateMulGrad(flatbuffers::FlatBufferBuilder &_fbb, const MulGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct NegT : public flatbuffers::NativeTable {
+  typedef Neg TableType;
+};
+
+struct Neg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NegT NativeTableType;
+  typedef NegBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return NegTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  NegT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(NegT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Neg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct NegBuilder {
+  typedef Neg Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit NegBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Neg> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Neg>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Neg> CreateNeg(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  NegBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Neg> CreateNeg(flatbuffers::FlatBufferBuilder &_fbb, const NegT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct NegGradT : public flatbuffers::NativeTable {
+  typedef NegGrad TableType;
+};
+
+struct NegGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NegGradT NativeTableType;
+  typedef NegGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return NegGradTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  NegGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(NegGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<NegGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct NegGradBuilder {
+  typedef NegGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit NegGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<NegGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<NegGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<NegGrad> CreateNegGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  NegGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<NegGrad> CreateNegGrad(flatbuffers::FlatBufferBuilder &_fbb, const NegGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct NotEqualT : public flatbuffers::NativeTable {
+  typedef NotEqual TableType;
+};
+
+struct NotEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NotEqualT NativeTableType;
+  typedef NotEqualBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return NotEqualTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  NotEqualT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(NotEqualT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<NotEqual> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct NotEqualBuilder {
+  typedef NotEqual Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit NotEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<NotEqual> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<NotEqual>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<NotEqual> CreateNotEqual(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  NotEqualBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<NotEqual> CreateNotEqual(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct NonMaxSuppressionT : public flatbuffers::NativeTable {
+  typedef NonMaxSuppression TableType;
+  int64_t center_point_box = 0;
+};
+
+struct NonMaxSuppression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NonMaxSuppressionT NativeTableType;
+  typedef NonMaxSuppressionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return NonMaxSuppressionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_CENTER_POINT_BOX = 4
+  };
+  int64_t center_point_box() const {
+    return GetField<int64_t>(VT_CENTER_POINT_BOX, 0);
+  }
+  bool mutate_center_point_box(int64_t _center_point_box) {
+    return SetField<int64_t>(VT_CENTER_POINT_BOX, _center_point_box, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_CENTER_POINT_BOX) &&
+           verifier.EndTable();
+  }
+  NonMaxSuppressionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(NonMaxSuppressionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<NonMaxSuppression> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct NonMaxSuppressionBuilder {
+  typedef NonMaxSuppression Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_center_point_box(int64_t center_point_box) {
+    fbb_.AddElement<int64_t>(NonMaxSuppression::VT_CENTER_POINT_BOX, center_point_box, 0);
+  }
+  explicit NonMaxSuppressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<NonMaxSuppression> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<NonMaxSuppression>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<NonMaxSuppression> CreateNonMaxSuppression(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t center_point_box = 0) {
+  NonMaxSuppressionBuilder builder_(_fbb);
+  builder_.add_center_point_box(center_point_box);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<NonMaxSuppression> CreateNonMaxSuppression(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct OneHotT : public flatbuffers::NativeTable {
+  typedef OneHot TableType;
+  int64_t axis = 0;
+};
+
+struct OneHot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef OneHotT NativeTableType;
+  typedef OneHotBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return OneHotTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+  OneHotT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(OneHotT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<OneHot> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct OneHotBuilder {
+  typedef OneHot Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(OneHot::VT_AXIS, axis, 0);
+  }
+  explicit OneHotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<OneHot> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<OneHot>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<OneHot> CreateOneHot(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0) {
+  OneHotBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<OneHot> CreateOneHot(flatbuffers::FlatBufferBuilder &_fbb, const OneHotT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct OnesLikeT : public flatbuffers::NativeTable {
+  typedef OnesLike TableType;
+};
+
+struct OnesLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef OnesLikeT NativeTableType;
+  typedef OnesLikeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return OnesLikeTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  OnesLikeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(OnesLikeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<OnesLike> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OnesLikeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct OnesLikeBuilder {
+  typedef OnesLike Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit OnesLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<OnesLike> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<OnesLike>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<OnesLike> CreateOnesLike(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  OnesLikeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<OnesLike> CreateOnesLike(flatbuffers::FlatBufferBuilder &_fbb, const OnesLikeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct PadFusionT : public flatbuffers::NativeTable {
+  typedef PadFusion TableType;
+  std::unique_ptr<mindspore::schema::Vec2DT> paddings{};
+  mindspore::schema::PaddingMode padding_mode = mindspore::schema::PaddingMode_CONSTANT;
+  float constant_value = 0.0f;
+};
+
+struct PadFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PadFusionT NativeTableType;
+  typedef PadFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return PadFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_PADDINGS = 4,
+    VT_PADDING_MODE = 6,
+    VT_CONSTANT_VALUE = 8
+  };
+  const mindspore::schema::Vec2D *paddings() const {
+    return GetPointer<const mindspore::schema::Vec2D *>(VT_PADDINGS);
+  }
+  mindspore::schema::Vec2D *mutable_paddings() {
+    return GetPointer<mindspore::schema::Vec2D *>(VT_PADDINGS);
+  }
+  mindspore::schema::PaddingMode padding_mode() const {
+    return static_cast<mindspore::schema::PaddingMode>(GetField<int8_t>(VT_PADDING_MODE, 0));
+  }
+  bool mutate_padding_mode(mindspore::schema::PaddingMode _padding_mode) {
+    return SetField<int8_t>(VT_PADDING_MODE, static_cast<int8_t>(_padding_mode), 0);
+  }
+  float constant_value() const {
+    return GetField<float>(VT_CONSTANT_VALUE, 0.0f);
+  }
+  bool mutate_constant_value(float _constant_value) {
+    return SetField<float>(VT_CONSTANT_VALUE, _constant_value, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_PADDINGS) &&
+           verifier.VerifyTable(paddings()) &&
+           VerifyField<int8_t>(verifier, VT_PADDING_MODE) &&
+           VerifyField<float>(verifier, VT_CONSTANT_VALUE) &&
+           verifier.EndTable();
+  }
+  PadFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(PadFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<PadFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct PadFusionBuilder {
+  typedef PadFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_paddings(flatbuffers::Offset<mindspore::schema::Vec2D> paddings) {
+    fbb_.AddOffset(PadFusion::VT_PADDINGS, paddings);
+  }
+  void add_padding_mode(mindspore::schema::PaddingMode padding_mode) {
+    fbb_.AddElement<int8_t>(PadFusion::VT_PADDING_MODE, static_cast<int8_t>(padding_mode), 0);
+  }
+  void add_constant_value(float constant_value) {
+    fbb_.AddElement<float>(PadFusion::VT_CONSTANT_VALUE, constant_value, 0.0f);
+  }
+  explicit PadFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<PadFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<PadFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<PadFusion> CreatePadFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0,
+    mindspore::schema::PaddingMode padding_mode = mindspore::schema::PaddingMode_CONSTANT,
+    float constant_value = 0.0f) {
+  PadFusionBuilder builder_(_fbb);
+  builder_.add_constant_value(constant_value);
+  builder_.add_paddings(paddings);
+  builder_.add_padding_mode(padding_mode);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<PadFusion> CreatePadFusion(flatbuffers::FlatBufferBuilder &_fbb, const PadFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct PartialFusionT : public flatbuffers::NativeTable {
+  typedef PartialFusion TableType;
+  int64_t sub_graph_index = 0;
+};
+
+struct PartialFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PartialFusionT NativeTableType;
+  typedef PartialFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return PartialFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SUB_GRAPH_INDEX = 4
+  };
+  int64_t sub_graph_index() const {
+    return GetField<int64_t>(VT_SUB_GRAPH_INDEX, 0);
+  }
+  bool mutate_sub_graph_index(int64_t _sub_graph_index) {
+    return SetField<int64_t>(VT_SUB_GRAPH_INDEX, _sub_graph_index, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SUB_GRAPH_INDEX) &&
+           verifier.EndTable();
+  }
+  PartialFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(PartialFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<PartialFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartialFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct PartialFusionBuilder {
+  typedef PartialFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_sub_graph_index(int64_t sub_graph_index) {
+    fbb_.AddElement<int64_t>(PartialFusion::VT_SUB_GRAPH_INDEX, sub_graph_index, 0);
+  }
+  explicit PartialFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<PartialFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<PartialFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<PartialFusion> CreatePartialFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t sub_graph_index = 0) {
+  PartialFusionBuilder builder_(_fbb);
+  builder_.add_sub_graph_index(sub_graph_index);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<PartialFusion> CreatePartialFusion(flatbuffers::FlatBufferBuilder &_fbb, const PartialFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct PowerGradT : public flatbuffers::NativeTable {
+  typedef PowerGrad TableType;
+  float power = 0.0f;
+  float scale = 0.0f;
+  float shift = 0.0f;
+};
+
+struct PowerGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PowerGradT NativeTableType;
+  typedef PowerGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return PowerGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_POWER = 4,
+    VT_SCALE = 6,
+    VT_SHIFT = 8
+  };
+  float power() const {
+    return GetField<float>(VT_POWER, 0.0f);
+  }
+  bool mutate_power(float _power) {
+    return SetField<float>(VT_POWER, _power, 0.0f);
+  }
+  float scale() const {
+    return GetField<float>(VT_SCALE, 0.0f);
+  }
+  bool mutate_scale(float _scale) {
+    return SetField<float>(VT_SCALE, _scale, 0.0f);
+  }
+  float shift() const {
+    return GetField<float>(VT_SHIFT, 0.0f);
+  }
+  bool mutate_shift(float _shift) {
+    return SetField<float>(VT_SHIFT, _shift, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_POWER) &&
+           VerifyField<float>(verifier, VT_SCALE) &&
+           VerifyField<float>(verifier, VT_SHIFT) &&
+           verifier.EndTable();
+  }
+  PowerGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(PowerGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<PowerGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowerGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct PowerGradBuilder {
+  typedef PowerGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_power(float power) {
+    fbb_.AddElement<float>(PowerGrad::VT_POWER, power, 0.0f);
+  }
+  void add_scale(float scale) {
+    fbb_.AddElement<float>(PowerGrad::VT_SCALE, scale, 0.0f);
+  }
+  void add_shift(float shift) {
+    fbb_.AddElement<float>(PowerGrad::VT_SHIFT, shift, 0.0f);
+  }
+  explicit PowerGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<PowerGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<PowerGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<PowerGrad> CreatePowerGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float power = 0.0f,
+    float scale = 0.0f,
+    float shift = 0.0f) {
+  PowerGradBuilder builder_(_fbb);
+  builder_.add_shift(shift);
+  builder_.add_scale(scale);
+  builder_.add_power(power);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<PowerGrad> CreatePowerGrad(flatbuffers::FlatBufferBuilder &_fbb, const PowerGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct PowFusionT : public flatbuffers::NativeTable {
+  typedef PowFusion TableType;
+  float scale = 1.0f;
+  float shift = 0.0f;
+};
+
+struct PowFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PowFusionT NativeTableType;
+  typedef PowFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return PowFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SCALE = 4,
+    VT_SHIFT = 6
+  };
+  float scale() const {
+    return GetField<float>(VT_SCALE, 1.0f);
+  }
+  bool mutate_scale(float _scale) {
+    return SetField<float>(VT_SCALE, _scale, 1.0f);
+  }
+  float shift() const {
+    return GetField<float>(VT_SHIFT, 0.0f);
+  }
+  bool mutate_shift(float _shift) {
+    return SetField<float>(VT_SHIFT, _shift, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_SCALE) &&
+           VerifyField<float>(verifier, VT_SHIFT) &&
+           verifier.EndTable();
+  }
+  PowFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(PowFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<PowFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct PowFusionBuilder {
+  typedef PowFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_scale(float scale) {
+    fbb_.AddElement<float>(PowFusion::VT_SCALE, scale, 1.0f);
+  }
+  void add_shift(float shift) {
+    fbb_.AddElement<float>(PowFusion::VT_SHIFT, shift, 0.0f);
+  }
+  explicit PowFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<PowFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<PowFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<PowFusion> CreatePowFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float scale = 1.0f,
+    float shift = 0.0f) {
+  PowFusionBuilder builder_(_fbb);
+  builder_.add_shift(shift);
+  builder_.add_scale(scale);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<PowFusion> CreatePowFusion(flatbuffers::FlatBufferBuilder &_fbb, const PowFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct PriorBoxT : public flatbuffers::NativeTable {
+  typedef PriorBox TableType;
+  std::vector<int64_t> min_sizes{};
+  std::vector<int64_t> max_sizes{};
+  std::vector<float> aspect_ratios{};
+  std::vector<float> variances{};
+  int64_t image_size_w = 0;
+  int64_t image_size_h = 0;
+  float step_w = 0.0f;
+  float step_h = 0.0f;
+  bool clip = false;
+  bool flip = false;
+  float offset = 0.0f;
+};
+
+struct PriorBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PriorBoxT NativeTableType;
+  typedef PriorBoxBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return PriorBoxTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_MIN_SIZES = 4,
+    VT_MAX_SIZES = 6,
+    VT_ASPECT_RATIOS = 8,
+    VT_VARIANCES = 10,
+    VT_IMAGE_SIZE_W = 12,
+    VT_IMAGE_SIZE_H = 14,
+    VT_STEP_W = 16,
+    VT_STEP_H = 18,
+    VT_CLIP = 20,
+    VT_FLIP = 22,
+    VT_OFFSET = 24
+  };
+  const flatbuffers::Vector<int64_t> *min_sizes() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_MIN_SIZES);
+  }
+  flatbuffers::Vector<int64_t> *mutable_min_sizes() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_MIN_SIZES);
+  }
+  const flatbuffers::Vector<int64_t> *max_sizes() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_MAX_SIZES);
+  }
+  flatbuffers::Vector<int64_t> *mutable_max_sizes() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_MAX_SIZES);
+  }
+  const flatbuffers::Vector<float> *aspect_ratios() const {
+    return GetPointer<const flatbuffers::Vector<float> *>(VT_ASPECT_RATIOS);
+  }
+  flatbuffers::Vector<float> *mutable_aspect_ratios() {
+    return GetPointer<flatbuffers::Vector<float> *>(VT_ASPECT_RATIOS);
+  }
+  const flatbuffers::Vector<float> *variances() const {
+    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARIANCES);
+  }
+  flatbuffers::Vector<float> *mutable_variances() {
+    return GetPointer<flatbuffers::Vector<float> *>(VT_VARIANCES);
+  }
+  int64_t image_size_w() const {
+    return GetField<int64_t>(VT_IMAGE_SIZE_W, 0);
+  }
+  bool mutate_image_size_w(int64_t _image_size_w) {
+    return SetField<int64_t>(VT_IMAGE_SIZE_W, _image_size_w, 0);
+  }
+  int64_t image_size_h() const {
+    return GetField<int64_t>(VT_IMAGE_SIZE_H, 0);
+  }
+  bool mutate_image_size_h(int64_t _image_size_h) {
+    return SetField<int64_t>(VT_IMAGE_SIZE_H, _image_size_h, 0);
+  }
+  float step_w() const {
+    return GetField<float>(VT_STEP_W, 0.0f);
+  }
+  bool mutate_step_w(float _step_w) {
+    return SetField<float>(VT_STEP_W, _step_w, 0.0f);
+  }
+  float step_h() const {
+    return GetField<float>(VT_STEP_H, 0.0f);
+  }
+  bool mutate_step_h(float _step_h) {
+    return SetField<float>(VT_STEP_H, _step_h, 0.0f);
+  }
+  bool clip() const {
+    return GetField<uint8_t>(VT_CLIP, 0) != 0;
+  }
+  bool mutate_clip(bool _clip) {
+    return SetField<uint8_t>(VT_CLIP, static_cast<uint8_t>(_clip), 0);
+  }
+  bool flip() const {
+    return GetField<uint8_t>(VT_FLIP, 0) != 0;
+  }
+  bool mutate_flip(bool _flip) {
+    return SetField<uint8_t>(VT_FLIP, static_cast<uint8_t>(_flip), 0);
+  }
+  float offset() const {
+    return GetField<float>(VT_OFFSET, 0.0f);
+  }
+  bool mutate_offset(float _offset) {
+    return SetField<float>(VT_OFFSET, _offset, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_MIN_SIZES) &&
+           verifier.VerifyVector(min_sizes()) &&
+           VerifyOffset(verifier, VT_MAX_SIZES) &&
+           verifier.VerifyVector(max_sizes()) &&
+           VerifyOffset(verifier, VT_ASPECT_RATIOS) &&
+           verifier.VerifyVector(aspect_ratios()) &&
+           VerifyOffset(verifier, VT_VARIANCES) &&
+           verifier.VerifyVector(variances()) &&
+           VerifyField<int64_t>(verifier, VT_IMAGE_SIZE_W) &&
+           VerifyField<int64_t>(verifier, VT_IMAGE_SIZE_H) &&
+           VerifyField<float>(verifier, VT_STEP_W) &&
+           VerifyField<float>(verifier, VT_STEP_H) &&
+           VerifyField<uint8_t>(verifier, VT_CLIP) &&
+           VerifyField<uint8_t>(verifier, VT_FLIP) &&
+           VerifyField<float>(verifier, VT_OFFSET) &&
+           verifier.EndTable();
+  }
+  PriorBoxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(PriorBoxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<PriorBox> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct PriorBoxBuilder {
+  typedef PriorBox Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_min_sizes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> min_sizes) {
+    fbb_.AddOffset(PriorBox::VT_MIN_SIZES, min_sizes);
+  }
+  void add_max_sizes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> max_sizes) {
+    fbb_.AddOffset(PriorBox::VT_MAX_SIZES, max_sizes);
+  }
+  void add_aspect_ratios(flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios) {
+    fbb_.AddOffset(PriorBox::VT_ASPECT_RATIOS, aspect_ratios);
+  }
+  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
+    fbb_.AddOffset(PriorBox::VT_VARIANCES, variances);
+  }
+  void add_image_size_w(int64_t image_size_w) {
+    fbb_.AddElement<int64_t>(PriorBox::VT_IMAGE_SIZE_W, image_size_w, 0);
+  }
+  void add_image_size_h(int64_t image_size_h) {
+    fbb_.AddElement<int64_t>(PriorBox::VT_IMAGE_SIZE_H, image_size_h, 0);
+  }
+  void add_step_w(float step_w) {
+    fbb_.AddElement<float>(PriorBox::VT_STEP_W, step_w, 0.0f);
+  }
+  void add_step_h(float step_h) {
+    fbb_.AddElement<float>(PriorBox::VT_STEP_H, step_h, 0.0f);
+  }
+  void add_clip(bool clip) {
+    fbb_.AddElement<uint8_t>(PriorBox::VT_CLIP, static_cast<uint8_t>(clip), 0);
+  }
+  void add_flip(bool flip) {
+    fbb_.AddElement<uint8_t>(PriorBox::VT_FLIP, static_cast<uint8_t>(flip), 0);
+  }
+  void add_offset(float offset) {
+    fbb_.AddElement<float>(PriorBox::VT_OFFSET, offset, 0.0f);
+  }
+  explicit PriorBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<PriorBox> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<PriorBox>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<PriorBox> CreatePriorBox(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> min_sizes = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> max_sizes = 0,
+    flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios = 0,
+    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
+    int64_t image_size_w = 0,
+    int64_t image_size_h = 0,
+    float step_w = 0.0f,
+    float step_h = 0.0f,
+    bool clip = false,
+    bool flip = false,
+    float offset = 0.0f) {
+  PriorBoxBuilder builder_(_fbb);
+  builder_.add_image_size_h(image_size_h);
+  builder_.add_image_size_w(image_size_w);
+  builder_.add_offset(offset);
+  builder_.add_step_h(step_h);
+  builder_.add_step_w(step_w);
+  builder_.add_variances(variances);
+  builder_.add_aspect_ratios(aspect_ratios);
+  builder_.add_max_sizes(max_sizes);
+  builder_.add_min_sizes(min_sizes);
+  builder_.add_flip(flip);
+  builder_.add_clip(clip);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<PriorBox> CreatePriorBoxDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *min_sizes = nullptr,
+    const std::vector<int64_t> *max_sizes = nullptr,
+    const std::vector<float> *aspect_ratios = nullptr,
+    const std::vector<float> *variances = nullptr,
+    int64_t image_size_w = 0,
+    int64_t image_size_h = 0,
+    float step_w = 0.0f,
+    float step_h = 0.0f,
+    bool clip = false,
+    bool flip = false,
+    float offset = 0.0f) {
+  auto min_sizes__ = min_sizes ? _fbb.CreateVector<int64_t>(*min_sizes) : 0;
+  auto max_sizes__ = max_sizes ? _fbb.CreateVector<int64_t>(*max_sizes) : 0;
+  auto aspect_ratios__ = aspect_ratios ? _fbb.CreateVector<float>(*aspect_ratios) : 0;
+  auto variances__ = variances ? _fbb.CreateVector<float>(*variances) : 0;
+  return mindspore::schema::CreatePriorBox(
+      _fbb,
+      min_sizes__,
+      max_sizes__,
+      aspect_ratios__,
+      variances__,
+      image_size_w,
+      image_size_h,
+      step_w,
+      step_h,
+      clip,
+      flip,
+      offset);
+}
+
+flatbuffers::Offset<PriorBox> CreatePriorBox(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct PReLUFusionT : public flatbuffers::NativeTable {
+  typedef PReLUFusion TableType;
+  bool channel_shared = false;
+};
+
+struct PReLUFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PReLUFusionT NativeTableType;
+  typedef PReLUFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return PReLUFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_CHANNEL_SHARED = 4
+  };
+  bool channel_shared() const {
+    return GetField<uint8_t>(VT_CHANNEL_SHARED, 0) != 0;
+  }
+  bool mutate_channel_shared(bool _channel_shared) {
+    return SetField<uint8_t>(VT_CHANNEL_SHARED, static_cast<uint8_t>(_channel_shared), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_CHANNEL_SHARED) &&
+           verifier.EndTable();
+  }
+  PReLUFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(PReLUFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<PReLUFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReLUFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct PReLUFusionBuilder {
+  typedef PReLUFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_channel_shared(bool channel_shared) {
+    fbb_.AddElement<uint8_t>(PReLUFusion::VT_CHANNEL_SHARED, static_cast<uint8_t>(channel_shared), 0);
+  }
+  explicit PReLUFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<PReLUFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<PReLUFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<PReLUFusion> CreatePReLUFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool channel_shared = false) {
+  PReLUFusionBuilder builder_(_fbb);
+  builder_.add_channel_shared(channel_shared);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<PReLUFusion> CreatePReLUFusion(flatbuffers::FlatBufferBuilder &_fbb, const PReLUFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct RankT : public flatbuffers::NativeTable {
+  typedef Rank TableType;
+};
+
+struct Rank FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RankT NativeTableType;
+  typedef RankBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return RankTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  RankT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(RankT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Rank> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct RankBuilder {
+  typedef Rank Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit RankBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Rank> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Rank>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Rank> CreateRank(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  RankBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Rank> CreateRank(flatbuffers::FlatBufferBuilder &_fbb, const RankT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct RangeT : public flatbuffers::NativeTable {
+  typedef Range TableType;
+  int64_t d_type = 0;
+  int64_t start = 0;
+  int64_t limit = 0;
+  int64_t delta = 1LL;
+};
+
+struct Range FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RangeT NativeTableType;
+  typedef RangeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return RangeTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_D_TYPE = 4,
+    VT_START = 6,
+    VT_LIMIT = 8,
+    VT_DELTA = 10
+  };
+  int64_t d_type() const {
+    return GetField<int64_t>(VT_D_TYPE, 0);
+  }
+  bool mutate_d_type(int64_t _d_type) {
+    return SetField<int64_t>(VT_D_TYPE, _d_type, 0);
+  }
+  int64_t start() const {
+    return GetField<int64_t>(VT_START, 0);
+  }
+  bool mutate_start(int64_t _start) {
+    return SetField<int64_t>(VT_START, _start, 0);
+  }
+  int64_t limit() const {
+    return GetField<int64_t>(VT_LIMIT, 0);
+  }
+  bool mutate_limit(int64_t _limit) {
+    return SetField<int64_t>(VT_LIMIT, _limit, 0);
+  }
+  int64_t delta() const {
+    return GetField<int64_t>(VT_DELTA, 1LL);
+  }
+  bool mutate_delta(int64_t _delta) {
+    return SetField<int64_t>(VT_DELTA, _delta, 1LL);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_D_TYPE) &&
+           VerifyField<int64_t>(verifier, VT_START) &&
+           VerifyField<int64_t>(verifier, VT_LIMIT) &&
+           VerifyField<int64_t>(verifier, VT_DELTA) &&
+           verifier.EndTable();
+  }
+  RangeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(RangeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Range> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct RangeBuilder {
+  typedef Range Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_d_type(int64_t d_type) {
+    fbb_.AddElement<int64_t>(Range::VT_D_TYPE, d_type, 0);
+  }
+  void add_start(int64_t start) {
+    fbb_.AddElement<int64_t>(Range::VT_START, start, 0);
+  }
+  void add_limit(int64_t limit) {
+    fbb_.AddElement<int64_t>(Range::VT_LIMIT, limit, 0);
+  }
+  void add_delta(int64_t delta) {
+    fbb_.AddElement<int64_t>(Range::VT_DELTA, delta, 1LL);
+  }
+  explicit RangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Range> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Range>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Range> CreateRange(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t d_type = 0,
+    int64_t start = 0,
+    int64_t limit = 0,
+    int64_t delta = 1LL) {
+  RangeBuilder builder_(_fbb);
+  builder_.add_delta(delta);
+  builder_.add_limit(limit);
+  builder_.add_start(start);
+  builder_.add_d_type(d_type);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Range> CreateRange(flatbuffers::FlatBufferBuilder &_fbb, const RangeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ReciprocalT : public flatbuffers::NativeTable {
+  typedef Reciprocal TableType;
+};
+
+struct Reciprocal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ReciprocalT NativeTableType;
+  typedef ReciprocalBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ReciprocalTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  ReciprocalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ReciprocalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Reciprocal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReciprocalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ReciprocalBuilder {
+  typedef Reciprocal Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ReciprocalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Reciprocal> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Reciprocal>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Reciprocal> CreateReciprocal(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ReciprocalBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Reciprocal> CreateReciprocal(flatbuffers::FlatBufferBuilder &_fbb, const ReciprocalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct RealDivT : public flatbuffers::NativeTable {
+  typedef RealDiv TableType;
+};
+
+struct RealDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RealDivT NativeTableType;
+  typedef RealDivBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return RealDivTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  RealDivT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(RealDivT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<RealDiv> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RealDivT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct RealDivBuilder {
+  typedef RealDiv Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit RealDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<RealDiv> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<RealDiv>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<RealDiv> CreateRealDiv(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  RealDivBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<RealDiv> CreateRealDiv(flatbuffers::FlatBufferBuilder &_fbb, const RealDivT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ReduceFusionT : public flatbuffers::NativeTable {
+  typedef ReduceFusion TableType;
+  bool keep_dims = false;
+  mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean;
+  bool reduce_to_end = false;
+  float coeff = 0.0f;
+};
+
+struct ReduceFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ReduceFusionT NativeTableType;
+  typedef ReduceFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ReduceFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KEEP_DIMS = 4,
+    VT_MODE = 6,
+    VT_REDUCE_TO_END = 8,
+    VT_COEFF = 10
+  };
+  bool keep_dims() const {
+    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
+  }
+  bool mutate_keep_dims(bool _keep_dims) {
+    return SetField<uint8_t>(VT_KEEP_DIMS, static_cast<uint8_t>(_keep_dims), 0);
+  }
+  mindspore::schema::ReduceMode mode() const {
+    return static_cast<mindspore::schema::ReduceMode>(GetField<int8_t>(VT_MODE, 0));
+  }
+  bool mutate_mode(mindspore::schema::ReduceMode _mode) {
+    return SetField<int8_t>(VT_MODE, static_cast<int8_t>(_mode), 0);
+  }
+  bool reduce_to_end() const {
+    return GetField<uint8_t>(VT_REDUCE_TO_END, 0) != 0;
+  }
+  bool mutate_reduce_to_end(bool _reduce_to_end) {
+    return SetField<uint8_t>(VT_REDUCE_TO_END, static_cast<uint8_t>(_reduce_to_end), 0);
+  }
+  float coeff() const {
+    return GetField<float>(VT_COEFF, 0.0f);
+  }
+  bool mutate_coeff(float _coeff) {
+    return SetField<float>(VT_COEFF, _coeff, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
+           VerifyField<int8_t>(verifier, VT_MODE) &&
+           VerifyField<uint8_t>(verifier, VT_REDUCE_TO_END) &&
+           VerifyField<float>(verifier, VT_COEFF) &&
+           verifier.EndTable();
+  }
+  ReduceFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ReduceFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ReduceFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ReduceFusionBuilder {
+  typedef ReduceFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_keep_dims(bool keep_dims) {
+    fbb_.AddElement<uint8_t>(ReduceFusion::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
+  }
+  void add_mode(mindspore::schema::ReduceMode mode) {
+    fbb_.AddElement<int8_t>(ReduceFusion::VT_MODE, static_cast<int8_t>(mode), 0);
+  }
+  void add_reduce_to_end(bool reduce_to_end) {
+    fbb_.AddElement<uint8_t>(ReduceFusion::VT_REDUCE_TO_END, static_cast<uint8_t>(reduce_to_end), 0);
+  }
+  void add_coeff(float coeff) {
+    fbb_.AddElement<float>(ReduceFusion::VT_COEFF, coeff, 0.0f);
+  }
+  explicit ReduceFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ReduceFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ReduceFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ReduceFusion> CreateReduceFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool keep_dims = false,
+    mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean,
+    bool reduce_to_end = false,
+    float coeff = 0.0f) {
+  ReduceFusionBuilder builder_(_fbb);
+  builder_.add_coeff(coeff);
+  builder_.add_reduce_to_end(reduce_to_end);
+  builder_.add_mode(mode);
+  builder_.add_keep_dims(keep_dims);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ReduceFusion> CreateReduceFusion(flatbuffers::FlatBufferBuilder &_fbb, const ReduceFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ReshapeT : public flatbuffers::NativeTable {
+  typedef Reshape TableType;
+};
+
+struct Reshape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ReshapeT NativeTableType;
+  typedef ReshapeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ReshapeTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  ReshapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ReshapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Reshape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ReshapeBuilder {
+  typedef Reshape Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ReshapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Reshape> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Reshape>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Reshape> CreateReshape(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ReshapeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Reshape> CreateReshape(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ResizeT : public flatbuffers::NativeTable {
+  typedef Resize TableType;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR;
+  int64_t new_height = 0;
+  int64_t new_width = 0;
+  bool preserve_aspect_ratio = false;
+  mindspore::schema::CoordinateTransformMode coordinate_transform_mode = mindspore::schema::CoordinateTransformMode_ASYMMETRIC;
+  float cubic_coeff = 0.0f;
+  int64_t exclude_outside = 0;
+  float extrapolation_value = 0.0f;
+  mindspore::schema::NearestMode nearest_mode = mindspore::schema::NearestMode_NORMAL;
+};
+
+struct Resize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ResizeT NativeTableType;
+  typedef ResizeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ResizeTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_METHOD = 6,
+    VT_NEW_HEIGHT = 8,
+    VT_NEW_WIDTH = 10,
+    VT_PRESERVE_ASPECT_RATIO = 12,
+    VT_COORDINATE_TRANSFORM_MODE = 14,
+    VT_CUBIC_COEFF = 16,
+    VT_EXCLUDE_OUTSIDE = 18,
+    VT_EXTRAPOLATION_VALUE = 20,
+    VT_NEAREST_MODE = 22
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  mindspore::schema::ResizeMethod method() const {
+    return static_cast<mindspore::schema::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
+  }
+  bool mutate_method(mindspore::schema::ResizeMethod _method) {
+    return SetField<int8_t>(VT_METHOD, static_cast<int8_t>(_method), 0);
+  }
+  int64_t new_height() const {
+    return GetField<int64_t>(VT_NEW_HEIGHT, 0);
+  }
+  bool mutate_new_height(int64_t _new_height) {
+    return SetField<int64_t>(VT_NEW_HEIGHT, _new_height, 0);
+  }
+  int64_t new_width() const {
+    return GetField<int64_t>(VT_NEW_WIDTH, 0);
+  }
+  bool mutate_new_width(int64_t _new_width) {
+    return SetField<int64_t>(VT_NEW_WIDTH, _new_width, 0);
+  }
+  bool preserve_aspect_ratio() const {
+    return GetField<uint8_t>(VT_PRESERVE_ASPECT_RATIO, 0) != 0;
+  }
+  bool mutate_preserve_aspect_ratio(bool _preserve_aspect_ratio) {
+    return SetField<uint8_t>(VT_PRESERVE_ASPECT_RATIO, static_cast<uint8_t>(_preserve_aspect_ratio), 0);
+  }
+  mindspore::schema::CoordinateTransformMode coordinate_transform_mode() const {
+    return static_cast<mindspore::schema::CoordinateTransformMode>(GetField<int8_t>(VT_COORDINATE_TRANSFORM_MODE, 0));
+  }
+  bool mutate_coordinate_transform_mode(mindspore::schema::CoordinateTransformMode _coordinate_transform_mode) {
+    return SetField<int8_t>(VT_COORDINATE_TRANSFORM_MODE, static_cast<int8_t>(_coordinate_transform_mode), 0);
+  }
+  float cubic_coeff() const {
+    return GetField<float>(VT_CUBIC_COEFF, 0.0f);
+  }
+  bool mutate_cubic_coeff(float _cubic_coeff) {
+    return SetField<float>(VT_CUBIC_COEFF, _cubic_coeff, 0.0f);
+  }
+  int64_t exclude_outside() const {
+    return GetField<int64_t>(VT_EXCLUDE_OUTSIDE, 0);
+  }
+  bool mutate_exclude_outside(int64_t _exclude_outside) {
+    return SetField<int64_t>(VT_EXCLUDE_OUTSIDE, _exclude_outside, 0);
+  }
+  float extrapolation_value() const {
+    return GetField<float>(VT_EXTRAPOLATION_VALUE, 0.0f);
+  }
+  bool mutate_extrapolation_value(float _extrapolation_value) {
+    return SetField<float>(VT_EXTRAPOLATION_VALUE, _extrapolation_value, 0.0f);
+  }
+  mindspore::schema::NearestMode nearest_mode() const {
+    return static_cast<mindspore::schema::NearestMode>(GetField<int8_t>(VT_NEAREST_MODE, 0));
+  }
+  bool mutate_nearest_mode(mindspore::schema::NearestMode _nearest_mode) {
+    return SetField<int8_t>(VT_NEAREST_MODE, static_cast<int8_t>(_nearest_mode), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<int8_t>(verifier, VT_METHOD) &&
+           VerifyField<int64_t>(verifier, VT_NEW_HEIGHT) &&
+           VerifyField<int64_t>(verifier, VT_NEW_WIDTH) &&
+           VerifyField<uint8_t>(verifier, VT_PRESERVE_ASPECT_RATIO) &&
+           VerifyField<int8_t>(verifier, VT_COORDINATE_TRANSFORM_MODE) &&
+           VerifyField<float>(verifier, VT_CUBIC_COEFF) &&
+           VerifyField<int64_t>(verifier, VT_EXCLUDE_OUTSIDE) &&
+           VerifyField<float>(verifier, VT_EXTRAPOLATION_VALUE) &&
+           VerifyField<int8_t>(verifier, VT_NEAREST_MODE) &&
+           verifier.EndTable();
+  }
+  ResizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ResizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Resize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ResizeBuilder {
+  typedef Resize Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(Resize::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_method(mindspore::schema::ResizeMethod method) {
+    fbb_.AddElement<int8_t>(Resize::VT_METHOD, static_cast<int8_t>(method), 0);
+  }
+  void add_new_height(int64_t new_height) {
+    fbb_.AddElement<int64_t>(Resize::VT_NEW_HEIGHT, new_height, 0);
+  }
+  void add_new_width(int64_t new_width) {
+    fbb_.AddElement<int64_t>(Resize::VT_NEW_WIDTH, new_width, 0);
+  }
+  void add_preserve_aspect_ratio(bool preserve_aspect_ratio) {
+    fbb_.AddElement<uint8_t>(Resize::VT_PRESERVE_ASPECT_RATIO, static_cast<uint8_t>(preserve_aspect_ratio), 0);
+  }
+  void add_coordinate_transform_mode(mindspore::schema::CoordinateTransformMode coordinate_transform_mode) {
+    fbb_.AddElement<int8_t>(Resize::VT_COORDINATE_TRANSFORM_MODE, static_cast<int8_t>(coordinate_transform_mode), 0);
+  }
+  void add_cubic_coeff(float cubic_coeff) {
+    fbb_.AddElement<float>(Resize::VT_CUBIC_COEFF, cubic_coeff, 0.0f);
+  }
+  void add_exclude_outside(int64_t exclude_outside) {
+    fbb_.AddElement<int64_t>(Resize::VT_EXCLUDE_OUTSIDE, exclude_outside, 0);
+  }
+  void add_extrapolation_value(float extrapolation_value) {
+    fbb_.AddElement<float>(Resize::VT_EXTRAPOLATION_VALUE, extrapolation_value, 0.0f);
+  }
+  void add_nearest_mode(mindspore::schema::NearestMode nearest_mode) {
+    fbb_.AddElement<int8_t>(Resize::VT_NEAREST_MODE, static_cast<int8_t>(nearest_mode), 0);
+  }
+  explicit ResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Resize> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Resize>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Resize> CreateResize(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR,
+    int64_t new_height = 0,
+    int64_t new_width = 0,
+    bool preserve_aspect_ratio = false,
+    mindspore::schema::CoordinateTransformMode coordinate_transform_mode = mindspore::schema::CoordinateTransformMode_ASYMMETRIC,
+    float cubic_coeff = 0.0f,
+    int64_t exclude_outside = 0,
+    float extrapolation_value = 0.0f,
+    mindspore::schema::NearestMode nearest_mode = mindspore::schema::NearestMode_NORMAL) {
+  ResizeBuilder builder_(_fbb);
+  builder_.add_exclude_outside(exclude_outside);
+  builder_.add_new_width(new_width);
+  builder_.add_new_height(new_height);
+  builder_.add_extrapolation_value(extrapolation_value);
+  builder_.add_cubic_coeff(cubic_coeff);
+  builder_.add_format(format);
+  builder_.add_nearest_mode(nearest_mode);
+  builder_.add_coordinate_transform_mode(coordinate_transform_mode);
+  builder_.add_preserve_aspect_ratio(preserve_aspect_ratio);
+  builder_.add_method(method);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Resize> CreateResize(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ReverseSequenceT : public flatbuffers::NativeTable {
+  typedef ReverseSequence TableType;
+  int64_t seq_dim = 0;
+  int64_t batch_dim = 0;
+};
+
+struct ReverseSequence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ReverseSequenceT NativeTableType;
+  typedef ReverseSequenceBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ReverseSequenceTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SEQ_DIM = 4,
+    VT_BATCH_DIM = 6
+  };
+  int64_t seq_dim() const {
+    return GetField<int64_t>(VT_SEQ_DIM, 0);
+  }
+  bool mutate_seq_dim(int64_t _seq_dim) {
+    return SetField<int64_t>(VT_SEQ_DIM, _seq_dim, 0);
+  }
+  int64_t batch_dim() const {
+    return GetField<int64_t>(VT_BATCH_DIM, 0);
+  }
+  bool mutate_batch_dim(int64_t _batch_dim) {
+    return SetField<int64_t>(VT_BATCH_DIM, _batch_dim, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SEQ_DIM) &&
+           VerifyField<int64_t>(verifier, VT_BATCH_DIM) &&
+           verifier.EndTable();
+  }
+  ReverseSequenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ReverseSequenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ReverseSequence> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ReverseSequenceBuilder {
+  typedef ReverseSequence Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_seq_dim(int64_t seq_dim) {
+    fbb_.AddElement<int64_t>(ReverseSequence::VT_SEQ_DIM, seq_dim, 0);
+  }
+  void add_batch_dim(int64_t batch_dim) {
+    fbb_.AddElement<int64_t>(ReverseSequence::VT_BATCH_DIM, batch_dim, 0);
+  }
+  explicit ReverseSequenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ReverseSequence> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ReverseSequence>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ReverseSequence> CreateReverseSequence(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t seq_dim = 0,
+    int64_t batch_dim = 0) {
+  ReverseSequenceBuilder builder_(_fbb);
+  builder_.add_batch_dim(batch_dim);
+  builder_.add_seq_dim(seq_dim);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ReverseSequence> CreateReverseSequence(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ReverseV2T : public flatbuffers::NativeTable {
+  typedef ReverseV2 TableType;
+  std::vector<int64_t> axis{};
+};
+
+struct ReverseV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ReverseV2T NativeTableType;
+  typedef ReverseV2Builder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ReverseV2TypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  const flatbuffers::Vector<int64_t> *axis() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  flatbuffers::Vector<int64_t> *mutable_axis() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_AXIS) &&
+           verifier.VerifyVector(axis()) &&
+           verifier.EndTable();
+  }
+  ReverseV2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ReverseV2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ReverseV2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ReverseV2Builder {
+  typedef ReverseV2 Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
+    fbb_.AddOffset(ReverseV2::VT_AXIS, axis);
+  }
+  explicit ReverseV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ReverseV2> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ReverseV2>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ReverseV2> CreateReverseV2(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
+  ReverseV2Builder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<ReverseV2> CreateReverseV2Direct(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *axis = nullptr) {
+  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
+  return mindspore::schema::CreateReverseV2(
+      _fbb,
+      axis__);
+}
+
+flatbuffers::Offset<ReverseV2> CreateReverseV2(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct RfftT : public flatbuffers::NativeTable {
+  typedef Rfft TableType;
+  int64_t fft_length = 0;
+};
+
+struct Rfft FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RfftT NativeTableType;
+  typedef RfftBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return RfftTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FFT_LENGTH = 4
+  };
+  int64_t fft_length() const {
+    return GetField<int64_t>(VT_FFT_LENGTH, 0);
+  }
+  bool mutate_fft_length(int64_t _fft_length) {
+    return SetField<int64_t>(VT_FFT_LENGTH, _fft_length, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_FFT_LENGTH) &&
+           verifier.EndTable();
+  }
+  RfftT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(RfftT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Rfft> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RfftT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct RfftBuilder {
+  typedef Rfft Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_fft_length(int64_t fft_length) {
+    fbb_.AddElement<int64_t>(Rfft::VT_FFT_LENGTH, fft_length, 0);
+  }
+  explicit RfftBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Rfft> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Rfft>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Rfft> CreateRfft(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t fft_length = 0) {
+  RfftBuilder builder_(_fbb);
+  builder_.add_fft_length(fft_length);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Rfft> CreateRfft(flatbuffers::FlatBufferBuilder &_fbb, const RfftT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ROIPoolingT : public flatbuffers::NativeTable {
+  typedef ROIPooling TableType;
+  int64_t pooled_h = 0;
+  int64_t pooled_w = 0;
+  float scale = 0.0f;
+};
+
+struct ROIPooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ROIPoolingT NativeTableType;
+  typedef ROIPoolingBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ROIPoolingTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_POOLED_H = 4,
+    VT_POOLED_W = 6,
+    VT_SCALE = 8
+  };
+  int64_t pooled_h() const {
+    return GetField<int64_t>(VT_POOLED_H, 0);
+  }
+  bool mutate_pooled_h(int64_t _pooled_h) {
+    return SetField<int64_t>(VT_POOLED_H, _pooled_h, 0);
+  }
+  int64_t pooled_w() const {
+    return GetField<int64_t>(VT_POOLED_W, 0);
+  }
+  bool mutate_pooled_w(int64_t _pooled_w) {
+    return SetField<int64_t>(VT_POOLED_W, _pooled_w, 0);
+  }
+  float scale() const {
+    return GetField<float>(VT_SCALE, 0.0f);
+  }
+  bool mutate_scale(float _scale) {
+    return SetField<float>(VT_SCALE, _scale, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_POOLED_H) &&
+           VerifyField<int64_t>(verifier, VT_POOLED_W) &&
+           VerifyField<float>(verifier, VT_SCALE) &&
+           verifier.EndTable();
+  }
+  ROIPoolingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ROIPoolingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ROIPooling> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ROIPoolingBuilder {
+  typedef ROIPooling Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_pooled_h(int64_t pooled_h) {
+    fbb_.AddElement<int64_t>(ROIPooling::VT_POOLED_H, pooled_h, 0);
+  }
+  void add_pooled_w(int64_t pooled_w) {
+    fbb_.AddElement<int64_t>(ROIPooling::VT_POOLED_W, pooled_w, 0);
+  }
+  void add_scale(float scale) {
+    fbb_.AddElement<float>(ROIPooling::VT_SCALE, scale, 0.0f);
+  }
+  explicit ROIPoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ROIPooling> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ROIPooling>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ROIPooling> CreateROIPooling(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t pooled_h = 0,
+    int64_t pooled_w = 0,
+    float scale = 0.0f) {
+  ROIPoolingBuilder builder_(_fbb);
+  builder_.add_pooled_w(pooled_w);
+  builder_.add_pooled_h(pooled_h);
+  builder_.add_scale(scale);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ROIPooling> CreateROIPooling(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct RoundT : public flatbuffers::NativeTable {
+  typedef Round TableType;
+};
+
+struct Round FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RoundT NativeTableType;
+  typedef RoundBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return RoundTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  RoundT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(RoundT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Round> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoundT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct RoundBuilder {
+  typedef Round Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit RoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Round> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Round>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Round> CreateRound(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  RoundBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Round> CreateRound(flatbuffers::FlatBufferBuilder &_fbb, const RoundT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct RsqrtT : public flatbuffers::NativeTable {
+  typedef Rsqrt TableType;
+};
+
+struct Rsqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RsqrtT NativeTableType;
+  typedef RsqrtBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return RsqrtTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  RsqrtT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(RsqrtT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Rsqrt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct RsqrtBuilder {
+  typedef Rsqrt Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit RsqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Rsqrt> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Rsqrt>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Rsqrt> CreateRsqrt(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  RsqrtBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Rsqrt> CreateRsqrt(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct QuantDTypeCastT : public flatbuffers::NativeTable {
+  typedef QuantDTypeCast TableType;
+  int64_t src_t = 0;
+  int64_t dst_t = 0;
+};
+
+struct QuantDTypeCast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef QuantDTypeCastT NativeTableType;
+  typedef QuantDTypeCastBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return QuantDTypeCastTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SRC_T = 4,
+    VT_DST_T = 6
+  };
+  int64_t src_t() const {
+    return GetField<int64_t>(VT_SRC_T, 0);
+  }
+  bool mutate_src_t(int64_t _src_t) {
+    return SetField<int64_t>(VT_SRC_T, _src_t, 0);
+  }
+  int64_t dst_t() const {
+    return GetField<int64_t>(VT_DST_T, 0);
+  }
+  bool mutate_dst_t(int64_t _dst_t) {
+    return SetField<int64_t>(VT_DST_T, _dst_t, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SRC_T) &&
+           VerifyField<int64_t>(verifier, VT_DST_T) &&
+           verifier.EndTable();
+  }
+  QuantDTypeCastT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(QuantDTypeCastT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<QuantDTypeCast> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantDTypeCastT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct QuantDTypeCastBuilder {
+  typedef QuantDTypeCast Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_src_t(int64_t src_t) {
+    fbb_.AddElement<int64_t>(QuantDTypeCast::VT_SRC_T, src_t, 0);
+  }
+  void add_dst_t(int64_t dst_t) {
+    fbb_.AddElement<int64_t>(QuantDTypeCast::VT_DST_T, dst_t, 0);
+  }
+  explicit QuantDTypeCastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<QuantDTypeCast> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<QuantDTypeCast>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t src_t = 0,
+    int64_t dst_t = 0) {
+  QuantDTypeCastBuilder builder_(_fbb);
+  builder_.add_dst_t(dst_t);
+  builder_.add_src_t(src_t);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(flatbuffers::FlatBufferBuilder &_fbb, const QuantDTypeCastT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ScaleFusionT : public flatbuffers::NativeTable {
+  typedef ScaleFusion TableType;
+  int64_t axis = 0;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct ScaleFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ScaleFusionT NativeTableType;
+  typedef ScaleFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ScaleFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4,
+    VT_ACTIVATION_TYPE = 6
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  ScaleFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ScaleFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ScaleFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ScaleFusionBuilder {
+  typedef ScaleFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(ScaleFusion::VT_AXIS, axis, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(ScaleFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit ScaleFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ScaleFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ScaleFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ScaleFusion> CreateScaleFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  ScaleFusionBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ScaleFusion> CreateScaleFusion(flatbuffers::FlatBufferBuilder &_fbb, const ScaleFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ScatterNdT : public flatbuffers::NativeTable {
+  typedef ScatterNd TableType;
+};
+
+struct ScatterNd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ScatterNdT NativeTableType;
+  typedef ScatterNdBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ScatterNdTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  ScatterNdT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ScatterNdT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ScatterNd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ScatterNdBuilder {
+  typedef ScatterNd Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ScatterNdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ScatterNd> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ScatterNd>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ScatterNd> CreateScatterNd(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ScatterNdBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ScatterNd> CreateScatterNd(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SGDT : public flatbuffers::NativeTable {
+  typedef SGD TableType;
+  bool nesterov = false;
+  float dampening = 0.0f;
+  float weight_decay = 0.0f;
+};
+
+struct SGD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SGDT NativeTableType;
+  typedef SGDBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SGDTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NESTEROV = 4,
+    VT_DAMPENING = 6,
+    VT_WEIGHT_DECAY = 8
+  };
+  bool nesterov() const {
+    return GetField<uint8_t>(VT_NESTEROV, 0) != 0;
+  }
+  bool mutate_nesterov(bool _nesterov) {
+    return SetField<uint8_t>(VT_NESTEROV, static_cast<uint8_t>(_nesterov), 0);
+  }
+  float dampening() const {
+    return GetField<float>(VT_DAMPENING, 0.0f);
+  }
+  bool mutate_dampening(float _dampening) {
+    return SetField<float>(VT_DAMPENING, _dampening, 0.0f);
+  }
+  float weight_decay() const {
+    return GetField<float>(VT_WEIGHT_DECAY, 0.0f);
+  }
+  bool mutate_weight_decay(float _weight_decay) {
+    return SetField<float>(VT_WEIGHT_DECAY, _weight_decay, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_NESTEROV) &&
+           VerifyField<float>(verifier, VT_DAMPENING) &&
+           VerifyField<float>(verifier, VT_WEIGHT_DECAY) &&
+           verifier.EndTable();
+  }
+  SGDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SGDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SGD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SGDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SGDBuilder {
+  typedef SGD Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_nesterov(bool nesterov) {
+    fbb_.AddElement<uint8_t>(SGD::VT_NESTEROV, static_cast<uint8_t>(nesterov), 0);
+  }
+  void add_dampening(float dampening) {
+    fbb_.AddElement<float>(SGD::VT_DAMPENING, dampening, 0.0f);
+  }
+  void add_weight_decay(float weight_decay) {
+    fbb_.AddElement<float>(SGD::VT_WEIGHT_DECAY, weight_decay, 0.0f);
+  }
+  explicit SGDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SGD> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SGD>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SGD> CreateSGD(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool nesterov = false,
+    float dampening = 0.0f,
+    float weight_decay = 0.0f) {
+  SGDBuilder builder_(_fbb);
+  builder_.add_weight_decay(weight_decay);
+  builder_.add_dampening(dampening);
+  builder_.add_nesterov(nesterov);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SGD> CreateSGD(flatbuffers::FlatBufferBuilder &_fbb, const SGDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ShapeT : public flatbuffers::NativeTable {
+  typedef Shape TableType;
+};
+
+struct Shape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ShapeT NativeTableType;
+  typedef ShapeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ShapeTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  ShapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ShapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Shape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ShapeBuilder {
+  typedef Shape Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Shape> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Shape>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Shape> CreateShape(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ShapeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Shape> CreateShape(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SigmoidCrossEntropyWithLogitsT : public flatbuffers::NativeTable {
+  typedef SigmoidCrossEntropyWithLogits TableType;
+};
+
+struct SigmoidCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SigmoidCrossEntropyWithLogitsT NativeTableType;
+  typedef SigmoidCrossEntropyWithLogitsBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SigmoidCrossEntropyWithLogitsTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SigmoidCrossEntropyWithLogitsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SigmoidCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SigmoidCrossEntropyWithLogits> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SigmoidCrossEntropyWithLogitsBuilder {
+  typedef SigmoidCrossEntropyWithLogits Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SigmoidCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SigmoidCrossEntropyWithLogits> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SigmoidCrossEntropyWithLogits>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SigmoidCrossEntropyWithLogits> CreateSigmoidCrossEntropyWithLogits(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SigmoidCrossEntropyWithLogitsBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SigmoidCrossEntropyWithLogits> CreateSigmoidCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SigmoidCrossEntropyWithLogitsGradT : public flatbuffers::NativeTable {
+  typedef SigmoidCrossEntropyWithLogitsGrad TableType;
+};
+
+struct SigmoidCrossEntropyWithLogitsGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SigmoidCrossEntropyWithLogitsGradT NativeTableType;
+  typedef SigmoidCrossEntropyWithLogitsGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SigmoidCrossEntropyWithLogitsGradTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SigmoidCrossEntropyWithLogitsGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SigmoidCrossEntropyWithLogitsGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SigmoidCrossEntropyWithLogitsGradBuilder {
+  typedef SigmoidCrossEntropyWithLogitsGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SigmoidCrossEntropyWithLogitsGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> CreateSigmoidCrossEntropyWithLogitsGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SigmoidCrossEntropyWithLogitsGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> CreateSigmoidCrossEntropyWithLogitsGrad(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SinT : public flatbuffers::NativeTable {
+  typedef Sin TableType;
+};
+
+struct Sin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SinT NativeTableType;
+  typedef SinBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SinTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Sin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SinBuilder {
+  typedef Sin Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Sin> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Sin>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Sin> CreateSin(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SinBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Sin> CreateSin(flatbuffers::FlatBufferBuilder &_fbb, const SinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SkipGramT : public flatbuffers::NativeTable {
+  typedef SkipGram TableType;
+  bool include_all_grams = false;
+  int64_t max_skip_size = 0;
+  int64_t ngram_size = 0;
+};
+
+struct SkipGram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SkipGramT NativeTableType;
+  typedef SkipGramBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SkipGramTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_INCLUDE_ALL_GRAMS = 4,
+    VT_MAX_SKIP_SIZE = 6,
+    VT_NGRAM_SIZE = 8
+  };
+  bool include_all_grams() const {
+    return GetField<uint8_t>(VT_INCLUDE_ALL_GRAMS, 0) != 0;
+  }
+  bool mutate_include_all_grams(bool _include_all_grams) {
+    return SetField<uint8_t>(VT_INCLUDE_ALL_GRAMS, static_cast<uint8_t>(_include_all_grams), 0);
+  }
+  int64_t max_skip_size() const {
+    return GetField<int64_t>(VT_MAX_SKIP_SIZE, 0);
+  }
+  bool mutate_max_skip_size(int64_t _max_skip_size) {
+    return SetField<int64_t>(VT_MAX_SKIP_SIZE, _max_skip_size, 0);
+  }
+  int64_t ngram_size() const {
+    return GetField<int64_t>(VT_NGRAM_SIZE, 0);
+  }
+  bool mutate_ngram_size(int64_t _ngram_size) {
+    return SetField<int64_t>(VT_NGRAM_SIZE, _ngram_size, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_GRAMS) &&
+           VerifyField<int64_t>(verifier, VT_MAX_SKIP_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_NGRAM_SIZE) &&
+           verifier.EndTable();
+  }
+  SkipGramT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SkipGramT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SkipGram> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SkipGramBuilder {
+  typedef SkipGram Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_include_all_grams(bool include_all_grams) {
+    fbb_.AddElement<uint8_t>(SkipGram::VT_INCLUDE_ALL_GRAMS, static_cast<uint8_t>(include_all_grams), 0);
+  }
+  void add_max_skip_size(int64_t max_skip_size) {
+    fbb_.AddElement<int64_t>(SkipGram::VT_MAX_SKIP_SIZE, max_skip_size, 0);
+  }
+  void add_ngram_size(int64_t ngram_size) {
+    fbb_.AddElement<int64_t>(SkipGram::VT_NGRAM_SIZE, ngram_size, 0);
+  }
+  explicit SkipGramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SkipGram> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SkipGram>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SkipGram> CreateSkipGram(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool include_all_grams = false,
+    int64_t max_skip_size = 0,
+    int64_t ngram_size = 0) {
+  SkipGramBuilder builder_(_fbb);
+  builder_.add_ngram_size(ngram_size);
+  builder_.add_max_skip_size(max_skip_size);
+  builder_.add_include_all_grams(include_all_grams);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SkipGram> CreateSkipGram(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SliceFusionT : public flatbuffers::NativeTable {
+  typedef SliceFusion TableType;
+  std::vector<int64_t> axes{};
+};
+
+struct SliceFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SliceFusionT NativeTableType;
+  typedef SliceFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SliceFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXES = 4
+  };
+  const flatbuffers::Vector<int64_t> *axes() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXES);
+  }
+  flatbuffers::Vector<int64_t> *mutable_axes() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXES);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_AXES) &&
+           verifier.VerifyVector(axes()) &&
+           verifier.EndTable();
+  }
+  SliceFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SliceFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SliceFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SliceFusionBuilder {
+  typedef SliceFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes) {
+    fbb_.AddOffset(SliceFusion::VT_AXES, axes);
+  }
+  explicit SliceFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SliceFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SliceFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SliceFusion> CreateSliceFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes = 0) {
+  SliceFusionBuilder builder_(_fbb);
+  builder_.add_axes(axes);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<SliceFusion> CreateSliceFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *axes = nullptr) {
+  auto axes__ = axes ? _fbb.CreateVector<int64_t>(*axes) : 0;
+  return mindspore::schema::CreateSliceFusion(
+      _fbb,
+      axes__);
+}
+
+flatbuffers::Offset<SliceFusion> CreateSliceFusion(flatbuffers::FlatBufferBuilder &_fbb, const SliceFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SmoothL1LossT : public flatbuffers::NativeTable {
+  typedef SmoothL1Loss TableType;
+  float beta = 0.0f;
+};
+
+struct SmoothL1Loss FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SmoothL1LossT NativeTableType;
+  typedef SmoothL1LossBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SmoothL1LossTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BETA = 4
+  };
+  float beta() const {
+    return GetField<float>(VT_BETA, 0.0f);
+  }
+  bool mutate_beta(float _beta) {
+    return SetField<float>(VT_BETA, _beta, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_BETA) &&
+           verifier.EndTable();
+  }
+  SmoothL1LossT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SmoothL1LossT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SmoothL1Loss> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SmoothL1LossBuilder {
+  typedef SmoothL1Loss Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_beta(float beta) {
+    fbb_.AddElement<float>(SmoothL1Loss::VT_BETA, beta, 0.0f);
+  }
+  explicit SmoothL1LossBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SmoothL1Loss> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SmoothL1Loss>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SmoothL1Loss> CreateSmoothL1Loss(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float beta = 0.0f) {
+  SmoothL1LossBuilder builder_(_fbb);
+  builder_.add_beta(beta);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SmoothL1Loss> CreateSmoothL1Loss(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SmoothL1LossGradT : public flatbuffers::NativeTable {
+  typedef SmoothL1LossGrad TableType;
+  float beta = 0.0f;
+};
+
+struct SmoothL1LossGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SmoothL1LossGradT NativeTableType;
+  typedef SmoothL1LossGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SmoothL1LossGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BETA = 4
+  };
+  float beta() const {
+    return GetField<float>(VT_BETA, 0.0f);
+  }
+  bool mutate_beta(float _beta) {
+    return SetField<float>(VT_BETA, _beta, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_BETA) &&
+           verifier.EndTable();
+  }
+  SmoothL1LossGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SmoothL1LossGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SmoothL1LossGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SmoothL1LossGradBuilder {
+  typedef SmoothL1LossGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_beta(float beta) {
+    fbb_.AddElement<float>(SmoothL1LossGrad::VT_BETA, beta, 0.0f);
+  }
+  explicit SmoothL1LossGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SmoothL1LossGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SmoothL1LossGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SmoothL1LossGrad> CreateSmoothL1LossGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float beta = 0.0f) {
+  SmoothL1LossGradBuilder builder_(_fbb);
+  builder_.add_beta(beta);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SmoothL1LossGrad> CreateSmoothL1LossGrad(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SoftmaxT : public flatbuffers::NativeTable {
+  typedef Softmax TableType;
+  std::vector<int64_t> axis{};
+};
+
+struct Softmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SoftmaxT NativeTableType;
+  typedef SoftmaxBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SoftmaxTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  const flatbuffers::Vector<int64_t> *axis() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  flatbuffers::Vector<int64_t> *mutable_axis() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_AXIS) &&
+           verifier.VerifyVector(axis()) &&
+           verifier.EndTable();
+  }
+  SoftmaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SoftmaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Softmax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SoftmaxBuilder {
+  typedef Softmax Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
+    fbb_.AddOffset(Softmax::VT_AXIS, axis);
+  }
+  explicit SoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Softmax> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Softmax>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Softmax> CreateSoftmax(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
+  SoftmaxBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Softmax> CreateSoftmaxDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *axis = nullptr) {
+  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
+  return mindspore::schema::CreateSoftmax(
+      _fbb,
+      axis__);
+}
+
+flatbuffers::Offset<Softmax> CreateSoftmax(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SoftmaxCrossEntropyWithLogitsT : public flatbuffers::NativeTable {
+  typedef SoftmaxCrossEntropyWithLogits TableType;
+};
+
+struct SoftmaxCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SoftmaxCrossEntropyWithLogitsT NativeTableType;
+  typedef SoftmaxCrossEntropyWithLogitsBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SoftmaxCrossEntropyWithLogitsTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SoftmaxCrossEntropyWithLogitsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SoftmaxCrossEntropyWithLogitsBuilder {
+  typedef SoftmaxCrossEntropyWithLogits Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SoftmaxCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SoftmaxCrossEntropyWithLogits>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> CreateSoftmaxCrossEntropyWithLogits(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SoftmaxCrossEntropyWithLogitsBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> CreateSoftmaxCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SpaceToBatchT : public flatbuffers::NativeTable {
+  typedef SpaceToBatch TableType;
+  std::vector<int64_t> block_size{};
+  std::unique_ptr<mindspore::schema::Vec2DT> paddings{};
+};
+
+struct SpaceToBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SpaceToBatchT NativeTableType;
+  typedef SpaceToBatchBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SpaceToBatchTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BLOCK_SIZE = 4,
+    VT_PADDINGS = 6
+  };
+  const flatbuffers::Vector<int64_t> *block_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_block_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_BLOCK_SIZE);
+  }
+  const mindspore::schema::Vec2D *paddings() const {
+    return GetPointer<const mindspore::schema::Vec2D *>(VT_PADDINGS);
+  }
+  mindspore::schema::Vec2D *mutable_paddings() {
+    return GetPointer<mindspore::schema::Vec2D *>(VT_PADDINGS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_BLOCK_SIZE) &&
+           verifier.VerifyVector(block_size()) &&
+           VerifyOffset(verifier, VT_PADDINGS) &&
+           verifier.VerifyTable(paddings()) &&
+           verifier.EndTable();
+  }
+  SpaceToBatchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SpaceToBatchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SpaceToBatch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SpaceToBatchBuilder {
+  typedef SpaceToBatch Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_block_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size) {
+    fbb_.AddOffset(SpaceToBatch::VT_BLOCK_SIZE, block_size);
+  }
+  void add_paddings(flatbuffers::Offset<mindspore::schema::Vec2D> paddings) {
+    fbb_.AddOffset(SpaceToBatch::VT_PADDINGS, paddings);
+  }
+  explicit SpaceToBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SpaceToBatch> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SpaceToBatch>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size = 0,
+    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
+  SpaceToBatchBuilder builder_(_fbb);
+  builder_.add_paddings(paddings);
+  builder_.add_block_size(block_size);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatchDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *block_size = nullptr,
+    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
+  auto block_size__ = block_size ? _fbb.CreateVector<int64_t>(*block_size) : 0;
+  return mindspore::schema::CreateSpaceToBatch(
+      _fbb,
+      block_size__,
+      paddings);
+}
+
+flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SpaceToBatchNDT : public flatbuffers::NativeTable {
+  typedef SpaceToBatchND TableType;
+  std::vector<int64_t> block_shape{};
+  std::unique_ptr<mindspore::schema::Vec2DT> paddings{};
+};
+
+struct SpaceToBatchND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SpaceToBatchNDT NativeTableType;
+  typedef SpaceToBatchNDBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SpaceToBatchNDTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BLOCK_SHAPE = 4,
+    VT_PADDINGS = 6
+  };
+  const flatbuffers::Vector<int64_t> *block_shape() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SHAPE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_block_shape() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_BLOCK_SHAPE);
+  }
+  const mindspore::schema::Vec2D *paddings() const {
+    return GetPointer<const mindspore::schema::Vec2D *>(VT_PADDINGS);
+  }
+  mindspore::schema::Vec2D *mutable_paddings() {
+    return GetPointer<mindspore::schema::Vec2D *>(VT_PADDINGS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_BLOCK_SHAPE) &&
+           verifier.VerifyVector(block_shape()) &&
+           VerifyOffset(verifier, VT_PADDINGS) &&
+           verifier.VerifyTable(paddings()) &&
+           verifier.EndTable();
+  }
+  SpaceToBatchNDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SpaceToBatchNDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SpaceToBatchND> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SpaceToBatchNDBuilder {
+  typedef SpaceToBatchND Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_block_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape) {
+    fbb_.AddOffset(SpaceToBatchND::VT_BLOCK_SHAPE, block_shape);
+  }
+  void add_paddings(flatbuffers::Offset<mindspore::schema::Vec2D> paddings) {
+    fbb_.AddOffset(SpaceToBatchND::VT_PADDINGS, paddings);
+  }
+  explicit SpaceToBatchNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SpaceToBatchND> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SpaceToBatchND>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape = 0,
+    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
+  SpaceToBatchNDBuilder builder_(_fbb);
+  builder_.add_paddings(paddings);
+  builder_.add_block_shape(block_shape);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchNDDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *block_shape = nullptr,
+    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
+  auto block_shape__ = block_shape ? _fbb.CreateVector<int64_t>(*block_shape) : 0;
+  return mindspore::schema::CreateSpaceToBatchND(
+      _fbb,
+      block_shape__,
+      paddings);
+}
+
+flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SpaceToDepthT : public flatbuffers::NativeTable {
+  typedef SpaceToDepth TableType;
+  int64_t block_size = 0;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+};
+
+struct SpaceToDepth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SpaceToDepthT NativeTableType;
+  typedef SpaceToDepthBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SpaceToDepthTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BLOCK_SIZE = 4,
+    VT_FORMAT = 6
+  };
+  int64_t block_size() const {
+    return GetField<int64_t>(VT_BLOCK_SIZE, 0);
+  }
+  bool mutate_block_size(int64_t _block_size) {
+    return SetField<int64_t>(VT_BLOCK_SIZE, _block_size, 0);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_BLOCK_SIZE) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           verifier.EndTable();
+  }
+  SpaceToDepthT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SpaceToDepthT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SpaceToDepth> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SpaceToDepthBuilder {
+  typedef SpaceToDepth Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_block_size(int64_t block_size) {
+    fbb_.AddElement<int64_t>(SpaceToDepth::VT_BLOCK_SIZE, block_size, 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(SpaceToDepth::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  explicit SpaceToDepthBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SpaceToDepth> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SpaceToDepth>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t block_size = 0,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  SpaceToDepthBuilder builder_(_fbb);
+  builder_.add_block_size(block_size);
+  builder_.add_format(format);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SparseSoftmaxCrossEntropyWithLogitsT : public flatbuffers::NativeTable {
+  typedef SparseSoftmaxCrossEntropyWithLogits TableType;
+  bool is_grad = false;
+};
+
+struct SparseSoftmaxCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SparseSoftmaxCrossEntropyWithLogitsT NativeTableType;
+  typedef SparseSoftmaxCrossEntropyWithLogitsBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SparseSoftmaxCrossEntropyWithLogitsTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_IS_GRAD = 4
+  };
+  bool is_grad() const {
+    return GetField<uint8_t>(VT_IS_GRAD, 0) != 0;
+  }
+  bool mutate_is_grad(bool _is_grad) {
+    return SetField<uint8_t>(VT_IS_GRAD, static_cast<uint8_t>(_is_grad), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_IS_GRAD) &&
+           verifier.EndTable();
+  }
+  SparseSoftmaxCrossEntropyWithLogitsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SparseSoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseSoftmaxCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SparseSoftmaxCrossEntropyWithLogitsBuilder {
+  typedef SparseSoftmaxCrossEntropyWithLogits Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_is_grad(bool is_grad) {
+    fbb_.AddElement<uint8_t>(SparseSoftmaxCrossEntropyWithLogits::VT_IS_GRAD, static_cast<uint8_t>(is_grad), 0);
+  }
+  explicit SparseSoftmaxCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> CreateSparseSoftmaxCrossEntropyWithLogits(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool is_grad = false) {
+  SparseSoftmaxCrossEntropyWithLogitsBuilder builder_(_fbb);
+  builder_.add_is_grad(is_grad);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> CreateSparseSoftmaxCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SparseSoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SparseToDenseT : public flatbuffers::NativeTable {
+  typedef SparseToDense TableType;
+};
+
+struct SparseToDense FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SparseToDenseT NativeTableType;
+  typedef SparseToDenseBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SparseToDenseTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SparseToDenseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SparseToDenseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SparseToDense> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SparseToDenseBuilder {
+  typedef SparseToDense Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SparseToDenseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SparseToDense> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SparseToDense>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SparseToDense> CreateSparseToDense(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SparseToDenseBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SparseToDense> CreateSparseToDense(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SplitT : public flatbuffers::NativeTable {
+  typedef Split TableType;
+  int64_t output_num = 0;
+  std::vector<int64_t> size_splits{};
+  int64_t axis = 0;
+};
+
+struct Split FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SplitT NativeTableType;
+  typedef SplitBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SplitTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_OUTPUT_NUM = 4,
+    VT_SIZE_SPLITS = 6,
+    VT_AXIS = 8
+  };
+  int64_t output_num() const {
+    return GetField<int64_t>(VT_OUTPUT_NUM, 0);
+  }
+  bool mutate_output_num(int64_t _output_num) {
+    return SetField<int64_t>(VT_OUTPUT_NUM, _output_num, 0);
+  }
+  const flatbuffers::Vector<int64_t> *size_splits() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SIZE_SPLITS);
+  }
+  flatbuffers::Vector<int64_t> *mutable_size_splits() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_SIZE_SPLITS);
+  }
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_OUTPUT_NUM) &&
+           VerifyOffset(verifier, VT_SIZE_SPLITS) &&
+           verifier.VerifyVector(size_splits()) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+  SplitT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SplitT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Split> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SplitBuilder {
+  typedef Split Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_output_num(int64_t output_num) {
+    fbb_.AddElement<int64_t>(Split::VT_OUTPUT_NUM, output_num, 0);
+  }
+  void add_size_splits(flatbuffers::Offset<flatbuffers::Vector<int64_t>> size_splits) {
+    fbb_.AddOffset(Split::VT_SIZE_SPLITS, size_splits);
+  }
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(Split::VT_AXIS, axis, 0);
+  }
+  explicit SplitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Split> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Split>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Split> CreateSplit(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t output_num = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> size_splits = 0,
+    int64_t axis = 0) {
+  SplitBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  builder_.add_output_num(output_num);
+  builder_.add_size_splits(size_splits);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Split> CreateSplitDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t output_num = 0,
+    const std::vector<int64_t> *size_splits = nullptr,
+    int64_t axis = 0) {
+  auto size_splits__ = size_splits ? _fbb.CreateVector<int64_t>(*size_splits) : 0;
+  return mindspore::schema::CreateSplit(
+      _fbb,
+      output_num,
+      size_splits__,
+      axis);
+}
+
+flatbuffers::Offset<Split> CreateSplit(flatbuffers::FlatBufferBuilder &_fbb, const SplitT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SqrtT : public flatbuffers::NativeTable {
+  typedef Sqrt TableType;
+};
+
+struct Sqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SqrtT NativeTableType;
+  typedef SqrtBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SqrtTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SqrtT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SqrtT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Sqrt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SqrtBuilder {
+  typedef Sqrt Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Sqrt> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Sqrt>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Sqrt> CreateSqrt(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SqrtBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Sqrt> CreateSqrt(flatbuffers::FlatBufferBuilder &_fbb, const SqrtT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SqueezeT : public flatbuffers::NativeTable {
+  typedef Squeeze TableType;
+  std::vector<int64_t> axis{};
+};
+
+struct Squeeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SqueezeT NativeTableType;
+  typedef SqueezeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SqueezeTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  const flatbuffers::Vector<int64_t> *axis() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  flatbuffers::Vector<int64_t> *mutable_axis() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_AXIS) &&
+           verifier.VerifyVector(axis()) &&
+           verifier.EndTable();
+  }
+  SqueezeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SqueezeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Squeeze> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SqueezeBuilder {
+  typedef Squeeze Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
+    fbb_.AddOffset(Squeeze::VT_AXIS, axis);
+  }
+  explicit SqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Squeeze> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Squeeze>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Squeeze> CreateSqueeze(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
+  SqueezeBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Squeeze> CreateSqueezeDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *axis = nullptr) {
+  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
+  return mindspore::schema::CreateSqueeze(
+      _fbb,
+      axis__);
+}
+
+flatbuffers::Offset<Squeeze> CreateSqueeze(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SquareT : public flatbuffers::NativeTable {
+  typedef Square TableType;
+};
+
+struct Square FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SquareT NativeTableType;
+  typedef SquareBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SquareTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SquareT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SquareT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Square> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SquareBuilder {
+  typedef Square Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SquareBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Square> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Square>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Square> CreateSquare(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SquareBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Square> CreateSquare(flatbuffers::FlatBufferBuilder &_fbb, const SquareT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SquaredDifferenceT : public flatbuffers::NativeTable {
+  typedef SquaredDifference TableType;
+};
+
+struct SquaredDifference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SquaredDifferenceT NativeTableType;
+  typedef SquaredDifferenceBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SquaredDifferenceTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SquaredDifferenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SquaredDifferenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SquaredDifference> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SquaredDifferenceBuilder {
+  typedef SquaredDifference Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SquaredDifferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SquaredDifference> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SquaredDifference>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SquaredDifferenceBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct StackT : public flatbuffers::NativeTable {
+  typedef Stack TableType;
+  int64_t axis = 0;
+};
+
+struct Stack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef StackT NativeTableType;
+  typedef StackBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return StackTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+  StackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(StackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Stack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct StackBuilder {
+  typedef Stack Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(Stack::VT_AXIS, axis, 0);
+  }
+  explicit StackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Stack> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Stack>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Stack> CreateStack(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0) {
+  StackBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Stack> CreateStack(flatbuffers::FlatBufferBuilder &_fbb, const StackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct StridedSliceT : public flatbuffers::NativeTable {
+  typedef StridedSlice TableType;
+  int64_t begin_mask = 0;
+  int64_t end_mask = 0;
+  int64_t ellipsis_mask = 0;
+  int64_t new_axis_mask = 0;
+  int64_t shrink_axis_mask = 0;
+};
+
+struct StridedSlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef StridedSliceT NativeTableType;
+  typedef StridedSliceBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return StridedSliceTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BEGIN_MASK = 4,
+    VT_END_MASK = 6,
+    VT_ELLIPSIS_MASK = 8,
+    VT_NEW_AXIS_MASK = 10,
+    VT_SHRINK_AXIS_MASK = 12
+  };
+  int64_t begin_mask() const {
+    return GetField<int64_t>(VT_BEGIN_MASK, 0);
+  }
+  bool mutate_begin_mask(int64_t _begin_mask) {
+    return SetField<int64_t>(VT_BEGIN_MASK, _begin_mask, 0);
+  }
+  int64_t end_mask() const {
+    return GetField<int64_t>(VT_END_MASK, 0);
+  }
+  bool mutate_end_mask(int64_t _end_mask) {
+    return SetField<int64_t>(VT_END_MASK, _end_mask, 0);
+  }
+  int64_t ellipsis_mask() const {
+    return GetField<int64_t>(VT_ELLIPSIS_MASK, 0);
+  }
+  bool mutate_ellipsis_mask(int64_t _ellipsis_mask) {
+    return SetField<int64_t>(VT_ELLIPSIS_MASK, _ellipsis_mask, 0);
+  }
+  int64_t new_axis_mask() const {
+    return GetField<int64_t>(VT_NEW_AXIS_MASK, 0);
+  }
+  bool mutate_new_axis_mask(int64_t _new_axis_mask) {
+    return SetField<int64_t>(VT_NEW_AXIS_MASK, _new_axis_mask, 0);
+  }
+  int64_t shrink_axis_mask() const {
+    return GetField<int64_t>(VT_SHRINK_AXIS_MASK, 0);
+  }
+  bool mutate_shrink_axis_mask(int64_t _shrink_axis_mask) {
+    return SetField<int64_t>(VT_SHRINK_AXIS_MASK, _shrink_axis_mask, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_BEGIN_MASK) &&
+           VerifyField<int64_t>(verifier, VT_END_MASK) &&
+           VerifyField<int64_t>(verifier, VT_ELLIPSIS_MASK) &&
+           VerifyField<int64_t>(verifier, VT_NEW_AXIS_MASK) &&
+           VerifyField<int64_t>(verifier, VT_SHRINK_AXIS_MASK) &&
+           verifier.EndTable();
+  }
+  StridedSliceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(StridedSliceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<StridedSlice> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct StridedSliceBuilder {
+  typedef StridedSlice Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_begin_mask(int64_t begin_mask) {
+    fbb_.AddElement<int64_t>(StridedSlice::VT_BEGIN_MASK, begin_mask, 0);
+  }
+  void add_end_mask(int64_t end_mask) {
+    fbb_.AddElement<int64_t>(StridedSlice::VT_END_MASK, end_mask, 0);
+  }
+  void add_ellipsis_mask(int64_t ellipsis_mask) {
+    fbb_.AddElement<int64_t>(StridedSlice::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
+  }
+  void add_new_axis_mask(int64_t new_axis_mask) {
+    fbb_.AddElement<int64_t>(StridedSlice::VT_NEW_AXIS_MASK, new_axis_mask, 0);
+  }
+  void add_shrink_axis_mask(int64_t shrink_axis_mask) {
+    fbb_.AddElement<int64_t>(StridedSlice::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
+  }
+  explicit StridedSliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<StridedSlice> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<StridedSlice>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<StridedSlice> CreateStridedSlice(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t begin_mask = 0,
+    int64_t end_mask = 0,
+    int64_t ellipsis_mask = 0,
+    int64_t new_axis_mask = 0,
+    int64_t shrink_axis_mask = 0) {
+  StridedSliceBuilder builder_(_fbb);
+  builder_.add_shrink_axis_mask(shrink_axis_mask);
+  builder_.add_new_axis_mask(new_axis_mask);
+  builder_.add_ellipsis_mask(ellipsis_mask);
+  builder_.add_end_mask(end_mask);
+  builder_.add_begin_mask(begin_mask);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<StridedSlice> CreateStridedSlice(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SubFusionT : public flatbuffers::NativeTable {
+  typedef SubFusion TableType;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+};
+
+struct SubFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SubFusionT NativeTableType;
+  typedef SubFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SubFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+  SubFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SubFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SubFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SubFusionBuilder {
+  typedef SubFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(SubFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit SubFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SubFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SubFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SubFusion> CreateSubFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  SubFusionBuilder builder_(_fbb);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SubFusion> CreateSubFusion(flatbuffers::FlatBufferBuilder &_fbb, const SubFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SubGradT : public flatbuffers::NativeTable {
+  typedef SubGrad TableType;
+};
+
+struct SubGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SubGradT NativeTableType;
+  typedef SubGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SubGradTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SubGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SubGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SubGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SubGradBuilder {
+  typedef SubGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SubGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SubGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SubGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SubGrad> CreateSubGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SubGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SubGrad> CreateSubGrad(flatbuffers::FlatBufferBuilder &_fbb, const SubGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SwitchT : public flatbuffers::NativeTable {
+  typedef Switch TableType;
+};
+
+struct Switch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SwitchT NativeTableType;
+  typedef SwitchBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SwitchTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SwitchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SwitchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Switch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwitchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SwitchBuilder {
+  typedef Switch Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SwitchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Switch> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Switch>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Switch> CreateSwitch(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SwitchBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Switch> CreateSwitch(flatbuffers::FlatBufferBuilder &_fbb, const SwitchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct TensorListFromTensorT : public flatbuffers::NativeTable {
+  typedef TensorListFromTensor TableType;
+  int64_t element_dtype = 0;
+  int64_t shape_type = 0;
+};
+
+struct TensorListFromTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorListFromTensorT NativeTableType;
+  typedef TensorListFromTensorBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TensorListFromTensorTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ELEMENT_DTYPE = 4,
+    VT_SHAPE_TYPE = 6
+  };
+  int64_t element_dtype() const {
+    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
+  }
+  bool mutate_element_dtype(int64_t _element_dtype) {
+    return SetField<int64_t>(VT_ELEMENT_DTYPE, _element_dtype, 0);
+  }
+  int64_t shape_type() const {
+    return GetField<int64_t>(VT_SHAPE_TYPE, 0);
+  }
+  bool mutate_shape_type(int64_t _shape_type) {
+    return SetField<int64_t>(VT_SHAPE_TYPE, _shape_type, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
+           VerifyField<int64_t>(verifier, VT_SHAPE_TYPE) &&
+           verifier.EndTable();
+  }
+  TensorListFromTensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TensorListFromTensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<TensorListFromTensor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListFromTensorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TensorListFromTensorBuilder {
+  typedef TensorListFromTensor Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_element_dtype(int64_t element_dtype) {
+    fbb_.AddElement<int64_t>(TensorListFromTensor::VT_ELEMENT_DTYPE, element_dtype, 0);
+  }
+  void add_shape_type(int64_t shape_type) {
+    fbb_.AddElement<int64_t>(TensorListFromTensor::VT_SHAPE_TYPE, shape_type, 0);
+  }
+  explicit TensorListFromTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorListFromTensor> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorListFromTensor>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorListFromTensor> CreateTensorListFromTensor(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t element_dtype = 0,
+    int64_t shape_type = 0) {
+  TensorListFromTensorBuilder builder_(_fbb);
+  builder_.add_shape_type(shape_type);
+  builder_.add_element_dtype(element_dtype);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<TensorListFromTensor> CreateTensorListFromTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorListFromTensorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct TensorListGetItemT : public flatbuffers::NativeTable {
+  typedef TensorListGetItem TableType;
+  int64_t element_dtype = 0;
+};
+
+struct TensorListGetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorListGetItemT NativeTableType;
+  typedef TensorListGetItemBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TensorListGetItemTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ELEMENT_DTYPE = 4
+  };
+  int64_t element_dtype() const {
+    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
+  }
+  bool mutate_element_dtype(int64_t _element_dtype) {
+    return SetField<int64_t>(VT_ELEMENT_DTYPE, _element_dtype, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
+           verifier.EndTable();
+  }
+  TensorListGetItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TensorListGetItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<TensorListGetItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListGetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TensorListGetItemBuilder {
+  typedef TensorListGetItem Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_element_dtype(int64_t element_dtype) {
+    fbb_.AddElement<int64_t>(TensorListGetItem::VT_ELEMENT_DTYPE, element_dtype, 0);
+  }
+  explicit TensorListGetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorListGetItem> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorListGetItem>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorListGetItem> CreateTensorListGetItem(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t element_dtype = 0) {
+  TensorListGetItemBuilder builder_(_fbb);
+  builder_.add_element_dtype(element_dtype);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<TensorListGetItem> CreateTensorListGetItem(flatbuffers::FlatBufferBuilder &_fbb, const TensorListGetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct TensorListReserveT : public flatbuffers::NativeTable {
+  typedef TensorListReserve TableType;
+  int64_t element_dtype = 0;
+  int64_t shape_type = 0;
+};
+
+struct TensorListReserve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorListReserveT NativeTableType;
+  typedef TensorListReserveBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TensorListReserveTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ELEMENT_DTYPE = 4,
+    VT_SHAPE_TYPE = 6
+  };
+  int64_t element_dtype() const {
+    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
+  }
+  bool mutate_element_dtype(int64_t _element_dtype) {
+    return SetField<int64_t>(VT_ELEMENT_DTYPE, _element_dtype, 0);
+  }
+  int64_t shape_type() const {
+    return GetField<int64_t>(VT_SHAPE_TYPE, 0);
+  }
+  bool mutate_shape_type(int64_t _shape_type) {
+    return SetField<int64_t>(VT_SHAPE_TYPE, _shape_type, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
+           VerifyField<int64_t>(verifier, VT_SHAPE_TYPE) &&
+           verifier.EndTable();
+  }
+  TensorListReserveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TensorListReserveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<TensorListReserve> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListReserveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TensorListReserveBuilder {
+  typedef TensorListReserve Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_element_dtype(int64_t element_dtype) {
+    fbb_.AddElement<int64_t>(TensorListReserve::VT_ELEMENT_DTYPE, element_dtype, 0);
+  }
+  void add_shape_type(int64_t shape_type) {
+    fbb_.AddElement<int64_t>(TensorListReserve::VT_SHAPE_TYPE, shape_type, 0);
+  }
+  explicit TensorListReserveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorListReserve> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorListReserve>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorListReserve> CreateTensorListReserve(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t element_dtype = 0,
+    int64_t shape_type = 0) {
+  TensorListReserveBuilder builder_(_fbb);
+  builder_.add_shape_type(shape_type);
+  builder_.add_element_dtype(element_dtype);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<TensorListReserve> CreateTensorListReserve(flatbuffers::FlatBufferBuilder &_fbb, const TensorListReserveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct TensorListSetItemT : public flatbuffers::NativeTable {
+  typedef TensorListSetItem TableType;
+  int64_t element_dtype = 0;
+};
+
+struct TensorListSetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorListSetItemT NativeTableType;
+  typedef TensorListSetItemBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TensorListSetItemTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ELEMENT_DTYPE = 4
+  };
+  int64_t element_dtype() const {
+    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
+  }
+  bool mutate_element_dtype(int64_t _element_dtype) {
+    return SetField<int64_t>(VT_ELEMENT_DTYPE, _element_dtype, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
+           verifier.EndTable();
+  }
+  TensorListSetItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TensorListSetItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<TensorListSetItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListSetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TensorListSetItemBuilder {
+  typedef TensorListSetItem Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_element_dtype(int64_t element_dtype) {
+    fbb_.AddElement<int64_t>(TensorListSetItem::VT_ELEMENT_DTYPE, element_dtype, 0);
+  }
+  explicit TensorListSetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorListSetItem> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorListSetItem>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorListSetItem> CreateTensorListSetItem(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t element_dtype = 0) {
+  TensorListSetItemBuilder builder_(_fbb);
+  builder_.add_element_dtype(element_dtype);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<TensorListSetItem> CreateTensorListSetItem(flatbuffers::FlatBufferBuilder &_fbb, const TensorListSetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct TensorListStackT : public flatbuffers::NativeTable {
+  typedef TensorListStack TableType;
+  int64_t num_elements = 0;
+  int64_t element_dtype = 0;
+};
+
+struct TensorListStack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorListStackT NativeTableType;
+  typedef TensorListStackBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TensorListStackTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUM_ELEMENTS = 4,
+    VT_ELEMENT_DTYPE = 6
+  };
+  int64_t num_elements() const {
+    return GetField<int64_t>(VT_NUM_ELEMENTS, 0);
+  }
+  bool mutate_num_elements(int64_t _num_elements) {
+    return SetField<int64_t>(VT_NUM_ELEMENTS, _num_elements, 0);
+  }
+  int64_t element_dtype() const {
+    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
+  }
+  bool mutate_element_dtype(int64_t _element_dtype) {
+    return SetField<int64_t>(VT_ELEMENT_DTYPE, _element_dtype, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_NUM_ELEMENTS) &&
+           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
+           verifier.EndTable();
+  }
+  TensorListStackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TensorListStackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<TensorListStack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListStackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TensorListStackBuilder {
+  typedef TensorListStack Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_num_elements(int64_t num_elements) {
+    fbb_.AddElement<int64_t>(TensorListStack::VT_NUM_ELEMENTS, num_elements, 0);
+  }
+  void add_element_dtype(int64_t element_dtype) {
+    fbb_.AddElement<int64_t>(TensorListStack::VT_ELEMENT_DTYPE, element_dtype, 0);
+  }
+  explicit TensorListStackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorListStack> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorListStack>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorListStack> CreateTensorListStack(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t num_elements = 0,
+    int64_t element_dtype = 0) {
+  TensorListStackBuilder builder_(_fbb);
+  builder_.add_element_dtype(element_dtype);
+  builder_.add_num_elements(num_elements);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<TensorListStack> CreateTensorListStack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListStackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct TileFusionT : public flatbuffers::NativeTable {
+  typedef TileFusion TableType;
+  std::vector<int64_t> dims{};
+};
+
+struct TileFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TileFusionT NativeTableType;
+  typedef TileFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TileFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DIMS = 4
+  };
+  const flatbuffers::Vector<int64_t> *dims() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DIMS);
+  }
+  flatbuffers::Vector<int64_t> *mutable_dims() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DIMS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_DIMS) &&
+           verifier.VerifyVector(dims()) &&
+           verifier.EndTable();
+  }
+  TileFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TileFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<TileFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TileFusionBuilder {
+  typedef TileFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims) {
+    fbb_.AddOffset(TileFusion::VT_DIMS, dims);
+  }
+  explicit TileFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TileFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TileFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TileFusion> CreateTileFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims = 0) {
+  TileFusionBuilder builder_(_fbb);
+  builder_.add_dims(dims);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<TileFusion> CreateTileFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *dims = nullptr) {
+  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
+  return mindspore::schema::CreateTileFusion(
+      _fbb,
+      dims__);
+}
+
+flatbuffers::Offset<TileFusion> CreateTileFusion(flatbuffers::FlatBufferBuilder &_fbb, const TileFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct TopKFusionT : public flatbuffers::NativeTable {
+  typedef TopKFusion TableType;
+  bool sorted = true;
+  int64_t axis = 0;
+  int64_t largest = 0;
+};
+
+struct TopKFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TopKFusionT NativeTableType;
+  typedef TopKFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TopKFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SORTED = 4,
+    VT_AXIS = 6,
+    VT_LARGEST = 8
+  };
+  bool sorted() const {
+    return GetField<uint8_t>(VT_SORTED, 1) != 0;
+  }
+  bool mutate_sorted(bool _sorted) {
+    return SetField<uint8_t>(VT_SORTED, static_cast<uint8_t>(_sorted), 1);
+  }
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  int64_t largest() const {
+    return GetField<int64_t>(VT_LARGEST, 0);
+  }
+  bool mutate_largest(int64_t _largest) {
+    return SetField<int64_t>(VT_LARGEST, _largest, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_SORTED) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_LARGEST) &&
+           verifier.EndTable();
+  }
+  TopKFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TopKFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<TopKFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TopKFusionBuilder {
+  typedef TopKFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_sorted(bool sorted) {
+    fbb_.AddElement<uint8_t>(TopKFusion::VT_SORTED, static_cast<uint8_t>(sorted), 1);
+  }
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(TopKFusion::VT_AXIS, axis, 0);
+  }
+  void add_largest(int64_t largest) {
+    fbb_.AddElement<int64_t>(TopKFusion::VT_LARGEST, largest, 0);
+  }
+  explicit TopKFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TopKFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TopKFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TopKFusion> CreateTopKFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool sorted = true,
+    int64_t axis = 0,
+    int64_t largest = 0) {
+  TopKFusionBuilder builder_(_fbb);
+  builder_.add_largest(largest);
+  builder_.add_axis(axis);
+  builder_.add_sorted(sorted);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<TopKFusion> CreateTopKFusion(flatbuffers::FlatBufferBuilder &_fbb, const TopKFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct TransposeT : public flatbuffers::NativeTable {
+  typedef Transpose TableType;
+};
+
+struct Transpose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TransposeT NativeTableType;
+  typedef TransposeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TransposeTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  TransposeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TransposeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Transpose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TransposeBuilder {
+  typedef Transpose Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit TransposeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Transpose> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Transpose>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Transpose> CreateTranspose(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  TransposeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Transpose> CreateTranspose(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct UniqueT : public flatbuffers::NativeTable {
+  typedef Unique TableType;
+};
+
+struct Unique FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef UniqueT NativeTableType;
+  typedef UniqueBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return UniqueTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  UniqueT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(UniqueT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Unique> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct UniqueBuilder {
+  typedef Unique Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit UniqueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Unique> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Unique>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Unique> CreateUnique(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  UniqueBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Unique> CreateUnique(flatbuffers::FlatBufferBuilder &_fbb, const UniqueT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct UnsortedSegmentSumT : public flatbuffers::NativeTable {
+  typedef UnsortedSegmentSum TableType;
+};
+
+struct UnsortedSegmentSum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef UnsortedSegmentSumT NativeTableType;
+  typedef UnsortedSegmentSumBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return UnsortedSegmentSumTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  UnsortedSegmentSumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(UnsortedSegmentSumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<UnsortedSegmentSum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct UnsortedSegmentSumBuilder {
+  typedef UnsortedSegmentSum Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit UnsortedSegmentSumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<UnsortedSegmentSum> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<UnsortedSegmentSum>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<UnsortedSegmentSum> CreateUnsortedSegmentSum(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  UnsortedSegmentSumBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<UnsortedSegmentSum> CreateUnsortedSegmentSum(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct UnsqueezeT : public flatbuffers::NativeTable {
+  typedef Unsqueeze TableType;
+  std::vector<int64_t> axis{};
+};
+
+struct Unsqueeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef UnsqueezeT NativeTableType;
+  typedef UnsqueezeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return UnsqueezeTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  const flatbuffers::Vector<int64_t> *axis() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  flatbuffers::Vector<int64_t> *mutable_axis() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_AXIS) &&
+           verifier.VerifyVector(axis()) &&
+           verifier.EndTable();
+  }
+  UnsqueezeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(UnsqueezeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Unsqueeze> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct UnsqueezeBuilder {
+  typedef Unsqueeze Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
+    fbb_.AddOffset(Unsqueeze::VT_AXIS, axis);
+  }
+  explicit UnsqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Unsqueeze> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Unsqueeze>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
+  UnsqueezeBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Unsqueeze> CreateUnsqueezeDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *axis = nullptr) {
+  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
+  return mindspore::schema::CreateUnsqueeze(
+      _fbb,
+      axis__);
+}
+
+flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(flatbuffers::FlatBufferBuilder &_fbb, const UnsqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct UnstackT : public flatbuffers::NativeTable {
+  typedef Unstack TableType;
+  int64_t axis = 0;
+};
+
+struct Unstack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef UnstackT NativeTableType;
+  typedef UnstackBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return UnstackTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+  UnstackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(UnstackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Unstack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnstackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct UnstackBuilder {
+  typedef Unstack Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(Unstack::VT_AXIS, axis, 0);
+  }
+  explicit UnstackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Unstack> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Unstack>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Unstack> CreateUnstack(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0) {
+  UnstackBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Unstack> CreateUnstack(flatbuffers::FlatBufferBuilder &_fbb, const UnstackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct WhereT : public flatbuffers::NativeTable {
+  typedef Where TableType;
+};
+
+struct Where FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef WhereT NativeTableType;
+  typedef WhereBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return WhereTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  WhereT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(WhereT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Where> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct WhereBuilder {
+  typedef Where Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit WhereBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Where> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Where>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Where> CreateWhere(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  WhereBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Where> CreateWhere(flatbuffers::FlatBufferBuilder &_fbb, const WhereT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ZerosLikeT : public flatbuffers::NativeTable {
+  typedef ZerosLike TableType;
+};
+
+struct ZerosLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ZerosLikeT NativeTableType;
+  typedef ZerosLikeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ZerosLikeTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  ZerosLikeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ZerosLikeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ZerosLike> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ZerosLikeBuilder {
+  typedef ZerosLike Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ZerosLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ZerosLike> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ZerosLike>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ZerosLike> CreateZerosLike(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ZerosLikeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ZerosLike> CreateZerosLike(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SelectT : public flatbuffers::NativeTable {
+  typedef Select TableType;
+};
+
+struct Select FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SelectT NativeTableType;
+  typedef SelectBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SelectTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SelectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SelectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Select> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SelectBuilder {
+  typedef Select Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SelectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Select> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Select>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Select> CreateSelect(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SelectBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Select> CreateSelect(flatbuffers::FlatBufferBuilder &_fbb, const SelectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct GRUT : public flatbuffers::NativeTable {
+  typedef GRU TableType;
+  bool bidirectional = false;
+};
+
+struct GRU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GRUT NativeTableType;
+  typedef GRUBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return GRUTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BIDIRECTIONAL = 4
+  };
+  bool bidirectional() const {
+    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
+  }
+  bool mutate_bidirectional(bool _bidirectional) {
+    return SetField<uint8_t>(VT_BIDIRECTIONAL, static_cast<uint8_t>(_bidirectional), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
+           verifier.EndTable();
+  }
+  GRUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(GRUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<GRU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GRUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct GRUBuilder {
+  typedef GRU Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_bidirectional(bool bidirectional) {
+    fbb_.AddElement<uint8_t>(GRU::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
+  }
+  explicit GRUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GRU> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GRU>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GRU> CreateGRU(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool bidirectional = false) {
+  GRUBuilder builder_(_fbb);
+  builder_.add_bidirectional(bidirectional);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<GRU> CreateGRU(flatbuffers::FlatBufferBuilder &_fbb, const GRUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct NonZeroT : public flatbuffers::NativeTable {
+  typedef NonZero TableType;
+};
+
+struct NonZero FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NonZeroT NativeTableType;
+  typedef NonZeroBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return NonZeroTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  NonZeroT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(NonZeroT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<NonZero> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonZeroT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct NonZeroBuilder {
+  typedef NonZero Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit NonZeroBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<NonZero> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<NonZero>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<NonZero> CreateNonZero(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  NonZeroBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<NonZero> CreateNonZero(flatbuffers::FlatBufferBuilder &_fbb, const NonZeroT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct InvertPermutationT : public flatbuffers::NativeTable {
+  typedef InvertPermutation TableType;
+};
+
+struct InvertPermutation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef InvertPermutationT NativeTableType;
+  typedef InvertPermutationBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return InvertPermutationTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  InvertPermutationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(InvertPermutationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<InvertPermutation> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InvertPermutationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct InvertPermutationBuilder {
+  typedef InvertPermutation Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit InvertPermutationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<InvertPermutation> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<InvertPermutation>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<InvertPermutation> CreateInvertPermutation(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  InvertPermutationBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<InvertPermutation> CreateInvertPermutation(flatbuffers::FlatBufferBuilder &_fbb, const InvertPermutationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SizeT : public flatbuffers::NativeTable {
+  typedef Size TableType;
+};
+
+struct Size FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SizeT NativeTableType;
+  typedef SizeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SizeTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Size> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SizeBuilder {
+  typedef Size Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Size> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Size>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Size> CreateSize(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SizeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Size> CreateSize(flatbuffers::FlatBufferBuilder &_fbb, const SizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct RandomStandardNormalT : public flatbuffers::NativeTable {
+  typedef RandomStandardNormal TableType;
+  int64_t seed = 0;
+  int64_t seed2 = 0;
+};
+
+struct RandomStandardNormal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RandomStandardNormalT NativeTableType;
+  typedef RandomStandardNormalBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return RandomStandardNormalTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SEED = 4,
+    VT_SEED2 = 6
+  };
+  int64_t seed() const {
+    return GetField<int64_t>(VT_SEED, 0);
+  }
+  bool mutate_seed(int64_t _seed) {
+    return SetField<int64_t>(VT_SEED, _seed, 0);
+  }
+  int64_t seed2() const {
+    return GetField<int64_t>(VT_SEED2, 0);
+  }
+  bool mutate_seed2(int64_t _seed2) {
+    return SetField<int64_t>(VT_SEED2, _seed2, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SEED) &&
+           VerifyField<int64_t>(verifier, VT_SEED2) &&
+           verifier.EndTable();
+  }
+  RandomStandardNormalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(RandomStandardNormalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<RandomStandardNormal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomStandardNormalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct RandomStandardNormalBuilder {
+  typedef RandomStandardNormal Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_seed(int64_t seed) {
+    fbb_.AddElement<int64_t>(RandomStandardNormal::VT_SEED, seed, 0);
+  }
+  void add_seed2(int64_t seed2) {
+    fbb_.AddElement<int64_t>(RandomStandardNormal::VT_SEED2, seed2, 0);
+  }
+  explicit RandomStandardNormalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<RandomStandardNormal> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<RandomStandardNormal>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<RandomStandardNormal> CreateRandomStandardNormal(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t seed = 0,
+    int64_t seed2 = 0) {
+  RandomStandardNormalBuilder builder_(_fbb);
+  builder_.add_seed2(seed2);
+  builder_.add_seed(seed);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<RandomStandardNormal> CreateRandomStandardNormal(flatbuffers::FlatBufferBuilder &_fbb, const RandomStandardNormalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct CropAndResizeT : public flatbuffers::NativeTable {
+  typedef CropAndResize TableType;
+  mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR;
+  float extrapolation_value = 0.0f;
+};
+
+struct CropAndResize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CropAndResizeT NativeTableType;
+  typedef CropAndResizeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return CropAndResizeTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_METHOD = 4,
+    VT_EXTRAPOLATION_VALUE = 6
+  };
+  mindspore::schema::ResizeMethod method() const {
+    return static_cast<mindspore::schema::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
+  }
+  bool mutate_method(mindspore::schema::ResizeMethod _method) {
+    return SetField<int8_t>(VT_METHOD, static_cast<int8_t>(_method), 0);
+  }
+  float extrapolation_value() const {
+    return GetField<float>(VT_EXTRAPOLATION_VALUE, 0.0f);
+  }
+  bool mutate_extrapolation_value(float _extrapolation_value) {
+    return SetField<float>(VT_EXTRAPOLATION_VALUE, _extrapolation_value, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_METHOD) &&
+           VerifyField<float>(verifier, VT_EXTRAPOLATION_VALUE) &&
+           verifier.EndTable();
+  }
+  CropAndResizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(CropAndResizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<CropAndResize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct CropAndResizeBuilder {
+  typedef CropAndResize Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_method(mindspore::schema::ResizeMethod method) {
+    fbb_.AddElement<int8_t>(CropAndResize::VT_METHOD, static_cast<int8_t>(method), 0);
+  }
+  void add_extrapolation_value(float extrapolation_value) {
+    fbb_.AddElement<float>(CropAndResize::VT_EXTRAPOLATION_VALUE, extrapolation_value, 0.0f);
+  }
+  explicit CropAndResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<CropAndResize> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<CropAndResize>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<CropAndResize> CreateCropAndResize(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR,
+    float extrapolation_value = 0.0f) {
+  CropAndResizeBuilder builder_(_fbb);
+  builder_.add_extrapolation_value(extrapolation_value);
+  builder_.add_method(method);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<CropAndResize> CreateCropAndResize(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ErfT : public flatbuffers::NativeTable {
+  typedef Erf TableType;
+};
+
+struct Erf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ErfT NativeTableType;
+  typedef ErfBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ErfTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  ErfT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ErfT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Erf> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErfT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ErfBuilder {
+  typedef Erf Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ErfBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Erf> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Erf>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Erf> CreateErf(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ErfBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Erf> CreateErf(flatbuffers::FlatBufferBuilder &_fbb, const ErfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct StridedSliceGradT : public flatbuffers::NativeTable {
+  typedef StridedSliceGrad TableType;
+  int64_t begin_mask = 0;
+  int64_t end_mask = 0;
+  int64_t ellipsis_mask = 0;
+  int64_t new_axis_mask = 0;
+  int64_t shrink_axis_mask = 0;
+};
+
+struct StridedSliceGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef StridedSliceGradT NativeTableType;
+  typedef StridedSliceGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return StridedSliceGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BEGIN_MASK = 4,
+    VT_END_MASK = 6,
+    VT_ELLIPSIS_MASK = 8,
+    VT_NEW_AXIS_MASK = 10,
+    VT_SHRINK_AXIS_MASK = 12
+  };
+  int64_t begin_mask() const {
+    return GetField<int64_t>(VT_BEGIN_MASK, 0);
+  }
+  bool mutate_begin_mask(int64_t _begin_mask) {
+    return SetField<int64_t>(VT_BEGIN_MASK, _begin_mask, 0);
+  }
+  int64_t end_mask() const {
+    return GetField<int64_t>(VT_END_MASK, 0);
+  }
+  bool mutate_end_mask(int64_t _end_mask) {
+    return SetField<int64_t>(VT_END_MASK, _end_mask, 0);
+  }
+  int64_t ellipsis_mask() const {
+    return GetField<int64_t>(VT_ELLIPSIS_MASK, 0);
+  }
+  bool mutate_ellipsis_mask(int64_t _ellipsis_mask) {
+    return SetField<int64_t>(VT_ELLIPSIS_MASK, _ellipsis_mask, 0);
+  }
+  int64_t new_axis_mask() const {
+    return GetField<int64_t>(VT_NEW_AXIS_MASK, 0);
+  }
+  bool mutate_new_axis_mask(int64_t _new_axis_mask) {
+    return SetField<int64_t>(VT_NEW_AXIS_MASK, _new_axis_mask, 0);
+  }
+  int64_t shrink_axis_mask() const {
+    return GetField<int64_t>(VT_SHRINK_AXIS_MASK, 0);
+  }
+  bool mutate_shrink_axis_mask(int64_t _shrink_axis_mask) {
+    return SetField<int64_t>(VT_SHRINK_AXIS_MASK, _shrink_axis_mask, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_BEGIN_MASK) &&
+           VerifyField<int64_t>(verifier, VT_END_MASK) &&
+           VerifyField<int64_t>(verifier, VT_ELLIPSIS_MASK) &&
+           VerifyField<int64_t>(verifier, VT_NEW_AXIS_MASK) &&
+           VerifyField<int64_t>(verifier, VT_SHRINK_AXIS_MASK) &&
+           verifier.EndTable();
+  }
+  StridedSliceGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(StridedSliceGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<StridedSliceGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct StridedSliceGradBuilder {
+  typedef StridedSliceGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_begin_mask(int64_t begin_mask) {
+    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_BEGIN_MASK, begin_mask, 0);
+  }
+  void add_end_mask(int64_t end_mask) {
+    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_END_MASK, end_mask, 0);
+  }
+  void add_ellipsis_mask(int64_t ellipsis_mask) {
+    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
+  }
+  void add_new_axis_mask(int64_t new_axis_mask) {
+    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_NEW_AXIS_MASK, new_axis_mask, 0);
+  }
+  void add_shrink_axis_mask(int64_t shrink_axis_mask) {
+    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
+  }
+  explicit StridedSliceGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<StridedSliceGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<StridedSliceGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<StridedSliceGrad> CreateStridedSliceGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t begin_mask = 0,
+    int64_t end_mask = 0,
+    int64_t ellipsis_mask = 0,
+    int64_t new_axis_mask = 0,
+    int64_t shrink_axis_mask = 0) {
+  StridedSliceGradBuilder builder_(_fbb);
+  builder_.add_shrink_axis_mask(shrink_axis_mask);
+  builder_.add_new_axis_mask(new_axis_mask);
+  builder_.add_ellipsis_mask(ellipsis_mask);
+  builder_.add_end_mask(end_mask);
+  builder_.add_begin_mask(begin_mask);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<StridedSliceGrad> CreateStridedSliceGrad(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct IsFiniteT : public flatbuffers::NativeTable {
+  typedef IsFinite TableType;
+};
+
+struct IsFinite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef IsFiniteT NativeTableType;
+  typedef IsFiniteBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return IsFiniteTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  IsFiniteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(IsFiniteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<IsFinite> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IsFiniteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct IsFiniteBuilder {
+  typedef IsFinite Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit IsFiniteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<IsFinite> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<IsFinite>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<IsFinite> CreateIsFinite(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  IsFiniteBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<IsFinite> CreateIsFinite(flatbuffers::FlatBufferBuilder &_fbb, const IsFiniteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LinSpaceT : public flatbuffers::NativeTable {
+  typedef LinSpace TableType;
+};
+
+struct LinSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LinSpaceT NativeTableType;
+  typedef LinSpaceBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LinSpaceTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  LinSpaceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LinSpaceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LinSpace> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LinSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LinSpaceBuilder {
+  typedef LinSpace Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LinSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LinSpace> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LinSpace>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LinSpace> CreateLinSpace(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LinSpaceBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LinSpace> CreateLinSpace(flatbuffers::FlatBufferBuilder &_fbb, const LinSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct UniformRealT : public flatbuffers::NativeTable {
+  typedef UniformReal TableType;
+  int64_t seed = 0;
+  int64_t seed2 = 0;
+};
+
+struct UniformReal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef UniformRealT NativeTableType;
+  typedef UniformRealBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return UniformRealTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SEED = 4,
+    VT_SEED2 = 6
+  };
+  int64_t seed() const {
+    return GetField<int64_t>(VT_SEED, 0);
+  }
+  bool mutate_seed(int64_t _seed) {
+    return SetField<int64_t>(VT_SEED, _seed, 0);
+  }
+  int64_t seed2() const {
+    return GetField<int64_t>(VT_SEED2, 0);
+  }
+  bool mutate_seed2(int64_t _seed2) {
+    return SetField<int64_t>(VT_SEED2, _seed2, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SEED) &&
+           VerifyField<int64_t>(verifier, VT_SEED2) &&
+           verifier.EndTable();
+  }
+  UniformRealT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(UniformRealT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<UniformReal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniformRealT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct UniformRealBuilder {
+  typedef UniformReal Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_seed(int64_t seed) {
+    fbb_.AddElement<int64_t>(UniformReal::VT_SEED, seed, 0);
+  }
+  void add_seed2(int64_t seed2) {
+    fbb_.AddElement<int64_t>(UniformReal::VT_SEED2, seed2, 0);
+  }
+  explicit UniformRealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<UniformReal> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<UniformReal>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<UniformReal> CreateUniformReal(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t seed = 0,
+    int64_t seed2 = 0) {
+  UniformRealBuilder builder_(_fbb);
+  builder_.add_seed2(seed2);
+  builder_.add_seed(seed);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<UniformReal> CreateUniformReal(flatbuffers::FlatBufferBuilder &_fbb, const UniformRealT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AbsGradT : public flatbuffers::NativeTable {
+  typedef AbsGrad TableType;
+};
+
+struct AbsGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AbsGradT NativeTableType;
+  typedef AbsGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AbsGradTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  AbsGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AbsGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<AbsGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AbsGradBuilder {
+  typedef AbsGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AbsGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AbsGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AbsGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AbsGrad> CreateAbsGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AbsGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<AbsGrad> CreateAbsGrad(flatbuffers::FlatBufferBuilder &_fbb, const AbsGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct RsqrtGradT : public flatbuffers::NativeTable {
+  typedef RsqrtGrad TableType;
+};
+
+struct RsqrtGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RsqrtGradT NativeTableType;
+  typedef RsqrtGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return RsqrtGradTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  RsqrtGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(RsqrtGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<RsqrtGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct RsqrtGradBuilder {
+  typedef RsqrtGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit RsqrtGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<RsqrtGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<RsqrtGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<RsqrtGrad> CreateRsqrtGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  RsqrtGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<RsqrtGrad> CreateRsqrtGrad(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SqrtGradT : public flatbuffers::NativeTable {
+  typedef SqrtGrad TableType;
+};
+
+struct SqrtGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SqrtGradT NativeTableType;
+  typedef SqrtGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SqrtGradTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  SqrtGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SqrtGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SqrtGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SqrtGradBuilder {
+  typedef SqrtGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SqrtGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SqrtGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SqrtGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SqrtGrad> CreateSqrtGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SqrtGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<SqrtGrad> CreateSqrtGrad(flatbuffers::FlatBufferBuilder &_fbb, const SqrtGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LayerNormGradT : public flatbuffers::NativeTable {
+  typedef LayerNormGrad TableType;
+  int64_t begin_norm_axis = 0;
+  int64_t begin_params_axis = 0;
+};
+
+struct LayerNormGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LayerNormGradT NativeTableType;
+  typedef LayerNormGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LayerNormGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BEGIN_NORM_AXIS = 4,
+    VT_BEGIN_PARAMS_AXIS = 6
+  };
+  int64_t begin_norm_axis() const {
+    return GetField<int64_t>(VT_BEGIN_NORM_AXIS, 0);
+  }
+  bool mutate_begin_norm_axis(int64_t _begin_norm_axis) {
+    return SetField<int64_t>(VT_BEGIN_NORM_AXIS, _begin_norm_axis, 0);
+  }
+  int64_t begin_params_axis() const {
+    return GetField<int64_t>(VT_BEGIN_PARAMS_AXIS, 0);
+  }
+  bool mutate_begin_params_axis(int64_t _begin_params_axis) {
+    return SetField<int64_t>(VT_BEGIN_PARAMS_AXIS, _begin_params_axis, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_BEGIN_NORM_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_BEGIN_PARAMS_AXIS) &&
+           verifier.EndTable();
+  }
+  LayerNormGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LayerNormGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LayerNormGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LayerNormGradBuilder {
+  typedef LayerNormGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_begin_norm_axis(int64_t begin_norm_axis) {
+    fbb_.AddElement<int64_t>(LayerNormGrad::VT_BEGIN_NORM_AXIS, begin_norm_axis, 0);
+  }
+  void add_begin_params_axis(int64_t begin_params_axis) {
+    fbb_.AddElement<int64_t>(LayerNormGrad::VT_BEGIN_PARAMS_AXIS, begin_params_axis, 0);
+  }
+  explicit LayerNormGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LayerNormGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LayerNormGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LayerNormGrad> CreateLayerNormGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t begin_norm_axis = 0,
+    int64_t begin_params_axis = 0) {
+  LayerNormGradBuilder builder_(_fbb);
+  builder_.add_begin_params_axis(begin_params_axis);
+  builder_.add_begin_norm_axis(begin_norm_axis);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LayerNormGrad> CreateLayerNormGrad(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ResizeGradT : public flatbuffers::NativeTable {
+  typedef ResizeGrad TableType;
+  mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR;
+  bool align_corners = false;
+};
+
+struct ResizeGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ResizeGradT NativeTableType;
+  typedef ResizeGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ResizeGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_METHOD = 4,
+    VT_ALIGN_CORNERS = 6
+  };
+  mindspore::schema::ResizeMethod method() const {
+    return static_cast<mindspore::schema::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
+  }
+  bool mutate_method(mindspore::schema::ResizeMethod _method) {
+    return SetField<int8_t>(VT_METHOD, static_cast<int8_t>(_method), 0);
+  }
+  bool align_corners() const {
+    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
+  }
+  bool mutate_align_corners(bool _align_corners) {
+    return SetField<uint8_t>(VT_ALIGN_CORNERS, static_cast<uint8_t>(_align_corners), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_METHOD) &&
+           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
+           verifier.EndTable();
+  }
+  ResizeGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ResizeGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ResizeGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ResizeGradBuilder {
+  typedef ResizeGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_method(mindspore::schema::ResizeMethod method) {
+    fbb_.AddElement<int8_t>(ResizeGrad::VT_METHOD, static_cast<int8_t>(method), 0);
+  }
+  void add_align_corners(bool align_corners) {
+    fbb_.AddElement<uint8_t>(ResizeGrad::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
+  }
+  explicit ResizeGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ResizeGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ResizeGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ResizeGrad> CreateResizeGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR,
+    bool align_corners = false) {
+  ResizeGradBuilder builder_(_fbb);
+  builder_.add_align_corners(align_corners);
+  builder_.add_method(method);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ResizeGrad> CreateResizeGrad(flatbuffers::FlatBufferBuilder &_fbb, const ResizeGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SpliceT : public flatbuffers::NativeTable {
+  typedef Splice TableType;
+  std::vector<int64_t> context{};
+  std::vector<int64_t> forward_indexes{};
+  int64_t output_dim = 0;
+};
+
+struct Splice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SpliceT NativeTableType;
+  typedef SpliceBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SpliceTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_CONTEXT = 4,
+    VT_FORWARD_INDEXES = 6,
+    VT_OUTPUT_DIM = 8
+  };
+  const flatbuffers::Vector<int64_t> *context() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_CONTEXT);
+  }
+  flatbuffers::Vector<int64_t> *mutable_context() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_CONTEXT);
+  }
+  const flatbuffers::Vector<int64_t> *forward_indexes() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_FORWARD_INDEXES);
+  }
+  flatbuffers::Vector<int64_t> *mutable_forward_indexes() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_FORWARD_INDEXES);
+  }
+  int64_t output_dim() const {
+    return GetField<int64_t>(VT_OUTPUT_DIM, 0);
+  }
+  bool mutate_output_dim(int64_t _output_dim) {
+    return SetField<int64_t>(VT_OUTPUT_DIM, _output_dim, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_CONTEXT) &&
+           verifier.VerifyVector(context()) &&
+           VerifyOffset(verifier, VT_FORWARD_INDEXES) &&
+           verifier.VerifyVector(forward_indexes()) &&
+           VerifyField<int64_t>(verifier, VT_OUTPUT_DIM) &&
+           verifier.EndTable();
+  }
+  SpliceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SpliceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Splice> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpliceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SpliceBuilder {
+  typedef Splice Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_context(flatbuffers::Offset<flatbuffers::Vector<int64_t>> context) {
+    fbb_.AddOffset(Splice::VT_CONTEXT, context);
+  }
+  void add_forward_indexes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> forward_indexes) {
+    fbb_.AddOffset(Splice::VT_FORWARD_INDEXES, forward_indexes);
+  }
+  void add_output_dim(int64_t output_dim) {
+    fbb_.AddElement<int64_t>(Splice::VT_OUTPUT_DIM, output_dim, 0);
+  }
+  explicit SpliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Splice> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Splice>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Splice> CreateSplice(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> context = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> forward_indexes = 0,
+    int64_t output_dim = 0) {
+  SpliceBuilder builder_(_fbb);
+  builder_.add_output_dim(output_dim);
+  builder_.add_forward_indexes(forward_indexes);
+  builder_.add_context(context);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Splice> CreateSpliceDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *context = nullptr,
+    const std::vector<int64_t> *forward_indexes = nullptr,
+    int64_t output_dim = 0) {
+  auto context__ = context ? _fbb.CreateVector<int64_t>(*context) : 0;
+  auto forward_indexes__ = forward_indexes ? _fbb.CreateVector<int64_t>(*forward_indexes) : 0;
+  return mindspore::schema::CreateSplice(
+      _fbb,
+      context__,
+      forward_indexes__,
+      output_dim);
+}
+
+flatbuffers::Offset<Splice> CreateSplice(flatbuffers::FlatBufferBuilder &_fbb, const SpliceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LogSoftmaxT : public flatbuffers::NativeTable {
+  typedef LogSoftmax TableType;
+  int64_t axis = 0;
+};
+
+struct LogSoftmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LogSoftmaxT NativeTableType;
+  typedef LogSoftmaxBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LogSoftmaxTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+  LogSoftmaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LogSoftmaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LogSoftmax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LogSoftmaxBuilder {
+  typedef LogSoftmax Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(LogSoftmax::VT_AXIS, axis, 0);
+  }
+  explicit LogSoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LogSoftmax> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LogSoftmax>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LogSoftmax> CreateLogSoftmax(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0) {
+  LogSoftmaxBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LogSoftmax> CreateLogSoftmax(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct CallT : public flatbuffers::NativeTable {
+  typedef Call TableType;
+  bool is_tail_call = true;
+};
+
+struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CallT NativeTableType;
+  typedef CallBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return CallTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_IS_TAIL_CALL = 4
+  };
+  bool is_tail_call() const {
+    return GetField<uint8_t>(VT_IS_TAIL_CALL, 1) != 0;
+  }
+  bool mutate_is_tail_call(bool _is_tail_call) {
+    return SetField<uint8_t>(VT_IS_TAIL_CALL, static_cast<uint8_t>(_is_tail_call), 1);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_IS_TAIL_CALL) &&
+           verifier.EndTable();
+  }
+  CallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(CallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Call> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct CallBuilder {
+  typedef Call Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_is_tail_call(bool is_tail_call) {
+    fbb_.AddElement<uint8_t>(Call::VT_IS_TAIL_CALL, static_cast<uint8_t>(is_tail_call), 1);
+  }
+  explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Call> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Call>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Call> CreateCall(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool is_tail_call = true) {
+  CallBuilder builder_(_fbb);
+  builder_.add_is_tail_call(is_tail_call);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<Call> CreateCall(flatbuffers::FlatBufferBuilder &_fbb, const CallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct CumSumT : public flatbuffers::NativeTable {
+  typedef CumSum TableType;
+  bool exclusive = false;
+  bool reverse = false;
+};
+
+struct CumSum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CumSumT NativeTableType;
+  typedef CumSumBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return CumSumTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_EXCLUSIVE = 4,
+    VT_REVERSE = 6
+  };
+  bool exclusive() const {
+    return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0;
+  }
+  bool mutate_exclusive(bool _exclusive) {
+    return SetField<uint8_t>(VT_EXCLUSIVE, static_cast<uint8_t>(_exclusive), 0);
+  }
+  bool reverse() const {
+    return GetField<uint8_t>(VT_REVERSE, 0) != 0;
+  }
+  bool mutate_reverse(bool _reverse) {
+    return SetField<uint8_t>(VT_REVERSE, static_cast<uint8_t>(_reverse), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_EXCLUSIVE) &&
+           VerifyField<uint8_t>(verifier, VT_REVERSE) &&
+           verifier.EndTable();
+  }
+  CumSumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(CumSumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<CumSum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct CumSumBuilder {
+  typedef CumSum Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_exclusive(bool exclusive) {
+    fbb_.AddElement<uint8_t>(CumSum::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);
+  }
+  void add_reverse(bool reverse) {
+    fbb_.AddElement<uint8_t>(CumSum::VT_REVERSE, static_cast<uint8_t>(reverse), 0);
+  }
+  explicit CumSumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<CumSum> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<CumSum>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<CumSum> CreateCumSum(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool exclusive = false,
+    bool reverse = false) {
+  CumSumBuilder builder_(_fbb);
+  builder_.add_reverse(reverse);
+  builder_.add_exclusive(exclusive);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<CumSum> CreateCumSum(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct CustomT : public flatbuffers::NativeTable {
+  typedef Custom TableType;
+  std::string type{};
+  std::vector<std::unique_ptr<mindspore::schema::AttributeT>> attr{};
+};
+
+struct Custom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CustomT NativeTableType;
+  typedef CustomBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return CustomTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_TYPE = 4,
+    VT_ATTR = 6
+  };
+  const flatbuffers::String *type() const {
+    return GetPointer<const flatbuffers::String *>(VT_TYPE);
+  }
+  flatbuffers::String *mutable_type() {
+    return GetPointer<flatbuffers::String *>(VT_TYPE);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>> *attr() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>> *>(VT_ATTR);
+  }
+  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>> *mutable_attr() {
+    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>> *>(VT_ATTR);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_TYPE) &&
+           verifier.VerifyString(type()) &&
+           VerifyOffset(verifier, VT_ATTR) &&
+           verifier.VerifyVector(attr()) &&
+           verifier.VerifyVectorOfTables(attr()) &&
+           verifier.EndTable();
+  }
+  CustomT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(CustomT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Custom> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct CustomBuilder {
+  typedef Custom Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
+    fbb_.AddOffset(Custom::VT_TYPE, type);
+  }
+  void add_attr(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>>> attr) {
+    fbb_.AddOffset(Custom::VT_ATTR, attr);
+  }
+  explicit CustomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Custom> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Custom>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Custom> CreateCustom(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> type = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>>> attr = 0) {
+  CustomBuilder builder_(_fbb);
+  builder_.add_attr(attr);
+  builder_.add_type(type);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Custom> CreateCustomDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *type = nullptr,
+    const std::vector<flatbuffers::Offset<mindspore::schema::Attribute>> *attr = nullptr) {
+  auto type__ = type ? _fbb.CreateString(type) : 0;
+  auto attr__ = attr ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Attribute>>(*attr) : 0;
+  return mindspore::schema::CreateCustom(
+      _fbb,
+      type__,
+      attr__);
+}
+
+flatbuffers::Offset<Custom> CreateCustom(flatbuffers::FlatBufferBuilder &_fbb, const CustomT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct SplitWithOverlapT : public flatbuffers::NativeTable {
+  typedef SplitWithOverlap TableType;
+  int64_t split_dim = 0;
+  int64_t number_split = 0;
+  std::vector<int64_t> ratio{};
+  std::vector<int64_t> extend_top{};
+  std::vector<int64_t> extend_bottom{};
+};
+
+struct SplitWithOverlap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SplitWithOverlapT NativeTableType;
+  typedef SplitWithOverlapBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return SplitWithOverlapTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SPLIT_DIM = 4,
+    VT_NUMBER_SPLIT = 6,
+    VT_RATIO = 8,
+    VT_EXTEND_TOP = 10,
+    VT_EXTEND_BOTTOM = 12
+  };
+  int64_t split_dim() const {
+    return GetField<int64_t>(VT_SPLIT_DIM, 0);
+  }
+  bool mutate_split_dim(int64_t _split_dim) {
+    return SetField<int64_t>(VT_SPLIT_DIM, _split_dim, 0);
+  }
+  int64_t number_split() const {
+    return GetField<int64_t>(VT_NUMBER_SPLIT, 0);
+  }
+  bool mutate_number_split(int64_t _number_split) {
+    return SetField<int64_t>(VT_NUMBER_SPLIT, _number_split, 0);
+  }
+  const flatbuffers::Vector<int64_t> *ratio() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_RATIO);
+  }
+  flatbuffers::Vector<int64_t> *mutable_ratio() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_RATIO);
+  }
+  const flatbuffers::Vector<int64_t> *extend_top() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EXTEND_TOP);
+  }
+  flatbuffers::Vector<int64_t> *mutable_extend_top() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_EXTEND_TOP);
+  }
+  const flatbuffers::Vector<int64_t> *extend_bottom() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EXTEND_BOTTOM);
+  }
+  flatbuffers::Vector<int64_t> *mutable_extend_bottom() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_EXTEND_BOTTOM);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SPLIT_DIM) &&
+           VerifyField<int64_t>(verifier, VT_NUMBER_SPLIT) &&
+           VerifyOffset(verifier, VT_RATIO) &&
+           verifier.VerifyVector(ratio()) &&
+           VerifyOffset(verifier, VT_EXTEND_TOP) &&
+           verifier.VerifyVector(extend_top()) &&
+           VerifyOffset(verifier, VT_EXTEND_BOTTOM) &&
+           verifier.VerifyVector(extend_bottom()) &&
+           verifier.EndTable();
+  }
+  SplitWithOverlapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(SplitWithOverlapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<SplitWithOverlap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitWithOverlapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct SplitWithOverlapBuilder {
+  typedef SplitWithOverlap Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_split_dim(int64_t split_dim) {
+    fbb_.AddElement<int64_t>(SplitWithOverlap::VT_SPLIT_DIM, split_dim, 0);
+  }
+  void add_number_split(int64_t number_split) {
+    fbb_.AddElement<int64_t>(SplitWithOverlap::VT_NUMBER_SPLIT, number_split, 0);
+  }
+  void add_ratio(flatbuffers::Offset<flatbuffers::Vector<int64_t>> ratio) {
+    fbb_.AddOffset(SplitWithOverlap::VT_RATIO, ratio);
+  }
+  void add_extend_top(flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_top) {
+    fbb_.AddOffset(SplitWithOverlap::VT_EXTEND_TOP, extend_top);
+  }
+  void add_extend_bottom(flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_bottom) {
+    fbb_.AddOffset(SplitWithOverlap::VT_EXTEND_BOTTOM, extend_bottom);
+  }
+  explicit SplitWithOverlapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SplitWithOverlap> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SplitWithOverlap>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SplitWithOverlap> CreateSplitWithOverlap(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t split_dim = 0,
+    int64_t number_split = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> ratio = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_top = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_bottom = 0) {
+  SplitWithOverlapBuilder builder_(_fbb);
+  builder_.add_number_split(number_split);
+  builder_.add_split_dim(split_dim);
+  builder_.add_extend_bottom(extend_bottom);
+  builder_.add_extend_top(extend_top);
+  builder_.add_ratio(ratio);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<SplitWithOverlap> CreateSplitWithOverlapDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t split_dim = 0,
+    int64_t number_split = 0,
+    const std::vector<int64_t> *ratio = nullptr,
+    const std::vector<int64_t> *extend_top = nullptr,
+    const std::vector<int64_t> *extend_bottom = nullptr) {
+  auto ratio__ = ratio ? _fbb.CreateVector<int64_t>(*ratio) : 0;
+  auto extend_top__ = extend_top ? _fbb.CreateVector<int64_t>(*extend_top) : 0;
+  auto extend_bottom__ = extend_bottom ? _fbb.CreateVector<int64_t>(*extend_bottom) : 0;
+  return mindspore::schema::CreateSplitWithOverlap(
+      _fbb,
+      split_dim,
+      number_split,
+      ratio__,
+      extend_top__,
+      extend_bottom__);
+}
+
+flatbuffers::Offset<SplitWithOverlap> CreateSplitWithOverlap(flatbuffers::FlatBufferBuilder &_fbb, const SplitWithOverlapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct GenOPT : public flatbuffers::NativeTable {
+  typedef GenOP TableType;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+  float alpha = 0.0f;
+  float min_val = 0.0f;
+  float max_val = 0.0f;
+  bool is_training = false;
+  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
+  std::vector<int64_t> kernel_size{};
+  std::vector<int64_t> stride{};
+  std::vector<int64_t> dilation{};
+  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
+  std::vector<int64_t> pad_list{};
+  int64_t mode = 0;
+  int64_t group = 0;
+  int64_t in_channel = 0;
+  int64_t out_channel = 0;
+  mindspore::schema::EltwiseMode eltwise_mode = mindspore::schema::EltwiseMode_PROD;
+  bool has_bias = false;
+  bool use_axis = false;
+  int64_t axis = 0;
+  float epsilon = 0.0001f;
+  float momentum = 0.9f;
+  bool transpose_a = false;
+  bool transpose_b = false;
+  std::vector<int64_t> pad{};
+  mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR;
+  bool global = false;
+  bool channel_shared = false;
+  std::vector<int64_t> axes{};
+  bool keep_dims = false;
+  mindspore::schema::ReduceMode reduce_mode = mindspore::schema::ReduceMode_ReduceMean;
+  bool reduce_to_end = false;
+  float coeff = 0.0f;
+};
+
+struct GenOP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GenOPT NativeTableType;
+  typedef GenOPBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return GenOPTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4,
+    VT_ALPHA = 6,
+    VT_MIN_VAL = 8,
+    VT_MAX_VAL = 10,
+    VT_IS_TRAINING = 12,
+    VT_FORMAT = 14,
+    VT_KERNEL_SIZE = 16,
+    VT_STRIDE = 18,
+    VT_DILATION = 20,
+    VT_PAD_MODE = 22,
+    VT_PAD_LIST = 24,
+    VT_MODE = 26,
+    VT_GROUP = 28,
+    VT_IN_CHANNEL = 30,
+    VT_OUT_CHANNEL = 32,
+    VT_ELTWISE_MODE = 34,
+    VT_HAS_BIAS = 36,
+    VT_USE_AXIS = 38,
+    VT_AXIS = 40,
+    VT_EPSILON = 42,
+    VT_MOMENTUM = 44,
+    VT_TRANSPOSE_A = 46,
+    VT_TRANSPOSE_B = 48,
+    VT_PAD = 50,
+    VT_ROUND_MODE = 52,
+    VT_GLOBAL = 54,
+    VT_CHANNEL_SHARED = 56,
+    VT_AXES = 58,
+    VT_KEEP_DIMS = 60,
+    VT_REDUCE_MODE = 62,
+    VT_REDUCE_TO_END = 64,
+    VT_COEFF = 66
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  float alpha() const {
+    return GetField<float>(VT_ALPHA, 0.0f);
+  }
+  bool mutate_alpha(float _alpha) {
+    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
+  }
+  float min_val() const {
+    return GetField<float>(VT_MIN_VAL, 0.0f);
+  }
+  bool mutate_min_val(float _min_val) {
+    return SetField<float>(VT_MIN_VAL, _min_val, 0.0f);
+  }
+  float max_val() const {
+    return GetField<float>(VT_MAX_VAL, 0.0f);
+  }
+  bool mutate_max_val(float _max_val) {
+    return SetField<float>(VT_MAX_VAL, _max_val, 0.0f);
+  }
+  bool is_training() const {
+    return GetField<uint8_t>(VT_IS_TRAINING, 0) != 0;
+  }
+  bool mutate_is_training(bool _is_training) {
+    return SetField<uint8_t>(VT_IS_TRAINING, static_cast<uint8_t>(_is_training), 0);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool mutate_format(mindspore::schema::Format _format) {
+    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  flatbuffers::Vector<int64_t> *mutable_stride() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  flatbuffers::Vector<int64_t> *mutable_dilation() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
+    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  flatbuffers::Vector<int64_t> *mutable_pad_list() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  int64_t mode() const {
+    return GetField<int64_t>(VT_MODE, 0);
+  }
+  bool mutate_mode(int64_t _mode) {
+    return SetField<int64_t>(VT_MODE, _mode, 0);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  bool mutate_group(int64_t _group) {
+    return SetField<int64_t>(VT_GROUP, _group, 0);
+  }
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  bool mutate_in_channel(int64_t _in_channel) {
+    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  bool mutate_out_channel(int64_t _out_channel) {
+    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
+  }
+  mindspore::schema::EltwiseMode eltwise_mode() const {
+    return static_cast<mindspore::schema::EltwiseMode>(GetField<int8_t>(VT_ELTWISE_MODE, 0));
+  }
+  bool mutate_eltwise_mode(mindspore::schema::EltwiseMode _eltwise_mode) {
+    return SetField<int8_t>(VT_ELTWISE_MODE, static_cast<int8_t>(_eltwise_mode), 0);
+  }
+  bool has_bias() const {
+    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
+  }
+  bool mutate_has_bias(bool _has_bias) {
+    return SetField<uint8_t>(VT_HAS_BIAS, static_cast<uint8_t>(_has_bias), 0);
+  }
+  bool use_axis() const {
+    return GetField<uint8_t>(VT_USE_AXIS, 0) != 0;
+  }
+  bool mutate_use_axis(bool _use_axis) {
+    return SetField<uint8_t>(VT_USE_AXIS, static_cast<uint8_t>(_use_axis), 0);
+  }
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, 0);
+  }
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.0001f);
+  }
+  bool mutate_epsilon(float _epsilon) {
+    return SetField<float>(VT_EPSILON, _epsilon, 0.0001f);
+  }
+  float momentum() const {
+    return GetField<float>(VT_MOMENTUM, 0.9f);
+  }
+  bool mutate_momentum(float _momentum) {
+    return SetField<float>(VT_MOMENTUM, _momentum, 0.9f);
+  }
+  bool transpose_a() const {
+    return GetField<uint8_t>(VT_TRANSPOSE_A, 0) != 0;
+  }
+  bool mutate_transpose_a(bool _transpose_a) {
+    return SetField<uint8_t>(VT_TRANSPOSE_A, static_cast<uint8_t>(_transpose_a), 0);
+  }
+  bool transpose_b() const {
+    return GetField<uint8_t>(VT_TRANSPOSE_B, 0) != 0;
+  }
+  bool mutate_transpose_b(bool _transpose_b) {
+    return SetField<uint8_t>(VT_TRANSPOSE_B, static_cast<uint8_t>(_transpose_b), 0);
+  }
+  const flatbuffers::Vector<int64_t> *pad() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  flatbuffers::Vector<int64_t> *mutable_pad() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  mindspore::schema::RoundMode round_mode() const {
+    return static_cast<mindspore::schema::RoundMode>(GetField<int8_t>(VT_ROUND_MODE, 0));
+  }
+  bool mutate_round_mode(mindspore::schema::RoundMode _round_mode) {
+    return SetField<int8_t>(VT_ROUND_MODE, static_cast<int8_t>(_round_mode), 0);
+  }
+  bool global() const {
+    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
+  }
+  bool mutate_global(bool _global) {
+    return SetField<uint8_t>(VT_GLOBAL, static_cast<uint8_t>(_global), 0);
+  }
+  bool channel_shared() const {
+    return GetField<uint8_t>(VT_CHANNEL_SHARED, 0) != 0;
+  }
+  bool mutate_channel_shared(bool _channel_shared) {
+    return SetField<uint8_t>(VT_CHANNEL_SHARED, static_cast<uint8_t>(_channel_shared), 0);
+  }
+  const flatbuffers::Vector<int64_t> *axes() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXES);
+  }
+  flatbuffers::Vector<int64_t> *mutable_axes() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXES);
+  }
+  bool keep_dims() const {
+    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
+  }
+  bool mutate_keep_dims(bool _keep_dims) {
+    return SetField<uint8_t>(VT_KEEP_DIMS, static_cast<uint8_t>(_keep_dims), 0);
+  }
+  mindspore::schema::ReduceMode reduce_mode() const {
+    return static_cast<mindspore::schema::ReduceMode>(GetField<int8_t>(VT_REDUCE_MODE, 0));
+  }
+  bool mutate_reduce_mode(mindspore::schema::ReduceMode _reduce_mode) {
+    return SetField<int8_t>(VT_REDUCE_MODE, static_cast<int8_t>(_reduce_mode), 0);
+  }
+  bool reduce_to_end() const {
+    return GetField<uint8_t>(VT_REDUCE_TO_END, 0) != 0;
+  }
+  bool mutate_reduce_to_end(bool _reduce_to_end) {
+    return SetField<uint8_t>(VT_REDUCE_TO_END, static_cast<uint8_t>(_reduce_to_end), 0);
+  }
+  float coeff() const {
+    return GetField<float>(VT_COEFF, 0.0f);
+  }
+  bool mutate_coeff(float _coeff) {
+    return SetField<float>(VT_COEFF, _coeff, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           VerifyField<float>(verifier, VT_ALPHA) &&
+           VerifyField<float>(verifier, VT_MIN_VAL) &&
+           VerifyField<float>(verifier, VT_MAX_VAL) &&
+           VerifyField<uint8_t>(verifier, VT_IS_TRAINING) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyField<int64_t>(verifier, VT_MODE) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyField<int8_t>(verifier, VT_ELTWISE_MODE) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
+           VerifyField<uint8_t>(verifier, VT_USE_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<float>(verifier, VT_MOMENTUM) &&
+           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_A) &&
+           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_B) &&
+           VerifyOffset(verifier, VT_PAD) &&
+           verifier.VerifyVector(pad()) &&
+           VerifyField<int8_t>(verifier, VT_ROUND_MODE) &&
+           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
+           VerifyField<uint8_t>(verifier, VT_CHANNEL_SHARED) &&
+           VerifyOffset(verifier, VT_AXES) &&
+           verifier.VerifyVector(axes()) &&
+           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
+           VerifyField<int8_t>(verifier, VT_REDUCE_MODE) &&
+           VerifyField<uint8_t>(verifier, VT_REDUCE_TO_END) &&
+           VerifyField<float>(verifier, VT_COEFF) &&
+           verifier.EndTable();
+  }
+  GenOPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(GenOPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<GenOP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GenOPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct GenOPBuilder {
+  typedef GenOP Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(GenOP::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  void add_alpha(float alpha) {
+    fbb_.AddElement<float>(GenOP::VT_ALPHA, alpha, 0.0f);
+  }
+  void add_min_val(float min_val) {
+    fbb_.AddElement<float>(GenOP::VT_MIN_VAL, min_val, 0.0f);
+  }
+  void add_max_val(float max_val) {
+    fbb_.AddElement<float>(GenOP::VT_MAX_VAL, max_val, 0.0f);
+  }
+  void add_is_training(bool is_training) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_IS_TRAINING, static_cast<uint8_t>(is_training), 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(GenOP::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(GenOP::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(GenOP::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(GenOP::VT_DILATION, dilation);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(GenOP::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(GenOP::VT_PAD_LIST, pad_list);
+  }
+  void add_mode(int64_t mode) {
+    fbb_.AddElement<int64_t>(GenOP::VT_MODE, mode, 0);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(GenOP::VT_GROUP, group, 0);
+  }
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(GenOP::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(GenOP::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_eltwise_mode(mindspore::schema::EltwiseMode eltwise_mode) {
+    fbb_.AddElement<int8_t>(GenOP::VT_ELTWISE_MODE, static_cast<int8_t>(eltwise_mode), 0);
+  }
+  void add_has_bias(bool has_bias) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
+  }
+  void add_use_axis(bool use_axis) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_USE_AXIS, static_cast<uint8_t>(use_axis), 0);
+  }
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(GenOP::VT_AXIS, axis, 0);
+  }
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(GenOP::VT_EPSILON, epsilon, 0.0001f);
+  }
+  void add_momentum(float momentum) {
+    fbb_.AddElement<float>(GenOP::VT_MOMENTUM, momentum, 0.9f);
+  }
+  void add_transpose_a(bool transpose_a) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_TRANSPOSE_A, static_cast<uint8_t>(transpose_a), 0);
+  }
+  void add_transpose_b(bool transpose_b) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_TRANSPOSE_B, static_cast<uint8_t>(transpose_b), 0);
+  }
+  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
+    fbb_.AddOffset(GenOP::VT_PAD, pad);
+  }
+  void add_round_mode(mindspore::schema::RoundMode round_mode) {
+    fbb_.AddElement<int8_t>(GenOP::VT_ROUND_MODE, static_cast<int8_t>(round_mode), 0);
+  }
+  void add_global(bool global) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_GLOBAL, static_cast<uint8_t>(global), 0);
+  }
+  void add_channel_shared(bool channel_shared) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_CHANNEL_SHARED, static_cast<uint8_t>(channel_shared), 0);
+  }
+  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes) {
+    fbb_.AddOffset(GenOP::VT_AXES, axes);
+  }
+  void add_keep_dims(bool keep_dims) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
+  }
+  void add_reduce_mode(mindspore::schema::ReduceMode reduce_mode) {
+    fbb_.AddElement<int8_t>(GenOP::VT_REDUCE_MODE, static_cast<int8_t>(reduce_mode), 0);
+  }
+  void add_reduce_to_end(bool reduce_to_end) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_REDUCE_TO_END, static_cast<uint8_t>(reduce_to_end), 0);
+  }
+  void add_coeff(float coeff) {
+    fbb_.AddElement<float>(GenOP::VT_COEFF, coeff, 0.0f);
+  }
+  explicit GenOPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GenOP> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GenOP>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GenOP> CreateGenOP(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    float alpha = 0.0f,
+    float min_val = 0.0f,
+    float max_val = 0.0f,
+    bool is_training = false,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::EltwiseMode eltwise_mode = mindspore::schema::EltwiseMode_PROD,
+    bool has_bias = false,
+    bool use_axis = false,
+    int64_t axis = 0,
+    float epsilon = 0.0001f,
+    float momentum = 0.9f,
+    bool transpose_a = false,
+    bool transpose_b = false,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
+    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
+    bool global = false,
+    bool channel_shared = false,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes = 0,
+    bool keep_dims = false,
+    mindspore::schema::ReduceMode reduce_mode = mindspore::schema::ReduceMode_ReduceMean,
+    bool reduce_to_end = false,
+    float coeff = 0.0f) {
+  GenOPBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_group(group);
+  builder_.add_mode(mode);
+  builder_.add_coeff(coeff);
+  builder_.add_axes(axes);
+  builder_.add_pad(pad);
+  builder_.add_momentum(momentum);
+  builder_.add_epsilon(epsilon);
+  builder_.add_pad_list(pad_list);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_format(format);
+  builder_.add_max_val(max_val);
+  builder_.add_min_val(min_val);
+  builder_.add_alpha(alpha);
+  builder_.add_reduce_to_end(reduce_to_end);
+  builder_.add_reduce_mode(reduce_mode);
+  builder_.add_keep_dims(keep_dims);
+  builder_.add_channel_shared(channel_shared);
+  builder_.add_global(global);
+  builder_.add_round_mode(round_mode);
+  builder_.add_transpose_b(transpose_b);
+  builder_.add_transpose_a(transpose_a);
+  builder_.add_use_axis(use_axis);
+  builder_.add_has_bias(has_bias);
+  builder_.add_eltwise_mode(eltwise_mode);
+  builder_.add_pad_mode(pad_mode);
+  builder_.add_is_training(is_training);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<GenOP> CreateGenOPDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    float alpha = 0.0f,
+    float min_val = 0.0f,
+    float max_val = 0.0f,
+    bool is_training = false,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad_list = nullptr,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::EltwiseMode eltwise_mode = mindspore::schema::EltwiseMode_PROD,
+    bool has_bias = false,
+    bool use_axis = false,
+    int64_t axis = 0,
+    float epsilon = 0.0001f,
+    float momentum = 0.9f,
+    bool transpose_a = false,
+    bool transpose_b = false,
+    const std::vector<int64_t> *pad = nullptr,
+    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
+    bool global = false,
+    bool channel_shared = false,
+    const std::vector<int64_t> *axes = nullptr,
+    bool keep_dims = false,
+    mindspore::schema::ReduceMode reduce_mode = mindspore::schema::ReduceMode_ReduceMean,
+    bool reduce_to_end = false,
+    float coeff = 0.0f) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
+  auto axes__ = axes ? _fbb.CreateVector<int64_t>(*axes) : 0;
+  return mindspore::schema::CreateGenOP(
+      _fbb,
+      activation_type,
+      alpha,
+      min_val,
+      max_val,
+      is_training,
+      format,
+      kernel_size__,
+      stride__,
+      dilation__,
+      pad_mode,
+      pad_list__,
+      mode,
+      group,
+      in_channel,
+      out_channel,
+      eltwise_mode,
+      has_bias,
+      use_axis,
+      axis,
+      epsilon,
+      momentum,
+      transpose_a,
+      transpose_b,
+      pad__,
+      round_mode,
+      global,
+      channel_shared,
+      axes__,
+      keep_dims,
+      reduce_mode,
+      reduce_to_end,
+      coeff);
+}
+
+flatbuffers::Offset<GenOP> CreateGenOP(flatbuffers::FlatBufferBuilder &_fbb, const GenOPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct RaggedRangeT : public flatbuffers::NativeTable {
+  typedef RaggedRange TableType;
+};
+
+struct RaggedRange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RaggedRangeT NativeTableType;
+  typedef RaggedRangeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return RaggedRangeTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  RaggedRangeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(RaggedRangeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<RaggedRange> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RaggedRangeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct RaggedRangeBuilder {
+  typedef RaggedRange Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit RaggedRangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<RaggedRange> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<RaggedRange>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<RaggedRange> CreateRaggedRange(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  RaggedRangeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<RaggedRange> CreateRaggedRange(flatbuffers::FlatBufferBuilder &_fbb, const RaggedRangeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct GLUT : public flatbuffers::NativeTable {
+  typedef GLU TableType;
+  int64_t axis = -1LL;
+};
+
+struct GLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GLUT NativeTableType;
+  typedef GLUBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return GLUTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, -1LL);
+  }
+  bool mutate_axis(int64_t _axis) {
+    return SetField<int64_t>(VT_AXIS, _axis, -1LL);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+  GLUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(GLUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<GLU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GLUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct GLUBuilder {
+  typedef GLU Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(GLU::VT_AXIS, axis, -1LL);
+  }
+  explicit GLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GLU> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GLU>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GLU> CreateGLU(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = -1LL) {
+  GLUBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<GLU> CreateGLU(flatbuffers::FlatBufferBuilder &_fbb, const GLUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct TensorArrayT : public flatbuffers::NativeTable {
+  typedef TensorArray TableType;
+  bool dynamic_size = false;
+  bool identical_element_shapes = false;
+  std::vector<int32_t> element_shape{};
+  int32_t data_type = 0;
+};
+
+struct TensorArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorArrayT NativeTableType;
+  typedef TensorArrayBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TensorArrayTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DYNAMIC_SIZE = 4,
+    VT_IDENTICAL_ELEMENT_SHAPES = 6,
+    VT_ELEMENT_SHAPE = 8,
+    VT_DATA_TYPE = 10
+  };
+  bool dynamic_size() const {
+    return GetField<uint8_t>(VT_DYNAMIC_SIZE, 0) != 0;
+  }
+  bool mutate_dynamic_size(bool _dynamic_size) {
+    return SetField<uint8_t>(VT_DYNAMIC_SIZE, static_cast<uint8_t>(_dynamic_size), 0);
+  }
+  bool identical_element_shapes() const {
+    return GetField<uint8_t>(VT_IDENTICAL_ELEMENT_SHAPES, 0) != 0;
+  }
+  bool mutate_identical_element_shapes(bool _identical_element_shapes) {
+    return SetField<uint8_t>(VT_IDENTICAL_ELEMENT_SHAPES, static_cast<uint8_t>(_identical_element_shapes), 0);
+  }
+  const flatbuffers::Vector<int32_t> *element_shape() const {
+    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ELEMENT_SHAPE);
+  }
+  flatbuffers::Vector<int32_t> *mutable_element_shape() {
+    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ELEMENT_SHAPE);
+  }
+  int32_t data_type() const {
+    return GetField<int32_t>(VT_DATA_TYPE, 0);
+  }
+  bool mutate_data_type(int32_t _data_type) {
+    return SetField<int32_t>(VT_DATA_TYPE, _data_type, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_DYNAMIC_SIZE) &&
+           VerifyField<uint8_t>(verifier, VT_IDENTICAL_ELEMENT_SHAPES) &&
+           VerifyOffset(verifier, VT_ELEMENT_SHAPE) &&
+           verifier.VerifyVector(element_shape()) &&
+           VerifyField<int32_t>(verifier, VT_DATA_TYPE) &&
+           verifier.EndTable();
+  }
+  TensorArrayT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TensorArrayT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<TensorArray> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TensorArrayBuilder {
+  typedef TensorArray Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_dynamic_size(bool dynamic_size) {
+    fbb_.AddElement<uint8_t>(TensorArray::VT_DYNAMIC_SIZE, static_cast<uint8_t>(dynamic_size), 0);
+  }
+  void add_identical_element_shapes(bool identical_element_shapes) {
+    fbb_.AddElement<uint8_t>(TensorArray::VT_IDENTICAL_ELEMENT_SHAPES, static_cast<uint8_t>(identical_element_shapes), 0);
+  }
+  void add_element_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_shape) {
+    fbb_.AddOffset(TensorArray::VT_ELEMENT_SHAPE, element_shape);
+  }
+  void add_data_type(int32_t data_type) {
+    fbb_.AddElement<int32_t>(TensorArray::VT_DATA_TYPE, data_type, 0);
+  }
+  explicit TensorArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorArray> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorArray>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorArray> CreateTensorArray(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool dynamic_size = false,
+    bool identical_element_shapes = false,
+    flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_shape = 0,
+    int32_t data_type = 0) {
+  TensorArrayBuilder builder_(_fbb);
+  builder_.add_data_type(data_type);
+  builder_.add_element_shape(element_shape);
+  builder_.add_identical_element_shapes(identical_element_shapes);
+  builder_.add_dynamic_size(dynamic_size);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<TensorArray> CreateTensorArrayDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool dynamic_size = false,
+    bool identical_element_shapes = false,
+    const std::vector<int32_t> *element_shape = nullptr,
+    int32_t data_type = 0) {
+  auto element_shape__ = element_shape ? _fbb.CreateVector<int32_t>(*element_shape) : 0;
+  return mindspore::schema::CreateTensorArray(
+      _fbb,
+      dynamic_size,
+      identical_element_shapes,
+      element_shape__,
+      data_type);
+}
+
+flatbuffers::Offset<TensorArray> CreateTensorArray(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct TensorArrayReadT : public flatbuffers::NativeTable {
+  typedef TensorArrayRead TableType;
+};
+
+struct TensorArrayRead FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorArrayReadT NativeTableType;
+  typedef TensorArrayReadBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TensorArrayReadTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  TensorArrayReadT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TensorArrayReadT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<TensorArrayRead> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayReadT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TensorArrayReadBuilder {
+  typedef TensorArrayRead Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit TensorArrayReadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorArrayRead> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorArrayRead>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorArrayRead> CreateTensorArrayRead(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  TensorArrayReadBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<TensorArrayRead> CreateTensorArrayRead(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayReadT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct TensorArrayWriteT : public flatbuffers::NativeTable {
+  typedef TensorArrayWrite TableType;
+};
+
+struct TensorArrayWrite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorArrayWriteT NativeTableType;
+  typedef TensorArrayWriteBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return TensorArrayWriteTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  TensorArrayWriteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(TensorArrayWriteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<TensorArrayWrite> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayWriteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct TensorArrayWriteBuilder {
+  typedef TensorArrayWrite Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit TensorArrayWriteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorArrayWrite> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorArrayWrite>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorArrayWrite> CreateTensorArrayWrite(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  TensorArrayWriteBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<TensorArrayWrite> CreateTensorArrayWrite(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AffineT : public flatbuffers::NativeTable {
+  typedef Affine TableType;
+  std::vector<int64_t> context{};
+  int64_t output_dim = 0;
+  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
+  bool transpose_a = false;
+  bool transpose_b = false;
+};
+
+struct Affine FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AffineT NativeTableType;
+  typedef AffineBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AffineTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_CONTEXT = 4,
+    VT_OUTPUT_DIM = 6,
+    VT_ACTIVATION_TYPE = 8,
+    VT_TRANSPOSE_A = 10,
+    VT_TRANSPOSE_B = 12
+  };
+  const flatbuffers::Vector<int64_t> *context() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_CONTEXT);
+  }
+  flatbuffers::Vector<int64_t> *mutable_context() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_CONTEXT);
+  }
+  int64_t output_dim() const {
+    return GetField<int64_t>(VT_OUTPUT_DIM, 0);
+  }
+  bool mutate_output_dim(int64_t _output_dim) {
+    return SetField<int64_t>(VT_OUTPUT_DIM, _output_dim, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
+    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
+  }
+  bool transpose_a() const {
+    return GetField<uint8_t>(VT_TRANSPOSE_A, 0) != 0;
+  }
+  bool mutate_transpose_a(bool _transpose_a) {
+    return SetField<uint8_t>(VT_TRANSPOSE_A, static_cast<uint8_t>(_transpose_a), 0);
+  }
+  bool transpose_b() const {
+    return GetField<uint8_t>(VT_TRANSPOSE_B, 0) != 0;
+  }
+  bool mutate_transpose_b(bool _transpose_b) {
+    return SetField<uint8_t>(VT_TRANSPOSE_B, static_cast<uint8_t>(_transpose_b), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_CONTEXT) &&
+           verifier.VerifyVector(context()) &&
+           VerifyField<int64_t>(verifier, VT_OUTPUT_DIM) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_A) &&
+           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_B) &&
+           verifier.EndTable();
+  }
+  AffineT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AffineT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Affine> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AffineT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AffineBuilder {
+  typedef Affine Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_context(flatbuffers::Offset<flatbuffers::Vector<int64_t>> context) {
+    fbb_.AddOffset(Affine::VT_CONTEXT, context);
+  }
+  void add_output_dim(int64_t output_dim) {
+    fbb_.AddElement<int64_t>(Affine::VT_OUTPUT_DIM, output_dim, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(Affine::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  void add_transpose_a(bool transpose_a) {
+    fbb_.AddElement<uint8_t>(Affine::VT_TRANSPOSE_A, static_cast<uint8_t>(transpose_a), 0);
+  }
+  void add_transpose_b(bool transpose_b) {
+    fbb_.AddElement<uint8_t>(Affine::VT_TRANSPOSE_B, static_cast<uint8_t>(transpose_b), 0);
+  }
+  explicit AffineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Affine> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Affine>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Affine> CreateAffine(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> context = 0,
+    int64_t output_dim = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    bool transpose_a = false,
+    bool transpose_b = false) {
+  AffineBuilder builder_(_fbb);
+  builder_.add_output_dim(output_dim);
+  builder_.add_context(context);
+  builder_.add_transpose_b(transpose_b);
+  builder_.add_transpose_a(transpose_a);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Affine> CreateAffineDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *context = nullptr,
+    int64_t output_dim = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    bool transpose_a = false,
+    bool transpose_b = false) {
+  auto context__ = context ? _fbb.CreateVector<int64_t>(*context) : 0;
+  return mindspore::schema::CreateAffine(
+      _fbb,
+      context__,
+      output_dim,
+      activation_type,
+      transpose_a,
+      transpose_b);
+}
+
+flatbuffers::Offset<Affine> CreateAffine(flatbuffers::FlatBufferBuilder &_fbb, const AffineT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ScatterNdUpdateT : public flatbuffers::NativeTable {
+  typedef ScatterNdUpdate TableType;
+};
+
+struct ScatterNdUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ScatterNdUpdateT NativeTableType;
+  typedef ScatterNdUpdateBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ScatterNdUpdateTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  ScatterNdUpdateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ScatterNdUpdateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ScatterNdUpdate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdUpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ScatterNdUpdateBuilder {
+  typedef ScatterNdUpdate Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ScatterNdUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ScatterNdUpdate> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ScatterNdUpdate>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ScatterNdUpdate> CreateScatterNdUpdate(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ScatterNdUpdateBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<ScatterNdUpdate> CreateScatterNdUpdate(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AllGatherT : public flatbuffers::NativeTable {
+  typedef AllGather TableType;
+  std::string group{};
+  int32_t rank_size = 0;
+};
+
+struct AllGather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AllGatherT NativeTableType;
+  typedef AllGatherBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AllGatherTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_GROUP = 4,
+    VT_RANK_SIZE = 6
+  };
+  const flatbuffers::String *group() const {
+    return GetPointer<const flatbuffers::String *>(VT_GROUP);
+  }
+  flatbuffers::String *mutable_group() {
+    return GetPointer<flatbuffers::String *>(VT_GROUP);
+  }
+  int32_t rank_size() const {
+    return GetField<int32_t>(VT_RANK_SIZE, 0);
+  }
+  bool mutate_rank_size(int32_t _rank_size) {
+    return SetField<int32_t>(VT_RANK_SIZE, _rank_size, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_GROUP) &&
+           verifier.VerifyString(group()) &&
+           VerifyField<int32_t>(verifier, VT_RANK_SIZE) &&
+           verifier.EndTable();
+  }
+  AllGatherT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AllGatherT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<AllGather> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AllGatherT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AllGatherBuilder {
+  typedef AllGather Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_group(flatbuffers::Offset<flatbuffers::String> group) {
+    fbb_.AddOffset(AllGather::VT_GROUP, group);
+  }
+  void add_rank_size(int32_t rank_size) {
+    fbb_.AddElement<int32_t>(AllGather::VT_RANK_SIZE, rank_size, 0);
+  }
+  explicit AllGatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AllGather> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AllGather>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AllGather> CreateAllGather(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> group = 0,
+    int32_t rank_size = 0) {
+  AllGatherBuilder builder_(_fbb);
+  builder_.add_rank_size(rank_size);
+  builder_.add_group(group);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<AllGather> CreateAllGatherDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *group = nullptr,
+    int32_t rank_size = 0) {
+  auto group__ = group ? _fbb.CreateString(group) : 0;
+  return mindspore::schema::CreateAllGather(
+      _fbb,
+      group__,
+      rank_size);
+}
+
+flatbuffers::Offset<AllGather> CreateAllGather(flatbuffers::FlatBufferBuilder &_fbb, const AllGatherT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct ReduceScatterT : public flatbuffers::NativeTable {
+  typedef ReduceScatter TableType;
+  std::string group{};
+  mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean;
+  int32_t rank_size = 0;
+};
+
+struct ReduceScatter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ReduceScatterT NativeTableType;
+  typedef ReduceScatterBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return ReduceScatterTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_GROUP = 4,
+    VT_MODE = 6,
+    VT_RANK_SIZE = 8
+  };
+  const flatbuffers::String *group() const {
+    return GetPointer<const flatbuffers::String *>(VT_GROUP);
+  }
+  flatbuffers::String *mutable_group() {
+    return GetPointer<flatbuffers::String *>(VT_GROUP);
+  }
+  mindspore::schema::ReduceMode mode() const {
+    return static_cast<mindspore::schema::ReduceMode>(GetField<int8_t>(VT_MODE, 0));
+  }
+  bool mutate_mode(mindspore::schema::ReduceMode _mode) {
+    return SetField<int8_t>(VT_MODE, static_cast<int8_t>(_mode), 0);
+  }
+  int32_t rank_size() const {
+    return GetField<int32_t>(VT_RANK_SIZE, 0);
+  }
+  bool mutate_rank_size(int32_t _rank_size) {
+    return SetField<int32_t>(VT_RANK_SIZE, _rank_size, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_GROUP) &&
+           verifier.VerifyString(group()) &&
+           VerifyField<int8_t>(verifier, VT_MODE) &&
+           VerifyField<int32_t>(verifier, VT_RANK_SIZE) &&
+           verifier.EndTable();
+  }
+  ReduceScatterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(ReduceScatterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<ReduceScatter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceScatterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct ReduceScatterBuilder {
+  typedef ReduceScatter Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_group(flatbuffers::Offset<flatbuffers::String> group) {
+    fbb_.AddOffset(ReduceScatter::VT_GROUP, group);
+  }
+  void add_mode(mindspore::schema::ReduceMode mode) {
+    fbb_.AddElement<int8_t>(ReduceScatter::VT_MODE, static_cast<int8_t>(mode), 0);
+  }
+  void add_rank_size(int32_t rank_size) {
+    fbb_.AddElement<int32_t>(ReduceScatter::VT_RANK_SIZE, rank_size, 0);
+  }
+  explicit ReduceScatterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ReduceScatter> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ReduceScatter>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ReduceScatter> CreateReduceScatter(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> group = 0,
+    mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean,
+    int32_t rank_size = 0) {
+  ReduceScatterBuilder builder_(_fbb);
+  builder_.add_rank_size(rank_size);
+  builder_.add_group(group);
+  builder_.add_mode(mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<ReduceScatter> CreateReduceScatterDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *group = nullptr,
+    mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean,
+    int32_t rank_size = 0) {
+  auto group__ = group ? _fbb.CreateString(group) : 0;
+  return mindspore::schema::CreateReduceScatter(
+      _fbb,
+      group__,
+      mode,
+      rank_size);
+}
+
+flatbuffers::Offset<ReduceScatter> CreateReduceScatter(flatbuffers::FlatBufferBuilder &_fbb, const ReduceScatterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct DynamicQuantT : public flatbuffers::NativeTable {
+  typedef DynamicQuant TableType;
+  bool symmetric = false;
+  int64_t dst_type = 32LL;
+};
+
+struct DynamicQuant FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DynamicQuantT NativeTableType;
+  typedef DynamicQuantBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return DynamicQuantTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SYMMETRIC = 4,
+    VT_DST_TYPE = 6
+  };
+  bool symmetric() const {
+    return GetField<uint8_t>(VT_SYMMETRIC, 0) != 0;
+  }
+  bool mutate_symmetric(bool _symmetric) {
+    return SetField<uint8_t>(VT_SYMMETRIC, static_cast<uint8_t>(_symmetric), 0);
+  }
+  int64_t dst_type() const {
+    return GetField<int64_t>(VT_DST_TYPE, 32LL);
+  }
+  bool mutate_dst_type(int64_t _dst_type) {
+    return SetField<int64_t>(VT_DST_TYPE, _dst_type, 32LL);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_SYMMETRIC) &&
+           VerifyField<int64_t>(verifier, VT_DST_TYPE) &&
+           verifier.EndTable();
+  }
+  DynamicQuantT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(DynamicQuantT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<DynamicQuant> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DynamicQuantT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct DynamicQuantBuilder {
+  typedef DynamicQuant Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_symmetric(bool symmetric) {
+    fbb_.AddElement<uint8_t>(DynamicQuant::VT_SYMMETRIC, static_cast<uint8_t>(symmetric), 0);
+  }
+  void add_dst_type(int64_t dst_type) {
+    fbb_.AddElement<int64_t>(DynamicQuant::VT_DST_TYPE, dst_type, 32LL);
+  }
+  explicit DynamicQuantBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DynamicQuant> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DynamicQuant>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DynamicQuant> CreateDynamicQuant(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool symmetric = false,
+    int64_t dst_type = 32LL) {
+  DynamicQuantBuilder builder_(_fbb);
+  builder_.add_dst_type(dst_type);
+  builder_.add_symmetric(symmetric);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<DynamicQuant> CreateDynamicQuant(flatbuffers::FlatBufferBuilder &_fbb, const DynamicQuantT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LSTMGradDataT : public flatbuffers::NativeTable {
+  typedef LSTMGradData TableType;
+  bool bidirectional = false;
+  bool has_bias = false;
+  int64_t input_size = 0;
+  int64_t hidden_size = 0;
+  int64_t num_layers = 0;
+  int64_t num_directions = 0;
+  float dropout = 0.0f;
+  float zoneout_cell = 0.0f;
+  float zoneout_hidden = 0.0f;
+};
+
+struct LSTMGradData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LSTMGradDataT NativeTableType;
+  typedef LSTMGradDataBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LSTMGradDataTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BIDIRECTIONAL = 4,
+    VT_HAS_BIAS = 6,
+    VT_INPUT_SIZE = 8,
+    VT_HIDDEN_SIZE = 10,
+    VT_NUM_LAYERS = 12,
+    VT_NUM_DIRECTIONS = 14,
+    VT_DROPOUT = 16,
+    VT_ZONEOUT_CELL = 18,
+    VT_ZONEOUT_HIDDEN = 20
+  };
+  bool bidirectional() const {
+    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
+  }
+  bool mutate_bidirectional(bool _bidirectional) {
+    return SetField<uint8_t>(VT_BIDIRECTIONAL, static_cast<uint8_t>(_bidirectional), 0);
+  }
+  bool has_bias() const {
+    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
+  }
+  bool mutate_has_bias(bool _has_bias) {
+    return SetField<uint8_t>(VT_HAS_BIAS, static_cast<uint8_t>(_has_bias), 0);
+  }
+  int64_t input_size() const {
+    return GetField<int64_t>(VT_INPUT_SIZE, 0);
+  }
+  bool mutate_input_size(int64_t _input_size) {
+    return SetField<int64_t>(VT_INPUT_SIZE, _input_size, 0);
+  }
+  int64_t hidden_size() const {
+    return GetField<int64_t>(VT_HIDDEN_SIZE, 0);
+  }
+  bool mutate_hidden_size(int64_t _hidden_size) {
+    return SetField<int64_t>(VT_HIDDEN_SIZE, _hidden_size, 0);
+  }
+  int64_t num_layers() const {
+    return GetField<int64_t>(VT_NUM_LAYERS, 0);
+  }
+  bool mutate_num_layers(int64_t _num_layers) {
+    return SetField<int64_t>(VT_NUM_LAYERS, _num_layers, 0);
+  }
+  int64_t num_directions() const {
+    return GetField<int64_t>(VT_NUM_DIRECTIONS, 0);
+  }
+  bool mutate_num_directions(int64_t _num_directions) {
+    return SetField<int64_t>(VT_NUM_DIRECTIONS, _num_directions, 0);
+  }
+  float dropout() const {
+    return GetField<float>(VT_DROPOUT, 0.0f);
+  }
+  bool mutate_dropout(float _dropout) {
+    return SetField<float>(VT_DROPOUT, _dropout, 0.0f);
+  }
+  float zoneout_cell() const {
+    return GetField<float>(VT_ZONEOUT_CELL, 0.0f);
+  }
+  bool mutate_zoneout_cell(float _zoneout_cell) {
+    return SetField<float>(VT_ZONEOUT_CELL, _zoneout_cell, 0.0f);
+  }
+  float zoneout_hidden() const {
+    return GetField<float>(VT_ZONEOUT_HIDDEN, 0.0f);
+  }
+  bool mutate_zoneout_hidden(float _zoneout_hidden) {
+    return SetField<float>(VT_ZONEOUT_HIDDEN, _zoneout_hidden, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
+           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_HIDDEN_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_NUM_LAYERS) &&
+           VerifyField<int64_t>(verifier, VT_NUM_DIRECTIONS) &&
+           VerifyField<float>(verifier, VT_DROPOUT) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_CELL) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_HIDDEN) &&
+           verifier.EndTable();
+  }
+  LSTMGradDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LSTMGradDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LSTMGradData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LSTMGradDataBuilder {
+  typedef LSTMGradData Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_bidirectional(bool bidirectional) {
+    fbb_.AddElement<uint8_t>(LSTMGradData::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
+  }
+  void add_has_bias(bool has_bias) {
+    fbb_.AddElement<uint8_t>(LSTMGradData::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
+  }
+  void add_input_size(int64_t input_size) {
+    fbb_.AddElement<int64_t>(LSTMGradData::VT_INPUT_SIZE, input_size, 0);
+  }
+  void add_hidden_size(int64_t hidden_size) {
+    fbb_.AddElement<int64_t>(LSTMGradData::VT_HIDDEN_SIZE, hidden_size, 0);
+  }
+  void add_num_layers(int64_t num_layers) {
+    fbb_.AddElement<int64_t>(LSTMGradData::VT_NUM_LAYERS, num_layers, 0);
+  }
+  void add_num_directions(int64_t num_directions) {
+    fbb_.AddElement<int64_t>(LSTMGradData::VT_NUM_DIRECTIONS, num_directions, 0);
+  }
+  void add_dropout(float dropout) {
+    fbb_.AddElement<float>(LSTMGradData::VT_DROPOUT, dropout, 0.0f);
+  }
+  void add_zoneout_cell(float zoneout_cell) {
+    fbb_.AddElement<float>(LSTMGradData::VT_ZONEOUT_CELL, zoneout_cell, 0.0f);
+  }
+  void add_zoneout_hidden(float zoneout_hidden) {
+    fbb_.AddElement<float>(LSTMGradData::VT_ZONEOUT_HIDDEN, zoneout_hidden, 0.0f);
+  }
+  explicit LSTMGradDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LSTMGradData> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LSTMGradData>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LSTMGradData> CreateLSTMGradData(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool bidirectional = false,
+    bool has_bias = false,
+    int64_t input_size = 0,
+    int64_t hidden_size = 0,
+    int64_t num_layers = 0,
+    int64_t num_directions = 0,
+    float dropout = 0.0f,
+    float zoneout_cell = 0.0f,
+    float zoneout_hidden = 0.0f) {
+  LSTMGradDataBuilder builder_(_fbb);
+  builder_.add_num_directions(num_directions);
+  builder_.add_num_layers(num_layers);
+  builder_.add_hidden_size(hidden_size);
+  builder_.add_input_size(input_size);
+  builder_.add_zoneout_hidden(zoneout_hidden);
+  builder_.add_zoneout_cell(zoneout_cell);
+  builder_.add_dropout(dropout);
+  builder_.add_has_bias(has_bias);
+  builder_.add_bidirectional(bidirectional);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LSTMGradData> CreateLSTMGradData(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct LSTMGradWeightT : public flatbuffers::NativeTable {
+  typedef LSTMGradWeight TableType;
+  bool bidirectional = false;
+  bool has_bias = false;
+  int64_t input_size = 0;
+  int64_t hidden_size = 0;
+  int64_t num_layers = 0;
+  int64_t num_directions = 0;
+  float dropout = 0.0f;
+  float zoneout_cell = 0.0f;
+  float zoneout_hidden = 0.0f;
+};
+
+struct LSTMGradWeight FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LSTMGradWeightT NativeTableType;
+  typedef LSTMGradWeightBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return LSTMGradWeightTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BIDIRECTIONAL = 4,
+    VT_HAS_BIAS = 6,
+    VT_INPUT_SIZE = 8,
+    VT_HIDDEN_SIZE = 10,
+    VT_NUM_LAYERS = 12,
+    VT_NUM_DIRECTIONS = 14,
+    VT_DROPOUT = 16,
+    VT_ZONEOUT_CELL = 18,
+    VT_ZONEOUT_HIDDEN = 20
+  };
+  bool bidirectional() const {
+    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
+  }
+  bool mutate_bidirectional(bool _bidirectional) {
+    return SetField<uint8_t>(VT_BIDIRECTIONAL, static_cast<uint8_t>(_bidirectional), 0);
+  }
+  bool has_bias() const {
+    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
+  }
+  bool mutate_has_bias(bool _has_bias) {
+    return SetField<uint8_t>(VT_HAS_BIAS, static_cast<uint8_t>(_has_bias), 0);
+  }
+  int64_t input_size() const {
+    return GetField<int64_t>(VT_INPUT_SIZE, 0);
+  }
+  bool mutate_input_size(int64_t _input_size) {
+    return SetField<int64_t>(VT_INPUT_SIZE, _input_size, 0);
+  }
+  int64_t hidden_size() const {
+    return GetField<int64_t>(VT_HIDDEN_SIZE, 0);
+  }
+  bool mutate_hidden_size(int64_t _hidden_size) {
+    return SetField<int64_t>(VT_HIDDEN_SIZE, _hidden_size, 0);
+  }
+  int64_t num_layers() const {
+    return GetField<int64_t>(VT_NUM_LAYERS, 0);
+  }
+  bool mutate_num_layers(int64_t _num_layers) {
+    return SetField<int64_t>(VT_NUM_LAYERS, _num_layers, 0);
+  }
+  int64_t num_directions() const {
+    return GetField<int64_t>(VT_NUM_DIRECTIONS, 0);
+  }
+  bool mutate_num_directions(int64_t _num_directions) {
+    return SetField<int64_t>(VT_NUM_DIRECTIONS, _num_directions, 0);
+  }
+  float dropout() const {
+    return GetField<float>(VT_DROPOUT, 0.0f);
+  }
+  bool mutate_dropout(float _dropout) {
+    return SetField<float>(VT_DROPOUT, _dropout, 0.0f);
+  }
+  float zoneout_cell() const {
+    return GetField<float>(VT_ZONEOUT_CELL, 0.0f);
+  }
+  bool mutate_zoneout_cell(float _zoneout_cell) {
+    return SetField<float>(VT_ZONEOUT_CELL, _zoneout_cell, 0.0f);
+  }
+  float zoneout_hidden() const {
+    return GetField<float>(VT_ZONEOUT_HIDDEN, 0.0f);
+  }
+  bool mutate_zoneout_hidden(float _zoneout_hidden) {
+    return SetField<float>(VT_ZONEOUT_HIDDEN, _zoneout_hidden, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
+           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_HIDDEN_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_NUM_LAYERS) &&
+           VerifyField<int64_t>(verifier, VT_NUM_DIRECTIONS) &&
+           VerifyField<float>(verifier, VT_DROPOUT) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_CELL) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_HIDDEN) &&
+           verifier.EndTable();
+  }
+  LSTMGradWeightT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(LSTMGradWeightT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<LSTMGradWeight> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradWeightT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct LSTMGradWeightBuilder {
+  typedef LSTMGradWeight Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_bidirectional(bool bidirectional) {
+    fbb_.AddElement<uint8_t>(LSTMGradWeight::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
+  }
+  void add_has_bias(bool has_bias) {
+    fbb_.AddElement<uint8_t>(LSTMGradWeight::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
+  }
+  void add_input_size(int64_t input_size) {
+    fbb_.AddElement<int64_t>(LSTMGradWeight::VT_INPUT_SIZE, input_size, 0);
+  }
+  void add_hidden_size(int64_t hidden_size) {
+    fbb_.AddElement<int64_t>(LSTMGradWeight::VT_HIDDEN_SIZE, hidden_size, 0);
+  }
+  void add_num_layers(int64_t num_layers) {
+    fbb_.AddElement<int64_t>(LSTMGradWeight::VT_NUM_LAYERS, num_layers, 0);
+  }
+  void add_num_directions(int64_t num_directions) {
+    fbb_.AddElement<int64_t>(LSTMGradWeight::VT_NUM_DIRECTIONS, num_directions, 0);
+  }
+  void add_dropout(float dropout) {
+    fbb_.AddElement<float>(LSTMGradWeight::VT_DROPOUT, dropout, 0.0f);
+  }
+  void add_zoneout_cell(float zoneout_cell) {
+    fbb_.AddElement<float>(LSTMGradWeight::VT_ZONEOUT_CELL, zoneout_cell, 0.0f);
+  }
+  void add_zoneout_hidden(float zoneout_hidden) {
+    fbb_.AddElement<float>(LSTMGradWeight::VT_ZONEOUT_HIDDEN, zoneout_hidden, 0.0f);
+  }
+  explicit LSTMGradWeightBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LSTMGradWeight> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LSTMGradWeight>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LSTMGradWeight> CreateLSTMGradWeight(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool bidirectional = false,
+    bool has_bias = false,
+    int64_t input_size = 0,
+    int64_t hidden_size = 0,
+    int64_t num_layers = 0,
+    int64_t num_directions = 0,
+    float dropout = 0.0f,
+    float zoneout_cell = 0.0f,
+    float zoneout_hidden = 0.0f) {
+  LSTMGradWeightBuilder builder_(_fbb);
+  builder_.add_num_directions(num_directions);
+  builder_.add_num_layers(num_layers);
+  builder_.add_hidden_size(hidden_size);
+  builder_.add_input_size(input_size);
+  builder_.add_zoneout_hidden(zoneout_hidden);
+  builder_.add_zoneout_cell(zoneout_cell);
+  builder_.add_dropout(dropout);
+  builder_.add_has_bias(has_bias);
+  builder_.add_bidirectional(bidirectional);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<LSTMGradWeight> CreateLSTMGradWeight(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradWeightT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct RandomNormalT : public flatbuffers::NativeTable {
+  typedef RandomNormal TableType;
+  float seed = 0.0f;
+  float mean = 0.0f;
+  float scale = 0.0f;
+};
+
+struct RandomNormal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RandomNormalT NativeTableType;
+  typedef RandomNormalBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return RandomNormalTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SEED = 4,
+    VT_MEAN = 6,
+    VT_SCALE = 8
+  };
+  float seed() const {
+    return GetField<float>(VT_SEED, 0.0f);
+  }
+  bool mutate_seed(float _seed) {
+    return SetField<float>(VT_SEED, _seed, 0.0f);
+  }
+  float mean() const {
+    return GetField<float>(VT_MEAN, 0.0f);
+  }
+  bool mutate_mean(float _mean) {
+    return SetField<float>(VT_MEAN, _mean, 0.0f);
+  }
+  float scale() const {
+    return GetField<float>(VT_SCALE, 0.0f);
+  }
+  bool mutate_scale(float _scale) {
+    return SetField<float>(VT_SCALE, _scale, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_SEED) &&
+           VerifyField<float>(verifier, VT_MEAN) &&
+           VerifyField<float>(verifier, VT_SCALE) &&
+           verifier.EndTable();
+  }
+  RandomNormalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(RandomNormalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<RandomNormal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomNormalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct RandomNormalBuilder {
+  typedef RandomNormal Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_seed(float seed) {
+    fbb_.AddElement<float>(RandomNormal::VT_SEED, seed, 0.0f);
+  }
+  void add_mean(float mean) {
+    fbb_.AddElement<float>(RandomNormal::VT_MEAN, mean, 0.0f);
+  }
+  void add_scale(float scale) {
+    fbb_.AddElement<float>(RandomNormal::VT_SCALE, scale, 0.0f);
+  }
+  explicit RandomNormalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<RandomNormal> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<RandomNormal>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<RandomNormal> CreateRandomNormal(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float seed = 0.0f,
+    float mean = 0.0f,
+    float scale = 0.0f) {
+  RandomNormalBuilder builder_(_fbb);
+  builder_.add_scale(scale);
+  builder_.add_mean(mean);
+  builder_.add_seed(seed);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<RandomNormal> CreateRandomNormal(flatbuffers::FlatBufferBuilder &_fbb, const RandomNormalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct NLLLossT : public flatbuffers::NativeTable {
+  typedef NLLLoss TableType;
+  mindspore::schema::Reduction reduction = mindspore::schema::Reduction_REDUCTION_SUM;
+};
+
+struct NLLLoss FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NLLLossT NativeTableType;
+  typedef NLLLossBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return NLLLossTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_REDUCTION = 4
+  };
+  mindspore::schema::Reduction reduction() const {
+    return static_cast<mindspore::schema::Reduction>(GetField<int8_t>(VT_REDUCTION, 0));
+  }
+  bool mutate_reduction(mindspore::schema::Reduction _reduction) {
+    return SetField<int8_t>(VT_REDUCTION, static_cast<int8_t>(_reduction), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_REDUCTION) &&
+           verifier.EndTable();
+  }
+  NLLLossT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(NLLLossT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<NLLLoss> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NLLLossT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct NLLLossBuilder {
+  typedef NLLLoss Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_reduction(mindspore::schema::Reduction reduction) {
+    fbb_.AddElement<int8_t>(NLLLoss::VT_REDUCTION, static_cast<int8_t>(reduction), 0);
+  }
+  explicit NLLLossBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<NLLLoss> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<NLLLoss>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<NLLLoss> CreateNLLLoss(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Reduction reduction = mindspore::schema::Reduction_REDUCTION_SUM) {
+  NLLLossBuilder builder_(_fbb);
+  builder_.add_reduction(reduction);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<NLLLoss> CreateNLLLoss(flatbuffers::FlatBufferBuilder &_fbb, const NLLLossT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct NLLLossGradT : public flatbuffers::NativeTable {
+  typedef NLLLossGrad TableType;
+  mindspore::schema::Reduction reduction = mindspore::schema::Reduction_REDUCTION_SUM;
+};
+
+struct NLLLossGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NLLLossGradT NativeTableType;
+  typedef NLLLossGradBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return NLLLossGradTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_REDUCTION = 4
+  };
+  mindspore::schema::Reduction reduction() const {
+    return static_cast<mindspore::schema::Reduction>(GetField<int8_t>(VT_REDUCTION, 0));
+  }
+  bool mutate_reduction(mindspore::schema::Reduction _reduction) {
+    return SetField<int8_t>(VT_REDUCTION, static_cast<int8_t>(_reduction), 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_REDUCTION) &&
+           verifier.EndTable();
+  }
+  NLLLossGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(NLLLossGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<NLLLossGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NLLLossGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct NLLLossGradBuilder {
+  typedef NLLLossGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_reduction(mindspore::schema::Reduction reduction) {
+    fbb_.AddElement<int8_t>(NLLLossGrad::VT_REDUCTION, static_cast<int8_t>(reduction), 0);
+  }
+  explicit NLLLossGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<NLLLossGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<NLLLossGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<NLLLossGrad> CreateNLLLossGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Reduction reduction = mindspore::schema::Reduction_REDUCTION_SUM) {
+  NLLLossGradBuilder builder_(_fbb);
+  builder_.add_reduction(reduction);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<NLLLossGrad> CreateNLLLossGrad(flatbuffers::FlatBufferBuilder &_fbb, const NLLLossGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct FormatTransposeT : public flatbuffers::NativeTable {
+  typedef FormatTranspose TableType;
+  mindspore::schema::Format src_format = mindspore::schema::Format_NHWC;
+  mindspore::schema::Format dst_format = mindspore::schema::Format_NHWC;
+};
+
+struct FormatTranspose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FormatTransposeT NativeTableType;
+  typedef FormatTransposeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return FormatTransposeTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SRC_FORMAT = 4,
+    VT_DST_FORMAT = 6
+  };
+  mindspore::schema::Format src_format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_SRC_FORMAT, 1));
+  }
+  bool mutate_src_format(mindspore::schema::Format _src_format) {
+    return SetField<int32_t>(VT_SRC_FORMAT, static_cast<int32_t>(_src_format), 1);
+  }
+  mindspore::schema::Format dst_format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_DST_FORMAT, 1));
+  }
+  bool mutate_dst_format(mindspore::schema::Format _dst_format) {
+    return SetField<int32_t>(VT_DST_FORMAT, static_cast<int32_t>(_dst_format), 1);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_SRC_FORMAT) &&
+           VerifyField<int32_t>(verifier, VT_DST_FORMAT) &&
+           verifier.EndTable();
+  }
+  FormatTransposeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(FormatTransposeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<FormatTranspose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FormatTransposeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct FormatTransposeBuilder {
+  typedef FormatTranspose Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_src_format(mindspore::schema::Format src_format) {
+    fbb_.AddElement<int32_t>(FormatTranspose::VT_SRC_FORMAT, static_cast<int32_t>(src_format), 1);
+  }
+  void add_dst_format(mindspore::schema::Format dst_format) {
+    fbb_.AddElement<int32_t>(FormatTranspose::VT_DST_FORMAT, static_cast<int32_t>(dst_format), 1);
+  }
+  explicit FormatTransposeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FormatTranspose> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FormatTranspose>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FormatTranspose> CreateFormatTranspose(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format src_format = mindspore::schema::Format_NHWC,
+    mindspore::schema::Format dst_format = mindspore::schema::Format_NHWC) {
+  FormatTransposeBuilder builder_(_fbb);
+  builder_.add_dst_format(dst_format);
+  builder_.add_src_format(src_format);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<FormatTranspose> CreateFormatTranspose(flatbuffers::FlatBufferBuilder &_fbb, const FormatTransposeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct GatherDT : public flatbuffers::NativeTable {
+  typedef GatherD TableType;
+};
+
+struct GatherD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GatherDT NativeTableType;
+  typedef GatherDBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return GatherDTypeTable();
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+  GatherDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(GatherDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<GatherD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct GatherDBuilder {
+  typedef GatherD Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit GatherDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GatherD> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GatherD>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GatherD> CreateGatherD(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  GatherDBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<GatherD> CreateGatherD(flatbuffers::FlatBufferBuilder &_fbb, const GatherDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct GroupNormFusionT : public flatbuffers::NativeTable {
+  typedef GroupNormFusion TableType;
+  int64_t num_groups = 0;
+  float epsilon = 1e-5f;
+  bool affine = true;
+};
+
+struct GroupNormFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GroupNormFusionT NativeTableType;
+  typedef GroupNormFusionBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return GroupNormFusionTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUM_GROUPS = 4,
+    VT_EPSILON = 6,
+    VT_AFFINE = 8
+  };
+  int64_t num_groups() const {
+    return GetField<int64_t>(VT_NUM_GROUPS, 0);
+  }
+  bool mutate_num_groups(int64_t _num_groups) {
+    return SetField<int64_t>(VT_NUM_GROUPS, _num_groups, 0);
+  }
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 1e-5f);
+  }
+  bool mutate_epsilon(float _epsilon) {
+    return SetField<float>(VT_EPSILON, _epsilon, 1e-5f);
+  }
+  bool affine() const {
+    return GetField<uint8_t>(VT_AFFINE, 1) != 0;
+  }
+  bool mutate_affine(bool _affine) {
+    return SetField<uint8_t>(VT_AFFINE, static_cast<uint8_t>(_affine), 1);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_NUM_GROUPS) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<uint8_t>(verifier, VT_AFFINE) &&
+           verifier.EndTable();
+  }
+  GroupNormFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(GroupNormFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<GroupNormFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupNormFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct GroupNormFusionBuilder {
+  typedef GroupNormFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_num_groups(int64_t num_groups) {
+    fbb_.AddElement<int64_t>(GroupNormFusion::VT_NUM_GROUPS, num_groups, 0);
+  }
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(GroupNormFusion::VT_EPSILON, epsilon, 1e-5f);
+  }
+  void add_affine(bool affine) {
+    fbb_.AddElement<uint8_t>(GroupNormFusion::VT_AFFINE, static_cast<uint8_t>(affine), 1);
+  }
+  explicit GroupNormFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GroupNormFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GroupNormFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GroupNormFusion> CreateGroupNormFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t num_groups = 0,
+    float epsilon = 1e-5f,
+    bool affine = true) {
+  GroupNormFusionBuilder builder_(_fbb);
+  builder_.add_num_groups(num_groups);
+  builder_.add_epsilon(epsilon);
+  builder_.add_affine(affine);
+  return builder_.Finish();
+}
+
+flatbuffers::Offset<GroupNormFusion> CreateGroupNormFusion(flatbuffers::FlatBufferBuilder &_fbb, const GroupNormFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+inline AbsT *Abs::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AbsT>(new AbsT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Abs::UnPackTo(AbsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Abs> Abs::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAbs(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Abs> CreateAbs(flatbuffers::FlatBufferBuilder &_fbb, const AbsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AbsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateAbs(
+      _fbb);
+}
+
+inline ActivationT *Activation::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ActivationT>(new ActivationT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Activation::UnPackTo(ActivationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = activation_type(); _o->activation_type = _e; }
+  { auto _e = alpha(); _o->alpha = _e; }
+  { auto _e = min_val(); _o->min_val = _e; }
+  { auto _e = max_val(); _o->max_val = _e; }
+  { auto _e = approximate(); _o->approximate = _e; }
+}
+
+inline flatbuffers::Offset<Activation> Activation::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActivationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateActivation(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Activation> CreateActivation(flatbuffers::FlatBufferBuilder &_fbb, const ActivationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActivationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _activation_type = _o->activation_type;
+  auto _alpha = _o->alpha;
+  auto _min_val = _o->min_val;
+  auto _max_val = _o->max_val;
+  auto _approximate = _o->approximate;
+  return mindspore::schema::CreateActivation(
+      _fbb,
+      _activation_type,
+      _alpha,
+      _min_val,
+      _max_val,
+      _approximate);
+}
+
+inline ActivationGradT *ActivationGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ActivationGradT>(new ActivationGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ActivationGrad::UnPackTo(ActivationGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = activation_type(); _o->activation_type = _e; }
+  { auto _e = alpha(); _o->alpha = _e; }
+}
+
+inline flatbuffers::Offset<ActivationGrad> ActivationGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActivationGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateActivationGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ActivationGrad> CreateActivationGrad(flatbuffers::FlatBufferBuilder &_fbb, const ActivationGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActivationGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _activation_type = _o->activation_type;
+  auto _alpha = _o->alpha;
+  return mindspore::schema::CreateActivationGrad(
+      _fbb,
+      _activation_type,
+      _alpha);
+}
+
+inline AdamT *Adam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AdamT>(new AdamT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Adam::UnPackTo(AdamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = use_locking(); _o->use_locking = _e; }
+  { auto _e = use_nesterov(); _o->use_nesterov = _e; }
+}
+
+inline flatbuffers::Offset<Adam> Adam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAdam(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Adam> CreateAdam(flatbuffers::FlatBufferBuilder &_fbb, const AdamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AdamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _use_locking = _o->use_locking;
+  auto _use_nesterov = _o->use_nesterov;
+  return mindspore::schema::CreateAdam(
+      _fbb,
+      _use_locking,
+      _use_nesterov);
+}
+
+inline AddFusionT *AddFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AddFusionT>(new AddFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void AddFusion::UnPackTo(AddFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<AddFusion> AddFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAddFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<AddFusion> CreateAddFusion(flatbuffers::FlatBufferBuilder &_fbb, const AddFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateAddFusion(
+      _fbb,
+      _activation_type);
+}
+
+inline AdderFusionT *AdderFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AdderFusionT>(new AdderFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void AdderFusion::UnPackTo(AdderFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
+  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
+  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
+  { auto _e = pad_mode(); _o->pad_mode = _e; }
+  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
+  { auto _e = group(); _o->group = _e; }
+  { auto _e = in_channel(); _o->in_channel = _e; }
+  { auto _e = out_channel(); _o->out_channel = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<AdderFusion> AdderFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdderFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAdderFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<AdderFusion> CreateAdderFusion(flatbuffers::FlatBufferBuilder &_fbb, const AdderFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AdderFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _format = _o->format;
+  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
+  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
+  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
+  auto _pad_mode = _o->pad_mode;
+  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
+  auto _group = _o->group;
+  auto _in_channel = _o->in_channel;
+  auto _out_channel = _o->out_channel;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateAdderFusion(
+      _fbb,
+      _format,
+      _kernel_size,
+      _stride,
+      _dilation,
+      _pad_mode,
+      _pad_list,
+      _group,
+      _in_channel,
+      _out_channel,
+      _activation_type);
+}
+
+inline AddGradT *AddGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AddGradT>(new AddGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void AddGrad::UnPackTo(AddGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<AddGrad> AddGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAddGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<AddGrad> CreateAddGrad(flatbuffers::FlatBufferBuilder &_fbb, const AddGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateAddGrad(
+      _fbb);
+}
+
+inline AddNT *AddN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AddNT>(new AddNT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void AddN::UnPackTo(AddNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<AddN> AddN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAddN(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<AddN> CreateAddN(flatbuffers::FlatBufferBuilder &_fbb, const AddNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateAddN(
+      _fbb);
+}
+
+inline AllT *All::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AllT>(new AllT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void All::UnPackTo(AllT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = keep_dims(); _o->keep_dims = _e; }
+}
+
+inline flatbuffers::Offset<All> All::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AllT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAll(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<All> CreateAll(flatbuffers::FlatBufferBuilder &_fbb, const AllT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AllT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _keep_dims = _o->keep_dims;
+  return mindspore::schema::CreateAll(
+      _fbb,
+      _keep_dims);
+}
+
+inline ApplyMomentumT *ApplyMomentum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ApplyMomentumT>(new ApplyMomentumT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ApplyMomentum::UnPackTo(ApplyMomentumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = use_nesterov(); _o->use_nesterov = _e; }
+  { auto _e = use_locking(); _o->use_locking = _e; }
+  { auto _e = gradient_scale(); _o->gradient_scale = _e; }
+}
+
+inline flatbuffers::Offset<ApplyMomentum> ApplyMomentum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ApplyMomentumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateApplyMomentum(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ApplyMomentum> CreateApplyMomentum(flatbuffers::FlatBufferBuilder &_fbb, const ApplyMomentumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ApplyMomentumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _use_nesterov = _o->use_nesterov;
+  auto _use_locking = _o->use_locking;
+  auto _gradient_scale = _o->gradient_scale;
+  return mindspore::schema::CreateApplyMomentum(
+      _fbb,
+      _use_nesterov,
+      _use_locking,
+      _gradient_scale);
+}
+
+inline ArgMaxFusionT *ArgMaxFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ArgMaxFusionT>(new ArgMaxFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ArgMaxFusion::UnPackTo(ArgMaxFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); _o->axis = _e; }
+  { auto _e = top_k(); _o->top_k = _e; }
+  { auto _e = keep_dims(); _o->keep_dims = _e; }
+  { auto _e = out_max_value(); _o->out_max_value = _e; }
+}
+
+inline flatbuffers::Offset<ArgMaxFusion> ArgMaxFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateArgMaxFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ArgMaxFusion> CreateArgMaxFusion(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis;
+  auto _top_k = _o->top_k;
+  auto _keep_dims = _o->keep_dims;
+  auto _out_max_value = _o->out_max_value;
+  return mindspore::schema::CreateArgMaxFusion(
+      _fbb,
+      _axis,
+      _top_k,
+      _keep_dims,
+      _out_max_value);
+}
+
+inline ArgMinFusionT *ArgMinFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ArgMinFusionT>(new ArgMinFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ArgMinFusion::UnPackTo(ArgMinFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); _o->axis = _e; }
+  { auto _e = top_k(); _o->top_k = _e; }
+  { auto _e = keep_dims(); _o->keep_dims = _e; }
+  { auto _e = out_max_value(); _o->out_max_value = _e; }
+}
+
+inline flatbuffers::Offset<ArgMinFusion> ArgMinFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateArgMinFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ArgMinFusion> CreateArgMinFusion(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMinFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis;
+  auto _top_k = _o->top_k;
+  auto _keep_dims = _o->keep_dims;
+  auto _out_max_value = _o->out_max_value;
+  return mindspore::schema::CreateArgMinFusion(
+      _fbb,
+      _axis,
+      _top_k,
+      _keep_dims,
+      _out_max_value);
+}
+
+inline AssertT *Assert::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AssertT>(new AssertT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Assert::UnPackTo(AssertT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = summarize(); _o->summarize = _e; }
+}
+
+inline flatbuffers::Offset<Assert> Assert::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssertT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAssert(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Assert> CreateAssert(flatbuffers::FlatBufferBuilder &_fbb, const AssertT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssertT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _summarize = _o->summarize;
+  return mindspore::schema::CreateAssert(
+      _fbb,
+      _summarize);
+}
+
+inline AssignT *Assign::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AssignT>(new AssignT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Assign::UnPackTo(AssignT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Assign> Assign::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAssign(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Assign> CreateAssign(flatbuffers::FlatBufferBuilder &_fbb, const AssignT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssignT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateAssign(
+      _fbb);
+}
+
+inline AssignAddT *AssignAdd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AssignAddT>(new AssignAddT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void AssignAdd::UnPackTo(AssignAddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<AssignAdd> AssignAdd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignAddT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAssignAdd(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<AssignAdd> CreateAssignAdd(flatbuffers::FlatBufferBuilder &_fbb, const AssignAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssignAddT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateAssignAdd(
+      _fbb);
+}
+
+inline AudioSpectrogramT *AudioSpectrogram::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AudioSpectrogramT>(new AudioSpectrogramT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void AudioSpectrogram::UnPackTo(AudioSpectrogramT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = window_size(); _o->window_size = _e; }
+  { auto _e = stride(); _o->stride = _e; }
+  { auto _e = mag_square(); _o->mag_square = _e; }
+}
+
+inline flatbuffers::Offset<AudioSpectrogram> AudioSpectrogram::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioSpectrogramT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAudioSpectrogram(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<AudioSpectrogram> CreateAudioSpectrogram(flatbuffers::FlatBufferBuilder &_fbb, const AudioSpectrogramT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AudioSpectrogramT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _window_size = _o->window_size;
+  auto _stride = _o->stride;
+  auto _mag_square = _o->mag_square;
+  return mindspore::schema::CreateAudioSpectrogram(
+      _fbb,
+      _window_size,
+      _stride,
+      _mag_square);
+}
+
+inline AvgPoolFusionT *AvgPoolFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AvgPoolFusionT>(new AvgPoolFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void AvgPoolFusion::UnPackTo(AvgPoolFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
+  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } }
+  { auto _e = pad(); if (_e) { _o->pad.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad[_i] = _e->Get(_i); } } }
+  { auto _e = pad_mode(); _o->pad_mode = _e; }
+  { auto _e = round_mode(); _o->round_mode = _e; }
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = global(); _o->global = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<AvgPoolFusion> AvgPoolFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAvgPoolFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<AvgPoolFusion> CreateAvgPoolFusion(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AvgPoolFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
+  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
+  auto _pad = _o->pad.size() ? _fbb.CreateVector(_o->pad) : 0;
+  auto _pad_mode = _o->pad_mode;
+  auto _round_mode = _o->round_mode;
+  auto _format = _o->format;
+  auto _global = _o->global;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateAvgPoolFusion(
+      _fbb,
+      _kernel_size,
+      _strides,
+      _pad,
+      _pad_mode,
+      _round_mode,
+      _format,
+      _global,
+      _activation_type);
+}
+
+inline AvgPoolGradT *AvgPoolGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AvgPoolGradT>(new AvgPoolGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void AvgPoolGrad::UnPackTo(AvgPoolGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
+  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } }
+  { auto _e = pad_mode(); _o->pad_mode = _e; }
+  { auto _e = format(); _o->format = _e; }
+}
+
+inline flatbuffers::Offset<AvgPoolGrad> AvgPoolGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAvgPoolGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<AvgPoolGrad> CreateAvgPoolGrad(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AvgPoolGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
+  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
+  auto _pad_mode = _o->pad_mode;
+  auto _format = _o->format;
+  return mindspore::schema::CreateAvgPoolGrad(
+      _fbb,
+      _kernel_size,
+      _strides,
+      _pad_mode,
+      _format);
+}
+
+inline BatchNormT *BatchNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<BatchNormT>(new BatchNormT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BatchNorm::UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = epsilon(); _o->epsilon = _e; }
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = is_training(); _o->is_training = _e; }
+}
+
+inline flatbuffers::Offset<BatchNorm> BatchNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBatchNorm(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _epsilon = _o->epsilon;
+  auto _format = _o->format;
+  auto _is_training = _o->is_training;
+  return mindspore::schema::CreateBatchNorm(
+      _fbb,
+      _epsilon,
+      _format,
+      _is_training);
+}
+
+inline BatchNormGradT *BatchNormGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<BatchNormGradT>(new BatchNormGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BatchNormGrad::UnPackTo(BatchNormGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = epsilon(); _o->epsilon = _e; }
+  { auto _e = is_training(); _o->is_training = _e; }
+}
+
+inline flatbuffers::Offset<BatchNormGrad> BatchNormGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBatchNormGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BatchNormGrad> CreateBatchNormGrad(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchNormGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _epsilon = _o->epsilon;
+  auto _is_training = _o->is_training;
+  return mindspore::schema::CreateBatchNormGrad(
+      _fbb,
+      _epsilon,
+      _is_training);
+}
+
+inline BatchToSpaceT *BatchToSpace::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<BatchToSpaceT>(new BatchToSpaceT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BatchToSpace::UnPackTo(BatchToSpaceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = block_size(); if (_e) { _o->block_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_size[_i] = _e->Get(_i); } } }
+  { auto _e = crops(); if (_e) _o->crops = std::unique_ptr<mindspore::schema::Vec2DT>(_e->UnPack(_resolver)); }
+}
+
+inline flatbuffers::Offset<BatchToSpace> BatchToSpace::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBatchToSpace(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchToSpaceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _block_size = _o->block_size.size() ? _fbb.CreateVector(_o->block_size) : 0;
+  auto _crops = _o->crops ? CreateVec2D(_fbb, _o->crops.get(), _rehasher) : 0;
+  return mindspore::schema::CreateBatchToSpace(
+      _fbb,
+      _block_size,
+      _crops);
+}
+
+inline BatchToSpaceNDT *BatchToSpaceND::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<BatchToSpaceNDT>(new BatchToSpaceNDT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BatchToSpaceND::UnPackTo(BatchToSpaceNDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = block_shape(); if (_e) { _o->block_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_shape[_i] = _e->Get(_i); } } }
+  { auto _e = crops(); if (_e) _o->crops = std::unique_ptr<mindspore::schema::Vec2DT>(_e->UnPack(_resolver)); }
+}
+
+inline flatbuffers::Offset<BatchToSpaceND> BatchToSpaceND::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBatchToSpaceND(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceND(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchToSpaceNDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _block_shape = _o->block_shape.size() ? _fbb.CreateVector(_o->block_shape) : 0;
+  auto _crops = _o->crops ? CreateVec2D(_fbb, _o->crops.get(), _rehasher) : 0;
+  return mindspore::schema::CreateBatchToSpaceND(
+      _fbb,
+      _block_shape,
+      _crops);
+}
+
+inline BiasAddT *BiasAdd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<BiasAddT>(new BiasAddT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BiasAdd::UnPackTo(BiasAddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = format(); _o->format = _e; }
+}
+
+inline flatbuffers::Offset<BiasAdd> BiasAdd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBiasAdd(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BiasAdd> CreateBiasAdd(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BiasAddT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _format = _o->format;
+  return mindspore::schema::CreateBiasAdd(
+      _fbb,
+      _format);
+}
+
+inline BinaryCrossEntropyT *BinaryCrossEntropy::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<BinaryCrossEntropyT>(new BinaryCrossEntropyT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BinaryCrossEntropy::UnPackTo(BinaryCrossEntropyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = reduction(); _o->reduction = _e; }
+}
+
+inline flatbuffers::Offset<BinaryCrossEntropy> BinaryCrossEntropy::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBinaryCrossEntropy(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BinaryCrossEntropy> CreateBinaryCrossEntropy(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BinaryCrossEntropyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _reduction = _o->reduction;
+  return mindspore::schema::CreateBinaryCrossEntropy(
+      _fbb,
+      _reduction);
+}
+
+inline BinaryCrossEntropyGradT *BinaryCrossEntropyGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<BinaryCrossEntropyGradT>(new BinaryCrossEntropyGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BinaryCrossEntropyGrad::UnPackTo(BinaryCrossEntropyGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = reduction(); _o->reduction = _e; }
+}
+
+inline flatbuffers::Offset<BinaryCrossEntropyGrad> BinaryCrossEntropyGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBinaryCrossEntropyGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BinaryCrossEntropyGrad> CreateBinaryCrossEntropyGrad(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BinaryCrossEntropyGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _reduction = _o->reduction;
+  return mindspore::schema::CreateBinaryCrossEntropyGrad(
+      _fbb,
+      _reduction);
+}
+
+inline BiasAddGradT *BiasAddGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<BiasAddGradT>(new BiasAddGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BiasAddGrad::UnPackTo(BiasAddGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<BiasAddGrad> BiasAddGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBiasAddGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BiasAddGrad> CreateBiasAddGrad(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BiasAddGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateBiasAddGrad(
+      _fbb);
+}
+
+inline BroadcastToT *BroadcastTo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<BroadcastToT>(new BroadcastToT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void BroadcastTo::UnPackTo(BroadcastToT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<BroadcastTo> BroadcastTo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateBroadcastTo(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BroadcastToT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
+  return mindspore::schema::CreateBroadcastTo(
+      _fbb,
+      _shape);
+}
+
+inline CastT *Cast::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<CastT>(new CastT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Cast::UnPackTo(CastT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Cast> Cast::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateCast(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Cast> CreateCast(flatbuffers::FlatBufferBuilder &_fbb, const CastT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CastT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateCast(
+      _fbb);
+}
+
+inline CeilT *Ceil::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<CeilT>(new CeilT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Ceil::UnPackTo(CeilT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Ceil> Ceil::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CeilT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateCeil(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Ceil> CreateCeil(flatbuffers::FlatBufferBuilder &_fbb, const CeilT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CeilT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateCeil(
+      _fbb);
+}
+
+inline ClipT *Clip::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ClipT>(new ClipT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Clip::UnPackTo(ClipT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = max(); _o->max = _e; }
+  { auto _e = min(); _o->min = _e; }
+}
+
+inline flatbuffers::Offset<Clip> Clip::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateClip(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Clip> CreateClip(flatbuffers::FlatBufferBuilder &_fbb, const ClipT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ClipT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _max = _o->max;
+  auto _min = _o->min;
+  return mindspore::schema::CreateClip(
+      _fbb,
+      _max,
+      _min);
+}
+
+inline ConcatT *Concat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ConcatT>(new ConcatT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Concat::UnPackTo(ConcatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); _o->axis = _e; }
+}
+
+inline flatbuffers::Offset<Concat> Concat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateConcat(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Concat> CreateConcat(flatbuffers::FlatBufferBuilder &_fbb, const ConcatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConcatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis;
+  return mindspore::schema::CreateConcat(
+      _fbb,
+      _axis);
+}
+
+inline AttentionT *Attention::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AttentionT>(new AttentionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Attention::UnPackTo(AttentionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Attention> Attention::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttentionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAttention(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Attention> CreateAttention(flatbuffers::FlatBufferBuilder &_fbb, const AttentionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttentionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateAttention(
+      _fbb);
+}
+
+inline Conv2DBackpropFilterFusionT *Conv2DBackpropFilterFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<Conv2DBackpropFilterFusionT>(new Conv2DBackpropFilterFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Conv2DBackpropFilterFusion::UnPackTo(Conv2DBackpropFilterFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
+  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
+  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
+  { auto _e = pad_mode(); _o->pad_mode = _e; }
+  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
+  { auto _e = mode(); _o->mode = _e; }
+  { auto _e = group(); _o->group = _e; }
+  { auto _e = in_channel(); _o->in_channel = _e; }
+  { auto _e = out_channel(); _o->out_channel = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<Conv2DBackpropFilterFusion> Conv2DBackpropFilterFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropFilterFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateConv2DBackpropFilterFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Conv2DBackpropFilterFusion> CreateConv2DBackpropFilterFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropFilterFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DBackpropFilterFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _format = _o->format;
+  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
+  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
+  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
+  auto _pad_mode = _o->pad_mode;
+  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
+  auto _mode = _o->mode;
+  auto _group = _o->group;
+  auto _in_channel = _o->in_channel;
+  auto _out_channel = _o->out_channel;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateConv2DBackpropFilterFusion(
+      _fbb,
+      _format,
+      _kernel_size,
+      _stride,
+      _dilation,
+      _pad_mode,
+      _pad_list,
+      _mode,
+      _group,
+      _in_channel,
+      _out_channel,
+      _activation_type);
+}
+
+inline Conv2DBackpropInputFusionT *Conv2DBackpropInputFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<Conv2DBackpropInputFusionT>(new Conv2DBackpropInputFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Conv2DBackpropInputFusion::UnPackTo(Conv2DBackpropInputFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
+  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
+  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
+  { auto _e = pad_mode(); _o->pad_mode = _e; }
+  { auto _e = pad(); if (_e) { _o->pad.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad[_i] = _e->Get(_i); } } }
+  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
+  { auto _e = mode(); _o->mode = _e; }
+  { auto _e = group(); _o->group = _e; }
+  { auto _e = in_channel(); _o->in_channel = _e; }
+  { auto _e = out_channel(); _o->out_channel = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<Conv2DBackpropInputFusion> Conv2DBackpropInputFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropInputFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateConv2DBackpropInputFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Conv2DBackpropInputFusion> CreateConv2DBackpropInputFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropInputFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DBackpropInputFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _format = _o->format;
+  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
+  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
+  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
+  auto _pad_mode = _o->pad_mode;
+  auto _pad = _o->pad.size() ? _fbb.CreateVector(_o->pad) : 0;
+  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
+  auto _mode = _o->mode;
+  auto _group = _o->group;
+  auto _in_channel = _o->in_channel;
+  auto _out_channel = _o->out_channel;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateConv2DBackpropInputFusion(
+      _fbb,
+      _format,
+      _kernel_size,
+      _stride,
+      _dilation,
+      _pad_mode,
+      _pad,
+      _pad_list,
+      _mode,
+      _group,
+      _in_channel,
+      _out_channel,
+      _activation_type);
+}
+
+inline Conv2DFusionT *Conv2DFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<Conv2DFusionT>(new Conv2DFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Conv2DFusion::UnPackTo(Conv2DFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
+  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
+  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
+  { auto _e = pad_mode(); _o->pad_mode = _e; }
+  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
+  { auto _e = mode(); _o->mode = _e; }
+  { auto _e = group(); _o->group = _e; }
+  { auto _e = in_channel(); _o->in_channel = _e; }
+  { auto _e = out_channel(); _o->out_channel = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<Conv2DFusion> Conv2DFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateConv2DFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Conv2DFusion> CreateConv2DFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _format = _o->format;
+  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
+  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
+  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
+  auto _pad_mode = _o->pad_mode;
+  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
+  auto _mode = _o->mode;
+  auto _group = _o->group;
+  auto _in_channel = _o->in_channel;
+  auto _out_channel = _o->out_channel;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateConv2DFusion(
+      _fbb,
+      _format,
+      _kernel_size,
+      _stride,
+      _dilation,
+      _pad_mode,
+      _pad_list,
+      _mode,
+      _group,
+      _in_channel,
+      _out_channel,
+      _activation_type);
+}
+
+inline Conv2dTransposeFusionT *Conv2dTransposeFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<Conv2dTransposeFusionT>(new Conv2dTransposeFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Conv2dTransposeFusion::UnPackTo(Conv2dTransposeFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
+  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
+  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
+  { auto _e = pad_mode(); _o->pad_mode = _e; }
+  { auto _e = pad(); if (_e) { _o->pad.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad[_i] = _e->Get(_i); } } }
+  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
+  { auto _e = mode(); _o->mode = _e; }
+  { auto _e = group(); _o->group = _e; }
+  { auto _e = in_channel(); _o->in_channel = _e; }
+  { auto _e = out_channel(); _o->out_channel = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+  { auto _e = output_paddings(); if (_e) { _o->output_paddings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->output_paddings[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<Conv2dTransposeFusion> Conv2dTransposeFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2dTransposeFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateConv2dTransposeFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Conv2dTransposeFusion> CreateConv2dTransposeFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2dTransposeFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2dTransposeFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _format = _o->format;
+  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
+  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
+  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
+  auto _pad_mode = _o->pad_mode;
+  auto _pad = _o->pad.size() ? _fbb.CreateVector(_o->pad) : 0;
+  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
+  auto _mode = _o->mode;
+  auto _group = _o->group;
+  auto _in_channel = _o->in_channel;
+  auto _out_channel = _o->out_channel;
+  auto _activation_type = _o->activation_type;
+  auto _output_paddings = _o->output_paddings.size() ? _fbb.CreateVector(_o->output_paddings) : 0;
+  return mindspore::schema::CreateConv2dTransposeFusion(
+      _fbb,
+      _format,
+      _kernel_size,
+      _stride,
+      _dilation,
+      _pad_mode,
+      _pad,
+      _pad_list,
+      _mode,
+      _group,
+      _in_channel,
+      _out_channel,
+      _activation_type,
+      _output_paddings);
+}
+
+inline CosT *Cos::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<CosT>(new CosT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Cos::UnPackTo(CosT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Cos> Cos::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateCos(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Cos> CreateCos(flatbuffers::FlatBufferBuilder &_fbb, const CosT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CosT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateCos(
+      _fbb);
+}
+
+inline ConstantOfShapeT *ConstantOfShape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ConstantOfShapeT>(new ConstantOfShapeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ConstantOfShape::UnPackTo(ConstantOfShapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = data_type(); _o->data_type = _e; }
+  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->value[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<ConstantOfShape> ConstantOfShape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstantOfShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateConstantOfShape(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShape(flatbuffers::FlatBufferBuilder &_fbb, const ConstantOfShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConstantOfShapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _data_type = _o->data_type;
+  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
+  return mindspore::schema::CreateConstantOfShape(
+      _fbb,
+      _data_type,
+      _value);
+}
+
+inline CropT *Crop::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<CropT>(new CropT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Crop::UnPackTo(CropT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); _o->axis = _e; }
+  { auto _e = offsets(); if (_e) { _o->offsets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->offsets[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<Crop> Crop::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateCrop(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Crop> CreateCrop(flatbuffers::FlatBufferBuilder &_fbb, const CropT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CropT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis;
+  auto _offsets = _o->offsets.size() ? _fbb.CreateVector(_o->offsets) : 0;
+  return mindspore::schema::CreateCrop(
+      _fbb,
+      _axis,
+      _offsets);
+}
+
+inline CustomExtractFeaturesT *CustomExtractFeatures::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<CustomExtractFeaturesT>(new CustomExtractFeaturesT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void CustomExtractFeatures::UnPackTo(CustomExtractFeaturesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<CustomExtractFeatures> CustomExtractFeatures::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomExtractFeaturesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateCustomExtractFeatures(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<CustomExtractFeatures> CreateCustomExtractFeatures(flatbuffers::FlatBufferBuilder &_fbb, const CustomExtractFeaturesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomExtractFeaturesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateCustomExtractFeatures(
+      _fbb);
+}
+
+inline CustomNormalizeT *CustomNormalize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<CustomNormalizeT>(new CustomNormalizeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void CustomNormalize::UnPackTo(CustomNormalizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<CustomNormalize> CustomNormalize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomNormalizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateCustomNormalize(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<CustomNormalize> CreateCustomNormalize(flatbuffers::FlatBufferBuilder &_fbb, const CustomNormalizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomNormalizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateCustomNormalize(
+      _fbb);
+}
+
+inline CustomPredictT *CustomPredict::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<CustomPredictT>(new CustomPredictT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void CustomPredict::UnPackTo(CustomPredictT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = output_num(); _o->output_num = _e; }
+  { auto _e = weight_threshold(); _o->weight_threshold = _e; }
+}
+
+inline flatbuffers::Offset<CustomPredict> CustomPredict::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomPredictT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateCustomPredict(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<CustomPredict> CreateCustomPredict(flatbuffers::FlatBufferBuilder &_fbb, const CustomPredictT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomPredictT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _output_num = _o->output_num;
+  auto _weight_threshold = _o->weight_threshold;
+  return mindspore::schema::CreateCustomPredict(
+      _fbb,
+      _output_num,
+      _weight_threshold);
+}
+
+inline DeConv2DGradFilterT *DeConv2DGradFilter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<DeConv2DGradFilterT>(new DeConv2DGradFilterT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void DeConv2DGradFilter::UnPackTo(DeConv2DGradFilterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = in_channel(); _o->in_channel = _e; }
+  { auto _e = out_channel(); _o->out_channel = _e; }
+  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
+  { auto _e = pad_mode(); _o->pad_mode = _e; }
+  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
+  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
+  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
+  { auto _e = group(); _o->group = _e; }
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<DeConv2DGradFilter> DeConv2DGradFilter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DGradFilterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateDeConv2DGradFilter(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilter(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DGradFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DeConv2DGradFilterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _in_channel = _o->in_channel;
+  auto _out_channel = _o->out_channel;
+  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
+  auto _pad_mode = _o->pad_mode;
+  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
+  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
+  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
+  auto _group = _o->group;
+  auto _format = _o->format;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateDeConv2DGradFilter(
+      _fbb,
+      _in_channel,
+      _out_channel,
+      _kernel_size,
+      _pad_mode,
+      _pad_list,
+      _stride,
+      _dilation,
+      _group,
+      _format,
+      _activation_type);
+}
+
+inline DependT *Depend::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<DependT>(new DependT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Depend::UnPackTo(DependT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Depend> Depend::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DependT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateDepend(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Depend> CreateDepend(flatbuffers::FlatBufferBuilder &_fbb, const DependT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DependT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateDepend(
+      _fbb);
+}
+
+inline DepthToSpaceT *DepthToSpace::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<DepthToSpaceT>(new DepthToSpaceT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void DepthToSpace::UnPackTo(DepthToSpaceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = block_size(); _o->block_size = _e; }
+  { auto _e = format(); _o->format = _e; }
+}
+
+inline flatbuffers::Offset<DepthToSpace> DepthToSpace::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateDepthToSpace(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthToSpaceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _block_size = _o->block_size;
+  auto _format = _o->format;
+  return mindspore::schema::CreateDepthToSpace(
+      _fbb,
+      _block_size,
+      _format);
+}
+
+inline DetectionPostProcessT *DetectionPostProcess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<DetectionPostProcessT>(new DetectionPostProcessT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void DetectionPostProcess::UnPackTo(DetectionPostProcessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = input_size(); _o->input_size = _e; }
+  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } }
+  { auto _e = nms_iou_threshold(); _o->nms_iou_threshold = _e; }
+  { auto _e = nms_score_threshold(); _o->nms_score_threshold = _e; }
+  { auto _e = max_detections(); _o->max_detections = _e; }
+  { auto _e = detections_per_class(); _o->detections_per_class = _e; }
+  { auto _e = max_classes_per_detection(); _o->max_classes_per_detection = _e; }
+  { auto _e = num_classes(); _o->num_classes = _e; }
+  { auto _e = use_regular_nms(); _o->use_regular_nms = _e; }
+  { auto _e = out_quantized(); _o->out_quantized = _e; }
+}
+
+inline flatbuffers::Offset<DetectionPostProcess> DetectionPostProcess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateDetectionPostProcess(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectionPostProcessT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _format = _o->format;
+  auto _input_size = _o->input_size;
+  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
+  auto _nms_iou_threshold = _o->nms_iou_threshold;
+  auto _nms_score_threshold = _o->nms_score_threshold;
+  auto _max_detections = _o->max_detections;
+  auto _detections_per_class = _o->detections_per_class;
+  auto _max_classes_per_detection = _o->max_classes_per_detection;
+  auto _num_classes = _o->num_classes;
+  auto _use_regular_nms = _o->use_regular_nms;
+  auto _out_quantized = _o->out_quantized;
+  return mindspore::schema::CreateDetectionPostProcess(
+      _fbb,
+      _format,
+      _input_size,
+      _scale,
+      _nms_iou_threshold,
+      _nms_score_threshold,
+      _max_detections,
+      _detections_per_class,
+      _max_classes_per_detection,
+      _num_classes,
+      _use_regular_nms,
+      _out_quantized);
+}
+
+inline DivFusionT *DivFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<DivFusionT>(new DivFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void DivFusion::UnPackTo(DivFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<DivFusion> DivFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateDivFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<DivFusion> CreateDivFusion(flatbuffers::FlatBufferBuilder &_fbb, const DivFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DivFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateDivFusion(
+      _fbb,
+      _activation_type);
+}
+
+inline DivGradT *DivGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<DivGradT>(new DivGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void DivGrad::UnPackTo(DivGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<DivGrad> DivGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateDivGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<DivGrad> CreateDivGrad(flatbuffers::FlatBufferBuilder &_fbb, const DivGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DivGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateDivGrad(
+      _fbb);
+}
+
+inline DropoutT *Dropout::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<DropoutT>(new DropoutT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Dropout::UnPackTo(DropoutT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = keep_prob(); _o->keep_prob = _e; }
+}
+
+inline flatbuffers::Offset<Dropout> Dropout::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DropoutT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateDropout(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Dropout> CreateDropout(flatbuffers::FlatBufferBuilder &_fbb, const DropoutT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DropoutT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _keep_prob = _o->keep_prob;
+  return mindspore::schema::CreateDropout(
+      _fbb,
+      _keep_prob);
+}
+
+inline DropoutGradT *DropoutGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<DropoutGradT>(new DropoutGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void DropoutGrad::UnPackTo(DropoutGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = keep_prob(); _o->keep_prob = _e; }
+}
+
+inline flatbuffers::Offset<DropoutGrad> DropoutGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DropoutGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateDropoutGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<DropoutGrad> CreateDropoutGrad(flatbuffers::FlatBufferBuilder &_fbb, const DropoutGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DropoutGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _keep_prob = _o->keep_prob;
+  return mindspore::schema::CreateDropoutGrad(
+      _fbb,
+      _keep_prob);
+}
+
+inline EluT *Elu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<EluT>(new EluT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Elu::UnPackTo(EluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = alpha(); _o->alpha = _e; }
+}
+
+inline flatbuffers::Offset<Elu> Elu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateElu(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Elu> CreateElu(flatbuffers::FlatBufferBuilder &_fbb, const EluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _alpha = _o->alpha;
+  return mindspore::schema::CreateElu(
+      _fbb,
+      _alpha);
+}
+
+inline EltwiseT *Eltwise::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<EltwiseT>(new EltwiseT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Eltwise::UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = mode(); _o->mode = _e; }
+}
+
+inline flatbuffers::Offset<Eltwise> Eltwise::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateEltwise(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EltwiseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _mode = _o->mode;
+  return mindspore::schema::CreateEltwise(
+      _fbb,
+      _mode);
+}
+
+inline EqualT *Equal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<EqualT>(new EqualT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Equal::UnPackTo(EqualT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Equal> Equal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateEqual(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Equal> CreateEqual(flatbuffers::FlatBufferBuilder &_fbb, const EqualT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EqualT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateEqual(
+      _fbb);
+}
+
+inline EmbeddingLookupFusionT *EmbeddingLookupFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<EmbeddingLookupFusionT>(new EmbeddingLookupFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void EmbeddingLookupFusion::UnPackTo(EmbeddingLookupFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = max_norm(); _o->max_norm = _e; }
+}
+
+inline flatbuffers::Offset<EmbeddingLookupFusion> EmbeddingLookupFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateEmbeddingLookupFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<EmbeddingLookupFusion> CreateEmbeddingLookupFusion(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EmbeddingLookupFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _max_norm = _o->max_norm;
+  return mindspore::schema::CreateEmbeddingLookupFusion(
+      _fbb,
+      _max_norm);
+}
+
+inline ExpFusionT *ExpFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ExpFusionT>(new ExpFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ExpFusion::UnPackTo(ExpFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = base(); _o->base = _e; }
+  { auto _e = scale(); _o->scale = _e; }
+  { auto _e = shift(); _o->shift = _e; }
+}
+
+inline flatbuffers::Offset<ExpFusion> ExpFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateExpFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ExpFusion> CreateExpFusion(flatbuffers::FlatBufferBuilder &_fbb, const ExpFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _base = _o->base;
+  auto _scale = _o->scale;
+  auto _shift = _o->shift;
+  return mindspore::schema::CreateExpFusion(
+      _fbb,
+      _base,
+      _scale,
+      _shift);
+}
+
+inline ExpandDimsT *ExpandDims::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ExpandDimsT>(new ExpandDimsT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ExpandDims::UnPackTo(ExpandDimsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<ExpandDims> ExpandDims::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateExpandDims(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ExpandDims> CreateExpandDims(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpandDimsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateExpandDims(
+      _fbb);
+}
+
+inline FakeQuantWithMinMaxVarsT *FakeQuantWithMinMaxVars::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FakeQuantWithMinMaxVarsT>(new FakeQuantWithMinMaxVarsT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void FakeQuantWithMinMaxVars::UnPackTo(FakeQuantWithMinMaxVarsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = num_bits(); _o->num_bits = _e; }
+  { auto _e = narrow_range(); _o->narrow_range = _e; }
+}
+
+inline flatbuffers::Offset<FakeQuantWithMinMaxVars> FakeQuantWithMinMaxVars::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFakeQuantWithMinMaxVars(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantWithMinMaxVarsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _num_bits = _o->num_bits;
+  auto _narrow_range = _o->narrow_range;
+  return mindspore::schema::CreateFakeQuantWithMinMaxVars(
+      _fbb,
+      _num_bits,
+      _narrow_range);
+}
+
+inline FakeQuantWithMinMaxVarsPerChannelT *FakeQuantWithMinMaxVarsPerChannel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FakeQuantWithMinMaxVarsPerChannelT>(new FakeQuantWithMinMaxVarsPerChannelT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void FakeQuantWithMinMaxVarsPerChannel::UnPackTo(FakeQuantWithMinMaxVarsPerChannelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = num_bits(); _o->num_bits = _e; }
+  { auto _e = narrow_range(); _o->narrow_range = _e; }
+}
+
+inline flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> FakeQuantWithMinMaxVarsPerChannel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsPerChannelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFakeQuantWithMinMaxVarsPerChannel(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> CreateFakeQuantWithMinMaxVarsPerChannel(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsPerChannelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantWithMinMaxVarsPerChannelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _num_bits = _o->num_bits;
+  auto _narrow_range = _o->narrow_range;
+  return mindspore::schema::CreateFakeQuantWithMinMaxVarsPerChannel(
+      _fbb,
+      _num_bits,
+      _narrow_range);
+}
+
+inline FftRealT *FftReal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FftRealT>(new FftRealT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void FftReal::UnPackTo(FftRealT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<FftReal> FftReal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FftRealT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFftReal(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<FftReal> CreateFftReal(flatbuffers::FlatBufferBuilder &_fbb, const FftRealT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FftRealT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateFftReal(
+      _fbb);
+}
+
+inline FftImagT *FftImag::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FftImagT>(new FftImagT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void FftImag::UnPackTo(FftImagT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<FftImag> FftImag::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FftImagT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFftImag(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<FftImag> CreateFftImag(flatbuffers::FlatBufferBuilder &_fbb, const FftImagT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FftImagT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateFftImag(
+      _fbb);
+}
+
+inline FlattenT *Flatten::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FlattenT>(new FlattenT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Flatten::UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); _o->axis = _e; }
+}
+
+inline flatbuffers::Offset<Flatten> Flatten::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFlatten(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis;
+  return mindspore::schema::CreateFlatten(
+      _fbb,
+      _axis);
+}
+
+inline FlattenGradT *FlattenGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FlattenGradT>(new FlattenGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void FlattenGrad::UnPackTo(FlattenGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<FlattenGrad> FlattenGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFlattenGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<FlattenGrad> CreateFlattenGrad(flatbuffers::FlatBufferBuilder &_fbb, const FlattenGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateFlattenGrad(
+      _fbb);
+}
+
+inline FloorT *Floor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FloorT>(new FloorT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Floor::UnPackTo(FloorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Floor> Floor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFloor(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Floor> CreateFloor(flatbuffers::FlatBufferBuilder &_fbb, const FloorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateFloor(
+      _fbb);
+}
+
+inline FloorDivT *FloorDiv::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FloorDivT>(new FloorDivT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void FloorDiv::UnPackTo(FloorDivT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<FloorDiv> FloorDiv::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFloorDiv(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<FloorDiv> CreateFloorDiv(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorDivT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateFloorDiv(
+      _fbb);
+}
+
+inline FloorModT *FloorMod::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FloorModT>(new FloorModT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void FloorMod::UnPackTo(FloorModT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<FloorMod> FloorMod::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFloorMod(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<FloorMod> CreateFloorMod(flatbuffers::FlatBufferBuilder &_fbb, const FloorModT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorModT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateFloorMod(
+      _fbb);
+}
+
+inline FillT *Fill::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FillT>(new FillT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Fill::UnPackTo(FillT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Fill> Fill::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFill(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Fill> CreateFill(flatbuffers::FlatBufferBuilder &_fbb, const FillT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FillT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateFill(
+      _fbb);
+}
+
+inline FullConnectionT *FullConnection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FullConnectionT>(new FullConnectionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void FullConnection::UnPackTo(FullConnectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = has_bias(); _o->has_bias = _e; }
+  { auto _e = use_axis(); _o->use_axis = _e; }
+  { auto _e = axis(); _o->axis = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<FullConnection> FullConnection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullConnectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFullConnection(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<FullConnection> CreateFullConnection(flatbuffers::FlatBufferBuilder &_fbb, const FullConnectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FullConnectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _has_bias = _o->has_bias;
+  auto _use_axis = _o->use_axis;
+  auto _axis = _o->axis;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateFullConnection(
+      _fbb,
+      _has_bias,
+      _use_axis,
+      _axis,
+      _activation_type);
+}
+
+inline FusedBatchNormT *FusedBatchNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FusedBatchNormT>(new FusedBatchNormT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void FusedBatchNorm::UnPackTo(FusedBatchNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = epsilon(); _o->epsilon = _e; }
+  { auto _e = momentum(); _o->momentum = _e; }
+  { auto _e = mode(); _o->mode = _e; }
+}
+
+inline flatbuffers::Offset<FusedBatchNorm> FusedBatchNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FusedBatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFusedBatchNorm(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const FusedBatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FusedBatchNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _epsilon = _o->epsilon;
+  auto _momentum = _o->momentum;
+  auto _mode = _o->mode;
+  return mindspore::schema::CreateFusedBatchNorm(
+      _fbb,
+      _epsilon,
+      _momentum,
+      _mode);
+}
+
+inline GatherT *Gather::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<GatherT>(new GatherT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Gather::UnPackTo(GatherT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Gather> Gather::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateGather(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Gather> CreateGather(flatbuffers::FlatBufferBuilder &_fbb, const GatherT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateGather(
+      _fbb);
+}
+
+inline GatherNdT *GatherNd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<GatherNdT>(new GatherNdT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void GatherNd::UnPackTo(GatherNdT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<GatherNd> GatherNd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateGatherNd(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<GatherNd> CreateGatherNd(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherNdT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateGatherNd(
+      _fbb);
+}
+
+inline GreaterT *Greater::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<GreaterT>(new GreaterT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Greater::UnPackTo(GreaterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Greater> Greater::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateGreater(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Greater> CreateGreater(flatbuffers::FlatBufferBuilder &_fbb, const GreaterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateGreater(
+      _fbb);
+}
+
+inline GreaterEqualT *GreaterEqual::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<GreaterEqualT>(new GreaterEqualT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void GreaterEqual::UnPackTo(GreaterEqualT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<GreaterEqual> GreaterEqual::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateGreaterEqual(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterEqualT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateGreaterEqual(
+      _fbb);
+}
+
+inline HashtableLookupT *HashtableLookup::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<HashtableLookupT>(new HashtableLookupT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void HashtableLookup::UnPackTo(HashtableLookupT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<HashtableLookup> HashtableLookup::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableLookupT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateHashtableLookup(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<HashtableLookup> CreateHashtableLookup(flatbuffers::FlatBufferBuilder &_fbb, const HashtableLookupT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableLookupT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateHashtableLookup(
+      _fbb);
+}
+
+inline InstanceNormT *InstanceNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<InstanceNormT>(new InstanceNormT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void InstanceNorm::UnPackTo(InstanceNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = epsilon(); _o->epsilon = _e; }
+}
+
+inline flatbuffers::Offset<InstanceNorm> InstanceNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateInstanceNorm(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<InstanceNorm> CreateInstanceNorm(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InstanceNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _epsilon = _o->epsilon;
+  return mindspore::schema::CreateInstanceNorm(
+      _fbb,
+      _epsilon);
+}
+
+inline LayerNormFusionT *LayerNormFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LayerNormFusionT>(new LayerNormFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LayerNormFusion::UnPackTo(LayerNormFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = begin_norm_axis(); _o->begin_norm_axis = _e; }
+  { auto _e = epsilon(); _o->epsilon = _e; }
+  { auto _e = elementwise_affine(); _o->elementwise_affine = _e; }
+  { auto _e = begin_params_axis(); _o->begin_params_axis = _e; }
+}
+
+inline flatbuffers::Offset<LayerNormFusion> LayerNormFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLayerNormFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LayerNormFusion> CreateLayerNormFusion(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LayerNormFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _begin_norm_axis = _o->begin_norm_axis;
+  auto _epsilon = _o->epsilon;
+  auto _elementwise_affine = _o->elementwise_affine;
+  auto _begin_params_axis = _o->begin_params_axis;
+  return mindspore::schema::CreateLayerNormFusion(
+      _fbb,
+      _begin_norm_axis,
+      _epsilon,
+      _elementwise_affine,
+      _begin_params_axis);
+}
+
+inline LeakyReluT *LeakyRelu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LeakyReluT>(new LeakyReluT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LeakyRelu::UnPackTo(LeakyReluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = negative_slope(); _o->negative_slope = _e; }
+}
+
+inline flatbuffers::Offset<LeakyRelu> LeakyRelu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLeakyRelu(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LeakyRelu> CreateLeakyRelu(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeakyReluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _negative_slope = _o->negative_slope;
+  return mindspore::schema::CreateLeakyRelu(
+      _fbb,
+      _negative_slope);
+}
+
+inline LessT *Less::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LessT>(new LessT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Less::UnPackTo(LessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Less> Less::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLess(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Less> CreateLess(flatbuffers::FlatBufferBuilder &_fbb, const LessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateLess(
+      _fbb);
+}
+
+inline LessEqualT *LessEqual::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LessEqualT>(new LessEqualT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LessEqual::UnPackTo(LessEqualT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<LessEqual> LessEqual::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLessEqual(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LessEqual> CreateLessEqual(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessEqualT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateLessEqual(
+      _fbb);
+}
+
+inline LogT *Log::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LogT>(new LogT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Log::UnPackTo(LogT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Log> Log::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLog(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Log> CreateLog(flatbuffers::FlatBufferBuilder &_fbb, const LogT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateLog(
+      _fbb);
+}
+
+inline LogGradT *LogGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LogGradT>(new LogGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LogGrad::UnPackTo(LogGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<LogGrad> LogGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLogGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LogGrad> CreateLogGrad(flatbuffers::FlatBufferBuilder &_fbb, const LogGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateLogGrad(
+      _fbb);
+}
+
+inline LogicalAndT *LogicalAnd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LogicalAndT>(new LogicalAndT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LogicalAnd::UnPackTo(LogicalAndT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<LogicalAnd> LogicalAnd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLogicalAnd(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalAndT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateLogicalAnd(
+      _fbb);
+}
+
+inline LogicalNotT *LogicalNot::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LogicalNotT>(new LogicalNotT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LogicalNot::UnPackTo(LogicalNotT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<LogicalNot> LogicalNot::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLogicalNot(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LogicalNot> CreateLogicalNot(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalNotT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateLogicalNot(
+      _fbb);
+}
+
+inline LogicalOrT *LogicalOr::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LogicalOrT>(new LogicalOrT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LogicalOr::UnPackTo(LogicalOrT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<LogicalOr> LogicalOr::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLogicalOr(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LogicalOr> CreateLogicalOr(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalOrT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateLogicalOr(
+      _fbb);
+}
+
+inline LpNormalizationT *LpNormalization::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LpNormalizationT>(new LpNormalizationT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LpNormalization::UnPackTo(LpNormalizationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); _o->axis = _e; }
+  { auto _e = p(); _o->p = _e; }
+}
+
+inline flatbuffers::Offset<LpNormalization> LpNormalization::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LpNormalizationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLpNormalization(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LpNormalization> CreateLpNormalization(flatbuffers::FlatBufferBuilder &_fbb, const LpNormalizationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LpNormalizationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis;
+  auto _p = _o->p;
+  return mindspore::schema::CreateLpNormalization(
+      _fbb,
+      _axis,
+      _p);
+}
+
+inline LRNT *LRN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LRNT>(new LRNT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LRN::UnPackTo(LRNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = depth_radius(); _o->depth_radius = _e; }
+  { auto _e = bias(); _o->bias = _e; }
+  { auto _e = alpha(); _o->alpha = _e; }
+  { auto _e = beta(); _o->beta = _e; }
+  { auto _e = norm_region(); if (_e) _o->norm_region = _e->str(); }
+}
+
+inline flatbuffers::Offset<LRN> LRN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLRN(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LRN> CreateLRN(flatbuffers::FlatBufferBuilder &_fbb, const LRNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LRNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _depth_radius = _o->depth_radius;
+  auto _bias = _o->bias;
+  auto _alpha = _o->alpha;
+  auto _beta = _o->beta;
+  auto _norm_region = _o->norm_region.empty() ? 0 : _fbb.CreateString(_o->norm_region);
+  return mindspore::schema::CreateLRN(
+      _fbb,
+      _depth_radius,
+      _bias,
+      _alpha,
+      _beta,
+      _norm_region);
+}
+
+inline LshProjectionT *LshProjection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LshProjectionT>(new LshProjectionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LshProjection::UnPackTo(LshProjectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = type(); _o->type = _e; }
+}
+
+inline flatbuffers::Offset<LshProjection> LshProjection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LshProjectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLshProjection(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LshProjection> CreateLshProjection(flatbuffers::FlatBufferBuilder &_fbb, const LshProjectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LshProjectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _type = _o->type;
+  return mindspore::schema::CreateLshProjection(
+      _fbb,
+      _type);
+}
+
+inline LSTMT *LSTM::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LSTMT>(new LSTMT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LSTM::UnPackTo(LSTMT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = bidirectional(); _o->bidirectional = _e; }
+  { auto _e = has_bias(); _o->has_bias = _e; }
+  { auto _e = input_size(); _o->input_size = _e; }
+  { auto _e = hidden_size(); _o->hidden_size = _e; }
+  { auto _e = num_layers(); _o->num_layers = _e; }
+  { auto _e = num_directions(); _o->num_directions = _e; }
+  { auto _e = dropout(); _o->dropout = _e; }
+  { auto _e = zoneout_cell(); _o->zoneout_cell = _e; }
+  { auto _e = zoneout_hidden(); _o->zoneout_hidden = _e; }
+}
+
+inline flatbuffers::Offset<LSTM> LSTM::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLSTM(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LSTM> CreateLSTM(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _bidirectional = _o->bidirectional;
+  auto _has_bias = _o->has_bias;
+  auto _input_size = _o->input_size;
+  auto _hidden_size = _o->hidden_size;
+  auto _num_layers = _o->num_layers;
+  auto _num_directions = _o->num_directions;
+  auto _dropout = _o->dropout;
+  auto _zoneout_cell = _o->zoneout_cell;
+  auto _zoneout_hidden = _o->zoneout_hidden;
+  return mindspore::schema::CreateLSTM(
+      _fbb,
+      _bidirectional,
+      _has_bias,
+      _input_size,
+      _hidden_size,
+      _num_layers,
+      _num_directions,
+      _dropout,
+      _zoneout_cell,
+      _zoneout_hidden);
+}
+
+inline LSTMGradT *LSTMGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LSTMGradT>(new LSTMGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LSTMGrad::UnPackTo(LSTMGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = bidirectional(); _o->bidirectional = _e; }
+  { auto _e = has_bias(); _o->has_bias = _e; }
+  { auto _e = input_size(); _o->input_size = _e; }
+  { auto _e = hidden_size(); _o->hidden_size = _e; }
+  { auto _e = num_layers(); _o->num_layers = _e; }
+  { auto _e = num_directions(); _o->num_directions = _e; }
+  { auto _e = dropout(); _o->dropout = _e; }
+  { auto _e = zoneout_cell(); _o->zoneout_cell = _e; }
+  { auto _e = zoneout_hidden(); _o->zoneout_hidden = _e; }
+}
+
+inline flatbuffers::Offset<LSTMGrad> LSTMGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLSTMGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LSTMGrad> CreateLSTMGrad(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _bidirectional = _o->bidirectional;
+  auto _has_bias = _o->has_bias;
+  auto _input_size = _o->input_size;
+  auto _hidden_size = _o->hidden_size;
+  auto _num_layers = _o->num_layers;
+  auto _num_directions = _o->num_directions;
+  auto _dropout = _o->dropout;
+  auto _zoneout_cell = _o->zoneout_cell;
+  auto _zoneout_hidden = _o->zoneout_hidden;
+  return mindspore::schema::CreateLSTMGrad(
+      _fbb,
+      _bidirectional,
+      _has_bias,
+      _input_size,
+      _hidden_size,
+      _num_layers,
+      _num_directions,
+      _dropout,
+      _zoneout_cell,
+      _zoneout_hidden);
+}
+
+inline L2NormalizeFusionT *L2NormalizeFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<L2NormalizeFusionT>(new L2NormalizeFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void L2NormalizeFusion::UnPackTo(L2NormalizeFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
+  { auto _e = epsilon(); _o->epsilon = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<L2NormalizeFusion> L2NormalizeFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormalizeFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateL2NormalizeFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<L2NormalizeFusion> CreateL2NormalizeFusion(flatbuffers::FlatBufferBuilder &_fbb, const L2NormalizeFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const L2NormalizeFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
+  auto _epsilon = _o->epsilon;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateL2NormalizeFusion(
+      _fbb,
+      _axis,
+      _epsilon,
+      _activation_type);
+}
+
+inline MatMulFusionT *MatMulFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<MatMulFusionT>(new MatMulFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void MatMulFusion::UnPackTo(MatMulFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = transpose_a(); _o->transpose_a = _e; }
+  { auto _e = transpose_b(); _o->transpose_b = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<MatMulFusion> MatMulFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatMulFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateMatMulFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<MatMulFusion> CreateMatMulFusion(flatbuffers::FlatBufferBuilder &_fbb, const MatMulFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatMulFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _transpose_a = _o->transpose_a;
+  auto _transpose_b = _o->transpose_b;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateMatMulFusion(
+      _fbb,
+      _transpose_a,
+      _transpose_b,
+      _activation_type);
+}
+
+inline MaximumT *Maximum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<MaximumT>(new MaximumT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Maximum::UnPackTo(MaximumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Maximum> Maximum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateMaximum(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Maximum> CreateMaximum(flatbuffers::FlatBufferBuilder &_fbb, const MaximumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaximumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateMaximum(
+      _fbb);
+}
+
+inline MaximumGradT *MaximumGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<MaximumGradT>(new MaximumGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void MaximumGrad::UnPackTo(MaximumGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = grad_x(); _o->grad_x = _e; }
+  { auto _e = grad_y(); _o->grad_y = _e; }
+}
+
+inline flatbuffers::Offset<MaximumGrad> MaximumGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateMaximumGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<MaximumGrad> CreateMaximumGrad(flatbuffers::FlatBufferBuilder &_fbb, const MaximumGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaximumGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _grad_x = _o->grad_x;
+  auto _grad_y = _o->grad_y;
+  return mindspore::schema::CreateMaximumGrad(
+      _fbb,
+      _grad_x,
+      _grad_y);
+}
+
+inline MaxPoolFusionT *MaxPoolFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<MaxPoolFusionT>(new MaxPoolFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void MaxPoolFusion::UnPackTo(MaxPoolFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
+  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } }
+  { auto _e = pad(); if (_e) { _o->pad.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad[_i] = _e->Get(_i); } } }
+  { auto _e = pad_mode(); _o->pad_mode = _e; }
+  { auto _e = round_mode(); _o->round_mode = _e; }
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = global(); _o->global = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<MaxPoolFusion> MaxPoolFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateMaxPoolFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<MaxPoolFusion> CreateMaxPoolFusion(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaxPoolFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
+  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
+  auto _pad = _o->pad.size() ? _fbb.CreateVector(_o->pad) : 0;
+  auto _pad_mode = _o->pad_mode;
+  auto _round_mode = _o->round_mode;
+  auto _format = _o->format;
+  auto _global = _o->global;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateMaxPoolFusion(
+      _fbb,
+      _kernel_size,
+      _strides,
+      _pad,
+      _pad_mode,
+      _round_mode,
+      _format,
+      _global,
+      _activation_type);
+}
+
+inline MaxPoolGradT *MaxPoolGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<MaxPoolGradT>(new MaxPoolGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void MaxPoolGrad::UnPackTo(MaxPoolGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
+  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } }
+  { auto _e = pad_mode(); _o->pad_mode = _e; }
+  { auto _e = format(); _o->format = _e; }
+}
+
+inline flatbuffers::Offset<MaxPoolGrad> MaxPoolGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateMaxPoolGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<MaxPoolGrad> CreateMaxPoolGrad(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaxPoolGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
+  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
+  auto _pad_mode = _o->pad_mode;
+  auto _format = _o->format;
+  return mindspore::schema::CreateMaxPoolGrad(
+      _fbb,
+      _kernel_size,
+      _strides,
+      _pad_mode,
+      _format);
+}
+
+inline SwitchLayerT *SwitchLayer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SwitchLayerT>(new SwitchLayerT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SwitchLayer::UnPackTo(SwitchLayerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<SwitchLayer> SwitchLayer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwitchLayerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSwitchLayer(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SwitchLayer> CreateSwitchLayer(flatbuffers::FlatBufferBuilder &_fbb, const SwitchLayerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SwitchLayerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSwitchLayer(
+      _fbb);
+}
+
+inline MfccT *Mfcc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<MfccT>(new MfccT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Mfcc::UnPackTo(MfccT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = freq_upper_limit(); _o->freq_upper_limit = _e; }
+  { auto _e = freq_lower_limit(); _o->freq_lower_limit = _e; }
+  { auto _e = filter_bank_channel_num(); _o->filter_bank_channel_num = _e; }
+  { auto _e = dct_coeff_num(); _o->dct_coeff_num = _e; }
+}
+
+inline flatbuffers::Offset<Mfcc> Mfcc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MfccT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateMfcc(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Mfcc> CreateMfcc(flatbuffers::FlatBufferBuilder &_fbb, const MfccT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MfccT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _freq_upper_limit = _o->freq_upper_limit;
+  auto _freq_lower_limit = _o->freq_lower_limit;
+  auto _filter_bank_channel_num = _o->filter_bank_channel_num;
+  auto _dct_coeff_num = _o->dct_coeff_num;
+  return mindspore::schema::CreateMfcc(
+      _fbb,
+      _freq_upper_limit,
+      _freq_lower_limit,
+      _filter_bank_channel_num,
+      _dct_coeff_num);
+}
+
+inline MinimumT *Minimum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<MinimumT>(new MinimumT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Minimum::UnPackTo(MinimumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Minimum> Minimum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinimumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateMinimum(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Minimum> CreateMinimum(flatbuffers::FlatBufferBuilder &_fbb, const MinimumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MinimumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateMinimum(
+      _fbb);
+}
+
+inline MinimumGradT *MinimumGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<MinimumGradT>(new MinimumGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void MinimumGrad::UnPackTo(MinimumGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = grad_x(); _o->grad_x = _e; }
+  { auto _e = grad_y(); _o->grad_y = _e; }
+}
+
+inline flatbuffers::Offset<MinimumGrad> MinimumGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinimumGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateMinimumGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<MinimumGrad> CreateMinimumGrad(flatbuffers::FlatBufferBuilder &_fbb, const MinimumGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MinimumGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _grad_x = _o->grad_x;
+  auto _grad_y = _o->grad_y;
+  return mindspore::schema::CreateMinimumGrad(
+      _fbb,
+      _grad_x,
+      _grad_y);
+}
+
+inline ModT *Mod::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ModT>(new ModT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Mod::UnPackTo(ModT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Mod> Mod::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateMod(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Mod> CreateMod(flatbuffers::FlatBufferBuilder &_fbb, const ModT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateMod(
+      _fbb);
+}
+
+inline MulFusionT *MulFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<MulFusionT>(new MulFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void MulFusion::UnPackTo(MulFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<MulFusion> MulFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateMulFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<MulFusion> CreateMulFusion(flatbuffers::FlatBufferBuilder &_fbb, const MulFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateMulFusion(
+      _fbb,
+      _activation_type);
+}
+
+inline MulGradT *MulGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<MulGradT>(new MulGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void MulGrad::UnPackTo(MulGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<MulGrad> MulGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateMulGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<MulGrad> CreateMulGrad(flatbuffers::FlatBufferBuilder &_fbb, const MulGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateMulGrad(
+      _fbb);
+}
+
+inline NegT *Neg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<NegT>(new NegT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Neg::UnPackTo(NegT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Neg> Neg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateNeg(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Neg> CreateNeg(flatbuffers::FlatBufferBuilder &_fbb, const NegT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NegT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateNeg(
+      _fbb);
+}
+
+inline NegGradT *NegGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<NegGradT>(new NegGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void NegGrad::UnPackTo(NegGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<NegGrad> NegGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateNegGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<NegGrad> CreateNegGrad(flatbuffers::FlatBufferBuilder &_fbb, const NegGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NegGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateNegGrad(
+      _fbb);
+}
+
+inline NotEqualT *NotEqual::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<NotEqualT>(new NotEqualT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void NotEqual::UnPackTo(NotEqualT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<NotEqual> NotEqual::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateNotEqual(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<NotEqual> CreateNotEqual(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NotEqualT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateNotEqual(
+      _fbb);
+}
+
+inline NonMaxSuppressionT *NonMaxSuppression::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<NonMaxSuppressionT>(new NonMaxSuppressionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void NonMaxSuppression::UnPackTo(NonMaxSuppressionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = center_point_box(); _o->center_point_box = _e; }
+}
+
+inline flatbuffers::Offset<NonMaxSuppression> NonMaxSuppression::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateNonMaxSuppression(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<NonMaxSuppression> CreateNonMaxSuppression(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _center_point_box = _o->center_point_box;
+  return mindspore::schema::CreateNonMaxSuppression(
+      _fbb,
+      _center_point_box);
+}
+
+inline OneHotT *OneHot::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<OneHotT>(new OneHotT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void OneHot::UnPackTo(OneHotT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); _o->axis = _e; }
+}
+
+inline flatbuffers::Offset<OneHot> OneHot::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateOneHot(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<OneHot> CreateOneHot(flatbuffers::FlatBufferBuilder &_fbb, const OneHotT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OneHotT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis;
+  return mindspore::schema::CreateOneHot(
+      _fbb,
+      _axis);
+}
+
+inline OnesLikeT *OnesLike::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<OnesLikeT>(new OnesLikeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void OnesLike::UnPackTo(OnesLikeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<OnesLike> OnesLike::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OnesLikeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateOnesLike(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<OnesLike> CreateOnesLike(flatbuffers::FlatBufferBuilder &_fbb, const OnesLikeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OnesLikeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateOnesLike(
+      _fbb);
+}
+
+inline PadFusionT *PadFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<PadFusionT>(new PadFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void PadFusion::UnPackTo(PadFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = paddings(); if (_e) _o->paddings = std::unique_ptr<mindspore::schema::Vec2DT>(_e->UnPack(_resolver)); }
+  { auto _e = padding_mode(); _o->padding_mode = _e; }
+  { auto _e = constant_value(); _o->constant_value = _e; }
+}
+
+inline flatbuffers::Offset<PadFusion> PadFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreatePadFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<PadFusion> CreatePadFusion(flatbuffers::FlatBufferBuilder &_fbb, const PadFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PadFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _paddings = _o->paddings ? CreateVec2D(_fbb, _o->paddings.get(), _rehasher) : 0;
+  auto _padding_mode = _o->padding_mode;
+  auto _constant_value = _o->constant_value;
+  return mindspore::schema::CreatePadFusion(
+      _fbb,
+      _paddings,
+      _padding_mode,
+      _constant_value);
+}
+
+inline PartialFusionT *PartialFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<PartialFusionT>(new PartialFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void PartialFusion::UnPackTo(PartialFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = sub_graph_index(); _o->sub_graph_index = _e; }
+}
+
+inline flatbuffers::Offset<PartialFusion> PartialFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartialFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreatePartialFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<PartialFusion> CreatePartialFusion(flatbuffers::FlatBufferBuilder &_fbb, const PartialFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartialFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _sub_graph_index = _o->sub_graph_index;
+  return mindspore::schema::CreatePartialFusion(
+      _fbb,
+      _sub_graph_index);
+}
+
+inline PowerGradT *PowerGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<PowerGradT>(new PowerGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void PowerGrad::UnPackTo(PowerGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = power(); _o->power = _e; }
+  { auto _e = scale(); _o->scale = _e; }
+  { auto _e = shift(); _o->shift = _e; }
+}
+
+inline flatbuffers::Offset<PowerGrad> PowerGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowerGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreatePowerGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<PowerGrad> CreatePowerGrad(flatbuffers::FlatBufferBuilder &_fbb, const PowerGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PowerGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _power = _o->power;
+  auto _scale = _o->scale;
+  auto _shift = _o->shift;
+  return mindspore::schema::CreatePowerGrad(
+      _fbb,
+      _power,
+      _scale,
+      _shift);
+}
+
+inline PowFusionT *PowFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<PowFusionT>(new PowFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void PowFusion::UnPackTo(PowFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = scale(); _o->scale = _e; }
+  { auto _e = shift(); _o->shift = _e; }
+}
+
+inline flatbuffers::Offset<PowFusion> PowFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreatePowFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<PowFusion> CreatePowFusion(flatbuffers::FlatBufferBuilder &_fbb, const PowFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PowFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _scale = _o->scale;
+  auto _shift = _o->shift;
+  return mindspore::schema::CreatePowFusion(
+      _fbb,
+      _scale,
+      _shift);
+}
+
+inline PriorBoxT *PriorBox::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<PriorBoxT>(new PriorBoxT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void PriorBox::UnPackTo(PriorBoxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = min_sizes(); if (_e) { _o->min_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->min_sizes[_i] = _e->Get(_i); } } }
+  { auto _e = max_sizes(); if (_e) { _o->max_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->max_sizes[_i] = _e->Get(_i); } } }
+  { auto _e = aspect_ratios(); if (_e) { _o->aspect_ratios.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aspect_ratios[_i] = _e->Get(_i); } } }
+  { auto _e = variances(); if (_e) { _o->variances.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->variances[_i] = _e->Get(_i); } } }
+  { auto _e = image_size_w(); _o->image_size_w = _e; }
+  { auto _e = image_size_h(); _o->image_size_h = _e; }
+  { auto _e = step_w(); _o->step_w = _e; }
+  { auto _e = step_h(); _o->step_h = _e; }
+  { auto _e = clip(); _o->clip = _e; }
+  { auto _e = flip(); _o->flip = _e; }
+  { auto _e = offset(); _o->offset = _e; }
+}
+
+inline flatbuffers::Offset<PriorBox> PriorBox::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreatePriorBox(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<PriorBox> CreatePriorBox(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PriorBoxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _min_sizes = _o->min_sizes.size() ? _fbb.CreateVector(_o->min_sizes) : 0;
+  auto _max_sizes = _o->max_sizes.size() ? _fbb.CreateVector(_o->max_sizes) : 0;
+  auto _aspect_ratios = _o->aspect_ratios.size() ? _fbb.CreateVector(_o->aspect_ratios) : 0;
+  auto _variances = _o->variances.size() ? _fbb.CreateVector(_o->variances) : 0;
+  auto _image_size_w = _o->image_size_w;
+  auto _image_size_h = _o->image_size_h;
+  auto _step_w = _o->step_w;
+  auto _step_h = _o->step_h;
+  auto _clip = _o->clip;
+  auto _flip = _o->flip;
+  auto _offset = _o->offset;
+  return mindspore::schema::CreatePriorBox(
+      _fbb,
+      _min_sizes,
+      _max_sizes,
+      _aspect_ratios,
+      _variances,
+      _image_size_w,
+      _image_size_h,
+      _step_w,
+      _step_h,
+      _clip,
+      _flip,
+      _offset);
+}
+
+inline PReLUFusionT *PReLUFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<PReLUFusionT>(new PReLUFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void PReLUFusion::UnPackTo(PReLUFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = channel_shared(); _o->channel_shared = _e; }
+}
+
+inline flatbuffers::Offset<PReLUFusion> PReLUFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReLUFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreatePReLUFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<PReLUFusion> CreatePReLUFusion(flatbuffers::FlatBufferBuilder &_fbb, const PReLUFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PReLUFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _channel_shared = _o->channel_shared;
+  return mindspore::schema::CreatePReLUFusion(
+      _fbb,
+      _channel_shared);
+}
+
+inline RankT *Rank::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<RankT>(new RankT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Rank::UnPackTo(RankT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Rank> Rank::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateRank(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Rank> CreateRank(flatbuffers::FlatBufferBuilder &_fbb, const RankT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RankT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateRank(
+      _fbb);
+}
+
+inline RangeT *Range::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<RangeT>(new RangeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Range::UnPackTo(RangeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = d_type(); _o->d_type = _e; }
+  { auto _e = start(); _o->start = _e; }
+  { auto _e = limit(); _o->limit = _e; }
+  { auto _e = delta(); _o->delta = _e; }
+}
+
+inline flatbuffers::Offset<Range> Range::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateRange(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Range> CreateRange(flatbuffers::FlatBufferBuilder &_fbb, const RangeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RangeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _d_type = _o->d_type;
+  auto _start = _o->start;
+  auto _limit = _o->limit;
+  auto _delta = _o->delta;
+  return mindspore::schema::CreateRange(
+      _fbb,
+      _d_type,
+      _start,
+      _limit,
+      _delta);
+}
+
+inline ReciprocalT *Reciprocal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ReciprocalT>(new ReciprocalT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Reciprocal::UnPackTo(ReciprocalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Reciprocal> Reciprocal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReciprocalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateReciprocal(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Reciprocal> CreateReciprocal(flatbuffers::FlatBufferBuilder &_fbb, const ReciprocalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReciprocalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateReciprocal(
+      _fbb);
+}
+
+inline RealDivT *RealDiv::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<RealDivT>(new RealDivT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void RealDiv::UnPackTo(RealDivT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<RealDiv> RealDiv::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RealDivT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateRealDiv(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<RealDiv> CreateRealDiv(flatbuffers::FlatBufferBuilder &_fbb, const RealDivT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RealDivT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateRealDiv(
+      _fbb);
+}
+
+inline ReduceFusionT *ReduceFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ReduceFusionT>(new ReduceFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ReduceFusion::UnPackTo(ReduceFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = keep_dims(); _o->keep_dims = _e; }
+  { auto _e = mode(); _o->mode = _e; }
+  { auto _e = reduce_to_end(); _o->reduce_to_end = _e; }
+  { auto _e = coeff(); _o->coeff = _e; }
+}
+
+inline flatbuffers::Offset<ReduceFusion> ReduceFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateReduceFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ReduceFusion> CreateReduceFusion(flatbuffers::FlatBufferBuilder &_fbb, const ReduceFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _keep_dims = _o->keep_dims;
+  auto _mode = _o->mode;
+  auto _reduce_to_end = _o->reduce_to_end;
+  auto _coeff = _o->coeff;
+  return mindspore::schema::CreateReduceFusion(
+      _fbb,
+      _keep_dims,
+      _mode,
+      _reduce_to_end,
+      _coeff);
+}
+
+inline ReshapeT *Reshape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ReshapeT>(new ReshapeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Reshape::UnPackTo(ReshapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Reshape> Reshape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateReshape(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Reshape> CreateReshape(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateReshape(
+      _fbb);
+}
+
+inline ResizeT *Resize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ResizeT>(new ResizeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Resize::UnPackTo(ResizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = method(); _o->method = _e; }
+  { auto _e = new_height(); _o->new_height = _e; }
+  { auto _e = new_width(); _o->new_width = _e; }
+  { auto _e = preserve_aspect_ratio(); _o->preserve_aspect_ratio = _e; }
+  { auto _e = coordinate_transform_mode(); _o->coordinate_transform_mode = _e; }
+  { auto _e = cubic_coeff(); _o->cubic_coeff = _e; }
+  { auto _e = exclude_outside(); _o->exclude_outside = _e; }
+  { auto _e = extrapolation_value(); _o->extrapolation_value = _e; }
+  { auto _e = nearest_mode(); _o->nearest_mode = _e; }
+}
+
+inline flatbuffers::Offset<Resize> Resize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateResize(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Resize> CreateResize(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _format = _o->format;
+  auto _method = _o->method;
+  auto _new_height = _o->new_height;
+  auto _new_width = _o->new_width;
+  auto _preserve_aspect_ratio = _o->preserve_aspect_ratio;
+  auto _coordinate_transform_mode = _o->coordinate_transform_mode;
+  auto _cubic_coeff = _o->cubic_coeff;
+  auto _exclude_outside = _o->exclude_outside;
+  auto _extrapolation_value = _o->extrapolation_value;
+  auto _nearest_mode = _o->nearest_mode;
+  return mindspore::schema::CreateResize(
+      _fbb,
+      _format,
+      _method,
+      _new_height,
+      _new_width,
+      _preserve_aspect_ratio,
+      _coordinate_transform_mode,
+      _cubic_coeff,
+      _exclude_outside,
+      _extrapolation_value,
+      _nearest_mode);
+}
+
+inline ReverseSequenceT *ReverseSequence::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ReverseSequenceT>(new ReverseSequenceT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ReverseSequence::UnPackTo(ReverseSequenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = seq_dim(); _o->seq_dim = _e; }
+  { auto _e = batch_dim(); _o->batch_dim = _e; }
+}
+
+inline flatbuffers::Offset<ReverseSequence> ReverseSequence::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateReverseSequence(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ReverseSequence> CreateReverseSequence(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseSequenceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _seq_dim = _o->seq_dim;
+  auto _batch_dim = _o->batch_dim;
+  return mindspore::schema::CreateReverseSequence(
+      _fbb,
+      _seq_dim,
+      _batch_dim);
+}
+
+inline ReverseV2T *ReverseV2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ReverseV2T>(new ReverseV2T());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ReverseV2::UnPackTo(ReverseV2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<ReverseV2> ReverseV2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateReverseV2(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ReverseV2> CreateReverseV2(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseV2T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
+  return mindspore::schema::CreateReverseV2(
+      _fbb,
+      _axis);
+}
+
+inline RfftT *Rfft::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<RfftT>(new RfftT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Rfft::UnPackTo(RfftT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = fft_length(); _o->fft_length = _e; }
+}
+
+inline flatbuffers::Offset<Rfft> Rfft::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RfftT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateRfft(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Rfft> CreateRfft(flatbuffers::FlatBufferBuilder &_fbb, const RfftT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RfftT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _fft_length = _o->fft_length;
+  return mindspore::schema::CreateRfft(
+      _fbb,
+      _fft_length);
+}
+
+inline ROIPoolingT *ROIPooling::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ROIPoolingT>(new ROIPoolingT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ROIPooling::UnPackTo(ROIPoolingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = pooled_h(); _o->pooled_h = _e; }
+  { auto _e = pooled_w(); _o->pooled_w = _e; }
+  { auto _e = scale(); _o->scale = _e; }
+}
+
+inline flatbuffers::Offset<ROIPooling> ROIPooling::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateROIPooling(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ROIPooling> CreateROIPooling(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ROIPoolingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _pooled_h = _o->pooled_h;
+  auto _pooled_w = _o->pooled_w;
+  auto _scale = _o->scale;
+  return mindspore::schema::CreateROIPooling(
+      _fbb,
+      _pooled_h,
+      _pooled_w,
+      _scale);
+}
+
+inline RoundT *Round::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<RoundT>(new RoundT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Round::UnPackTo(RoundT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Round> Round::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoundT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateRound(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Round> CreateRound(flatbuffers::FlatBufferBuilder &_fbb, const RoundT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoundT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateRound(
+      _fbb);
+}
+
+inline RsqrtT *Rsqrt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<RsqrtT>(new RsqrtT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Rsqrt::UnPackTo(RsqrtT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Rsqrt> Rsqrt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateRsqrt(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Rsqrt> CreateRsqrt(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RsqrtT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateRsqrt(
+      _fbb);
+}
+
+inline QuantDTypeCastT *QuantDTypeCast::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<QuantDTypeCastT>(new QuantDTypeCastT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void QuantDTypeCast::UnPackTo(QuantDTypeCastT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = src_t(); _o->src_t = _e; }
+  { auto _e = dst_t(); _o->dst_t = _e; }
+}
+
+inline flatbuffers::Offset<QuantDTypeCast> QuantDTypeCast::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantDTypeCastT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateQuantDTypeCast(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(flatbuffers::FlatBufferBuilder &_fbb, const QuantDTypeCastT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantDTypeCastT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _src_t = _o->src_t;
+  auto _dst_t = _o->dst_t;
+  return mindspore::schema::CreateQuantDTypeCast(
+      _fbb,
+      _src_t,
+      _dst_t);
+}
+
+inline ScaleFusionT *ScaleFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ScaleFusionT>(new ScaleFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ScaleFusion::UnPackTo(ScaleFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); _o->axis = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<ScaleFusion> ScaleFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateScaleFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ScaleFusion> CreateScaleFusion(flatbuffers::FlatBufferBuilder &_fbb, const ScaleFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScaleFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateScaleFusion(
+      _fbb,
+      _axis,
+      _activation_type);
+}
+
+inline ScatterNdT *ScatterNd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ScatterNdT>(new ScatterNdT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ScatterNd::UnPackTo(ScatterNdT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<ScatterNd> ScatterNd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateScatterNd(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ScatterNd> CreateScatterNd(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScatterNdT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateScatterNd(
+      _fbb);
+}
+
+inline SGDT *SGD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SGDT>(new SGDT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SGD::UnPackTo(SGDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = nesterov(); _o->nesterov = _e; }
+  { auto _e = dampening(); _o->dampening = _e; }
+  { auto _e = weight_decay(); _o->weight_decay = _e; }
+}
+
+inline flatbuffers::Offset<SGD> SGD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SGDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSGD(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SGD> CreateSGD(flatbuffers::FlatBufferBuilder &_fbb, const SGDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SGDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _nesterov = _o->nesterov;
+  auto _dampening = _o->dampening;
+  auto _weight_decay = _o->weight_decay;
+  return mindspore::schema::CreateSGD(
+      _fbb,
+      _nesterov,
+      _dampening,
+      _weight_decay);
+}
+
+inline ShapeT *Shape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ShapeT>(new ShapeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Shape::UnPackTo(ShapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Shape> Shape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateShape(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Shape> CreateShape(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateShape(
+      _fbb);
+}
+
+inline SigmoidCrossEntropyWithLogitsT *SigmoidCrossEntropyWithLogits::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SigmoidCrossEntropyWithLogitsT>(new SigmoidCrossEntropyWithLogitsT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SigmoidCrossEntropyWithLogits::UnPackTo(SigmoidCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<SigmoidCrossEntropyWithLogits> SigmoidCrossEntropyWithLogits::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSigmoidCrossEntropyWithLogits(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SigmoidCrossEntropyWithLogits> CreateSigmoidCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SigmoidCrossEntropyWithLogitsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSigmoidCrossEntropyWithLogits(
+      _fbb);
+}
+
+inline SigmoidCrossEntropyWithLogitsGradT *SigmoidCrossEntropyWithLogitsGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SigmoidCrossEntropyWithLogitsGradT>(new SigmoidCrossEntropyWithLogitsGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SigmoidCrossEntropyWithLogitsGrad::UnPackTo(SigmoidCrossEntropyWithLogitsGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> SigmoidCrossEntropyWithLogitsGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSigmoidCrossEntropyWithLogitsGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> CreateSigmoidCrossEntropyWithLogitsGrad(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SigmoidCrossEntropyWithLogitsGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSigmoidCrossEntropyWithLogitsGrad(
+      _fbb);
+}
+
+inline SinT *Sin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SinT>(new SinT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Sin::UnPackTo(SinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Sin> Sin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSin(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Sin> CreateSin(flatbuffers::FlatBufferBuilder &_fbb, const SinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SinT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSin(
+      _fbb);
+}
+
+inline SkipGramT *SkipGram::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SkipGramT>(new SkipGramT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SkipGram::UnPackTo(SkipGramT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = include_all_grams(); _o->include_all_grams = _e; }
+  { auto _e = max_skip_size(); _o->max_skip_size = _e; }
+  { auto _e = ngram_size(); _o->ngram_size = _e; }
+}
+
+inline flatbuffers::Offset<SkipGram> SkipGram::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSkipGram(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SkipGram> CreateSkipGram(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SkipGramT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _include_all_grams = _o->include_all_grams;
+  auto _max_skip_size = _o->max_skip_size;
+  auto _ngram_size = _o->ngram_size;
+  return mindspore::schema::CreateSkipGram(
+      _fbb,
+      _include_all_grams,
+      _max_skip_size,
+      _ngram_size);
+}
+
+inline SliceFusionT *SliceFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SliceFusionT>(new SliceFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SliceFusion::UnPackTo(SliceFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axes(); if (_e) { _o->axes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axes[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<SliceFusion> SliceFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSliceFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SliceFusion> CreateSliceFusion(flatbuffers::FlatBufferBuilder &_fbb, const SliceFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axes = _o->axes.size() ? _fbb.CreateVector(_o->axes) : 0;
+  return mindspore::schema::CreateSliceFusion(
+      _fbb,
+      _axes);
+}
+
+inline SmoothL1LossT *SmoothL1Loss::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SmoothL1LossT>(new SmoothL1LossT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SmoothL1Loss::UnPackTo(SmoothL1LossT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = beta(); _o->beta = _e; }
+}
+
+inline flatbuffers::Offset<SmoothL1Loss> SmoothL1Loss::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSmoothL1Loss(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SmoothL1Loss> CreateSmoothL1Loss(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SmoothL1LossT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _beta = _o->beta;
+  return mindspore::schema::CreateSmoothL1Loss(
+      _fbb,
+      _beta);
+}
+
+inline SmoothL1LossGradT *SmoothL1LossGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SmoothL1LossGradT>(new SmoothL1LossGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SmoothL1LossGrad::UnPackTo(SmoothL1LossGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = beta(); _o->beta = _e; }
+}
+
+inline flatbuffers::Offset<SmoothL1LossGrad> SmoothL1LossGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSmoothL1LossGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SmoothL1LossGrad> CreateSmoothL1LossGrad(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SmoothL1LossGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _beta = _o->beta;
+  return mindspore::schema::CreateSmoothL1LossGrad(
+      _fbb,
+      _beta);
+}
+
+inline SoftmaxT *Softmax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SoftmaxT>(new SoftmaxT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Softmax::UnPackTo(SoftmaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<Softmax> Softmax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSoftmax(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Softmax> CreateSoftmax(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
+  return mindspore::schema::CreateSoftmax(
+      _fbb,
+      _axis);
+}
+
+inline SoftmaxCrossEntropyWithLogitsT *SoftmaxCrossEntropyWithLogits::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SoftmaxCrossEntropyWithLogitsT>(new SoftmaxCrossEntropyWithLogitsT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SoftmaxCrossEntropyWithLogits::UnPackTo(SoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> SoftmaxCrossEntropyWithLogits::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSoftmaxCrossEntropyWithLogits(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> CreateSoftmaxCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxCrossEntropyWithLogitsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSoftmaxCrossEntropyWithLogits(
+      _fbb);
+}
+
+inline SpaceToBatchT *SpaceToBatch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SpaceToBatchT>(new SpaceToBatchT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SpaceToBatch::UnPackTo(SpaceToBatchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = block_size(); if (_e) { _o->block_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_size[_i] = _e->Get(_i); } } }
+  { auto _e = paddings(); if (_e) _o->paddings = std::unique_ptr<mindspore::schema::Vec2DT>(_e->UnPack(_resolver)); }
+}
+
+inline flatbuffers::Offset<SpaceToBatch> SpaceToBatch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSpaceToBatch(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToBatchT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _block_size = _o->block_size.size() ? _fbb.CreateVector(_o->block_size) : 0;
+  auto _paddings = _o->paddings ? CreateVec2D(_fbb, _o->paddings.get(), _rehasher) : 0;
+  return mindspore::schema::CreateSpaceToBatch(
+      _fbb,
+      _block_size,
+      _paddings);
+}
+
+inline SpaceToBatchNDT *SpaceToBatchND::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SpaceToBatchNDT>(new SpaceToBatchNDT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SpaceToBatchND::UnPackTo(SpaceToBatchNDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = block_shape(); if (_e) { _o->block_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_shape[_i] = _e->Get(_i); } } }
+  { auto _e = paddings(); if (_e) _o->paddings = std::unique_ptr<mindspore::schema::Vec2DT>(_e->UnPack(_resolver)); }
+}
+
+inline flatbuffers::Offset<SpaceToBatchND> SpaceToBatchND::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSpaceToBatchND(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToBatchNDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _block_shape = _o->block_shape.size() ? _fbb.CreateVector(_o->block_shape) : 0;
+  auto _paddings = _o->paddings ? CreateVec2D(_fbb, _o->paddings.get(), _rehasher) : 0;
+  return mindspore::schema::CreateSpaceToBatchND(
+      _fbb,
+      _block_shape,
+      _paddings);
+}
+
+inline SpaceToDepthT *SpaceToDepth::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SpaceToDepthT>(new SpaceToDepthT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SpaceToDepth::UnPackTo(SpaceToDepthT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = block_size(); _o->block_size = _e; }
+  { auto _e = format(); _o->format = _e; }
+}
+
+inline flatbuffers::Offset<SpaceToDepth> SpaceToDepth::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSpaceToDepth(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToDepthT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _block_size = _o->block_size;
+  auto _format = _o->format;
+  return mindspore::schema::CreateSpaceToDepth(
+      _fbb,
+      _block_size,
+      _format);
+}
+
+inline SparseSoftmaxCrossEntropyWithLogitsT *SparseSoftmaxCrossEntropyWithLogits::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SparseSoftmaxCrossEntropyWithLogitsT>(new SparseSoftmaxCrossEntropyWithLogitsT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SparseSoftmaxCrossEntropyWithLogits::UnPackTo(SparseSoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = is_grad(); _o->is_grad = _e; }
+}
+
+inline flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> SparseSoftmaxCrossEntropyWithLogits::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseSoftmaxCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSparseSoftmaxCrossEntropyWithLogits(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> CreateSparseSoftmaxCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SparseSoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparseSoftmaxCrossEntropyWithLogitsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _is_grad = _o->is_grad;
+  return mindspore::schema::CreateSparseSoftmaxCrossEntropyWithLogits(
+      _fbb,
+      _is_grad);
+}
+
+inline SparseToDenseT *SparseToDense::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SparseToDenseT>(new SparseToDenseT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SparseToDense::UnPackTo(SparseToDenseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<SparseToDense> SparseToDense::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSparseToDense(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SparseToDense> CreateSparseToDense(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparseToDenseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSparseToDense(
+      _fbb);
+}
+
+inline SplitT *Split::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SplitT>(new SplitT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Split::UnPackTo(SplitT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = output_num(); _o->output_num = _e; }
+  { auto _e = size_splits(); if (_e) { _o->size_splits.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->size_splits[_i] = _e->Get(_i); } } }
+  { auto _e = axis(); _o->axis = _e; }
+}
+
+inline flatbuffers::Offset<Split> Split::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSplit(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Split> CreateSplit(flatbuffers::FlatBufferBuilder &_fbb, const SplitT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _output_num = _o->output_num;
+  auto _size_splits = _o->size_splits.size() ? _fbb.CreateVector(_o->size_splits) : 0;
+  auto _axis = _o->axis;
+  return mindspore::schema::CreateSplit(
+      _fbb,
+      _output_num,
+      _size_splits,
+      _axis);
+}
+
+inline SqrtT *Sqrt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SqrtT>(new SqrtT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Sqrt::UnPackTo(SqrtT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Sqrt> Sqrt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSqrt(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Sqrt> CreateSqrt(flatbuffers::FlatBufferBuilder &_fbb, const SqrtT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqrtT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSqrt(
+      _fbb);
+}
+
+inline SqueezeT *Squeeze::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SqueezeT>(new SqueezeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Squeeze::UnPackTo(SqueezeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<Squeeze> Squeeze::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSqueeze(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Squeeze> CreateSqueeze(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqueezeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
+  return mindspore::schema::CreateSqueeze(
+      _fbb,
+      _axis);
+}
+
+inline SquareT *Square::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SquareT>(new SquareT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Square::UnPackTo(SquareT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Square> Square::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSquare(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Square> CreateSquare(flatbuffers::FlatBufferBuilder &_fbb, const SquareT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquareT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSquare(
+      _fbb);
+}
+
+inline SquaredDifferenceT *SquaredDifference::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SquaredDifferenceT>(new SquaredDifferenceT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SquaredDifference::UnPackTo(SquaredDifferenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<SquaredDifference> SquaredDifference::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSquaredDifference(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquaredDifferenceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSquaredDifference(
+      _fbb);
+}
+
+inline StackT *Stack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<StackT>(new StackT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Stack::UnPackTo(StackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); _o->axis = _e; }
+}
+
+inline flatbuffers::Offset<Stack> Stack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateStack(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Stack> CreateStack(flatbuffers::FlatBufferBuilder &_fbb, const StackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StackT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis;
+  return mindspore::schema::CreateStack(
+      _fbb,
+      _axis);
+}
+
+inline StridedSliceT *StridedSlice::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<StridedSliceT>(new StridedSliceT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void StridedSlice::UnPackTo(StridedSliceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = begin_mask(); _o->begin_mask = _e; }
+  { auto _e = end_mask(); _o->end_mask = _e; }
+  { auto _e = ellipsis_mask(); _o->ellipsis_mask = _e; }
+  { auto _e = new_axis_mask(); _o->new_axis_mask = _e; }
+  { auto _e = shrink_axis_mask(); _o->shrink_axis_mask = _e; }
+}
+
+inline flatbuffers::Offset<StridedSlice> StridedSlice::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateStridedSlice(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<StridedSlice> CreateStridedSlice(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _begin_mask = _o->begin_mask;
+  auto _end_mask = _o->end_mask;
+  auto _ellipsis_mask = _o->ellipsis_mask;
+  auto _new_axis_mask = _o->new_axis_mask;
+  auto _shrink_axis_mask = _o->shrink_axis_mask;
+  return mindspore::schema::CreateStridedSlice(
+      _fbb,
+      _begin_mask,
+      _end_mask,
+      _ellipsis_mask,
+      _new_axis_mask,
+      _shrink_axis_mask);
+}
+
+inline SubFusionT *SubFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SubFusionT>(new SubFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SubFusion::UnPackTo(SubFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = activation_type(); _o->activation_type = _e; }
+}
+
+inline flatbuffers::Offset<SubFusion> SubFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSubFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SubFusion> CreateSubFusion(flatbuffers::FlatBufferBuilder &_fbb, const SubFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _activation_type = _o->activation_type;
+  return mindspore::schema::CreateSubFusion(
+      _fbb,
+      _activation_type);
+}
+
+inline SubGradT *SubGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SubGradT>(new SubGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SubGrad::UnPackTo(SubGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<SubGrad> SubGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSubGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SubGrad> CreateSubGrad(flatbuffers::FlatBufferBuilder &_fbb, const SubGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSubGrad(
+      _fbb);
+}
+
+inline SwitchT *Switch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SwitchT>(new SwitchT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Switch::UnPackTo(SwitchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Switch> Switch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwitchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSwitch(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Switch> CreateSwitch(flatbuffers::FlatBufferBuilder &_fbb, const SwitchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SwitchT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSwitch(
+      _fbb);
+}
+
+inline TensorListFromTensorT *TensorListFromTensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TensorListFromTensorT>(new TensorListFromTensorT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void TensorListFromTensor::UnPackTo(TensorListFromTensorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = element_dtype(); _o->element_dtype = _e; }
+  { auto _e = shape_type(); _o->shape_type = _e; }
+}
+
+inline flatbuffers::Offset<TensorListFromTensor> TensorListFromTensor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListFromTensorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTensorListFromTensor(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<TensorListFromTensor> CreateTensorListFromTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorListFromTensorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListFromTensorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _element_dtype = _o->element_dtype;
+  auto _shape_type = _o->shape_type;
+  return mindspore::schema::CreateTensorListFromTensor(
+      _fbb,
+      _element_dtype,
+      _shape_type);
+}
+
+inline TensorListGetItemT *TensorListGetItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TensorListGetItemT>(new TensorListGetItemT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void TensorListGetItem::UnPackTo(TensorListGetItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = element_dtype(); _o->element_dtype = _e; }
+}
+
+inline flatbuffers::Offset<TensorListGetItem> TensorListGetItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListGetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTensorListGetItem(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<TensorListGetItem> CreateTensorListGetItem(flatbuffers::FlatBufferBuilder &_fbb, const TensorListGetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListGetItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _element_dtype = _o->element_dtype;
+  return mindspore::schema::CreateTensorListGetItem(
+      _fbb,
+      _element_dtype);
+}
+
+inline TensorListReserveT *TensorListReserve::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TensorListReserveT>(new TensorListReserveT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void TensorListReserve::UnPackTo(TensorListReserveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = element_dtype(); _o->element_dtype = _e; }
+  { auto _e = shape_type(); _o->shape_type = _e; }
+}
+
+inline flatbuffers::Offset<TensorListReserve> TensorListReserve::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListReserveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTensorListReserve(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<TensorListReserve> CreateTensorListReserve(flatbuffers::FlatBufferBuilder &_fbb, const TensorListReserveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListReserveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _element_dtype = _o->element_dtype;
+  auto _shape_type = _o->shape_type;
+  return mindspore::schema::CreateTensorListReserve(
+      _fbb,
+      _element_dtype,
+      _shape_type);
+}
+
+inline TensorListSetItemT *TensorListSetItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TensorListSetItemT>(new TensorListSetItemT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void TensorListSetItem::UnPackTo(TensorListSetItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = element_dtype(); _o->element_dtype = _e; }
+}
+
+inline flatbuffers::Offset<TensorListSetItem> TensorListSetItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListSetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTensorListSetItem(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<TensorListSetItem> CreateTensorListSetItem(flatbuffers::FlatBufferBuilder &_fbb, const TensorListSetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListSetItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _element_dtype = _o->element_dtype;
+  return mindspore::schema::CreateTensorListSetItem(
+      _fbb,
+      _element_dtype);
+}
+
+inline TensorListStackT *TensorListStack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TensorListStackT>(new TensorListStackT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void TensorListStack::UnPackTo(TensorListStackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = num_elements(); _o->num_elements = _e; }
+  { auto _e = element_dtype(); _o->element_dtype = _e; }
+}
+
+inline flatbuffers::Offset<TensorListStack> TensorListStack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListStackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTensorListStack(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<TensorListStack> CreateTensorListStack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListStackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListStackT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _num_elements = _o->num_elements;
+  auto _element_dtype = _o->element_dtype;
+  return mindspore::schema::CreateTensorListStack(
+      _fbb,
+      _num_elements,
+      _element_dtype);
+}
+
+inline TileFusionT *TileFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TileFusionT>(new TileFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void TileFusion::UnPackTo(TileFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<TileFusion> TileFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTileFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<TileFusion> CreateTileFusion(flatbuffers::FlatBufferBuilder &_fbb, const TileFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TileFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
+  return mindspore::schema::CreateTileFusion(
+      _fbb,
+      _dims);
+}
+
+inline TopKFusionT *TopKFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TopKFusionT>(new TopKFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void TopKFusion::UnPackTo(TopKFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = sorted(); _o->sorted = _e; }
+  { auto _e = axis(); _o->axis = _e; }
+  { auto _e = largest(); _o->largest = _e; }
+}
+
+inline flatbuffers::Offset<TopKFusion> TopKFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTopKFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<TopKFusion> CreateTopKFusion(flatbuffers::FlatBufferBuilder &_fbb, const TopKFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TopKFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _sorted = _o->sorted;
+  auto _axis = _o->axis;
+  auto _largest = _o->largest;
+  return mindspore::schema::CreateTopKFusion(
+      _fbb,
+      _sorted,
+      _axis,
+      _largest);
+}
+
+inline TransposeT *Transpose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TransposeT>(new TransposeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Transpose::UnPackTo(TransposeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Transpose> Transpose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTranspose(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Transpose> CreateTranspose(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateTranspose(
+      _fbb);
+}
+
+inline UniqueT *Unique::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<UniqueT>(new UniqueT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Unique::UnPackTo(UniqueT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Unique> Unique::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateUnique(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Unique> CreateUnique(flatbuffers::FlatBufferBuilder &_fbb, const UniqueT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UniqueT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateUnique(
+      _fbb);
+}
+
+inline UnsortedSegmentSumT *UnsortedSegmentSum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<UnsortedSegmentSumT>(new UnsortedSegmentSumT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void UnsortedSegmentSum::UnPackTo(UnsortedSegmentSumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<UnsortedSegmentSum> UnsortedSegmentSum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateUnsortedSegmentSum(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<UnsortedSegmentSum> CreateUnsortedSegmentSum(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentSumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateUnsortedSegmentSum(
+      _fbb);
+}
+
+inline UnsqueezeT *Unsqueeze::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<UnsqueezeT>(new UnsqueezeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Unsqueeze::UnPackTo(UnsqueezeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<Unsqueeze> Unsqueeze::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateUnsqueeze(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(flatbuffers::FlatBufferBuilder &_fbb, const UnsqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsqueezeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
+  return mindspore::schema::CreateUnsqueeze(
+      _fbb,
+      _axis);
+}
+
+inline UnstackT *Unstack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<UnstackT>(new UnstackT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Unstack::UnPackTo(UnstackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); _o->axis = _e; }
+}
+
+inline flatbuffers::Offset<Unstack> Unstack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnstackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateUnstack(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Unstack> CreateUnstack(flatbuffers::FlatBufferBuilder &_fbb, const UnstackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnstackT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis;
+  return mindspore::schema::CreateUnstack(
+      _fbb,
+      _axis);
+}
+
+inline WhereT *Where::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<WhereT>(new WhereT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Where::UnPackTo(WhereT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Where> Where::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateWhere(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Where> CreateWhere(flatbuffers::FlatBufferBuilder &_fbb, const WhereT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WhereT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateWhere(
+      _fbb);
+}
+
+inline ZerosLikeT *ZerosLike::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ZerosLikeT>(new ZerosLikeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ZerosLike::UnPackTo(ZerosLikeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<ZerosLike> ZerosLike::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateZerosLike(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ZerosLike> CreateZerosLike(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ZerosLikeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateZerosLike(
+      _fbb);
+}
+
+inline SelectT *Select::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SelectT>(new SelectT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Select::UnPackTo(SelectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Select> Select::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSelect(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Select> CreateSelect(flatbuffers::FlatBufferBuilder &_fbb, const SelectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelectT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSelect(
+      _fbb);
+}
+
+inline GRUT *GRU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<GRUT>(new GRUT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void GRU::UnPackTo(GRUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = bidirectional(); _o->bidirectional = _e; }
+}
+
+inline flatbuffers::Offset<GRU> GRU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GRUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateGRU(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<GRU> CreateGRU(flatbuffers::FlatBufferBuilder &_fbb, const GRUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GRUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _bidirectional = _o->bidirectional;
+  return mindspore::schema::CreateGRU(
+      _fbb,
+      _bidirectional);
+}
+
+inline NonZeroT *NonZero::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<NonZeroT>(new NonZeroT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void NonZero::UnPackTo(NonZeroT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<NonZero> NonZero::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonZeroT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateNonZero(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<NonZero> CreateNonZero(flatbuffers::FlatBufferBuilder &_fbb, const NonZeroT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonZeroT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateNonZero(
+      _fbb);
+}
+
+inline InvertPermutationT *InvertPermutation::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<InvertPermutationT>(new InvertPermutationT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void InvertPermutation::UnPackTo(InvertPermutationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<InvertPermutation> InvertPermutation::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InvertPermutationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateInvertPermutation(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<InvertPermutation> CreateInvertPermutation(flatbuffers::FlatBufferBuilder &_fbb, const InvertPermutationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InvertPermutationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateInvertPermutation(
+      _fbb);
+}
+
+inline SizeT *Size::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SizeT>(new SizeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Size::UnPackTo(SizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Size> Size::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSize(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Size> CreateSize(flatbuffers::FlatBufferBuilder &_fbb, const SizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSize(
+      _fbb);
+}
+
+inline RandomStandardNormalT *RandomStandardNormal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<RandomStandardNormalT>(new RandomStandardNormalT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void RandomStandardNormal::UnPackTo(RandomStandardNormalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = seed(); _o->seed = _e; }
+  { auto _e = seed2(); _o->seed2 = _e; }
+}
+
+inline flatbuffers::Offset<RandomStandardNormal> RandomStandardNormal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomStandardNormalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateRandomStandardNormal(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<RandomStandardNormal> CreateRandomStandardNormal(flatbuffers::FlatBufferBuilder &_fbb, const RandomStandardNormalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RandomStandardNormalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _seed = _o->seed;
+  auto _seed2 = _o->seed2;
+  return mindspore::schema::CreateRandomStandardNormal(
+      _fbb,
+      _seed,
+      _seed2);
+}
+
+inline CropAndResizeT *CropAndResize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<CropAndResizeT>(new CropAndResizeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void CropAndResize::UnPackTo(CropAndResizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = method(); _o->method = _e; }
+  { auto _e = extrapolation_value(); _o->extrapolation_value = _e; }
+}
+
+inline flatbuffers::Offset<CropAndResize> CropAndResize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateCropAndResize(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<CropAndResize> CreateCropAndResize(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CropAndResizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _method = _o->method;
+  auto _extrapolation_value = _o->extrapolation_value;
+  return mindspore::schema::CreateCropAndResize(
+      _fbb,
+      _method,
+      _extrapolation_value);
+}
+
+inline ErfT *Erf::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ErfT>(new ErfT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Erf::UnPackTo(ErfT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<Erf> Erf::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErfT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateErf(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Erf> CreateErf(flatbuffers::FlatBufferBuilder &_fbb, const ErfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ErfT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateErf(
+      _fbb);
+}
+
+inline StridedSliceGradT *StridedSliceGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<StridedSliceGradT>(new StridedSliceGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void StridedSliceGrad::UnPackTo(StridedSliceGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = begin_mask(); _o->begin_mask = _e; }
+  { auto _e = end_mask(); _o->end_mask = _e; }
+  { auto _e = ellipsis_mask(); _o->ellipsis_mask = _e; }
+  { auto _e = new_axis_mask(); _o->new_axis_mask = _e; }
+  { auto _e = shrink_axis_mask(); _o->shrink_axis_mask = _e; }
+}
+
+inline flatbuffers::Offset<StridedSliceGrad> StridedSliceGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateStridedSliceGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<StridedSliceGrad> CreateStridedSliceGrad(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _begin_mask = _o->begin_mask;
+  auto _end_mask = _o->end_mask;
+  auto _ellipsis_mask = _o->ellipsis_mask;
+  auto _new_axis_mask = _o->new_axis_mask;
+  auto _shrink_axis_mask = _o->shrink_axis_mask;
+  return mindspore::schema::CreateStridedSliceGrad(
+      _fbb,
+      _begin_mask,
+      _end_mask,
+      _ellipsis_mask,
+      _new_axis_mask,
+      _shrink_axis_mask);
+}
+
+inline IsFiniteT *IsFinite::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<IsFiniteT>(new IsFiniteT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void IsFinite::UnPackTo(IsFiniteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<IsFinite> IsFinite::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IsFiniteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateIsFinite(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<IsFinite> CreateIsFinite(flatbuffers::FlatBufferBuilder &_fbb, const IsFiniteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IsFiniteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateIsFinite(
+      _fbb);
+}
+
+inline LinSpaceT *LinSpace::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LinSpaceT>(new LinSpaceT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LinSpace::UnPackTo(LinSpaceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<LinSpace> LinSpace::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LinSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLinSpace(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LinSpace> CreateLinSpace(flatbuffers::FlatBufferBuilder &_fbb, const LinSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LinSpaceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateLinSpace(
+      _fbb);
+}
+
+inline UniformRealT *UniformReal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<UniformRealT>(new UniformRealT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void UniformReal::UnPackTo(UniformRealT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = seed(); _o->seed = _e; }
+  { auto _e = seed2(); _o->seed2 = _e; }
+}
+
+inline flatbuffers::Offset<UniformReal> UniformReal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniformRealT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateUniformReal(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<UniformReal> CreateUniformReal(flatbuffers::FlatBufferBuilder &_fbb, const UniformRealT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UniformRealT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _seed = _o->seed;
+  auto _seed2 = _o->seed2;
+  return mindspore::schema::CreateUniformReal(
+      _fbb,
+      _seed,
+      _seed2);
+}
+
+inline AbsGradT *AbsGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AbsGradT>(new AbsGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void AbsGrad::UnPackTo(AbsGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<AbsGrad> AbsGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAbsGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<AbsGrad> CreateAbsGrad(flatbuffers::FlatBufferBuilder &_fbb, const AbsGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AbsGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateAbsGrad(
+      _fbb);
+}
+
+inline RsqrtGradT *RsqrtGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<RsqrtGradT>(new RsqrtGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void RsqrtGrad::UnPackTo(RsqrtGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<RsqrtGrad> RsqrtGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateRsqrtGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<RsqrtGrad> CreateRsqrtGrad(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RsqrtGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateRsqrtGrad(
+      _fbb);
+}
+
+inline SqrtGradT *SqrtGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SqrtGradT>(new SqrtGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SqrtGrad::UnPackTo(SqrtGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<SqrtGrad> SqrtGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSqrtGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SqrtGrad> CreateSqrtGrad(flatbuffers::FlatBufferBuilder &_fbb, const SqrtGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqrtGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateSqrtGrad(
+      _fbb);
+}
+
+inline LayerNormGradT *LayerNormGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LayerNormGradT>(new LayerNormGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LayerNormGrad::UnPackTo(LayerNormGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = begin_norm_axis(); _o->begin_norm_axis = _e; }
+  { auto _e = begin_params_axis(); _o->begin_params_axis = _e; }
+}
+
+inline flatbuffers::Offset<LayerNormGrad> LayerNormGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLayerNormGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LayerNormGrad> CreateLayerNormGrad(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LayerNormGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _begin_norm_axis = _o->begin_norm_axis;
+  auto _begin_params_axis = _o->begin_params_axis;
+  return mindspore::schema::CreateLayerNormGrad(
+      _fbb,
+      _begin_norm_axis,
+      _begin_params_axis);
+}
+
+inline ResizeGradT *ResizeGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ResizeGradT>(new ResizeGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ResizeGrad::UnPackTo(ResizeGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = method(); _o->method = _e; }
+  { auto _e = align_corners(); _o->align_corners = _e; }
+}
+
+inline flatbuffers::Offset<ResizeGrad> ResizeGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateResizeGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ResizeGrad> CreateResizeGrad(flatbuffers::FlatBufferBuilder &_fbb, const ResizeGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _method = _o->method;
+  auto _align_corners = _o->align_corners;
+  return mindspore::schema::CreateResizeGrad(
+      _fbb,
+      _method,
+      _align_corners);
+}
+
+inline SpliceT *Splice::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SpliceT>(new SpliceT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Splice::UnPackTo(SpliceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = context(); if (_e) { _o->context.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->context[_i] = _e->Get(_i); } } }
+  { auto _e = forward_indexes(); if (_e) { _o->forward_indexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->forward_indexes[_i] = _e->Get(_i); } } }
+  { auto _e = output_dim(); _o->output_dim = _e; }
+}
+
+inline flatbuffers::Offset<Splice> Splice::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpliceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSplice(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Splice> CreateSplice(flatbuffers::FlatBufferBuilder &_fbb, const SpliceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpliceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _context = _o->context.size() ? _fbb.CreateVector(_o->context) : 0;
+  auto _forward_indexes = _o->forward_indexes.size() ? _fbb.CreateVector(_o->forward_indexes) : 0;
+  auto _output_dim = _o->output_dim;
+  return mindspore::schema::CreateSplice(
+      _fbb,
+      _context,
+      _forward_indexes,
+      _output_dim);
+}
+
+inline LogSoftmaxT *LogSoftmax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LogSoftmaxT>(new LogSoftmaxT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LogSoftmax::UnPackTo(LogSoftmaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); _o->axis = _e; }
+}
+
+inline flatbuffers::Offset<LogSoftmax> LogSoftmax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLogSoftmax(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LogSoftmax> CreateLogSoftmax(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogSoftmaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis;
+  return mindspore::schema::CreateLogSoftmax(
+      _fbb,
+      _axis);
+}
+
+inline CallT *Call::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<CallT>(new CallT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Call::UnPackTo(CallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = is_tail_call(); _o->is_tail_call = _e; }
+}
+
+inline flatbuffers::Offset<Call> Call::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateCall(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Call> CreateCall(flatbuffers::FlatBufferBuilder &_fbb, const CallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _is_tail_call = _o->is_tail_call;
+  return mindspore::schema::CreateCall(
+      _fbb,
+      _is_tail_call);
+}
+
+inline CumSumT *CumSum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<CumSumT>(new CumSumT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void CumSum::UnPackTo(CumSumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = exclusive(); _o->exclusive = _e; }
+  { auto _e = reverse(); _o->reverse = _e; }
+}
+
+inline flatbuffers::Offset<CumSum> CumSum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateCumSum(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<CumSum> CreateCumSum(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CumSumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _exclusive = _o->exclusive;
+  auto _reverse = _o->reverse;
+  return mindspore::schema::CreateCumSum(
+      _fbb,
+      _exclusive,
+      _reverse);
+}
+
+inline CustomT *Custom::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<CustomT>(new CustomT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Custom::UnPackTo(CustomT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = type(); if (_e) _o->type = _e->str(); }
+  { auto _e = attr(); if (_e) { _o->attr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attr[_i] = std::unique_ptr<mindspore::schema::AttributeT>(_e->Get(_i)->UnPack(_resolver)); } } }
+}
+
+inline flatbuffers::Offset<Custom> Custom::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateCustom(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Custom> CreateCustom(flatbuffers::FlatBufferBuilder &_fbb, const CustomT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
+  auto _attr = _o->attr.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Attribute>> (_o->attr.size(), [](size_t i, _VectorArgs *__va) { return CreateAttribute(*__va->__fbb, __va->__o->attr[i].get(), __va->__rehasher); }, &_va ) : 0;
+  return mindspore::schema::CreateCustom(
+      _fbb,
+      _type,
+      _attr);
+}
+
+inline SplitWithOverlapT *SplitWithOverlap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<SplitWithOverlapT>(new SplitWithOverlapT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void SplitWithOverlap::UnPackTo(SplitWithOverlapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = split_dim(); _o->split_dim = _e; }
+  { auto _e = number_split(); _o->number_split = _e; }
+  { auto _e = ratio(); if (_e) { _o->ratio.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ratio[_i] = _e->Get(_i); } } }
+  { auto _e = extend_top(); if (_e) { _o->extend_top.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extend_top[_i] = _e->Get(_i); } } }
+  { auto _e = extend_bottom(); if (_e) { _o->extend_bottom.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extend_bottom[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<SplitWithOverlap> SplitWithOverlap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitWithOverlapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateSplitWithOverlap(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<SplitWithOverlap> CreateSplitWithOverlap(flatbuffers::FlatBufferBuilder &_fbb, const SplitWithOverlapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitWithOverlapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _split_dim = _o->split_dim;
+  auto _number_split = _o->number_split;
+  auto _ratio = _o->ratio.size() ? _fbb.CreateVector(_o->ratio) : 0;
+  auto _extend_top = _o->extend_top.size() ? _fbb.CreateVector(_o->extend_top) : 0;
+  auto _extend_bottom = _o->extend_bottom.size() ? _fbb.CreateVector(_o->extend_bottom) : 0;
+  return mindspore::schema::CreateSplitWithOverlap(
+      _fbb,
+      _split_dim,
+      _number_split,
+      _ratio,
+      _extend_top,
+      _extend_bottom);
+}
+
+inline GenOPT *GenOP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<GenOPT>(new GenOPT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void GenOP::UnPackTo(GenOPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = activation_type(); _o->activation_type = _e; }
+  { auto _e = alpha(); _o->alpha = _e; }
+  { auto _e = min_val(); _o->min_val = _e; }
+  { auto _e = max_val(); _o->max_val = _e; }
+  { auto _e = is_training(); _o->is_training = _e; }
+  { auto _e = format(); _o->format = _e; }
+  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
+  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
+  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
+  { auto _e = pad_mode(); _o->pad_mode = _e; }
+  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
+  { auto _e = mode(); _o->mode = _e; }
+  { auto _e = group(); _o->group = _e; }
+  { auto _e = in_channel(); _o->in_channel = _e; }
+  { auto _e = out_channel(); _o->out_channel = _e; }
+  { auto _e = eltwise_mode(); _o->eltwise_mode = _e; }
+  { auto _e = has_bias(); _o->has_bias = _e; }
+  { auto _e = use_axis(); _o->use_axis = _e; }
+  { auto _e = axis(); _o->axis = _e; }
+  { auto _e = epsilon(); _o->epsilon = _e; }
+  { auto _e = momentum(); _o->momentum = _e; }
+  { auto _e = transpose_a(); _o->transpose_a = _e; }
+  { auto _e = transpose_b(); _o->transpose_b = _e; }
+  { auto _e = pad(); if (_e) { _o->pad.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad[_i] = _e->Get(_i); } } }
+  { auto _e = round_mode(); _o->round_mode = _e; }
+  { auto _e = global(); _o->global = _e; }
+  { auto _e = channel_shared(); _o->channel_shared = _e; }
+  { auto _e = axes(); if (_e) { _o->axes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axes[_i] = _e->Get(_i); } } }
+  { auto _e = keep_dims(); _o->keep_dims = _e; }
+  { auto _e = reduce_mode(); _o->reduce_mode = _e; }
+  { auto _e = reduce_to_end(); _o->reduce_to_end = _e; }
+  { auto _e = coeff(); _o->coeff = _e; }
+}
+
+inline flatbuffers::Offset<GenOP> GenOP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GenOPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateGenOP(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<GenOP> CreateGenOP(flatbuffers::FlatBufferBuilder &_fbb, const GenOPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GenOPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _activation_type = _o->activation_type;
+  auto _alpha = _o->alpha;
+  auto _min_val = _o->min_val;
+  auto _max_val = _o->max_val;
+  auto _is_training = _o->is_training;
+  auto _format = _o->format;
+  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
+  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
+  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
+  auto _pad_mode = _o->pad_mode;
+  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
+  auto _mode = _o->mode;
+  auto _group = _o->group;
+  auto _in_channel = _o->in_channel;
+  auto _out_channel = _o->out_channel;
+  auto _eltwise_mode = _o->eltwise_mode;
+  auto _has_bias = _o->has_bias;
+  auto _use_axis = _o->use_axis;
+  auto _axis = _o->axis;
+  auto _epsilon = _o->epsilon;
+  auto _momentum = _o->momentum;
+  auto _transpose_a = _o->transpose_a;
+  auto _transpose_b = _o->transpose_b;
+  auto _pad = _o->pad.size() ? _fbb.CreateVector(_o->pad) : 0;
+  auto _round_mode = _o->round_mode;
+  auto _global = _o->global;
+  auto _channel_shared = _o->channel_shared;
+  auto _axes = _o->axes.size() ? _fbb.CreateVector(_o->axes) : 0;
+  auto _keep_dims = _o->keep_dims;
+  auto _reduce_mode = _o->reduce_mode;
+  auto _reduce_to_end = _o->reduce_to_end;
+  auto _coeff = _o->coeff;
+  return mindspore::schema::CreateGenOP(
+      _fbb,
+      _activation_type,
+      _alpha,
+      _min_val,
+      _max_val,
+      _is_training,
+      _format,
+      _kernel_size,
+      _stride,
+      _dilation,
+      _pad_mode,
+      _pad_list,
+      _mode,
+      _group,
+      _in_channel,
+      _out_channel,
+      _eltwise_mode,
+      _has_bias,
+      _use_axis,
+      _axis,
+      _epsilon,
+      _momentum,
+      _transpose_a,
+      _transpose_b,
+      _pad,
+      _round_mode,
+      _global,
+      _channel_shared,
+      _axes,
+      _keep_dims,
+      _reduce_mode,
+      _reduce_to_end,
+      _coeff);
+}
+
+inline RaggedRangeT *RaggedRange::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<RaggedRangeT>(new RaggedRangeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void RaggedRange::UnPackTo(RaggedRangeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<RaggedRange> RaggedRange::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RaggedRangeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateRaggedRange(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<RaggedRange> CreateRaggedRange(flatbuffers::FlatBufferBuilder &_fbb, const RaggedRangeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RaggedRangeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateRaggedRange(
+      _fbb);
+}
+
+inline GLUT *GLU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<GLUT>(new GLUT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void GLU::UnPackTo(GLUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = axis(); _o->axis = _e; }
+}
+
+inline flatbuffers::Offset<GLU> GLU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GLUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateGLU(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<GLU> CreateGLU(flatbuffers::FlatBufferBuilder &_fbb, const GLUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GLUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _axis = _o->axis;
+  return mindspore::schema::CreateGLU(
+      _fbb,
+      _axis);
+}
+
+inline TensorArrayT *TensorArray::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TensorArrayT>(new TensorArrayT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void TensorArray::UnPackTo(TensorArrayT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = dynamic_size(); _o->dynamic_size = _e; }
+  { auto _e = identical_element_shapes(); _o->identical_element_shapes = _e; }
+  { auto _e = element_shape(); if (_e) { _o->element_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->element_shape[_i] = _e->Get(_i); } } }
+  { auto _e = data_type(); _o->data_type = _e; }
+}
+
+inline flatbuffers::Offset<TensorArray> TensorArray::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTensorArray(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<TensorArray> CreateTensorArray(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorArrayT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _dynamic_size = _o->dynamic_size;
+  auto _identical_element_shapes = _o->identical_element_shapes;
+  auto _element_shape = _o->element_shape.size() ? _fbb.CreateVector(_o->element_shape) : 0;
+  auto _data_type = _o->data_type;
+  return mindspore::schema::CreateTensorArray(
+      _fbb,
+      _dynamic_size,
+      _identical_element_shapes,
+      _element_shape,
+      _data_type);
+}
+
+inline TensorArrayReadT *TensorArrayRead::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TensorArrayReadT>(new TensorArrayReadT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void TensorArrayRead::UnPackTo(TensorArrayReadT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<TensorArrayRead> TensorArrayRead::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayReadT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTensorArrayRead(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<TensorArrayRead> CreateTensorArrayRead(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayReadT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorArrayReadT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateTensorArrayRead(
+      _fbb);
+}
+
+inline TensorArrayWriteT *TensorArrayWrite::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<TensorArrayWriteT>(new TensorArrayWriteT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void TensorArrayWrite::UnPackTo(TensorArrayWriteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<TensorArrayWrite> TensorArrayWrite::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayWriteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateTensorArrayWrite(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<TensorArrayWrite> CreateTensorArrayWrite(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorArrayWriteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateTensorArrayWrite(
+      _fbb);
+}
+
+inline AffineT *Affine::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AffineT>(new AffineT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Affine::UnPackTo(AffineT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = context(); if (_e) { _o->context.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->context[_i] = _e->Get(_i); } } }
+  { auto _e = output_dim(); _o->output_dim = _e; }
+  { auto _e = activation_type(); _o->activation_type = _e; }
+  { auto _e = transpose_a(); _o->transpose_a = _e; }
+  { auto _e = transpose_b(); _o->transpose_b = _e; }
+}
+
+inline flatbuffers::Offset<Affine> Affine::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AffineT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAffine(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Affine> CreateAffine(flatbuffers::FlatBufferBuilder &_fbb, const AffineT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AffineT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _context = _o->context.size() ? _fbb.CreateVector(_o->context) : 0;
+  auto _output_dim = _o->output_dim;
+  auto _activation_type = _o->activation_type;
+  auto _transpose_a = _o->transpose_a;
+  auto _transpose_b = _o->transpose_b;
+  return mindspore::schema::CreateAffine(
+      _fbb,
+      _context,
+      _output_dim,
+      _activation_type,
+      _transpose_a,
+      _transpose_b);
+}
+
+inline ScatterNdUpdateT *ScatterNdUpdate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ScatterNdUpdateT>(new ScatterNdUpdateT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ScatterNdUpdate::UnPackTo(ScatterNdUpdateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<ScatterNdUpdate> ScatterNdUpdate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdUpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateScatterNdUpdate(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ScatterNdUpdate> CreateScatterNdUpdate(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScatterNdUpdateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateScatterNdUpdate(
+      _fbb);
+}
+
+inline AllGatherT *AllGather::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AllGatherT>(new AllGatherT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void AllGather::UnPackTo(AllGatherT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = group(); if (_e) _o->group = _e->str(); }
+  { auto _e = rank_size(); _o->rank_size = _e; }
+}
+
+inline flatbuffers::Offset<AllGather> AllGather::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AllGatherT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAllGather(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<AllGather> CreateAllGather(flatbuffers::FlatBufferBuilder &_fbb, const AllGatherT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AllGatherT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _group = _o->group.empty() ? 0 : _fbb.CreateString(_o->group);
+  auto _rank_size = _o->rank_size;
+  return mindspore::schema::CreateAllGather(
+      _fbb,
+      _group,
+      _rank_size);
+}
+
+inline ReduceScatterT *ReduceScatter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<ReduceScatterT>(new ReduceScatterT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void ReduceScatter::UnPackTo(ReduceScatterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = group(); if (_e) _o->group = _e->str(); }
+  { auto _e = mode(); _o->mode = _e; }
+  { auto _e = rank_size(); _o->rank_size = _e; }
+}
+
+inline flatbuffers::Offset<ReduceScatter> ReduceScatter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceScatterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateReduceScatter(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<ReduceScatter> CreateReduceScatter(flatbuffers::FlatBufferBuilder &_fbb, const ReduceScatterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceScatterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _group = _o->group.empty() ? 0 : _fbb.CreateString(_o->group);
+  auto _mode = _o->mode;
+  auto _rank_size = _o->rank_size;
+  return mindspore::schema::CreateReduceScatter(
+      _fbb,
+      _group,
+      _mode,
+      _rank_size);
+}
+
+inline DynamicQuantT *DynamicQuant::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<DynamicQuantT>(new DynamicQuantT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void DynamicQuant::UnPackTo(DynamicQuantT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = symmetric(); _o->symmetric = _e; }
+  { auto _e = dst_type(); _o->dst_type = _e; }
+}
+
+inline flatbuffers::Offset<DynamicQuant> DynamicQuant::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DynamicQuantT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateDynamicQuant(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<DynamicQuant> CreateDynamicQuant(flatbuffers::FlatBufferBuilder &_fbb, const DynamicQuantT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DynamicQuantT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _symmetric = _o->symmetric;
+  auto _dst_type = _o->dst_type;
+  return mindspore::schema::CreateDynamicQuant(
+      _fbb,
+      _symmetric,
+      _dst_type);
+}
+
+inline LSTMGradDataT *LSTMGradData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LSTMGradDataT>(new LSTMGradDataT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LSTMGradData::UnPackTo(LSTMGradDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = bidirectional(); _o->bidirectional = _e; }
+  { auto _e = has_bias(); _o->has_bias = _e; }
+  { auto _e = input_size(); _o->input_size = _e; }
+  { auto _e = hidden_size(); _o->hidden_size = _e; }
+  { auto _e = num_layers(); _o->num_layers = _e; }
+  { auto _e = num_directions(); _o->num_directions = _e; }
+  { auto _e = dropout(); _o->dropout = _e; }
+  { auto _e = zoneout_cell(); _o->zoneout_cell = _e; }
+  { auto _e = zoneout_hidden(); _o->zoneout_hidden = _e; }
+}
+
+inline flatbuffers::Offset<LSTMGradData> LSTMGradData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLSTMGradData(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LSTMGradData> CreateLSTMGradData(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMGradDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _bidirectional = _o->bidirectional;
+  auto _has_bias = _o->has_bias;
+  auto _input_size = _o->input_size;
+  auto _hidden_size = _o->hidden_size;
+  auto _num_layers = _o->num_layers;
+  auto _num_directions = _o->num_directions;
+  auto _dropout = _o->dropout;
+  auto _zoneout_cell = _o->zoneout_cell;
+  auto _zoneout_hidden = _o->zoneout_hidden;
+  return mindspore::schema::CreateLSTMGradData(
+      _fbb,
+      _bidirectional,
+      _has_bias,
+      _input_size,
+      _hidden_size,
+      _num_layers,
+      _num_directions,
+      _dropout,
+      _zoneout_cell,
+      _zoneout_hidden);
+}
+
+inline LSTMGradWeightT *LSTMGradWeight::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<LSTMGradWeightT>(new LSTMGradWeightT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void LSTMGradWeight::UnPackTo(LSTMGradWeightT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = bidirectional(); _o->bidirectional = _e; }
+  { auto _e = has_bias(); _o->has_bias = _e; }
+  { auto _e = input_size(); _o->input_size = _e; }
+  { auto _e = hidden_size(); _o->hidden_size = _e; }
+  { auto _e = num_layers(); _o->num_layers = _e; }
+  { auto _e = num_directions(); _o->num_directions = _e; }
+  { auto _e = dropout(); _o->dropout = _e; }
+  { auto _e = zoneout_cell(); _o->zoneout_cell = _e; }
+  { auto _e = zoneout_hidden(); _o->zoneout_hidden = _e; }
+}
+
+inline flatbuffers::Offset<LSTMGradWeight> LSTMGradWeight::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradWeightT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateLSTMGradWeight(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<LSTMGradWeight> CreateLSTMGradWeight(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradWeightT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMGradWeightT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _bidirectional = _o->bidirectional;
+  auto _has_bias = _o->has_bias;
+  auto _input_size = _o->input_size;
+  auto _hidden_size = _o->hidden_size;
+  auto _num_layers = _o->num_layers;
+  auto _num_directions = _o->num_directions;
+  auto _dropout = _o->dropout;
+  auto _zoneout_cell = _o->zoneout_cell;
+  auto _zoneout_hidden = _o->zoneout_hidden;
+  return mindspore::schema::CreateLSTMGradWeight(
+      _fbb,
+      _bidirectional,
+      _has_bias,
+      _input_size,
+      _hidden_size,
+      _num_layers,
+      _num_directions,
+      _dropout,
+      _zoneout_cell,
+      _zoneout_hidden);
+}
+
+inline RandomNormalT *RandomNormal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<RandomNormalT>(new RandomNormalT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void RandomNormal::UnPackTo(RandomNormalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = seed(); _o->seed = _e; }
+  { auto _e = mean(); _o->mean = _e; }
+  { auto _e = scale(); _o->scale = _e; }
+}
+
+inline flatbuffers::Offset<RandomNormal> RandomNormal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomNormalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateRandomNormal(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<RandomNormal> CreateRandomNormal(flatbuffers::FlatBufferBuilder &_fbb, const RandomNormalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RandomNormalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _seed = _o->seed;
+  auto _mean = _o->mean;
+  auto _scale = _o->scale;
+  return mindspore::schema::CreateRandomNormal(
+      _fbb,
+      _seed,
+      _mean,
+      _scale);
+}
+
+inline NLLLossT *NLLLoss::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<NLLLossT>(new NLLLossT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void NLLLoss::UnPackTo(NLLLossT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = reduction(); _o->reduction = _e; }
+}
+
+inline flatbuffers::Offset<NLLLoss> NLLLoss::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NLLLossT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateNLLLoss(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<NLLLoss> CreateNLLLoss(flatbuffers::FlatBufferBuilder &_fbb, const NLLLossT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NLLLossT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _reduction = _o->reduction;
+  return mindspore::schema::CreateNLLLoss(
+      _fbb,
+      _reduction);
+}
+
+inline NLLLossGradT *NLLLossGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<NLLLossGradT>(new NLLLossGradT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void NLLLossGrad::UnPackTo(NLLLossGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = reduction(); _o->reduction = _e; }
+}
+
+inline flatbuffers::Offset<NLLLossGrad> NLLLossGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NLLLossGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateNLLLossGrad(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<NLLLossGrad> CreateNLLLossGrad(flatbuffers::FlatBufferBuilder &_fbb, const NLLLossGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NLLLossGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _reduction = _o->reduction;
+  return mindspore::schema::CreateNLLLossGrad(
+      _fbb,
+      _reduction);
+}
+
+inline FormatTransposeT *FormatTranspose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<FormatTransposeT>(new FormatTransposeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void FormatTranspose::UnPackTo(FormatTransposeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = src_format(); _o->src_format = _e; }
+  { auto _e = dst_format(); _o->dst_format = _e; }
+}
+
+inline flatbuffers::Offset<FormatTranspose> FormatTranspose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FormatTransposeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateFormatTranspose(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<FormatTranspose> CreateFormatTranspose(flatbuffers::FlatBufferBuilder &_fbb, const FormatTransposeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FormatTransposeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _src_format = _o->src_format;
+  auto _dst_format = _o->dst_format;
+  return mindspore::schema::CreateFormatTranspose(
+      _fbb,
+      _src_format,
+      _dst_format);
+}
+
+inline GatherDT *GatherD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<GatherDT>(new GatherDT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void GatherD::UnPackTo(GatherDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+}
+
+inline flatbuffers::Offset<GatherD> GatherD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateGatherD(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<GatherD> CreateGatherD(flatbuffers::FlatBufferBuilder &_fbb, const GatherDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  return mindspore::schema::CreateGatherD(
+      _fbb);
+}
+
+inline GroupNormFusionT *GroupNormFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<GroupNormFusionT>(new GroupNormFusionT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void GroupNormFusion::UnPackTo(GroupNormFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = num_groups(); _o->num_groups = _e; }
+  { auto _e = epsilon(); _o->epsilon = _e; }
+  { auto _e = affine(); _o->affine = _e; }
+}
+
+inline flatbuffers::Offset<GroupNormFusion> GroupNormFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupNormFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateGroupNormFusion(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<GroupNormFusion> CreateGroupNormFusion(flatbuffers::FlatBufferBuilder &_fbb, const GroupNormFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GroupNormFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _num_groups = _o->num_groups;
+  auto _epsilon = _o->epsilon;
+  auto _affine = _o->affine;
+  return mindspore::schema::CreateGroupNormFusion(
+      _fbb,
+      _num_groups,
+      _epsilon,
+      _affine);
+}
+
+inline bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type) {
+  switch (type) {
+    case PrimitiveType_NONE: {
+      return true;
+    }
+    case PrimitiveType_Abs: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Abs *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Activation: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Activation *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ActivationGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ActivationGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Adam: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Adam *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AddFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AddFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AdderFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AdderFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AddGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AddGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AddN: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AddN *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_All: {
+      auto ptr = reinterpret_cast<const mindspore::schema::All *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ApplyMomentum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ApplyMomentum *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ArgMaxFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ArgMaxFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ArgMinFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ArgMinFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Assert: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Assert *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Assign: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Assign *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AssignAdd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AssignAdd *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AudioSpectrogram: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AudioSpectrogram *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AvgPoolFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AvgPoolGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BatchNorm: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchNorm *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BatchNormGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchNormGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BatchToSpace: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpace *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BatchToSpaceND: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpaceND *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BiasAdd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BiasAdd *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BinaryCrossEntropy: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropy *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BinaryCrossEntropyGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropyGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BiasAddGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BiasAddGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BroadcastTo: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BroadcastTo *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Cast: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Cast *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Ceil: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Ceil *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Clip: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Clip *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Concat: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Concat *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Attention: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Attention *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Conv2DBackpropFilterFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropFilterFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Conv2DBackpropInputFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropInputFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Conv2DFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Conv2dTransposeFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2dTransposeFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Cos: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Cos *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ConstantOfShape: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ConstantOfShape *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Crop: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Crop *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_CustomExtractFeatures: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomExtractFeatures *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_CustomNormalize: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomNormalize *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_CustomPredict: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomPredict *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DeConv2DGradFilter: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DeConv2DGradFilter *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Depend: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Depend *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DepthToSpace: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DepthToSpace *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DetectionPostProcess: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DetectionPostProcess *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DivFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DivFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DivGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DivGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Dropout: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Dropout *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DropoutGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DropoutGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Elu: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Elu *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Eltwise: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Eltwise *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Equal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Equal *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_EmbeddingLookupFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::EmbeddingLookupFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ExpFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ExpFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ExpandDims: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ExpandDims *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FakeQuantWithMinMaxVars: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVars *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FakeQuantWithMinMaxVarsPerChannel: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsPerChannel *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FftReal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FftReal *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FftImag: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FftImag *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Flatten: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Flatten *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FlattenGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FlattenGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Floor: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Floor *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FloorDiv: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FloorDiv *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FloorMod: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FloorMod *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Fill: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Fill *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FullConnection: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FullConnection *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FusedBatchNorm: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FusedBatchNorm *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Gather: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Gather *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GatherNd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GatherNd *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Greater: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Greater *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GreaterEqual: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GreaterEqual *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_HashtableLookup: {
+      auto ptr = reinterpret_cast<const mindspore::schema::HashtableLookup *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_InstanceNorm: {
+      auto ptr = reinterpret_cast<const mindspore::schema::InstanceNorm *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LayerNormFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LeakyRelu: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LeakyRelu *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Less: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Less *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LessEqual: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LessEqual *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Log: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Log *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LogGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LogicalAnd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogicalAnd *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LogicalNot: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogicalNot *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LogicalOr: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogicalOr *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LpNormalization: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LpNormalization *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LRN: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LRN *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LshProjection: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LshProjection *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LSTM: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTM *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_L2NormalizeFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::L2NormalizeFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MatMulFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MatMulFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Maximum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Maximum *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MaximumGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaximumGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MaxPoolFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MaxPoolGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SwitchLayer: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SwitchLayer *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Mfcc: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Mfcc *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Minimum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Minimum *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MinimumGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MinimumGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Mod: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Mod *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MulFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MulFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MulGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MulGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Neg: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Neg *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_NegGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NegGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_NotEqual: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NotEqual *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_NonMaxSuppression: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NonMaxSuppression *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_OneHot: {
+      auto ptr = reinterpret_cast<const mindspore::schema::OneHot *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_OnesLike: {
+      auto ptr = reinterpret_cast<const mindspore::schema::OnesLike *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_PadFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PadFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_PartialFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PartialFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_PowerGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PowerGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_PowFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PowFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_PriorBox: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PriorBox *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_PReLUFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PReLUFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_QuantDTypeCast: {
+      auto ptr = reinterpret_cast<const mindspore::schema::QuantDTypeCast *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Rank: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Rank *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Range: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Range *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Reciprocal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Reciprocal *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_RealDiv: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RealDiv *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ReduceFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReduceFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Reshape: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Reshape *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Resize: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Resize *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ReverseSequence: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReverseSequence *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ReverseV2: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReverseV2 *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Rfft: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Rfft *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ROIPooling: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ROIPooling *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Round: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Round *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Rsqrt: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Rsqrt *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ScaleFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ScaleFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ScatterNd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNd *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SGD: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SGD *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Shape: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Shape *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogits *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Sin: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Sin *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SkipGram: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SkipGram *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SliceFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SliceFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SmoothL1Loss: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1Loss *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SmoothL1LossGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1LossGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Softmax: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Softmax *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SoftmaxCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SoftmaxCrossEntropyWithLogits *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SpaceToBatch: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatch *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SpaceToBatchND: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatchND *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SpaceToDepth: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToDepth *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SparseSoftmaxCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SparseSoftmaxCrossEntropyWithLogits *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SparseToDense: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SparseToDense *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Split: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Split *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Sqrt: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Sqrt *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Squeeze: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Squeeze *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Square: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Square *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SquaredDifference: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SquaredDifference *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Stack: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Stack *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_StridedSlice: {
+      auto ptr = reinterpret_cast<const mindspore::schema::StridedSlice *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SubFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SubFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SubGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SubGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Switch: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Switch *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorListFromTensor: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListFromTensor *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorListGetItem: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListGetItem *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorListReserve: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListReserve *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorListSetItem: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListSetItem *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorListStack: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListStack *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TileFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TileFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TopKFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TopKFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Transpose: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Transpose *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Unique: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Unique *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_UnsortedSegmentSum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::UnsortedSegmentSum *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Unsqueeze: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Unsqueeze *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Unstack: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Unstack *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LSTMGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Where: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Where *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ZerosLike: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ZerosLike *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Select: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Select *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ScatterNdUpdate: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNdUpdate *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GRU: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GRU *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_NonZero: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NonZero *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_InvertPermutation: {
+      auto ptr = reinterpret_cast<const mindspore::schema::InvertPermutation *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Size: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Size *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_RandomStandardNormal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RandomStandardNormal *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_CropAndResize: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CropAndResize *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Erf: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Erf *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_StridedSliceGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::StridedSliceGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_IsFinite: {
+      auto ptr = reinterpret_cast<const mindspore::schema::IsFinite *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LinSpace: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LinSpace *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_UniformReal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::UniformReal *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AbsGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AbsGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_RsqrtGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RsqrtGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SqrtGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SqrtGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LayerNormGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ResizeGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ResizeGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Splice: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Splice *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LogSoftmax: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogSoftmax *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Call: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Call *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Custom: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Custom *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_CumSum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CumSum *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SplitWithOverlap: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SplitWithOverlap *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GenOP: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GenOP *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_RaggedRange: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RaggedRange *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GLU: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GLU *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorArray: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorArray *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorArrayRead: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayRead *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorArrayWrite: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayWrite *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Affine: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Affine *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AllGather: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AllGather *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ReduceScatter: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReduceScatter *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DynamicQuant: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DynamicQuant *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LSTMGradData: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGradData *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LSTMGradWeight: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGradWeight *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_RandomNormal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RandomNormal *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_NLLLoss: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NLLLoss *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_NLLLossGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NLLLossGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FormatTranspose: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FormatTranspose *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GatherD: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GatherD *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GroupNormFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GroupNormFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    default: return true;
+  }
+}
+
+inline bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
+  if (!values || !types) return !values && !types;
+  if (values->size() != types->size()) return false;
+  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
+    if (!VerifyPrimitiveType(
+        verifier,  values->Get(i), types->GetEnum<PrimitiveType>(i))) {
+      return false;
+    }
+  }
+  return true;
+}
+
+inline void *PrimitiveTypeUnion::UnPack(const void *obj, PrimitiveType type, const flatbuffers::resolver_function_t *resolver) {
+  switch (type) {
+    case PrimitiveType_Abs: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Abs *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Activation: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Activation *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ActivationGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ActivationGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Adam: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Adam *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_AddFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AddFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_AdderFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AdderFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_AddGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AddGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_AddN: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AddN *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_All: {
+      auto ptr = reinterpret_cast<const mindspore::schema::All *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ApplyMomentum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ApplyMomentum *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ArgMaxFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ArgMaxFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ArgMinFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ArgMinFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Assert: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Assert *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Assign: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Assign *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_AssignAdd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AssignAdd *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_AudioSpectrogram: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AudioSpectrogram *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_AvgPoolFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_AvgPoolGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_BatchNorm: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchNorm *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_BatchNormGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchNormGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_BatchToSpace: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpace *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_BatchToSpaceND: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpaceND *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_BiasAdd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BiasAdd *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_BinaryCrossEntropy: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropy *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_BinaryCrossEntropyGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropyGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_BiasAddGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BiasAddGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_BroadcastTo: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BroadcastTo *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Cast: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Cast *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Ceil: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Ceil *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Clip: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Clip *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Concat: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Concat *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Attention: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Attention *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Conv2DBackpropFilterFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropFilterFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Conv2DBackpropInputFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropInputFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Conv2DFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Conv2dTransposeFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2dTransposeFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Cos: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Cos *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ConstantOfShape: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ConstantOfShape *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Crop: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Crop *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_CustomExtractFeatures: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomExtractFeatures *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_CustomNormalize: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomNormalize *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_CustomPredict: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomPredict *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_DeConv2DGradFilter: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DeConv2DGradFilter *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Depend: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Depend *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_DepthToSpace: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DepthToSpace *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_DetectionPostProcess: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DetectionPostProcess *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_DivFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DivFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_DivGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DivGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Dropout: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Dropout *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_DropoutGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DropoutGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Elu: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Elu *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Eltwise: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Eltwise *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Equal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Equal *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_EmbeddingLookupFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::EmbeddingLookupFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ExpFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ExpFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ExpandDims: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ExpandDims *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_FakeQuantWithMinMaxVars: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVars *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_FakeQuantWithMinMaxVarsPerChannel: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsPerChannel *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_FftReal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FftReal *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_FftImag: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FftImag *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Flatten: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Flatten *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_FlattenGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FlattenGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Floor: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Floor *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_FloorDiv: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FloorDiv *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_FloorMod: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FloorMod *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Fill: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Fill *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_FullConnection: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FullConnection *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_FusedBatchNorm: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FusedBatchNorm *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Gather: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Gather *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_GatherNd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GatherNd *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Greater: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Greater *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_GreaterEqual: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GreaterEqual *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_HashtableLookup: {
+      auto ptr = reinterpret_cast<const mindspore::schema::HashtableLookup *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_InstanceNorm: {
+      auto ptr = reinterpret_cast<const mindspore::schema::InstanceNorm *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LayerNormFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LeakyRelu: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LeakyRelu *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Less: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Less *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LessEqual: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LessEqual *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Log: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Log *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LogGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LogicalAnd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogicalAnd *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LogicalNot: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogicalNot *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LogicalOr: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogicalOr *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LpNormalization: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LpNormalization *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LRN: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LRN *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LshProjection: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LshProjection *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LSTM: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTM *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_L2NormalizeFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::L2NormalizeFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_MatMulFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MatMulFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Maximum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Maximum *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_MaximumGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaximumGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_MaxPoolFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_MaxPoolGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SwitchLayer: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SwitchLayer *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Mfcc: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Mfcc *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Minimum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Minimum *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_MinimumGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MinimumGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Mod: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Mod *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_MulFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MulFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_MulGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MulGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Neg: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Neg *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_NegGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NegGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_NotEqual: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NotEqual *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_NonMaxSuppression: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NonMaxSuppression *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_OneHot: {
+      auto ptr = reinterpret_cast<const mindspore::schema::OneHot *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_OnesLike: {
+      auto ptr = reinterpret_cast<const mindspore::schema::OnesLike *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_PadFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PadFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_PartialFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PartialFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_PowerGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PowerGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_PowFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PowFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_PriorBox: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PriorBox *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_PReLUFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PReLUFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_QuantDTypeCast: {
+      auto ptr = reinterpret_cast<const mindspore::schema::QuantDTypeCast *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Rank: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Rank *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Range: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Range *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Reciprocal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Reciprocal *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_RealDiv: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RealDiv *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ReduceFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReduceFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Reshape: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Reshape *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Resize: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Resize *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ReverseSequence: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReverseSequence *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ReverseV2: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReverseV2 *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Rfft: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Rfft *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ROIPooling: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ROIPooling *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Round: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Round *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Rsqrt: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Rsqrt *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ScaleFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ScaleFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ScatterNd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNd *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SGD: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SGD *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Shape: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Shape *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogits *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Sin: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Sin *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SkipGram: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SkipGram *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SliceFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SliceFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SmoothL1Loss: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1Loss *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SmoothL1LossGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1LossGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Softmax: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Softmax *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SoftmaxCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SoftmaxCrossEntropyWithLogits *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SpaceToBatch: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatch *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SpaceToBatchND: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatchND *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SpaceToDepth: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToDepth *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SparseSoftmaxCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SparseSoftmaxCrossEntropyWithLogits *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SparseToDense: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SparseToDense *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Split: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Split *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Sqrt: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Sqrt *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Squeeze: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Squeeze *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Square: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Square *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SquaredDifference: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SquaredDifference *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Stack: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Stack *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_StridedSlice: {
+      auto ptr = reinterpret_cast<const mindspore::schema::StridedSlice *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SubFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SubFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SubGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SubGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Switch: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Switch *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_TensorListFromTensor: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListFromTensor *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_TensorListGetItem: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListGetItem *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_TensorListReserve: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListReserve *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_TensorListSetItem: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListSetItem *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_TensorListStack: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListStack *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_TileFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TileFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_TopKFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TopKFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Transpose: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Transpose *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Unique: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Unique *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_UnsortedSegmentSum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::UnsortedSegmentSum *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Unsqueeze: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Unsqueeze *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Unstack: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Unstack *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LSTMGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Where: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Where *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ZerosLike: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ZerosLike *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Select: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Select *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ScatterNdUpdate: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNdUpdate *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_GRU: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GRU *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_NonZero: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NonZero *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_InvertPermutation: {
+      auto ptr = reinterpret_cast<const mindspore::schema::InvertPermutation *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Size: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Size *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_RandomStandardNormal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RandomStandardNormal *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_CropAndResize: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CropAndResize *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Erf: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Erf *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_StridedSliceGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::StridedSliceGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_IsFinite: {
+      auto ptr = reinterpret_cast<const mindspore::schema::IsFinite *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LinSpace: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LinSpace *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_UniformReal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::UniformReal *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_AbsGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AbsGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_RsqrtGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RsqrtGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SqrtGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SqrtGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LayerNormGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ResizeGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ResizeGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Splice: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Splice *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LogSoftmax: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogSoftmax *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Call: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Call *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Custom: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Custom *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_CumSum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CumSum *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_SplitWithOverlap: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SplitWithOverlap *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_GenOP: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GenOP *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_RaggedRange: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RaggedRange *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_GLU: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GLU *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_TensorArray: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorArray *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_TensorArrayRead: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayRead *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_TensorArrayWrite: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayWrite *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_Affine: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Affine *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_AllGather: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AllGather *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_ReduceScatter: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReduceScatter *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_DynamicQuant: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DynamicQuant *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LSTMGradData: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGradData *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_LSTMGradWeight: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGradWeight *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_RandomNormal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RandomNormal *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_NLLLoss: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NLLLoss *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_NLLLossGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NLLLossGrad *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_FormatTranspose: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FormatTranspose *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_GatherD: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GatherD *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    case PrimitiveType_GroupNormFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GroupNormFusion *>(obj);
+      return ptr->UnPack(resolver);
+    }
+    default: return nullptr;
+  }
+}
+
+inline flatbuffers::Offset<void> PrimitiveTypeUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
+  switch (type) {
+    case PrimitiveType_Abs: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AbsT *>(value);
+      return CreateAbs(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Activation: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ActivationT *>(value);
+      return CreateActivation(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ActivationGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ActivationGradT *>(value);
+      return CreateActivationGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Adam: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AdamT *>(value);
+      return CreateAdam(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_AddFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AddFusionT *>(value);
+      return CreateAddFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_AdderFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AdderFusionT *>(value);
+      return CreateAdderFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_AddGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AddGradT *>(value);
+      return CreateAddGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_AddN: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AddNT *>(value);
+      return CreateAddN(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_All: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AllT *>(value);
+      return CreateAll(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ApplyMomentum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ApplyMomentumT *>(value);
+      return CreateApplyMomentum(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ArgMaxFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ArgMaxFusionT *>(value);
+      return CreateArgMaxFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ArgMinFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ArgMinFusionT *>(value);
+      return CreateArgMinFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Assert: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AssertT *>(value);
+      return CreateAssert(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Assign: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AssignT *>(value);
+      return CreateAssign(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_AssignAdd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AssignAddT *>(value);
+      return CreateAssignAdd(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_AudioSpectrogram: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AudioSpectrogramT *>(value);
+      return CreateAudioSpectrogram(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_AvgPoolFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolFusionT *>(value);
+      return CreateAvgPoolFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_AvgPoolGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolGradT *>(value);
+      return CreateAvgPoolGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_BatchNorm: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchNormT *>(value);
+      return CreateBatchNorm(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_BatchNormGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchNormGradT *>(value);
+      return CreateBatchNormGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_BatchToSpace: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpaceT *>(value);
+      return CreateBatchToSpace(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_BatchToSpaceND: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpaceNDT *>(value);
+      return CreateBatchToSpaceND(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_BiasAdd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BiasAddT *>(value);
+      return CreateBiasAdd(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_BinaryCrossEntropy: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropyT *>(value);
+      return CreateBinaryCrossEntropy(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_BinaryCrossEntropyGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropyGradT *>(value);
+      return CreateBinaryCrossEntropyGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_BiasAddGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BiasAddGradT *>(value);
+      return CreateBiasAddGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_BroadcastTo: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BroadcastToT *>(value);
+      return CreateBroadcastTo(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Cast: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CastT *>(value);
+      return CreateCast(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Ceil: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CeilT *>(value);
+      return CreateCeil(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Clip: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ClipT *>(value);
+      return CreateClip(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Concat: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ConcatT *>(value);
+      return CreateConcat(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Attention: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AttentionT *>(value);
+      return CreateAttention(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Conv2DBackpropFilterFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropFilterFusionT *>(value);
+      return CreateConv2DBackpropFilterFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Conv2DBackpropInputFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropInputFusionT *>(value);
+      return CreateConv2DBackpropInputFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Conv2DFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DFusionT *>(value);
+      return CreateConv2DFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Conv2dTransposeFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2dTransposeFusionT *>(value);
+      return CreateConv2dTransposeFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Cos: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CosT *>(value);
+      return CreateCos(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ConstantOfShape: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ConstantOfShapeT *>(value);
+      return CreateConstantOfShape(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Crop: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CropT *>(value);
+      return CreateCrop(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_CustomExtractFeatures: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomExtractFeaturesT *>(value);
+      return CreateCustomExtractFeatures(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_CustomNormalize: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomNormalizeT *>(value);
+      return CreateCustomNormalize(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_CustomPredict: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomPredictT *>(value);
+      return CreateCustomPredict(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_DeConv2DGradFilter: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DeConv2DGradFilterT *>(value);
+      return CreateDeConv2DGradFilter(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Depend: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DependT *>(value);
+      return CreateDepend(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_DepthToSpace: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DepthToSpaceT *>(value);
+      return CreateDepthToSpace(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_DetectionPostProcess: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DetectionPostProcessT *>(value);
+      return CreateDetectionPostProcess(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_DivFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DivFusionT *>(value);
+      return CreateDivFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_DivGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DivGradT *>(value);
+      return CreateDivGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Dropout: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DropoutT *>(value);
+      return CreateDropout(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_DropoutGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DropoutGradT *>(value);
+      return CreateDropoutGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Elu: {
+      auto ptr = reinterpret_cast<const mindspore::schema::EluT *>(value);
+      return CreateElu(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Eltwise: {
+      auto ptr = reinterpret_cast<const mindspore::schema::EltwiseT *>(value);
+      return CreateEltwise(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Equal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::EqualT *>(value);
+      return CreateEqual(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_EmbeddingLookupFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::EmbeddingLookupFusionT *>(value);
+      return CreateEmbeddingLookupFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ExpFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ExpFusionT *>(value);
+      return CreateExpFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ExpandDims: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ExpandDimsT *>(value);
+      return CreateExpandDims(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_FakeQuantWithMinMaxVars: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsT *>(value);
+      return CreateFakeQuantWithMinMaxVars(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_FakeQuantWithMinMaxVarsPerChannel: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *>(value);
+      return CreateFakeQuantWithMinMaxVarsPerChannel(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_FftReal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FftRealT *>(value);
+      return CreateFftReal(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_FftImag: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FftImagT *>(value);
+      return CreateFftImag(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Flatten: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FlattenT *>(value);
+      return CreateFlatten(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_FlattenGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FlattenGradT *>(value);
+      return CreateFlattenGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Floor: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FloorT *>(value);
+      return CreateFloor(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_FloorDiv: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FloorDivT *>(value);
+      return CreateFloorDiv(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_FloorMod: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FloorModT *>(value);
+      return CreateFloorMod(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Fill: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FillT *>(value);
+      return CreateFill(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_FullConnection: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FullConnectionT *>(value);
+      return CreateFullConnection(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_FusedBatchNorm: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FusedBatchNormT *>(value);
+      return CreateFusedBatchNorm(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Gather: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GatherT *>(value);
+      return CreateGather(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_GatherNd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GatherNdT *>(value);
+      return CreateGatherNd(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Greater: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GreaterT *>(value);
+      return CreateGreater(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_GreaterEqual: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GreaterEqualT *>(value);
+      return CreateGreaterEqual(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_HashtableLookup: {
+      auto ptr = reinterpret_cast<const mindspore::schema::HashtableLookupT *>(value);
+      return CreateHashtableLookup(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_InstanceNorm: {
+      auto ptr = reinterpret_cast<const mindspore::schema::InstanceNormT *>(value);
+      return CreateInstanceNorm(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LayerNormFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormFusionT *>(value);
+      return CreateLayerNormFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LeakyRelu: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LeakyReluT *>(value);
+      return CreateLeakyRelu(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Less: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LessT *>(value);
+      return CreateLess(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LessEqual: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LessEqualT *>(value);
+      return CreateLessEqual(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Log: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogT *>(value);
+      return CreateLog(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LogGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogGradT *>(value);
+      return CreateLogGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LogicalAnd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogicalAndT *>(value);
+      return CreateLogicalAnd(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LogicalNot: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogicalNotT *>(value);
+      return CreateLogicalNot(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LogicalOr: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogicalOrT *>(value);
+      return CreateLogicalOr(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LpNormalization: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LpNormalizationT *>(value);
+      return CreateLpNormalization(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LRN: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LRNT *>(value);
+      return CreateLRN(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LshProjection: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LshProjectionT *>(value);
+      return CreateLshProjection(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LSTM: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMT *>(value);
+      return CreateLSTM(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_L2NormalizeFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::L2NormalizeFusionT *>(value);
+      return CreateL2NormalizeFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_MatMulFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MatMulFusionT *>(value);
+      return CreateMatMulFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Maximum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaximumT *>(value);
+      return CreateMaximum(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_MaximumGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaximumGradT *>(value);
+      return CreateMaximumGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_MaxPoolFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolFusionT *>(value);
+      return CreateMaxPoolFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_MaxPoolGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolGradT *>(value);
+      return CreateMaxPoolGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SwitchLayer: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SwitchLayerT *>(value);
+      return CreateSwitchLayer(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Mfcc: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MfccT *>(value);
+      return CreateMfcc(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Minimum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MinimumT *>(value);
+      return CreateMinimum(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_MinimumGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MinimumGradT *>(value);
+      return CreateMinimumGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Mod: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ModT *>(value);
+      return CreateMod(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_MulFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MulFusionT *>(value);
+      return CreateMulFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_MulGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MulGradT *>(value);
+      return CreateMulGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Neg: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NegT *>(value);
+      return CreateNeg(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_NegGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NegGradT *>(value);
+      return CreateNegGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_NotEqual: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NotEqualT *>(value);
+      return CreateNotEqual(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_NonMaxSuppression: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NonMaxSuppressionT *>(value);
+      return CreateNonMaxSuppression(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_OneHot: {
+      auto ptr = reinterpret_cast<const mindspore::schema::OneHotT *>(value);
+      return CreateOneHot(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_OnesLike: {
+      auto ptr = reinterpret_cast<const mindspore::schema::OnesLikeT *>(value);
+      return CreateOnesLike(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_PadFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PadFusionT *>(value);
+      return CreatePadFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_PartialFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PartialFusionT *>(value);
+      return CreatePartialFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_PowerGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PowerGradT *>(value);
+      return CreatePowerGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_PowFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PowFusionT *>(value);
+      return CreatePowFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_PriorBox: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PriorBoxT *>(value);
+      return CreatePriorBox(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_PReLUFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PReLUFusionT *>(value);
+      return CreatePReLUFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_QuantDTypeCast: {
+      auto ptr = reinterpret_cast<const mindspore::schema::QuantDTypeCastT *>(value);
+      return CreateQuantDTypeCast(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Rank: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RankT *>(value);
+      return CreateRank(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Range: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RangeT *>(value);
+      return CreateRange(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Reciprocal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReciprocalT *>(value);
+      return CreateReciprocal(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_RealDiv: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RealDivT *>(value);
+      return CreateRealDiv(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ReduceFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReduceFusionT *>(value);
+      return CreateReduceFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Reshape: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReshapeT *>(value);
+      return CreateReshape(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Resize: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ResizeT *>(value);
+      return CreateResize(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ReverseSequence: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReverseSequenceT *>(value);
+      return CreateReverseSequence(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ReverseV2: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReverseV2T *>(value);
+      return CreateReverseV2(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Rfft: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RfftT *>(value);
+      return CreateRfft(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ROIPooling: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ROIPoolingT *>(value);
+      return CreateROIPooling(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Round: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RoundT *>(value);
+      return CreateRound(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Rsqrt: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RsqrtT *>(value);
+      return CreateRsqrt(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ScaleFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ScaleFusionT *>(value);
+      return CreateScaleFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ScatterNd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNdT *>(value);
+      return CreateScatterNd(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SGD: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SGDT *>(value);
+      return CreateSGD(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Shape: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ShapeT *>(value);
+      return CreateShape(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsT *>(value);
+      return CreateSigmoidCrossEntropyWithLogits(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *>(value);
+      return CreateSigmoidCrossEntropyWithLogitsGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Sin: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SinT *>(value);
+      return CreateSin(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SkipGram: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SkipGramT *>(value);
+      return CreateSkipGram(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SliceFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SliceFusionT *>(value);
+      return CreateSliceFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SmoothL1Loss: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1LossT *>(value);
+      return CreateSmoothL1Loss(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SmoothL1LossGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1LossGradT *>(value);
+      return CreateSmoothL1LossGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Softmax: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SoftmaxT *>(value);
+      return CreateSoftmax(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SoftmaxCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SoftmaxCrossEntropyWithLogitsT *>(value);
+      return CreateSoftmaxCrossEntropyWithLogits(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SpaceToBatch: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatchT *>(value);
+      return CreateSpaceToBatch(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SpaceToBatchND: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatchNDT *>(value);
+      return CreateSpaceToBatchND(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SpaceToDepth: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToDepthT *>(value);
+      return CreateSpaceToDepth(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SparseSoftmaxCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *>(value);
+      return CreateSparseSoftmaxCrossEntropyWithLogits(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SparseToDense: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SparseToDenseT *>(value);
+      return CreateSparseToDense(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Split: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SplitT *>(value);
+      return CreateSplit(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Sqrt: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SqrtT *>(value);
+      return CreateSqrt(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Squeeze: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SqueezeT *>(value);
+      return CreateSqueeze(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Square: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SquareT *>(value);
+      return CreateSquare(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SquaredDifference: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SquaredDifferenceT *>(value);
+      return CreateSquaredDifference(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Stack: {
+      auto ptr = reinterpret_cast<const mindspore::schema::StackT *>(value);
+      return CreateStack(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_StridedSlice: {
+      auto ptr = reinterpret_cast<const mindspore::schema::StridedSliceT *>(value);
+      return CreateStridedSlice(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SubFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SubFusionT *>(value);
+      return CreateSubFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SubGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SubGradT *>(value);
+      return CreateSubGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Switch: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SwitchT *>(value);
+      return CreateSwitch(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_TensorListFromTensor: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListFromTensorT *>(value);
+      return CreateTensorListFromTensor(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_TensorListGetItem: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListGetItemT *>(value);
+      return CreateTensorListGetItem(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_TensorListReserve: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListReserveT *>(value);
+      return CreateTensorListReserve(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_TensorListSetItem: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListSetItemT *>(value);
+      return CreateTensorListSetItem(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_TensorListStack: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListStackT *>(value);
+      return CreateTensorListStack(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_TileFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TileFusionT *>(value);
+      return CreateTileFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_TopKFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TopKFusionT *>(value);
+      return CreateTopKFusion(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Transpose: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TransposeT *>(value);
+      return CreateTranspose(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Unique: {
+      auto ptr = reinterpret_cast<const mindspore::schema::UniqueT *>(value);
+      return CreateUnique(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_UnsortedSegmentSum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::UnsortedSegmentSumT *>(value);
+      return CreateUnsortedSegmentSum(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Unsqueeze: {
+      auto ptr = reinterpret_cast<const mindspore::schema::UnsqueezeT *>(value);
+      return CreateUnsqueeze(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Unstack: {
+      auto ptr = reinterpret_cast<const mindspore::schema::UnstackT *>(value);
+      return CreateUnstack(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LSTMGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGradT *>(value);
+      return CreateLSTMGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Where: {
+      auto ptr = reinterpret_cast<const mindspore::schema::WhereT *>(value);
+      return CreateWhere(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ZerosLike: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ZerosLikeT *>(value);
+      return CreateZerosLike(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Select: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SelectT *>(value);
+      return CreateSelect(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ScatterNdUpdate: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNdUpdateT *>(value);
+      return CreateScatterNdUpdate(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_GRU: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GRUT *>(value);
+      return CreateGRU(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_NonZero: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NonZeroT *>(value);
+      return CreateNonZero(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_InvertPermutation: {
+      auto ptr = reinterpret_cast<const mindspore::schema::InvertPermutationT *>(value);
+      return CreateInvertPermutation(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Size: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SizeT *>(value);
+      return CreateSize(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_RandomStandardNormal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RandomStandardNormalT *>(value);
+      return CreateRandomStandardNormal(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_CropAndResize: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CropAndResizeT *>(value);
+      return CreateCropAndResize(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Erf: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ErfT *>(value);
+      return CreateErf(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_StridedSliceGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::StridedSliceGradT *>(value);
+      return CreateStridedSliceGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_IsFinite: {
+      auto ptr = reinterpret_cast<const mindspore::schema::IsFiniteT *>(value);
+      return CreateIsFinite(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LinSpace: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LinSpaceT *>(value);
+      return CreateLinSpace(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_UniformReal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::UniformRealT *>(value);
+      return CreateUniformReal(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_AbsGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AbsGradT *>(value);
+      return CreateAbsGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_RsqrtGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RsqrtGradT *>(value);
+      return CreateRsqrtGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SqrtGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SqrtGradT *>(value);
+      return CreateSqrtGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LayerNormGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormGradT *>(value);
+      return CreateLayerNormGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ResizeGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ResizeGradT *>(value);
+      return CreateResizeGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Splice: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpliceT *>(value);
+      return CreateSplice(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LogSoftmax: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogSoftmaxT *>(value);
+      return CreateLogSoftmax(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Call: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CallT *>(value);
+      return CreateCall(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Custom: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomT *>(value);
+      return CreateCustom(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_CumSum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CumSumT *>(value);
+      return CreateCumSum(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_SplitWithOverlap: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SplitWithOverlapT *>(value);
+      return CreateSplitWithOverlap(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_GenOP: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GenOPT *>(value);
+      return CreateGenOP(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_RaggedRange: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RaggedRangeT *>(value);
+      return CreateRaggedRange(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_GLU: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GLUT *>(value);
+      return CreateGLU(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_TensorArray: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayT *>(value);
+      return CreateTensorArray(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_TensorArrayRead: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayReadT *>(value);
+      return CreateTensorArrayRead(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_TensorArrayWrite: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayWriteT *>(value);
+      return CreateTensorArrayWrite(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_Affine: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AffineT *>(value);
+      return CreateAffine(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_AllGather: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AllGatherT *>(value);
+      return CreateAllGather(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_ReduceScatter: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReduceScatterT *>(value);
+      return CreateReduceScatter(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_DynamicQuant: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DynamicQuantT *>(value);
+      return CreateDynamicQuant(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LSTMGradData: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGradDataT *>(value);
+      return CreateLSTMGradData(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_LSTMGradWeight: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGradWeightT *>(value);
+      return CreateLSTMGradWeight(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_RandomNormal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RandomNormalT *>(value);
+      return CreateRandomNormal(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_NLLLoss: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NLLLossT *>(value);
+      return CreateNLLLoss(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_NLLLossGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NLLLossGradT *>(value);
+      return CreateNLLLossGrad(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_FormatTranspose: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FormatTransposeT *>(value);
+      return CreateFormatTranspose(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_GatherD: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GatherDT *>(value);
+      return CreateGatherD(_fbb, ptr, _rehasher).Union();
+    }
+    case PrimitiveType_GroupNormFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GroupNormFusionT *>(value);
+      return CreateGroupNormFusion(_fbb, ptr, _rehasher).Union();
+    }
+    default: return 0;
+  }
+}
+
+inline PrimitiveTypeUnion::PrimitiveTypeUnion(const PrimitiveTypeUnion &u) : type(u.type), value(nullptr) {
+  switch (type) {
+    case PrimitiveType_Abs: {
+      value = new mindspore::schema::AbsT(*reinterpret_cast<mindspore::schema::AbsT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Activation: {
+      value = new mindspore::schema::ActivationT(*reinterpret_cast<mindspore::schema::ActivationT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ActivationGrad: {
+      value = new mindspore::schema::ActivationGradT(*reinterpret_cast<mindspore::schema::ActivationGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Adam: {
+      value = new mindspore::schema::AdamT(*reinterpret_cast<mindspore::schema::AdamT *>(u.value));
+      break;
+    }
+    case PrimitiveType_AddFusion: {
+      value = new mindspore::schema::AddFusionT(*reinterpret_cast<mindspore::schema::AddFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_AdderFusion: {
+      value = new mindspore::schema::AdderFusionT(*reinterpret_cast<mindspore::schema::AdderFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_AddGrad: {
+      value = new mindspore::schema::AddGradT(*reinterpret_cast<mindspore::schema::AddGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_AddN: {
+      value = new mindspore::schema::AddNT(*reinterpret_cast<mindspore::schema::AddNT *>(u.value));
+      break;
+    }
+    case PrimitiveType_All: {
+      value = new mindspore::schema::AllT(*reinterpret_cast<mindspore::schema::AllT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ApplyMomentum: {
+      value = new mindspore::schema::ApplyMomentumT(*reinterpret_cast<mindspore::schema::ApplyMomentumT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ArgMaxFusion: {
+      value = new mindspore::schema::ArgMaxFusionT(*reinterpret_cast<mindspore::schema::ArgMaxFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ArgMinFusion: {
+      value = new mindspore::schema::ArgMinFusionT(*reinterpret_cast<mindspore::schema::ArgMinFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Assert: {
+      value = new mindspore::schema::AssertT(*reinterpret_cast<mindspore::schema::AssertT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Assign: {
+      value = new mindspore::schema::AssignT(*reinterpret_cast<mindspore::schema::AssignT *>(u.value));
+      break;
+    }
+    case PrimitiveType_AssignAdd: {
+      value = new mindspore::schema::AssignAddT(*reinterpret_cast<mindspore::schema::AssignAddT *>(u.value));
+      break;
+    }
+    case PrimitiveType_AudioSpectrogram: {
+      value = new mindspore::schema::AudioSpectrogramT(*reinterpret_cast<mindspore::schema::AudioSpectrogramT *>(u.value));
+      break;
+    }
+    case PrimitiveType_AvgPoolFusion: {
+      value = new mindspore::schema::AvgPoolFusionT(*reinterpret_cast<mindspore::schema::AvgPoolFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_AvgPoolGrad: {
+      value = new mindspore::schema::AvgPoolGradT(*reinterpret_cast<mindspore::schema::AvgPoolGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_BatchNorm: {
+      value = new mindspore::schema::BatchNormT(*reinterpret_cast<mindspore::schema::BatchNormT *>(u.value));
+      break;
+    }
+    case PrimitiveType_BatchNormGrad: {
+      value = new mindspore::schema::BatchNormGradT(*reinterpret_cast<mindspore::schema::BatchNormGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_BatchToSpace: {
+      FLATBUFFERS_ASSERT(false);  // mindspore::schema::BatchToSpaceT not copyable.
+      break;
+    }
+    case PrimitiveType_BatchToSpaceND: {
+      FLATBUFFERS_ASSERT(false);  // mindspore::schema::BatchToSpaceNDT not copyable.
+      break;
+    }
+    case PrimitiveType_BiasAdd: {
+      value = new mindspore::schema::BiasAddT(*reinterpret_cast<mindspore::schema::BiasAddT *>(u.value));
+      break;
+    }
+    case PrimitiveType_BinaryCrossEntropy: {
+      value = new mindspore::schema::BinaryCrossEntropyT(*reinterpret_cast<mindspore::schema::BinaryCrossEntropyT *>(u.value));
+      break;
+    }
+    case PrimitiveType_BinaryCrossEntropyGrad: {
+      value = new mindspore::schema::BinaryCrossEntropyGradT(*reinterpret_cast<mindspore::schema::BinaryCrossEntropyGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_BiasAddGrad: {
+      value = new mindspore::schema::BiasAddGradT(*reinterpret_cast<mindspore::schema::BiasAddGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_BroadcastTo: {
+      value = new mindspore::schema::BroadcastToT(*reinterpret_cast<mindspore::schema::BroadcastToT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Cast: {
+      value = new mindspore::schema::CastT(*reinterpret_cast<mindspore::schema::CastT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Ceil: {
+      value = new mindspore::schema::CeilT(*reinterpret_cast<mindspore::schema::CeilT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Clip: {
+      value = new mindspore::schema::ClipT(*reinterpret_cast<mindspore::schema::ClipT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Concat: {
+      value = new mindspore::schema::ConcatT(*reinterpret_cast<mindspore::schema::ConcatT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Attention: {
+      value = new mindspore::schema::AttentionT(*reinterpret_cast<mindspore::schema::AttentionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Conv2DBackpropFilterFusion: {
+      value = new mindspore::schema::Conv2DBackpropFilterFusionT(*reinterpret_cast<mindspore::schema::Conv2DBackpropFilterFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Conv2DBackpropInputFusion: {
+      value = new mindspore::schema::Conv2DBackpropInputFusionT(*reinterpret_cast<mindspore::schema::Conv2DBackpropInputFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Conv2DFusion: {
+      value = new mindspore::schema::Conv2DFusionT(*reinterpret_cast<mindspore::schema::Conv2DFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Conv2dTransposeFusion: {
+      value = new mindspore::schema::Conv2dTransposeFusionT(*reinterpret_cast<mindspore::schema::Conv2dTransposeFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Cos: {
+      value = new mindspore::schema::CosT(*reinterpret_cast<mindspore::schema::CosT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ConstantOfShape: {
+      value = new mindspore::schema::ConstantOfShapeT(*reinterpret_cast<mindspore::schema::ConstantOfShapeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Crop: {
+      value = new mindspore::schema::CropT(*reinterpret_cast<mindspore::schema::CropT *>(u.value));
+      break;
+    }
+    case PrimitiveType_CustomExtractFeatures: {
+      value = new mindspore::schema::CustomExtractFeaturesT(*reinterpret_cast<mindspore::schema::CustomExtractFeaturesT *>(u.value));
+      break;
+    }
+    case PrimitiveType_CustomNormalize: {
+      value = new mindspore::schema::CustomNormalizeT(*reinterpret_cast<mindspore::schema::CustomNormalizeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_CustomPredict: {
+      value = new mindspore::schema::CustomPredictT(*reinterpret_cast<mindspore::schema::CustomPredictT *>(u.value));
+      break;
+    }
+    case PrimitiveType_DeConv2DGradFilter: {
+      value = new mindspore::schema::DeConv2DGradFilterT(*reinterpret_cast<mindspore::schema::DeConv2DGradFilterT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Depend: {
+      value = new mindspore::schema::DependT(*reinterpret_cast<mindspore::schema::DependT *>(u.value));
+      break;
+    }
+    case PrimitiveType_DepthToSpace: {
+      value = new mindspore::schema::DepthToSpaceT(*reinterpret_cast<mindspore::schema::DepthToSpaceT *>(u.value));
+      break;
+    }
+    case PrimitiveType_DetectionPostProcess: {
+      value = new mindspore::schema::DetectionPostProcessT(*reinterpret_cast<mindspore::schema::DetectionPostProcessT *>(u.value));
+      break;
+    }
+    case PrimitiveType_DivFusion: {
+      value = new mindspore::schema::DivFusionT(*reinterpret_cast<mindspore::schema::DivFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_DivGrad: {
+      value = new mindspore::schema::DivGradT(*reinterpret_cast<mindspore::schema::DivGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Dropout: {
+      value = new mindspore::schema::DropoutT(*reinterpret_cast<mindspore::schema::DropoutT *>(u.value));
+      break;
+    }
+    case PrimitiveType_DropoutGrad: {
+      value = new mindspore::schema::DropoutGradT(*reinterpret_cast<mindspore::schema::DropoutGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Elu: {
+      value = new mindspore::schema::EluT(*reinterpret_cast<mindspore::schema::EluT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Eltwise: {
+      value = new mindspore::schema::EltwiseT(*reinterpret_cast<mindspore::schema::EltwiseT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Equal: {
+      value = new mindspore::schema::EqualT(*reinterpret_cast<mindspore::schema::EqualT *>(u.value));
+      break;
+    }
+    case PrimitiveType_EmbeddingLookupFusion: {
+      value = new mindspore::schema::EmbeddingLookupFusionT(*reinterpret_cast<mindspore::schema::EmbeddingLookupFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ExpFusion: {
+      value = new mindspore::schema::ExpFusionT(*reinterpret_cast<mindspore::schema::ExpFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ExpandDims: {
+      value = new mindspore::schema::ExpandDimsT(*reinterpret_cast<mindspore::schema::ExpandDimsT *>(u.value));
+      break;
+    }
+    case PrimitiveType_FakeQuantWithMinMaxVars: {
+      value = new mindspore::schema::FakeQuantWithMinMaxVarsT(*reinterpret_cast<mindspore::schema::FakeQuantWithMinMaxVarsT *>(u.value));
+      break;
+    }
+    case PrimitiveType_FakeQuantWithMinMaxVarsPerChannel: {
+      value = new mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT(*reinterpret_cast<mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *>(u.value));
+      break;
+    }
+    case PrimitiveType_FftReal: {
+      value = new mindspore::schema::FftRealT(*reinterpret_cast<mindspore::schema::FftRealT *>(u.value));
+      break;
+    }
+    case PrimitiveType_FftImag: {
+      value = new mindspore::schema::FftImagT(*reinterpret_cast<mindspore::schema::FftImagT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Flatten: {
+      value = new mindspore::schema::FlattenT(*reinterpret_cast<mindspore::schema::FlattenT *>(u.value));
+      break;
+    }
+    case PrimitiveType_FlattenGrad: {
+      value = new mindspore::schema::FlattenGradT(*reinterpret_cast<mindspore::schema::FlattenGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Floor: {
+      value = new mindspore::schema::FloorT(*reinterpret_cast<mindspore::schema::FloorT *>(u.value));
+      break;
+    }
+    case PrimitiveType_FloorDiv: {
+      value = new mindspore::schema::FloorDivT(*reinterpret_cast<mindspore::schema::FloorDivT *>(u.value));
+      break;
+    }
+    case PrimitiveType_FloorMod: {
+      value = new mindspore::schema::FloorModT(*reinterpret_cast<mindspore::schema::FloorModT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Fill: {
+      value = new mindspore::schema::FillT(*reinterpret_cast<mindspore::schema::FillT *>(u.value));
+      break;
+    }
+    case PrimitiveType_FullConnection: {
+      value = new mindspore::schema::FullConnectionT(*reinterpret_cast<mindspore::schema::FullConnectionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_FusedBatchNorm: {
+      value = new mindspore::schema::FusedBatchNormT(*reinterpret_cast<mindspore::schema::FusedBatchNormT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Gather: {
+      value = new mindspore::schema::GatherT(*reinterpret_cast<mindspore::schema::GatherT *>(u.value));
+      break;
+    }
+    case PrimitiveType_GatherNd: {
+      value = new mindspore::schema::GatherNdT(*reinterpret_cast<mindspore::schema::GatherNdT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Greater: {
+      value = new mindspore::schema::GreaterT(*reinterpret_cast<mindspore::schema::GreaterT *>(u.value));
+      break;
+    }
+    case PrimitiveType_GreaterEqual: {
+      value = new mindspore::schema::GreaterEqualT(*reinterpret_cast<mindspore::schema::GreaterEqualT *>(u.value));
+      break;
+    }
+    case PrimitiveType_HashtableLookup: {
+      value = new mindspore::schema::HashtableLookupT(*reinterpret_cast<mindspore::schema::HashtableLookupT *>(u.value));
+      break;
+    }
+    case PrimitiveType_InstanceNorm: {
+      value = new mindspore::schema::InstanceNormT(*reinterpret_cast<mindspore::schema::InstanceNormT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LayerNormFusion: {
+      value = new mindspore::schema::LayerNormFusionT(*reinterpret_cast<mindspore::schema::LayerNormFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LeakyRelu: {
+      value = new mindspore::schema::LeakyReluT(*reinterpret_cast<mindspore::schema::LeakyReluT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Less: {
+      value = new mindspore::schema::LessT(*reinterpret_cast<mindspore::schema::LessT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LessEqual: {
+      value = new mindspore::schema::LessEqualT(*reinterpret_cast<mindspore::schema::LessEqualT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Log: {
+      value = new mindspore::schema::LogT(*reinterpret_cast<mindspore::schema::LogT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LogGrad: {
+      value = new mindspore::schema::LogGradT(*reinterpret_cast<mindspore::schema::LogGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LogicalAnd: {
+      value = new mindspore::schema::LogicalAndT(*reinterpret_cast<mindspore::schema::LogicalAndT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LogicalNot: {
+      value = new mindspore::schema::LogicalNotT(*reinterpret_cast<mindspore::schema::LogicalNotT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LogicalOr: {
+      value = new mindspore::schema::LogicalOrT(*reinterpret_cast<mindspore::schema::LogicalOrT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LpNormalization: {
+      value = new mindspore::schema::LpNormalizationT(*reinterpret_cast<mindspore::schema::LpNormalizationT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LRN: {
+      value = new mindspore::schema::LRNT(*reinterpret_cast<mindspore::schema::LRNT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LshProjection: {
+      value = new mindspore::schema::LshProjectionT(*reinterpret_cast<mindspore::schema::LshProjectionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LSTM: {
+      value = new mindspore::schema::LSTMT(*reinterpret_cast<mindspore::schema::LSTMT *>(u.value));
+      break;
+    }
+    case PrimitiveType_L2NormalizeFusion: {
+      value = new mindspore::schema::L2NormalizeFusionT(*reinterpret_cast<mindspore::schema::L2NormalizeFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_MatMulFusion: {
+      value = new mindspore::schema::MatMulFusionT(*reinterpret_cast<mindspore::schema::MatMulFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Maximum: {
+      value = new mindspore::schema::MaximumT(*reinterpret_cast<mindspore::schema::MaximumT *>(u.value));
+      break;
+    }
+    case PrimitiveType_MaximumGrad: {
+      value = new mindspore::schema::MaximumGradT(*reinterpret_cast<mindspore::schema::MaximumGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_MaxPoolFusion: {
+      value = new mindspore::schema::MaxPoolFusionT(*reinterpret_cast<mindspore::schema::MaxPoolFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_MaxPoolGrad: {
+      value = new mindspore::schema::MaxPoolGradT(*reinterpret_cast<mindspore::schema::MaxPoolGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SwitchLayer: {
+      value = new mindspore::schema::SwitchLayerT(*reinterpret_cast<mindspore::schema::SwitchLayerT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Mfcc: {
+      value = new mindspore::schema::MfccT(*reinterpret_cast<mindspore::schema::MfccT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Minimum: {
+      value = new mindspore::schema::MinimumT(*reinterpret_cast<mindspore::schema::MinimumT *>(u.value));
+      break;
+    }
+    case PrimitiveType_MinimumGrad: {
+      value = new mindspore::schema::MinimumGradT(*reinterpret_cast<mindspore::schema::MinimumGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Mod: {
+      value = new mindspore::schema::ModT(*reinterpret_cast<mindspore::schema::ModT *>(u.value));
+      break;
+    }
+    case PrimitiveType_MulFusion: {
+      value = new mindspore::schema::MulFusionT(*reinterpret_cast<mindspore::schema::MulFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_MulGrad: {
+      value = new mindspore::schema::MulGradT(*reinterpret_cast<mindspore::schema::MulGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Neg: {
+      value = new mindspore::schema::NegT(*reinterpret_cast<mindspore::schema::NegT *>(u.value));
+      break;
+    }
+    case PrimitiveType_NegGrad: {
+      value = new mindspore::schema::NegGradT(*reinterpret_cast<mindspore::schema::NegGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_NotEqual: {
+      value = new mindspore::schema::NotEqualT(*reinterpret_cast<mindspore::schema::NotEqualT *>(u.value));
+      break;
+    }
+    case PrimitiveType_NonMaxSuppression: {
+      value = new mindspore::schema::NonMaxSuppressionT(*reinterpret_cast<mindspore::schema::NonMaxSuppressionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_OneHot: {
+      value = new mindspore::schema::OneHotT(*reinterpret_cast<mindspore::schema::OneHotT *>(u.value));
+      break;
+    }
+    case PrimitiveType_OnesLike: {
+      value = new mindspore::schema::OnesLikeT(*reinterpret_cast<mindspore::schema::OnesLikeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_PadFusion: {
+      FLATBUFFERS_ASSERT(false);  // mindspore::schema::PadFusionT not copyable.
+      break;
+    }
+    case PrimitiveType_PartialFusion: {
+      value = new mindspore::schema::PartialFusionT(*reinterpret_cast<mindspore::schema::PartialFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_PowerGrad: {
+      value = new mindspore::schema::PowerGradT(*reinterpret_cast<mindspore::schema::PowerGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_PowFusion: {
+      value = new mindspore::schema::PowFusionT(*reinterpret_cast<mindspore::schema::PowFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_PriorBox: {
+      value = new mindspore::schema::PriorBoxT(*reinterpret_cast<mindspore::schema::PriorBoxT *>(u.value));
+      break;
+    }
+    case PrimitiveType_PReLUFusion: {
+      value = new mindspore::schema::PReLUFusionT(*reinterpret_cast<mindspore::schema::PReLUFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_QuantDTypeCast: {
+      value = new mindspore::schema::QuantDTypeCastT(*reinterpret_cast<mindspore::schema::QuantDTypeCastT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Rank: {
+      value = new mindspore::schema::RankT(*reinterpret_cast<mindspore::schema::RankT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Range: {
+      value = new mindspore::schema::RangeT(*reinterpret_cast<mindspore::schema::RangeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Reciprocal: {
+      value = new mindspore::schema::ReciprocalT(*reinterpret_cast<mindspore::schema::ReciprocalT *>(u.value));
+      break;
+    }
+    case PrimitiveType_RealDiv: {
+      value = new mindspore::schema::RealDivT(*reinterpret_cast<mindspore::schema::RealDivT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ReduceFusion: {
+      value = new mindspore::schema::ReduceFusionT(*reinterpret_cast<mindspore::schema::ReduceFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Reshape: {
+      value = new mindspore::schema::ReshapeT(*reinterpret_cast<mindspore::schema::ReshapeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Resize: {
+      value = new mindspore::schema::ResizeT(*reinterpret_cast<mindspore::schema::ResizeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ReverseSequence: {
+      value = new mindspore::schema::ReverseSequenceT(*reinterpret_cast<mindspore::schema::ReverseSequenceT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ReverseV2: {
+      value = new mindspore::schema::ReverseV2T(*reinterpret_cast<mindspore::schema::ReverseV2T *>(u.value));
+      break;
+    }
+    case PrimitiveType_Rfft: {
+      value = new mindspore::schema::RfftT(*reinterpret_cast<mindspore::schema::RfftT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ROIPooling: {
+      value = new mindspore::schema::ROIPoolingT(*reinterpret_cast<mindspore::schema::ROIPoolingT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Round: {
+      value = new mindspore::schema::RoundT(*reinterpret_cast<mindspore::schema::RoundT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Rsqrt: {
+      value = new mindspore::schema::RsqrtT(*reinterpret_cast<mindspore::schema::RsqrtT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ScaleFusion: {
+      value = new mindspore::schema::ScaleFusionT(*reinterpret_cast<mindspore::schema::ScaleFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ScatterNd: {
+      value = new mindspore::schema::ScatterNdT(*reinterpret_cast<mindspore::schema::ScatterNdT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SGD: {
+      value = new mindspore::schema::SGDT(*reinterpret_cast<mindspore::schema::SGDT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Shape: {
+      value = new mindspore::schema::ShapeT(*reinterpret_cast<mindspore::schema::ShapeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
+      value = new mindspore::schema::SigmoidCrossEntropyWithLogitsT(*reinterpret_cast<mindspore::schema::SigmoidCrossEntropyWithLogitsT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
+      value = new mindspore::schema::SigmoidCrossEntropyWithLogitsGradT(*reinterpret_cast<mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Sin: {
+      value = new mindspore::schema::SinT(*reinterpret_cast<mindspore::schema::SinT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SkipGram: {
+      value = new mindspore::schema::SkipGramT(*reinterpret_cast<mindspore::schema::SkipGramT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SliceFusion: {
+      value = new mindspore::schema::SliceFusionT(*reinterpret_cast<mindspore::schema::SliceFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SmoothL1Loss: {
+      value = new mindspore::schema::SmoothL1LossT(*reinterpret_cast<mindspore::schema::SmoothL1LossT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SmoothL1LossGrad: {
+      value = new mindspore::schema::SmoothL1LossGradT(*reinterpret_cast<mindspore::schema::SmoothL1LossGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Softmax: {
+      value = new mindspore::schema::SoftmaxT(*reinterpret_cast<mindspore::schema::SoftmaxT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SoftmaxCrossEntropyWithLogits: {
+      value = new mindspore::schema::SoftmaxCrossEntropyWithLogitsT(*reinterpret_cast<mindspore::schema::SoftmaxCrossEntropyWithLogitsT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SpaceToBatch: {
+      FLATBUFFERS_ASSERT(false);  // mindspore::schema::SpaceToBatchT not copyable.
+      break;
+    }
+    case PrimitiveType_SpaceToBatchND: {
+      FLATBUFFERS_ASSERT(false);  // mindspore::schema::SpaceToBatchNDT not copyable.
+      break;
+    }
+    case PrimitiveType_SpaceToDepth: {
+      value = new mindspore::schema::SpaceToDepthT(*reinterpret_cast<mindspore::schema::SpaceToDepthT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SparseSoftmaxCrossEntropyWithLogits: {
+      value = new mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT(*reinterpret_cast<mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SparseToDense: {
+      value = new mindspore::schema::SparseToDenseT(*reinterpret_cast<mindspore::schema::SparseToDenseT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Split: {
+      value = new mindspore::schema::SplitT(*reinterpret_cast<mindspore::schema::SplitT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Sqrt: {
+      value = new mindspore::schema::SqrtT(*reinterpret_cast<mindspore::schema::SqrtT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Squeeze: {
+      value = new mindspore::schema::SqueezeT(*reinterpret_cast<mindspore::schema::SqueezeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Square: {
+      value = new mindspore::schema::SquareT(*reinterpret_cast<mindspore::schema::SquareT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SquaredDifference: {
+      value = new mindspore::schema::SquaredDifferenceT(*reinterpret_cast<mindspore::schema::SquaredDifferenceT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Stack: {
+      value = new mindspore::schema::StackT(*reinterpret_cast<mindspore::schema::StackT *>(u.value));
+      break;
+    }
+    case PrimitiveType_StridedSlice: {
+      value = new mindspore::schema::StridedSliceT(*reinterpret_cast<mindspore::schema::StridedSliceT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SubFusion: {
+      value = new mindspore::schema::SubFusionT(*reinterpret_cast<mindspore::schema::SubFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SubGrad: {
+      value = new mindspore::schema::SubGradT(*reinterpret_cast<mindspore::schema::SubGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Switch: {
+      value = new mindspore::schema::SwitchT(*reinterpret_cast<mindspore::schema::SwitchT *>(u.value));
+      break;
+    }
+    case PrimitiveType_TensorListFromTensor: {
+      value = new mindspore::schema::TensorListFromTensorT(*reinterpret_cast<mindspore::schema::TensorListFromTensorT *>(u.value));
+      break;
+    }
+    case PrimitiveType_TensorListGetItem: {
+      value = new mindspore::schema::TensorListGetItemT(*reinterpret_cast<mindspore::schema::TensorListGetItemT *>(u.value));
+      break;
+    }
+    case PrimitiveType_TensorListReserve: {
+      value = new mindspore::schema::TensorListReserveT(*reinterpret_cast<mindspore::schema::TensorListReserveT *>(u.value));
+      break;
+    }
+    case PrimitiveType_TensorListSetItem: {
+      value = new mindspore::schema::TensorListSetItemT(*reinterpret_cast<mindspore::schema::TensorListSetItemT *>(u.value));
+      break;
+    }
+    case PrimitiveType_TensorListStack: {
+      value = new mindspore::schema::TensorListStackT(*reinterpret_cast<mindspore::schema::TensorListStackT *>(u.value));
+      break;
+    }
+    case PrimitiveType_TileFusion: {
+      value = new mindspore::schema::TileFusionT(*reinterpret_cast<mindspore::schema::TileFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_TopKFusion: {
+      value = new mindspore::schema::TopKFusionT(*reinterpret_cast<mindspore::schema::TopKFusionT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Transpose: {
+      value = new mindspore::schema::TransposeT(*reinterpret_cast<mindspore::schema::TransposeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Unique: {
+      value = new mindspore::schema::UniqueT(*reinterpret_cast<mindspore::schema::UniqueT *>(u.value));
+      break;
+    }
+    case PrimitiveType_UnsortedSegmentSum: {
+      value = new mindspore::schema::UnsortedSegmentSumT(*reinterpret_cast<mindspore::schema::UnsortedSegmentSumT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Unsqueeze: {
+      value = new mindspore::schema::UnsqueezeT(*reinterpret_cast<mindspore::schema::UnsqueezeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Unstack: {
+      value = new mindspore::schema::UnstackT(*reinterpret_cast<mindspore::schema::UnstackT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LSTMGrad: {
+      value = new mindspore::schema::LSTMGradT(*reinterpret_cast<mindspore::schema::LSTMGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Where: {
+      value = new mindspore::schema::WhereT(*reinterpret_cast<mindspore::schema::WhereT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ZerosLike: {
+      value = new mindspore::schema::ZerosLikeT(*reinterpret_cast<mindspore::schema::ZerosLikeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Select: {
+      value = new mindspore::schema::SelectT(*reinterpret_cast<mindspore::schema::SelectT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ScatterNdUpdate: {
+      value = new mindspore::schema::ScatterNdUpdateT(*reinterpret_cast<mindspore::schema::ScatterNdUpdateT *>(u.value));
+      break;
+    }
+    case PrimitiveType_GRU: {
+      value = new mindspore::schema::GRUT(*reinterpret_cast<mindspore::schema::GRUT *>(u.value));
+      break;
+    }
+    case PrimitiveType_NonZero: {
+      value = new mindspore::schema::NonZeroT(*reinterpret_cast<mindspore::schema::NonZeroT *>(u.value));
+      break;
+    }
+    case PrimitiveType_InvertPermutation: {
+      value = new mindspore::schema::InvertPermutationT(*reinterpret_cast<mindspore::schema::InvertPermutationT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Size: {
+      value = new mindspore::schema::SizeT(*reinterpret_cast<mindspore::schema::SizeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_RandomStandardNormal: {
+      value = new mindspore::schema::RandomStandardNormalT(*reinterpret_cast<mindspore::schema::RandomStandardNormalT *>(u.value));
+      break;
+    }
+    case PrimitiveType_CropAndResize: {
+      value = new mindspore::schema::CropAndResizeT(*reinterpret_cast<mindspore::schema::CropAndResizeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Erf: {
+      value = new mindspore::schema::ErfT(*reinterpret_cast<mindspore::schema::ErfT *>(u.value));
+      break;
+    }
+    case PrimitiveType_StridedSliceGrad: {
+      value = new mindspore::schema::StridedSliceGradT(*reinterpret_cast<mindspore::schema::StridedSliceGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_IsFinite: {
+      value = new mindspore::schema::IsFiniteT(*reinterpret_cast<mindspore::schema::IsFiniteT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LinSpace: {
+      value = new mindspore::schema::LinSpaceT(*reinterpret_cast<mindspore::schema::LinSpaceT *>(u.value));
+      break;
+    }
+    case PrimitiveType_UniformReal: {
+      value = new mindspore::schema::UniformRealT(*reinterpret_cast<mindspore::schema::UniformRealT *>(u.value));
+      break;
+    }
+    case PrimitiveType_AbsGrad: {
+      value = new mindspore::schema::AbsGradT(*reinterpret_cast<mindspore::schema::AbsGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_RsqrtGrad: {
+      value = new mindspore::schema::RsqrtGradT(*reinterpret_cast<mindspore::schema::RsqrtGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SqrtGrad: {
+      value = new mindspore::schema::SqrtGradT(*reinterpret_cast<mindspore::schema::SqrtGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LayerNormGrad: {
+      value = new mindspore::schema::LayerNormGradT(*reinterpret_cast<mindspore::schema::LayerNormGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ResizeGrad: {
+      value = new mindspore::schema::ResizeGradT(*reinterpret_cast<mindspore::schema::ResizeGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Splice: {
+      value = new mindspore::schema::SpliceT(*reinterpret_cast<mindspore::schema::SpliceT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LogSoftmax: {
+      value = new mindspore::schema::LogSoftmaxT(*reinterpret_cast<mindspore::schema::LogSoftmaxT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Call: {
+      value = new mindspore::schema::CallT(*reinterpret_cast<mindspore::schema::CallT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Custom: {
+      FLATBUFFERS_ASSERT(false);  // mindspore::schema::CustomT not copyable.
+      break;
+    }
+    case PrimitiveType_CumSum: {
+      value = new mindspore::schema::CumSumT(*reinterpret_cast<mindspore::schema::CumSumT *>(u.value));
+      break;
+    }
+    case PrimitiveType_SplitWithOverlap: {
+      value = new mindspore::schema::SplitWithOverlapT(*reinterpret_cast<mindspore::schema::SplitWithOverlapT *>(u.value));
+      break;
+    }
+    case PrimitiveType_GenOP: {
+      value = new mindspore::schema::GenOPT(*reinterpret_cast<mindspore::schema::GenOPT *>(u.value));
+      break;
+    }
+    case PrimitiveType_RaggedRange: {
+      value = new mindspore::schema::RaggedRangeT(*reinterpret_cast<mindspore::schema::RaggedRangeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_GLU: {
+      value = new mindspore::schema::GLUT(*reinterpret_cast<mindspore::schema::GLUT *>(u.value));
+      break;
+    }
+    case PrimitiveType_TensorArray: {
+      value = new mindspore::schema::TensorArrayT(*reinterpret_cast<mindspore::schema::TensorArrayT *>(u.value));
+      break;
+    }
+    case PrimitiveType_TensorArrayRead: {
+      value = new mindspore::schema::TensorArrayReadT(*reinterpret_cast<mindspore::schema::TensorArrayReadT *>(u.value));
+      break;
+    }
+    case PrimitiveType_TensorArrayWrite: {
+      value = new mindspore::schema::TensorArrayWriteT(*reinterpret_cast<mindspore::schema::TensorArrayWriteT *>(u.value));
+      break;
+    }
+    case PrimitiveType_Affine: {
+      value = new mindspore::schema::AffineT(*reinterpret_cast<mindspore::schema::AffineT *>(u.value));
+      break;
+    }
+    case PrimitiveType_AllGather: {
+      value = new mindspore::schema::AllGatherT(*reinterpret_cast<mindspore::schema::AllGatherT *>(u.value));
+      break;
+    }
+    case PrimitiveType_ReduceScatter: {
+      value = new mindspore::schema::ReduceScatterT(*reinterpret_cast<mindspore::schema::ReduceScatterT *>(u.value));
+      break;
+    }
+    case PrimitiveType_DynamicQuant: {
+      value = new mindspore::schema::DynamicQuantT(*reinterpret_cast<mindspore::schema::DynamicQuantT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LSTMGradData: {
+      value = new mindspore::schema::LSTMGradDataT(*reinterpret_cast<mindspore::schema::LSTMGradDataT *>(u.value));
+      break;
+    }
+    case PrimitiveType_LSTMGradWeight: {
+      value = new mindspore::schema::LSTMGradWeightT(*reinterpret_cast<mindspore::schema::LSTMGradWeightT *>(u.value));
+      break;
+    }
+    case PrimitiveType_RandomNormal: {
+      value = new mindspore::schema::RandomNormalT(*reinterpret_cast<mindspore::schema::RandomNormalT *>(u.value));
+      break;
+    }
+    case PrimitiveType_NLLLoss: {
+      value = new mindspore::schema::NLLLossT(*reinterpret_cast<mindspore::schema::NLLLossT *>(u.value));
+      break;
+    }
+    case PrimitiveType_NLLLossGrad: {
+      value = new mindspore::schema::NLLLossGradT(*reinterpret_cast<mindspore::schema::NLLLossGradT *>(u.value));
+      break;
+    }
+    case PrimitiveType_FormatTranspose: {
+      value = new mindspore::schema::FormatTransposeT(*reinterpret_cast<mindspore::schema::FormatTransposeT *>(u.value));
+      break;
+    }
+    case PrimitiveType_GatherD: {
+      value = new mindspore::schema::GatherDT(*reinterpret_cast<mindspore::schema::GatherDT *>(u.value));
+      break;
+    }
+    case PrimitiveType_GroupNormFusion: {
+      value = new mindspore::schema::GroupNormFusionT(*reinterpret_cast<mindspore::schema::GroupNormFusionT *>(u.value));
+      break;
+    }
+    default:
+      break;
+  }
+}
+
+inline void PrimitiveTypeUnion::Reset() {
+  switch (type) {
+    case PrimitiveType_Abs: {
+      auto ptr = reinterpret_cast<mindspore::schema::AbsT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Activation: {
+      auto ptr = reinterpret_cast<mindspore::schema::ActivationT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ActivationGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::ActivationGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Adam: {
+      auto ptr = reinterpret_cast<mindspore::schema::AdamT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_AddFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::AddFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_AdderFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::AdderFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_AddGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::AddGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_AddN: {
+      auto ptr = reinterpret_cast<mindspore::schema::AddNT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_All: {
+      auto ptr = reinterpret_cast<mindspore::schema::AllT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ApplyMomentum: {
+      auto ptr = reinterpret_cast<mindspore::schema::ApplyMomentumT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ArgMaxFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::ArgMaxFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ArgMinFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::ArgMinFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Assert: {
+      auto ptr = reinterpret_cast<mindspore::schema::AssertT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Assign: {
+      auto ptr = reinterpret_cast<mindspore::schema::AssignT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_AssignAdd: {
+      auto ptr = reinterpret_cast<mindspore::schema::AssignAddT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_AudioSpectrogram: {
+      auto ptr = reinterpret_cast<mindspore::schema::AudioSpectrogramT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_AvgPoolFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::AvgPoolFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_AvgPoolGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::AvgPoolGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_BatchNorm: {
+      auto ptr = reinterpret_cast<mindspore::schema::BatchNormT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_BatchNormGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::BatchNormGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_BatchToSpace: {
+      auto ptr = reinterpret_cast<mindspore::schema::BatchToSpaceT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_BatchToSpaceND: {
+      auto ptr = reinterpret_cast<mindspore::schema::BatchToSpaceNDT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_BiasAdd: {
+      auto ptr = reinterpret_cast<mindspore::schema::BiasAddT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_BinaryCrossEntropy: {
+      auto ptr = reinterpret_cast<mindspore::schema::BinaryCrossEntropyT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_BinaryCrossEntropyGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::BinaryCrossEntropyGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_BiasAddGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::BiasAddGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_BroadcastTo: {
+      auto ptr = reinterpret_cast<mindspore::schema::BroadcastToT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Cast: {
+      auto ptr = reinterpret_cast<mindspore::schema::CastT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Ceil: {
+      auto ptr = reinterpret_cast<mindspore::schema::CeilT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Clip: {
+      auto ptr = reinterpret_cast<mindspore::schema::ClipT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Concat: {
+      auto ptr = reinterpret_cast<mindspore::schema::ConcatT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Attention: {
+      auto ptr = reinterpret_cast<mindspore::schema::AttentionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Conv2DBackpropFilterFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::Conv2DBackpropFilterFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Conv2DBackpropInputFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::Conv2DBackpropInputFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Conv2DFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::Conv2DFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Conv2dTransposeFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::Conv2dTransposeFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Cos: {
+      auto ptr = reinterpret_cast<mindspore::schema::CosT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ConstantOfShape: {
+      auto ptr = reinterpret_cast<mindspore::schema::ConstantOfShapeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Crop: {
+      auto ptr = reinterpret_cast<mindspore::schema::CropT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_CustomExtractFeatures: {
+      auto ptr = reinterpret_cast<mindspore::schema::CustomExtractFeaturesT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_CustomNormalize: {
+      auto ptr = reinterpret_cast<mindspore::schema::CustomNormalizeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_CustomPredict: {
+      auto ptr = reinterpret_cast<mindspore::schema::CustomPredictT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_DeConv2DGradFilter: {
+      auto ptr = reinterpret_cast<mindspore::schema::DeConv2DGradFilterT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Depend: {
+      auto ptr = reinterpret_cast<mindspore::schema::DependT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_DepthToSpace: {
+      auto ptr = reinterpret_cast<mindspore::schema::DepthToSpaceT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_DetectionPostProcess: {
+      auto ptr = reinterpret_cast<mindspore::schema::DetectionPostProcessT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_DivFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::DivFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_DivGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::DivGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Dropout: {
+      auto ptr = reinterpret_cast<mindspore::schema::DropoutT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_DropoutGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::DropoutGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Elu: {
+      auto ptr = reinterpret_cast<mindspore::schema::EluT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Eltwise: {
+      auto ptr = reinterpret_cast<mindspore::schema::EltwiseT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Equal: {
+      auto ptr = reinterpret_cast<mindspore::schema::EqualT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_EmbeddingLookupFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::EmbeddingLookupFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ExpFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::ExpFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ExpandDims: {
+      auto ptr = reinterpret_cast<mindspore::schema::ExpandDimsT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_FakeQuantWithMinMaxVars: {
+      auto ptr = reinterpret_cast<mindspore::schema::FakeQuantWithMinMaxVarsT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_FakeQuantWithMinMaxVarsPerChannel: {
+      auto ptr = reinterpret_cast<mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_FftReal: {
+      auto ptr = reinterpret_cast<mindspore::schema::FftRealT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_FftImag: {
+      auto ptr = reinterpret_cast<mindspore::schema::FftImagT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Flatten: {
+      auto ptr = reinterpret_cast<mindspore::schema::FlattenT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_FlattenGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::FlattenGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Floor: {
+      auto ptr = reinterpret_cast<mindspore::schema::FloorT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_FloorDiv: {
+      auto ptr = reinterpret_cast<mindspore::schema::FloorDivT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_FloorMod: {
+      auto ptr = reinterpret_cast<mindspore::schema::FloorModT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Fill: {
+      auto ptr = reinterpret_cast<mindspore::schema::FillT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_FullConnection: {
+      auto ptr = reinterpret_cast<mindspore::schema::FullConnectionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_FusedBatchNorm: {
+      auto ptr = reinterpret_cast<mindspore::schema::FusedBatchNormT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Gather: {
+      auto ptr = reinterpret_cast<mindspore::schema::GatherT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_GatherNd: {
+      auto ptr = reinterpret_cast<mindspore::schema::GatherNdT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Greater: {
+      auto ptr = reinterpret_cast<mindspore::schema::GreaterT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_GreaterEqual: {
+      auto ptr = reinterpret_cast<mindspore::schema::GreaterEqualT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_HashtableLookup: {
+      auto ptr = reinterpret_cast<mindspore::schema::HashtableLookupT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_InstanceNorm: {
+      auto ptr = reinterpret_cast<mindspore::schema::InstanceNormT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LayerNormFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::LayerNormFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LeakyRelu: {
+      auto ptr = reinterpret_cast<mindspore::schema::LeakyReluT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Less: {
+      auto ptr = reinterpret_cast<mindspore::schema::LessT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LessEqual: {
+      auto ptr = reinterpret_cast<mindspore::schema::LessEqualT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Log: {
+      auto ptr = reinterpret_cast<mindspore::schema::LogT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LogGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::LogGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LogicalAnd: {
+      auto ptr = reinterpret_cast<mindspore::schema::LogicalAndT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LogicalNot: {
+      auto ptr = reinterpret_cast<mindspore::schema::LogicalNotT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LogicalOr: {
+      auto ptr = reinterpret_cast<mindspore::schema::LogicalOrT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LpNormalization: {
+      auto ptr = reinterpret_cast<mindspore::schema::LpNormalizationT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LRN: {
+      auto ptr = reinterpret_cast<mindspore::schema::LRNT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LshProjection: {
+      auto ptr = reinterpret_cast<mindspore::schema::LshProjectionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LSTM: {
+      auto ptr = reinterpret_cast<mindspore::schema::LSTMT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_L2NormalizeFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::L2NormalizeFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_MatMulFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::MatMulFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Maximum: {
+      auto ptr = reinterpret_cast<mindspore::schema::MaximumT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_MaximumGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::MaximumGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_MaxPoolFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::MaxPoolFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_MaxPoolGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::MaxPoolGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SwitchLayer: {
+      auto ptr = reinterpret_cast<mindspore::schema::SwitchLayerT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Mfcc: {
+      auto ptr = reinterpret_cast<mindspore::schema::MfccT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Minimum: {
+      auto ptr = reinterpret_cast<mindspore::schema::MinimumT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_MinimumGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::MinimumGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Mod: {
+      auto ptr = reinterpret_cast<mindspore::schema::ModT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_MulFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::MulFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_MulGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::MulGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Neg: {
+      auto ptr = reinterpret_cast<mindspore::schema::NegT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_NegGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::NegGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_NotEqual: {
+      auto ptr = reinterpret_cast<mindspore::schema::NotEqualT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_NonMaxSuppression: {
+      auto ptr = reinterpret_cast<mindspore::schema::NonMaxSuppressionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_OneHot: {
+      auto ptr = reinterpret_cast<mindspore::schema::OneHotT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_OnesLike: {
+      auto ptr = reinterpret_cast<mindspore::schema::OnesLikeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_PadFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::PadFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_PartialFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::PartialFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_PowerGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::PowerGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_PowFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::PowFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_PriorBox: {
+      auto ptr = reinterpret_cast<mindspore::schema::PriorBoxT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_PReLUFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::PReLUFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_QuantDTypeCast: {
+      auto ptr = reinterpret_cast<mindspore::schema::QuantDTypeCastT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Rank: {
+      auto ptr = reinterpret_cast<mindspore::schema::RankT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Range: {
+      auto ptr = reinterpret_cast<mindspore::schema::RangeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Reciprocal: {
+      auto ptr = reinterpret_cast<mindspore::schema::ReciprocalT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_RealDiv: {
+      auto ptr = reinterpret_cast<mindspore::schema::RealDivT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ReduceFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::ReduceFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Reshape: {
+      auto ptr = reinterpret_cast<mindspore::schema::ReshapeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Resize: {
+      auto ptr = reinterpret_cast<mindspore::schema::ResizeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ReverseSequence: {
+      auto ptr = reinterpret_cast<mindspore::schema::ReverseSequenceT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ReverseV2: {
+      auto ptr = reinterpret_cast<mindspore::schema::ReverseV2T *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Rfft: {
+      auto ptr = reinterpret_cast<mindspore::schema::RfftT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ROIPooling: {
+      auto ptr = reinterpret_cast<mindspore::schema::ROIPoolingT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Round: {
+      auto ptr = reinterpret_cast<mindspore::schema::RoundT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Rsqrt: {
+      auto ptr = reinterpret_cast<mindspore::schema::RsqrtT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ScaleFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::ScaleFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ScatterNd: {
+      auto ptr = reinterpret_cast<mindspore::schema::ScatterNdT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SGD: {
+      auto ptr = reinterpret_cast<mindspore::schema::SGDT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Shape: {
+      auto ptr = reinterpret_cast<mindspore::schema::ShapeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<mindspore::schema::SigmoidCrossEntropyWithLogitsT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Sin: {
+      auto ptr = reinterpret_cast<mindspore::schema::SinT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SkipGram: {
+      auto ptr = reinterpret_cast<mindspore::schema::SkipGramT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SliceFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::SliceFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SmoothL1Loss: {
+      auto ptr = reinterpret_cast<mindspore::schema::SmoothL1LossT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SmoothL1LossGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::SmoothL1LossGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Softmax: {
+      auto ptr = reinterpret_cast<mindspore::schema::SoftmaxT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SoftmaxCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<mindspore::schema::SoftmaxCrossEntropyWithLogitsT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SpaceToBatch: {
+      auto ptr = reinterpret_cast<mindspore::schema::SpaceToBatchT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SpaceToBatchND: {
+      auto ptr = reinterpret_cast<mindspore::schema::SpaceToBatchNDT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SpaceToDepth: {
+      auto ptr = reinterpret_cast<mindspore::schema::SpaceToDepthT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SparseSoftmaxCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SparseToDense: {
+      auto ptr = reinterpret_cast<mindspore::schema::SparseToDenseT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Split: {
+      auto ptr = reinterpret_cast<mindspore::schema::SplitT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Sqrt: {
+      auto ptr = reinterpret_cast<mindspore::schema::SqrtT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Squeeze: {
+      auto ptr = reinterpret_cast<mindspore::schema::SqueezeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Square: {
+      auto ptr = reinterpret_cast<mindspore::schema::SquareT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SquaredDifference: {
+      auto ptr = reinterpret_cast<mindspore::schema::SquaredDifferenceT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Stack: {
+      auto ptr = reinterpret_cast<mindspore::schema::StackT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_StridedSlice: {
+      auto ptr = reinterpret_cast<mindspore::schema::StridedSliceT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SubFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::SubFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SubGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::SubGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Switch: {
+      auto ptr = reinterpret_cast<mindspore::schema::SwitchT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_TensorListFromTensor: {
+      auto ptr = reinterpret_cast<mindspore::schema::TensorListFromTensorT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_TensorListGetItem: {
+      auto ptr = reinterpret_cast<mindspore::schema::TensorListGetItemT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_TensorListReserve: {
+      auto ptr = reinterpret_cast<mindspore::schema::TensorListReserveT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_TensorListSetItem: {
+      auto ptr = reinterpret_cast<mindspore::schema::TensorListSetItemT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_TensorListStack: {
+      auto ptr = reinterpret_cast<mindspore::schema::TensorListStackT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_TileFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::TileFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_TopKFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::TopKFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Transpose: {
+      auto ptr = reinterpret_cast<mindspore::schema::TransposeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Unique: {
+      auto ptr = reinterpret_cast<mindspore::schema::UniqueT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_UnsortedSegmentSum: {
+      auto ptr = reinterpret_cast<mindspore::schema::UnsortedSegmentSumT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Unsqueeze: {
+      auto ptr = reinterpret_cast<mindspore::schema::UnsqueezeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Unstack: {
+      auto ptr = reinterpret_cast<mindspore::schema::UnstackT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LSTMGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::LSTMGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Where: {
+      auto ptr = reinterpret_cast<mindspore::schema::WhereT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ZerosLike: {
+      auto ptr = reinterpret_cast<mindspore::schema::ZerosLikeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Select: {
+      auto ptr = reinterpret_cast<mindspore::schema::SelectT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ScatterNdUpdate: {
+      auto ptr = reinterpret_cast<mindspore::schema::ScatterNdUpdateT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_GRU: {
+      auto ptr = reinterpret_cast<mindspore::schema::GRUT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_NonZero: {
+      auto ptr = reinterpret_cast<mindspore::schema::NonZeroT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_InvertPermutation: {
+      auto ptr = reinterpret_cast<mindspore::schema::InvertPermutationT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Size: {
+      auto ptr = reinterpret_cast<mindspore::schema::SizeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_RandomStandardNormal: {
+      auto ptr = reinterpret_cast<mindspore::schema::RandomStandardNormalT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_CropAndResize: {
+      auto ptr = reinterpret_cast<mindspore::schema::CropAndResizeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Erf: {
+      auto ptr = reinterpret_cast<mindspore::schema::ErfT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_StridedSliceGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::StridedSliceGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_IsFinite: {
+      auto ptr = reinterpret_cast<mindspore::schema::IsFiniteT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LinSpace: {
+      auto ptr = reinterpret_cast<mindspore::schema::LinSpaceT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_UniformReal: {
+      auto ptr = reinterpret_cast<mindspore::schema::UniformRealT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_AbsGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::AbsGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_RsqrtGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::RsqrtGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SqrtGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::SqrtGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LayerNormGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::LayerNormGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ResizeGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::ResizeGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Splice: {
+      auto ptr = reinterpret_cast<mindspore::schema::SpliceT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LogSoftmax: {
+      auto ptr = reinterpret_cast<mindspore::schema::LogSoftmaxT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Call: {
+      auto ptr = reinterpret_cast<mindspore::schema::CallT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Custom: {
+      auto ptr = reinterpret_cast<mindspore::schema::CustomT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_CumSum: {
+      auto ptr = reinterpret_cast<mindspore::schema::CumSumT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_SplitWithOverlap: {
+      auto ptr = reinterpret_cast<mindspore::schema::SplitWithOverlapT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_GenOP: {
+      auto ptr = reinterpret_cast<mindspore::schema::GenOPT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_RaggedRange: {
+      auto ptr = reinterpret_cast<mindspore::schema::RaggedRangeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_GLU: {
+      auto ptr = reinterpret_cast<mindspore::schema::GLUT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_TensorArray: {
+      auto ptr = reinterpret_cast<mindspore::schema::TensorArrayT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_TensorArrayRead: {
+      auto ptr = reinterpret_cast<mindspore::schema::TensorArrayReadT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_TensorArrayWrite: {
+      auto ptr = reinterpret_cast<mindspore::schema::TensorArrayWriteT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_Affine: {
+      auto ptr = reinterpret_cast<mindspore::schema::AffineT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_AllGather: {
+      auto ptr = reinterpret_cast<mindspore::schema::AllGatherT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_ReduceScatter: {
+      auto ptr = reinterpret_cast<mindspore::schema::ReduceScatterT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_DynamicQuant: {
+      auto ptr = reinterpret_cast<mindspore::schema::DynamicQuantT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LSTMGradData: {
+      auto ptr = reinterpret_cast<mindspore::schema::LSTMGradDataT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_LSTMGradWeight: {
+      auto ptr = reinterpret_cast<mindspore::schema::LSTMGradWeightT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_RandomNormal: {
+      auto ptr = reinterpret_cast<mindspore::schema::RandomNormalT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_NLLLoss: {
+      auto ptr = reinterpret_cast<mindspore::schema::NLLLossT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_NLLLossGrad: {
+      auto ptr = reinterpret_cast<mindspore::schema::NLLLossGradT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_FormatTranspose: {
+      auto ptr = reinterpret_cast<mindspore::schema::FormatTransposeT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_GatherD: {
+      auto ptr = reinterpret_cast<mindspore::schema::GatherDT *>(value);
+      delete ptr;
+      break;
+    }
+    case PrimitiveType_GroupNormFusion: {
+      auto ptr = reinterpret_cast<mindspore::schema::GroupNormFusionT *>(value);
+      delete ptr;
+      break;
+    }
+    default: break;
+  }
+  value = nullptr;
+  type = PrimitiveType_NONE;
+}
+
+inline const flatbuffers::TypeTable *PrimitiveTypeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_SEQUENCE, 0, -1 },
+    { flatbuffers::ET_SEQUENCE, 0, 0 },
+    { flatbuffers::ET_SEQUENCE, 0, 1 },
+    { flatbuffers::ET_SEQUENCE, 0, 2 },
+    { flatbuffers::ET_SEQUENCE, 0, 3 },
+    { flatbuffers::ET_SEQUENCE, 0, 4 },
+    { flatbuffers::ET_SEQUENCE, 0, 5 },
+    { flatbuffers::ET_SEQUENCE, 0, 6 },
+    { flatbuffers::ET_SEQUENCE, 0, 7 },
+    { flatbuffers::ET_SEQUENCE, 0, 8 },
+    { flatbuffers::ET_SEQUENCE, 0, 9 },
+    { flatbuffers::ET_SEQUENCE, 0, 10 },
+    { flatbuffers::ET_SEQUENCE, 0, 11 },
+    { flatbuffers::ET_SEQUENCE, 0, 12 },
+    { flatbuffers::ET_SEQUENCE, 0, 13 },
+    { flatbuffers::ET_SEQUENCE, 0, 14 },
+    { flatbuffers::ET_SEQUENCE, 0, 15 },
+    { flatbuffers::ET_SEQUENCE, 0, 16 },
+    { flatbuffers::ET_SEQUENCE, 0, 17 },
+    { flatbuffers::ET_SEQUENCE, 0, 18 },
+    { flatbuffers::ET_SEQUENCE, 0, 19 },
+    { flatbuffers::ET_SEQUENCE, 0, 20 },
+    { flatbuffers::ET_SEQUENCE, 0, 21 },
+    { flatbuffers::ET_SEQUENCE, 0, 22 },
+    { flatbuffers::ET_SEQUENCE, 0, 23 },
+    { flatbuffers::ET_SEQUENCE, 0, 24 },
+    { flatbuffers::ET_SEQUENCE, 0, 25 },
+    { flatbuffers::ET_SEQUENCE, 0, 26 },
+    { flatbuffers::ET_SEQUENCE, 0, 27 },
+    { flatbuffers::ET_SEQUENCE, 0, 28 },
+    { flatbuffers::ET_SEQUENCE, 0, 29 },
+    { flatbuffers::ET_SEQUENCE, 0, 30 },
+    { flatbuffers::ET_SEQUENCE, 0, 31 },
+    { flatbuffers::ET_SEQUENCE, 0, 32 },
+    { flatbuffers::ET_SEQUENCE, 0, 33 },
+    { flatbuffers::ET_SEQUENCE, 0, 34 },
+    { flatbuffers::ET_SEQUENCE, 0, 35 },
+    { flatbuffers::ET_SEQUENCE, 0, 36 },
+    { flatbuffers::ET_SEQUENCE, 0, 37 },
+    { flatbuffers::ET_SEQUENCE, 0, 38 },
+    { flatbuffers::ET_SEQUENCE, 0, 39 },
+    { flatbuffers::ET_SEQUENCE, 0, 40 },
+    { flatbuffers::ET_SEQUENCE, 0, 41 },
+    { flatbuffers::ET_SEQUENCE, 0, 42 },
+    { flatbuffers::ET_SEQUENCE, 0, 43 },
+    { flatbuffers::ET_SEQUENCE, 0, 44 },
+    { flatbuffers::ET_SEQUENCE, 0, 45 },
+    { flatbuffers::ET_SEQUENCE, 0, 46 },
+    { flatbuffers::ET_SEQUENCE, 0, 47 },
+    { flatbuffers::ET_SEQUENCE, 0, 48 },
+    { flatbuffers::ET_SEQUENCE, 0, 49 },
+    { flatbuffers::ET_SEQUENCE, 0, 50 },
+    { flatbuffers::ET_SEQUENCE, 0, 51 },
+    { flatbuffers::ET_SEQUENCE, 0, 52 },
+    { flatbuffers::ET_SEQUENCE, 0, 53 },
+    { flatbuffers::ET_SEQUENCE, 0, 54 },
+    { flatbuffers::ET_SEQUENCE, 0, 55 },
+    { flatbuffers::ET_SEQUENCE, 0, 56 },
+    { flatbuffers::ET_SEQUENCE, 0, 57 },
+    { flatbuffers::ET_SEQUENCE, 0, 58 },
+    { flatbuffers::ET_SEQUENCE, 0, 59 },
+    { flatbuffers::ET_SEQUENCE, 0, 60 },
+    { flatbuffers::ET_SEQUENCE, 0, 61 },
+    { flatbuffers::ET_SEQUENCE, 0, 62 },
+    { flatbuffers::ET_SEQUENCE, 0, 63 },
+    { flatbuffers::ET_SEQUENCE, 0, 64 },
+    { flatbuffers::ET_SEQUENCE, 0, 65 },
+    { flatbuffers::ET_SEQUENCE, 0, 66 },
+    { flatbuffers::ET_SEQUENCE, 0, 67 },
+    { flatbuffers::ET_SEQUENCE, 0, 68 },
+    { flatbuffers::ET_SEQUENCE, 0, 69 },
+    { flatbuffers::ET_SEQUENCE, 0, 70 },
+    { flatbuffers::ET_SEQUENCE, 0, 71 },
+    { flatbuffers::ET_SEQUENCE, 0, 72 },
+    { flatbuffers::ET_SEQUENCE, 0, 73 },
+    { flatbuffers::ET_SEQUENCE, 0, 74 },
+    { flatbuffers::ET_SEQUENCE, 0, 75 },
+    { flatbuffers::ET_SEQUENCE, 0, 76 },
+    { flatbuffers::ET_SEQUENCE, 0, 77 },
+    { flatbuffers::ET_SEQUENCE, 0, 78 },
+    { flatbuffers::ET_SEQUENCE, 0, 79 },
+    { flatbuffers::ET_SEQUENCE, 0, 80 },
+    { flatbuffers::ET_SEQUENCE, 0, 81 },
+    { flatbuffers::ET_SEQUENCE, 0, 82 },
+    { flatbuffers::ET_SEQUENCE, 0, 83 },
+    { flatbuffers::ET_SEQUENCE, 0, 84 },
+    { flatbuffers::ET_SEQUENCE, 0, 85 },
+    { flatbuffers::ET_SEQUENCE, 0, 86 },
+    { flatbuffers::ET_SEQUENCE, 0, 87 },
+    { flatbuffers::ET_SEQUENCE, 0, 88 },
+    { flatbuffers::ET_SEQUENCE, 0, 89 },
+    { flatbuffers::ET_SEQUENCE, 0, 90 },
+    { flatbuffers::ET_SEQUENCE, 0, 91 },
+    { flatbuffers::ET_SEQUENCE, 0, 92 },
+    { flatbuffers::ET_SEQUENCE, 0, 93 },
+    { flatbuffers::ET_SEQUENCE, 0, 94 },
+    { flatbuffers::ET_SEQUENCE, 0, 95 },
+    { flatbuffers::ET_SEQUENCE, 0, 96 },
+    { flatbuffers::ET_SEQUENCE, 0, 97 },
+    { flatbuffers::ET_SEQUENCE, 0, 98 },
+    { flatbuffers::ET_SEQUENCE, 0, 99 },
+    { flatbuffers::ET_SEQUENCE, 0, 100 },
+    { flatbuffers::ET_SEQUENCE, 0, 101 },
+    { flatbuffers::ET_SEQUENCE, 0, 102 },
+    { flatbuffers::ET_SEQUENCE, 0, 103 },
+    { flatbuffers::ET_SEQUENCE, 0, 104 },
+    { flatbuffers::ET_SEQUENCE, 0, 105 },
+    { flatbuffers::ET_SEQUENCE, 0, 106 },
+    { flatbuffers::ET_SEQUENCE, 0, 107 },
+    { flatbuffers::ET_SEQUENCE, 0, 108 },
+    { flatbuffers::ET_SEQUENCE, 0, 109 },
+    { flatbuffers::ET_SEQUENCE, 0, 110 },
+    { flatbuffers::ET_SEQUENCE, 0, 111 },
+    { flatbuffers::ET_SEQUENCE, 0, 112 },
+    { flatbuffers::ET_SEQUENCE, 0, 113 },
+    { flatbuffers::ET_SEQUENCE, 0, 114 },
+    { flatbuffers::ET_SEQUENCE, 0, 115 },
+    { flatbuffers::ET_SEQUENCE, 0, 116 },
+    { flatbuffers::ET_SEQUENCE, 0, 117 },
+    { flatbuffers::ET_SEQUENCE, 0, 118 },
+    { flatbuffers::ET_SEQUENCE, 0, 119 },
+    { flatbuffers::ET_SEQUENCE, 0, 120 },
+    { flatbuffers::ET_SEQUENCE, 0, 121 },
+    { flatbuffers::ET_SEQUENCE, 0, 122 },
+    { flatbuffers::ET_SEQUENCE, 0, 123 },
+    { flatbuffers::ET_SEQUENCE, 0, 124 },
+    { flatbuffers::ET_SEQUENCE, 0, 125 },
+    { flatbuffers::ET_SEQUENCE, 0, 126 },
+    { flatbuffers::ET_SEQUENCE, 0, 127 },
+    { flatbuffers::ET_SEQUENCE, 0, 128 },
+    { flatbuffers::ET_SEQUENCE, 0, 129 },
+    { flatbuffers::ET_SEQUENCE, 0, 130 },
+    { flatbuffers::ET_SEQUENCE, 0, 131 },
+    { flatbuffers::ET_SEQUENCE, 0, 132 },
+    { flatbuffers::ET_SEQUENCE, 0, 133 },
+    { flatbuffers::ET_SEQUENCE, 0, 134 },
+    { flatbuffers::ET_SEQUENCE, 0, 135 },
+    { flatbuffers::ET_SEQUENCE, 0, 136 },
+    { flatbuffers::ET_SEQUENCE, 0, 137 },
+    { flatbuffers::ET_SEQUENCE, 0, 138 },
+    { flatbuffers::ET_SEQUENCE, 0, 139 },
+    { flatbuffers::ET_SEQUENCE, 0, 140 },
+    { flatbuffers::ET_SEQUENCE, 0, 141 },
+    { flatbuffers::ET_SEQUENCE, 0, 142 },
+    { flatbuffers::ET_SEQUENCE, 0, 143 },
+    { flatbuffers::ET_SEQUENCE, 0, 144 },
+    { flatbuffers::ET_SEQUENCE, 0, 145 },
+    { flatbuffers::ET_SEQUENCE, 0, 146 },
+    { flatbuffers::ET_SEQUENCE, 0, 147 },
+    { flatbuffers::ET_SEQUENCE, 0, 148 },
+    { flatbuffers::ET_SEQUENCE, 0, 149 },
+    { flatbuffers::ET_SEQUENCE, 0, 150 },
+    { flatbuffers::ET_SEQUENCE, 0, 151 },
+    { flatbuffers::ET_SEQUENCE, 0, 152 },
+    { flatbuffers::ET_SEQUENCE, 0, 153 },
+    { flatbuffers::ET_SEQUENCE, 0, 154 },
+    { flatbuffers::ET_SEQUENCE, 0, 155 },
+    { flatbuffers::ET_SEQUENCE, 0, 156 },
+    { flatbuffers::ET_SEQUENCE, 0, 157 },
+    { flatbuffers::ET_SEQUENCE, 0, 158 },
+    { flatbuffers::ET_SEQUENCE, 0, 159 },
+    { flatbuffers::ET_SEQUENCE, 0, 160 },
+    { flatbuffers::ET_SEQUENCE, 0, 161 },
+    { flatbuffers::ET_SEQUENCE, 0, 162 },
+    { flatbuffers::ET_SEQUENCE, 0, 163 },
+    { flatbuffers::ET_SEQUENCE, 0, 164 },
+    { flatbuffers::ET_SEQUENCE, 0, 165 },
+    { flatbuffers::ET_SEQUENCE, 0, 166 },
+    { flatbuffers::ET_SEQUENCE, 0, 167 },
+    { flatbuffers::ET_SEQUENCE, 0, 168 },
+    { flatbuffers::ET_SEQUENCE, 0, 169 },
+    { flatbuffers::ET_SEQUENCE, 0, 170 },
+    { flatbuffers::ET_SEQUENCE, 0, 171 },
+    { flatbuffers::ET_SEQUENCE, 0, 172 },
+    { flatbuffers::ET_SEQUENCE, 0, 173 },
+    { flatbuffers::ET_SEQUENCE, 0, 174 },
+    { flatbuffers::ET_SEQUENCE, 0, 175 },
+    { flatbuffers::ET_SEQUENCE, 0, 176 },
+    { flatbuffers::ET_SEQUENCE, 0, 177 },
+    { flatbuffers::ET_SEQUENCE, 0, 178 },
+    { flatbuffers::ET_SEQUENCE, 0, 179 },
+    { flatbuffers::ET_SEQUENCE, 0, 180 },
+    { flatbuffers::ET_SEQUENCE, 0, 181 },
+    { flatbuffers::ET_SEQUENCE, 0, 182 },
+    { flatbuffers::ET_SEQUENCE, 0, 183 },
+    { flatbuffers::ET_SEQUENCE, 0, 184 },
+    { flatbuffers::ET_SEQUENCE, 0, 185 },
+    { flatbuffers::ET_SEQUENCE, 0, 186 },
+    { flatbuffers::ET_SEQUENCE, 0, 187 },
+    { flatbuffers::ET_SEQUENCE, 0, 188 },
+    { flatbuffers::ET_SEQUENCE, 0, 189 },
+    { flatbuffers::ET_SEQUENCE, 0, 190 },
+    { flatbuffers::ET_SEQUENCE, 0, 191 },
+    { flatbuffers::ET_SEQUENCE, 0, 192 },
+    { flatbuffers::ET_SEQUENCE, 0, 193 },
+    { flatbuffers::ET_SEQUENCE, 0, 194 },
+    { flatbuffers::ET_SEQUENCE, 0, 195 },
+    { flatbuffers::ET_SEQUENCE, 0, 196 },
+    { flatbuffers::ET_SEQUENCE, 0, 197 },
+    { flatbuffers::ET_SEQUENCE, 0, 198 },
+    { flatbuffers::ET_SEQUENCE, 0, 199 },
+    { flatbuffers::ET_SEQUENCE, 0, 200 },
+    { flatbuffers::ET_SEQUENCE, 0, 201 },
+    { flatbuffers::ET_SEQUENCE, 0, 202 },
+    { flatbuffers::ET_SEQUENCE, 0, 203 },
+    { flatbuffers::ET_SEQUENCE, 0, 204 },
+    { flatbuffers::ET_SEQUENCE, 0, 205 },
+    { flatbuffers::ET_SEQUENCE, 0, 206 },
+    { flatbuffers::ET_SEQUENCE, 0, 207 },
+    { flatbuffers::ET_SEQUENCE, 0, 208 },
+    { flatbuffers::ET_SEQUENCE, 0, 209 },
+    { flatbuffers::ET_SEQUENCE, 0, 210 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::AbsTypeTable,
+    mindspore::schema::ActivationTypeTable,
+    mindspore::schema::ActivationGradTypeTable,
+    mindspore::schema::AdamTypeTable,
+    mindspore::schema::AddFusionTypeTable,
+    mindspore::schema::AdderFusionTypeTable,
+    mindspore::schema::AddGradTypeTable,
+    mindspore::schema::AddNTypeTable,
+    mindspore::schema::AllTypeTable,
+    mindspore::schema::ApplyMomentumTypeTable,
+    mindspore::schema::ArgMaxFusionTypeTable,
+    mindspore::schema::ArgMinFusionTypeTable,
+    mindspore::schema::AssertTypeTable,
+    mindspore::schema::AssignTypeTable,
+    mindspore::schema::AssignAddTypeTable,
+    mindspore::schema::AudioSpectrogramTypeTable,
+    mindspore::schema::AvgPoolFusionTypeTable,
+    mindspore::schema::AvgPoolGradTypeTable,
+    mindspore::schema::BatchNormTypeTable,
+    mindspore::schema::BatchNormGradTypeTable,
+    mindspore::schema::BatchToSpaceTypeTable,
+    mindspore::schema::BatchToSpaceNDTypeTable,
+    mindspore::schema::BiasAddTypeTable,
+    mindspore::schema::BinaryCrossEntropyTypeTable,
+    mindspore::schema::BinaryCrossEntropyGradTypeTable,
+    mindspore::schema::BiasAddGradTypeTable,
+    mindspore::schema::BroadcastToTypeTable,
+    mindspore::schema::CastTypeTable,
+    mindspore::schema::CeilTypeTable,
+    mindspore::schema::ClipTypeTable,
+    mindspore::schema::ConcatTypeTable,
+    mindspore::schema::AttentionTypeTable,
+    mindspore::schema::Conv2DBackpropFilterFusionTypeTable,
+    mindspore::schema::Conv2DBackpropInputFusionTypeTable,
+    mindspore::schema::Conv2DFusionTypeTable,
+    mindspore::schema::Conv2dTransposeFusionTypeTable,
+    mindspore::schema::CosTypeTable,
+    mindspore::schema::ConstantOfShapeTypeTable,
+    mindspore::schema::CropTypeTable,
+    mindspore::schema::CustomExtractFeaturesTypeTable,
+    mindspore::schema::CustomNormalizeTypeTable,
+    mindspore::schema::CustomPredictTypeTable,
+    mindspore::schema::DeConv2DGradFilterTypeTable,
+    mindspore::schema::DependTypeTable,
+    mindspore::schema::DepthToSpaceTypeTable,
+    mindspore::schema::DetectionPostProcessTypeTable,
+    mindspore::schema::DivFusionTypeTable,
+    mindspore::schema::DivGradTypeTable,
+    mindspore::schema::DropoutTypeTable,
+    mindspore::schema::DropoutGradTypeTable,
+    mindspore::schema::EluTypeTable,
+    mindspore::schema::EltwiseTypeTable,
+    mindspore::schema::EqualTypeTable,
+    mindspore::schema::EmbeddingLookupFusionTypeTable,
+    mindspore::schema::ExpFusionTypeTable,
+    mindspore::schema::ExpandDimsTypeTable,
+    mindspore::schema::FakeQuantWithMinMaxVarsTypeTable,
+    mindspore::schema::FakeQuantWithMinMaxVarsPerChannelTypeTable,
+    mindspore::schema::FftRealTypeTable,
+    mindspore::schema::FftImagTypeTable,
+    mindspore::schema::FlattenTypeTable,
+    mindspore::schema::FlattenGradTypeTable,
+    mindspore::schema::FloorTypeTable,
+    mindspore::schema::FloorDivTypeTable,
+    mindspore::schema::FloorModTypeTable,
+    mindspore::schema::FillTypeTable,
+    mindspore::schema::FullConnectionTypeTable,
+    mindspore::schema::FusedBatchNormTypeTable,
+    mindspore::schema::GatherTypeTable,
+    mindspore::schema::GatherNdTypeTable,
+    mindspore::schema::GreaterTypeTable,
+    mindspore::schema::GreaterEqualTypeTable,
+    mindspore::schema::HashtableLookupTypeTable,
+    mindspore::schema::InstanceNormTypeTable,
+    mindspore::schema::LayerNormFusionTypeTable,
+    mindspore::schema::LeakyReluTypeTable,
+    mindspore::schema::LessTypeTable,
+    mindspore::schema::LessEqualTypeTable,
+    mindspore::schema::LogTypeTable,
+    mindspore::schema::LogGradTypeTable,
+    mindspore::schema::LogicalAndTypeTable,
+    mindspore::schema::LogicalNotTypeTable,
+    mindspore::schema::LogicalOrTypeTable,
+    mindspore::schema::LpNormalizationTypeTable,
+    mindspore::schema::LRNTypeTable,
+    mindspore::schema::LshProjectionTypeTable,
+    mindspore::schema::LSTMTypeTable,
+    mindspore::schema::L2NormalizeFusionTypeTable,
+    mindspore::schema::MatMulFusionTypeTable,
+    mindspore::schema::MaximumTypeTable,
+    mindspore::schema::MaximumGradTypeTable,
+    mindspore::schema::MaxPoolFusionTypeTable,
+    mindspore::schema::MaxPoolGradTypeTable,
+    mindspore::schema::SwitchLayerTypeTable,
+    mindspore::schema::MfccTypeTable,
+    mindspore::schema::MinimumTypeTable,
+    mindspore::schema::MinimumGradTypeTable,
+    mindspore::schema::ModTypeTable,
+    mindspore::schema::MulFusionTypeTable,
+    mindspore::schema::MulGradTypeTable,
+    mindspore::schema::NegTypeTable,
+    mindspore::schema::NegGradTypeTable,
+    mindspore::schema::NotEqualTypeTable,
+    mindspore::schema::NonMaxSuppressionTypeTable,
+    mindspore::schema::OneHotTypeTable,
+    mindspore::schema::OnesLikeTypeTable,
+    mindspore::schema::PadFusionTypeTable,
+    mindspore::schema::PartialFusionTypeTable,
+    mindspore::schema::PowerGradTypeTable,
+    mindspore::schema::PowFusionTypeTable,
+    mindspore::schema::PriorBoxTypeTable,
+    mindspore::schema::PReLUFusionTypeTable,
+    mindspore::schema::QuantDTypeCastTypeTable,
+    mindspore::schema::RankTypeTable,
+    mindspore::schema::RangeTypeTable,
+    mindspore::schema::ReciprocalTypeTable,
+    mindspore::schema::RealDivTypeTable,
+    mindspore::schema::ReduceFusionTypeTable,
+    mindspore::schema::ReshapeTypeTable,
+    mindspore::schema::ResizeTypeTable,
+    mindspore::schema::ReverseSequenceTypeTable,
+    mindspore::schema::ReverseV2TypeTable,
+    mindspore::schema::RfftTypeTable,
+    mindspore::schema::ROIPoolingTypeTable,
+    mindspore::schema::RoundTypeTable,
+    mindspore::schema::RsqrtTypeTable,
+    mindspore::schema::ScaleFusionTypeTable,
+    mindspore::schema::ScatterNdTypeTable,
+    mindspore::schema::SGDTypeTable,
+    mindspore::schema::ShapeTypeTable,
+    mindspore::schema::SigmoidCrossEntropyWithLogitsTypeTable,
+    mindspore::schema::SigmoidCrossEntropyWithLogitsGradTypeTable,
+    mindspore::schema::SinTypeTable,
+    mindspore::schema::SkipGramTypeTable,
+    mindspore::schema::SliceFusionTypeTable,
+    mindspore::schema::SmoothL1LossTypeTable,
+    mindspore::schema::SmoothL1LossGradTypeTable,
+    mindspore::schema::SoftmaxTypeTable,
+    mindspore::schema::SoftmaxCrossEntropyWithLogitsTypeTable,
+    mindspore::schema::SpaceToBatchTypeTable,
+    mindspore::schema::SpaceToBatchNDTypeTable,
+    mindspore::schema::SpaceToDepthTypeTable,
+    mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsTypeTable,
+    mindspore::schema::SparseToDenseTypeTable,
+    mindspore::schema::SplitTypeTable,
+    mindspore::schema::SqrtTypeTable,
+    mindspore::schema::SqueezeTypeTable,
+    mindspore::schema::SquareTypeTable,
+    mindspore::schema::SquaredDifferenceTypeTable,
+    mindspore::schema::StackTypeTable,
+    mindspore::schema::StridedSliceTypeTable,
+    mindspore::schema::SubFusionTypeTable,
+    mindspore::schema::SubGradTypeTable,
+    mindspore::schema::SwitchTypeTable,
+    mindspore::schema::TensorListFromTensorTypeTable,
+    mindspore::schema::TensorListGetItemTypeTable,
+    mindspore::schema::TensorListReserveTypeTable,
+    mindspore::schema::TensorListSetItemTypeTable,
+    mindspore::schema::TensorListStackTypeTable,
+    mindspore::schema::TileFusionTypeTable,
+    mindspore::schema::TopKFusionTypeTable,
+    mindspore::schema::TransposeTypeTable,
+    mindspore::schema::UniqueTypeTable,
+    mindspore::schema::UnsortedSegmentSumTypeTable,
+    mindspore::schema::UnsqueezeTypeTable,
+    mindspore::schema::UnstackTypeTable,
+    mindspore::schema::LSTMGradTypeTable,
+    mindspore::schema::WhereTypeTable,
+    mindspore::schema::ZerosLikeTypeTable,
+    mindspore::schema::SelectTypeTable,
+    mindspore::schema::ScatterNdUpdateTypeTable,
+    mindspore::schema::GRUTypeTable,
+    mindspore::schema::NonZeroTypeTable,
+    mindspore::schema::InvertPermutationTypeTable,
+    mindspore::schema::SizeTypeTable,
+    mindspore::schema::RandomStandardNormalTypeTable,
+    mindspore::schema::CropAndResizeTypeTable,
+    mindspore::schema::ErfTypeTable,
+    mindspore::schema::StridedSliceGradTypeTable,
+    mindspore::schema::IsFiniteTypeTable,
+    mindspore::schema::LinSpaceTypeTable,
+    mindspore::schema::UniformRealTypeTable,
+    mindspore::schema::AbsGradTypeTable,
+    mindspore::schema::RsqrtGradTypeTable,
+    mindspore::schema::SqrtGradTypeTable,
+    mindspore::schema::LayerNormGradTypeTable,
+    mindspore::schema::ResizeGradTypeTable,
+    mindspore::schema::SpliceTypeTable,
+    mindspore::schema::LogSoftmaxTypeTable,
+    mindspore::schema::CallTypeTable,
+    mindspore::schema::CustomTypeTable,
+    mindspore::schema::CumSumTypeTable,
+    mindspore::schema::SplitWithOverlapTypeTable,
+    mindspore::schema::GenOPTypeTable,
+    mindspore::schema::RaggedRangeTypeTable,
+    mindspore::schema::GLUTypeTable,
+    mindspore::schema::TensorArrayTypeTable,
+    mindspore::schema::TensorArrayReadTypeTable,
+    mindspore::schema::TensorArrayWriteTypeTable,
+    mindspore::schema::AffineTypeTable,
+    mindspore::schema::AllGatherTypeTable,
+    mindspore::schema::ReduceScatterTypeTable,
+    mindspore::schema::DynamicQuantTypeTable,
+    mindspore::schema::LSTMGradDataTypeTable,
+    mindspore::schema::LSTMGradWeightTypeTable,
+    mindspore::schema::RandomNormalTypeTable,
+    mindspore::schema::NLLLossTypeTable,
+    mindspore::schema::NLLLossGradTypeTable,
+    mindspore::schema::FormatTransposeTypeTable,
+    mindspore::schema::GatherDTypeTable,
+    mindspore::schema::GroupNormFusionTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_UNION, 212, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AbsTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ActivationTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ActivationGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AdamTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AddFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AdderFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_CHAR, 0, 1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 2 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable,
+    mindspore::schema::PadModeTypeTable,
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AddGradTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AddNTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AllTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ApplyMomentumTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ArgMaxFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ArgMinFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AssertTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AssignTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AssignAddTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AudioSpectrogramTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AvgPoolFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 1 },
+    { flatbuffers::ET_INT, 0, 2 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 3 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::PadModeTypeTable,
+    mindspore::schema::RoundModeTypeTable,
+    mindspore::schema::FormatTypeTable,
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AvgPoolGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_INT, 0, 1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::PadModeTypeTable,
+    mindspore::schema::FormatTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *BatchNormTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *BatchNormGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *BatchToSpaceTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_SEQUENCE, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::Vec2DTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *BatchToSpaceNDTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_SEQUENCE, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::Vec2DTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *BiasAddTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *BinaryCrossEntropyTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ReductionTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *BinaryCrossEntropyGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ReductionTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *BiasAddGradTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *BroadcastToTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CastTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CeilTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ClipTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ConcatTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AttentionTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *Conv2DBackpropFilterFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_CHAR, 0, 1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 2 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable,
+    mindspore::schema::PadModeTypeTable,
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *Conv2DBackpropInputFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_CHAR, 0, 1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 2 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable,
+    mindspore::schema::PadModeTypeTable,
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 12, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *Conv2DFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_CHAR, 0, 1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 2 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable,
+    mindspore::schema::PadModeTypeTable,
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *Conv2dTransposeFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_CHAR, 0, 1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 2 },
+    { flatbuffers::ET_LONG, 1, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable,
+    mindspore::schema::PadModeTypeTable,
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 13, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CosTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ConstantOfShapeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CropTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CustomExtractFeaturesTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CustomNormalizeTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CustomPredictTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *DeConv2DGradFilterTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_INT, 0, 1 },
+    { flatbuffers::ET_CHAR, 0, 2 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::PadModeTypeTable,
+    mindspore::schema::FormatTypeTable,
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *DependTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *DepthToSpaceTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_INT, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *DetectionPostProcessTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 1, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *DivFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *DivGradTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *DropoutTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *DropoutGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *EluTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *EltwiseTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::EltwiseModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *EqualTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *EmbeddingLookupFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ExpFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ExpandDimsTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FakeQuantWithMinMaxVarsTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FakeQuantWithMinMaxVarsPerChannelTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FftRealTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FftImagTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FlattenTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FlattenGradTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FloorTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FloorDivTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FloorModTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FillTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FullConnectionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FusedBatchNormTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *GatherTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *GatherNdTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *GreaterTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *GreaterEqualTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *HashtableLookupTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *InstanceNormTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LayerNormFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LeakyReluTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LessTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LessEqualTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LogTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LogGradTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LogicalAndTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LogicalNotTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LogicalOrTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LpNormalizationTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LRNTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_STRING, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LshProjectionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::LshProjectionTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LSTMTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 9, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LSTMGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 9, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *L2NormalizeFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *MatMulFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *MaximumTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *MaximumGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *MaxPoolFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 1 },
+    { flatbuffers::ET_INT, 0, 2 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 3 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::PadModeTypeTable,
+    mindspore::schema::RoundModeTypeTable,
+    mindspore::schema::FormatTypeTable,
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *MaxPoolGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_INT, 0, 1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::PadModeTypeTable,
+    mindspore::schema::FormatTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SwitchLayerTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *MfccTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *MinimumTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *MinimumGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ModTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *MulFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *MulGradTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *NegTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *NegGradTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *NotEqualTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *NonMaxSuppressionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *OneHotTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *OnesLikeTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *PadFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_SEQUENCE, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::Vec2DTypeTable,
+    mindspore::schema::PaddingModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *PartialFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *PowerGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *PowFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *PriorBoxTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_FLOAT, 1, -1 },
+    { flatbuffers::ET_FLOAT, 1, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 11, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *PReLUFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *RankTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *RangeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ReciprocalTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *RealDivTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ReduceFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ReduceModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ReshapeTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ResizeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 2 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 3 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable,
+    mindspore::schema::ResizeMethodTypeTable,
+    mindspore::schema::CoordinateTransformModeTypeTable,
+    mindspore::schema::NearestModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ReverseSequenceTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ReverseV2TypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *RfftTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ROIPoolingTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *RoundTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *RsqrtTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *QuantDTypeCastTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ScaleFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ScatterNdTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SGDTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ShapeTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SigmoidCrossEntropyWithLogitsTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SigmoidCrossEntropyWithLogitsGradTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SinTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SkipGramTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SliceFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SmoothL1LossTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SmoothL1LossGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SoftmaxTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SoftmaxCrossEntropyWithLogitsTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SpaceToBatchTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_SEQUENCE, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::Vec2DTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SpaceToBatchNDTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_SEQUENCE, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::Vec2DTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SpaceToDepthTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_INT, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SparseSoftmaxCrossEntropyWithLogitsTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SparseToDenseTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SplitTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SqrtTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SqueezeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SquareTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SquaredDifferenceTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *StackTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *StridedSliceTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SubFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SubGradTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SwitchTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *TensorListFromTensorTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *TensorListGetItemTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *TensorListReserveTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *TensorListSetItemTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *TensorListStackTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *TileFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *TopKFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *TransposeTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *UniqueTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *UnsortedSegmentSumTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *UnsqueezeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *UnstackTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *WhereTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ZerosLikeTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SelectTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *GRUTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *NonZeroTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *InvertPermutationTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SizeTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *RandomStandardNormalTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CropAndResizeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ResizeMethodTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ErfTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *StridedSliceGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *IsFiniteTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LinSpaceTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *UniformRealTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AbsGradTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *RsqrtGradTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SqrtGradTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LayerNormGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ResizeGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ResizeMethodTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SpliceTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LogSoftmaxTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CallTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CumSumTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CustomTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_SEQUENCE, 1, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::AttributeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *SplitWithOverlapTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *GenOPTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_INT, 0, 1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_CHAR, 0, 2 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 3 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_CHAR, 0, 4 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 5 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable,
+    mindspore::schema::FormatTypeTable,
+    mindspore::schema::PadModeTypeTable,
+    mindspore::schema::EltwiseModeTypeTable,
+    mindspore::schema::RoundModeTypeTable,
+    mindspore::schema::ReduceModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 32, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *RaggedRangeTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *GLUTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *TensorArrayTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_INT, 1, -1 },
+    { flatbuffers::ET_INT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *TensorArrayReadTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *TensorArrayWriteTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AffineTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ScatterNdUpdateTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AllGatherTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_INT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ReduceScatterTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_INT, 0, -1 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ReduceModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *DynamicQuantTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LSTMGradDataTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 9, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LSTMGradWeightTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 9, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *RandomNormalTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *NLLLossTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ReductionTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *NLLLossGradTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ReductionTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FormatTransposeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *GatherDTypeTable() {
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *GroupNormFusionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 0, -1 },
+    { flatbuffers::ET_FLOAT, 0, -1 },
+    { flatbuffers::ET_BOOL, 0, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+}  // namespace schema
+}  // namespace mindspore
+
+#endif  // FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
diff --git a/mindspore/lite/schema/inner/ops_types_generated.h b/mindspore/lite/schema/inner/ops_types_generated.h
new file mode 100644
index 00000000..15e5a0ea
--- /dev/null
+++ b/mindspore/lite/schema/inner/ops_types_generated.h
@@ -0,0 +1,1164 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+
+
+#ifndef FLATBUFFERS_GENERATED_OPSTYPES_MINDSPORE_SCHEMA_H_
+#define FLATBUFFERS_GENERATED_OPSTYPES_MINDSPORE_SCHEMA_H_
+
+#include "flatbuffers/flatbuffers.h"
+
+namespace mindspore {
+namespace schema {
+
+struct Vec;
+struct VecBuilder;
+struct VecT;
+
+struct Vec2D;
+struct Vec2DBuilder;
+struct Vec2DT;
+
+struct Attribute;
+struct AttributeBuilder;
+struct AttributeT;
+
+inline const flatbuffers::TypeTable *VecTypeTable();
+
+inline const flatbuffers::TypeTable *Vec2DTypeTable();
+
+inline const flatbuffers::TypeTable *AttributeTypeTable();
+
+enum ResizeMethod : int8_t {
+  ResizeMethod_UNKNOWN = -1,
+  ResizeMethod_LINEAR = 0,
+  ResizeMethod_NEAREST = 1,
+  ResizeMethod_CUBIC = 2,
+  ResizeMethod_MIN = ResizeMethod_UNKNOWN,
+  ResizeMethod_MAX = ResizeMethod_CUBIC
+};
+
+inline const ResizeMethod (&EnumValuesResizeMethod())[4] {
+  static const ResizeMethod values[] = {
+    ResizeMethod_UNKNOWN,
+    ResizeMethod_LINEAR,
+    ResizeMethod_NEAREST,
+    ResizeMethod_CUBIC
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesResizeMethod() {
+  static const char * const names[5] = {
+    "UNKNOWN",
+    "LINEAR",
+    "NEAREST",
+    "CUBIC",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameResizeMethod(ResizeMethod e) {
+  if (flatbuffers::IsOutRange(e, ResizeMethod_UNKNOWN, ResizeMethod_CUBIC)) return "";
+  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ResizeMethod_UNKNOWN);
+  return EnumNamesResizeMethod()[index];
+}
+
+enum CoordinateTransformMode : int8_t {
+  CoordinateTransformMode_ASYMMETRIC = 0,
+  CoordinateTransformMode_ALIGN_CORNERS = 1,
+  CoordinateTransformMode_HALF_PIXEL = 2,
+  CoordinateTransformMode_MIN = CoordinateTransformMode_ASYMMETRIC,
+  CoordinateTransformMode_MAX = CoordinateTransformMode_HALF_PIXEL
+};
+
+inline const CoordinateTransformMode (&EnumValuesCoordinateTransformMode())[3] {
+  static const CoordinateTransformMode values[] = {
+    CoordinateTransformMode_ASYMMETRIC,
+    CoordinateTransformMode_ALIGN_CORNERS,
+    CoordinateTransformMode_HALF_PIXEL
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesCoordinateTransformMode() {
+  static const char * const names[4] = {
+    "ASYMMETRIC",
+    "ALIGN_CORNERS",
+    "HALF_PIXEL",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameCoordinateTransformMode(CoordinateTransformMode e) {
+  if (flatbuffers::IsOutRange(e, CoordinateTransformMode_ASYMMETRIC, CoordinateTransformMode_HALF_PIXEL)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesCoordinateTransformMode()[index];
+}
+
+enum NearestMode : int8_t {
+  NearestMode_NORMAL = 0,
+  NearestMode_ROUND_HALF_DOWN = 1,
+  NearestMode_ROUND_HALF_UP = 2,
+  NearestMode_FLOOR = 3,
+  NearestMode_CEIL = 4,
+  NearestMode_MIN = NearestMode_NORMAL,
+  NearestMode_MAX = NearestMode_CEIL
+};
+
+inline const NearestMode (&EnumValuesNearestMode())[5] {
+  static const NearestMode values[] = {
+    NearestMode_NORMAL,
+    NearestMode_ROUND_HALF_DOWN,
+    NearestMode_ROUND_HALF_UP,
+    NearestMode_FLOOR,
+    NearestMode_CEIL
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesNearestMode() {
+  static const char * const names[6] = {
+    "NORMAL",
+    "ROUND_HALF_DOWN",
+    "ROUND_HALF_UP",
+    "FLOOR",
+    "CEIL",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameNearestMode(NearestMode e) {
+  if (flatbuffers::IsOutRange(e, NearestMode_NORMAL, NearestMode_CEIL)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesNearestMode()[index];
+}
+
+enum Format : int32_t {
+  Format_NCHW = 0,
+  Format_NHWC = 1,
+  Format_NHWC4 = 2,
+  Format_HWKC = 3,
+  Format_HWCK = 4,
+  Format_KCHW = 5,
+  Format_CKHW = 6,
+  Format_KHWC = 7,
+  Format_CHWK = 8,
+  Format_HW = 9,
+  Format_HW4 = 10,
+  Format_NC = 11,
+  Format_NC4 = 12,
+  Format_NC4HW4 = 13,
+  Format_NUM_OF_FORMAT = 14,
+  Format_NCDHW = 15,
+  Format_NWC = 16,
+  Format_NCW = 17,
+  Format_MIN = Format_NCHW,
+  Format_MAX = Format_NCW
+};
+
+inline const Format (&EnumValuesFormat())[18] {
+  static const Format values[] = {
+    Format_NCHW,
+    Format_NHWC,
+    Format_NHWC4,
+    Format_HWKC,
+    Format_HWCK,
+    Format_KCHW,
+    Format_CKHW,
+    Format_KHWC,
+    Format_CHWK,
+    Format_HW,
+    Format_HW4,
+    Format_NC,
+    Format_NC4,
+    Format_NC4HW4,
+    Format_NUM_OF_FORMAT,
+    Format_NCDHW,
+    Format_NWC,
+    Format_NCW
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesFormat() {
+  static const char * const names[19] = {
+    "NCHW",
+    "NHWC",
+    "NHWC4",
+    "HWKC",
+    "HWCK",
+    "KCHW",
+    "CKHW",
+    "KHWC",
+    "CHWK",
+    "HW",
+    "HW4",
+    "NC",
+    "NC4",
+    "NC4HW4",
+    "NUM_OF_FORMAT",
+    "NCDHW",
+    "NWC",
+    "NCW",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameFormat(Format e) {
+  if (flatbuffers::IsOutRange(e, Format_NCHW, Format_NCW)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesFormat()[index];
+}
+
+enum ActivationType : int8_t {
+  ActivationType_NO_ACTIVATION = 0,
+  ActivationType_RELU = 1,
+  ActivationType_SIGMOID = 2,
+  ActivationType_RELU6 = 3,
+  ActivationType_ELU = 4,
+  ActivationType_LEAKY_RELU = 5,
+  ActivationType_ABS = 6,
+  ActivationType_RELU1 = 7,
+  ActivationType_SOFTSIGN = 8,
+  ActivationType_SOFTPLUS = 9,
+  ActivationType_TANH = 10,
+  ActivationType_SELU = 11,
+  ActivationType_HSWISH = 12,
+  ActivationType_HSIGMOID = 13,
+  ActivationType_THRESHOLDRELU = 14,
+  ActivationType_LINEAR = 15,
+  ActivationType_HARD_TANH = 16,
+  ActivationType_SIGN = 17,
+  ActivationType_SWISH = 18,
+  ActivationType_GELU = 19,
+  ActivationType_UNKNOWN = 20,
+  ActivationType_MIN = ActivationType_NO_ACTIVATION,
+  ActivationType_MAX = ActivationType_UNKNOWN
+};
+
+inline const ActivationType (&EnumValuesActivationType())[21] {
+  static const ActivationType values[] = {
+    ActivationType_NO_ACTIVATION,
+    ActivationType_RELU,
+    ActivationType_SIGMOID,
+    ActivationType_RELU6,
+    ActivationType_ELU,
+    ActivationType_LEAKY_RELU,
+    ActivationType_ABS,
+    ActivationType_RELU1,
+    ActivationType_SOFTSIGN,
+    ActivationType_SOFTPLUS,
+    ActivationType_TANH,
+    ActivationType_SELU,
+    ActivationType_HSWISH,
+    ActivationType_HSIGMOID,
+    ActivationType_THRESHOLDRELU,
+    ActivationType_LINEAR,
+    ActivationType_HARD_TANH,
+    ActivationType_SIGN,
+    ActivationType_SWISH,
+    ActivationType_GELU,
+    ActivationType_UNKNOWN
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesActivationType() {
+  static const char * const names[22] = {
+    "NO_ACTIVATION",
+    "RELU",
+    "SIGMOID",
+    "RELU6",
+    "ELU",
+    "LEAKY_RELU",
+    "ABS",
+    "RELU1",
+    "SOFTSIGN",
+    "SOFTPLUS",
+    "TANH",
+    "SELU",
+    "HSWISH",
+    "HSIGMOID",
+    "THRESHOLDRELU",
+    "LINEAR",
+    "HARD_TANH",
+    "SIGN",
+    "SWISH",
+    "GELU",
+    "UNKNOWN",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameActivationType(ActivationType e) {
+  if (flatbuffers::IsOutRange(e, ActivationType_NO_ACTIVATION, ActivationType_UNKNOWN)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesActivationType()[index];
+}
+
+enum ReduceMode : int8_t {
+  ReduceMode_ReduceMean = 0,
+  ReduceMode_ReduceMax = 1,
+  ReduceMode_ReduceMin = 2,
+  ReduceMode_ReduceProd = 3,
+  ReduceMode_ReduceSum = 4,
+  ReduceMode_ReduceSumSquare = 5,
+  ReduceMode_ReduceASum = 6,
+  ReduceMode_ReduceAll = 7,
+  ReduceMode_ReduceL2 = 8,
+  ReduceMode_MIN = ReduceMode_ReduceMean,
+  ReduceMode_MAX = ReduceMode_ReduceL2
+};
+
+inline const ReduceMode (&EnumValuesReduceMode())[9] {
+  static const ReduceMode values[] = {
+    ReduceMode_ReduceMean,
+    ReduceMode_ReduceMax,
+    ReduceMode_ReduceMin,
+    ReduceMode_ReduceProd,
+    ReduceMode_ReduceSum,
+    ReduceMode_ReduceSumSquare,
+    ReduceMode_ReduceASum,
+    ReduceMode_ReduceAll,
+    ReduceMode_ReduceL2
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesReduceMode() {
+  static const char * const names[10] = {
+    "ReduceMean",
+    "ReduceMax",
+    "ReduceMin",
+    "ReduceProd",
+    "ReduceSum",
+    "ReduceSumSquare",
+    "ReduceASum",
+    "ReduceAll",
+    "ReduceL2",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameReduceMode(ReduceMode e) {
+  if (flatbuffers::IsOutRange(e, ReduceMode_ReduceMean, ReduceMode_ReduceL2)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesReduceMode()[index];
+}
+
+enum PoolMode : int8_t {
+  PoolMode_MAX_POOLING = 0,
+  PoolMode_MEAN_POOLING = 1,
+  PoolMode_MIN = PoolMode_MAX_POOLING,
+  PoolMode_MAX = PoolMode_MEAN_POOLING
+};
+
+inline const PoolMode (&EnumValuesPoolMode())[2] {
+  static const PoolMode values[] = {
+    PoolMode_MAX_POOLING,
+    PoolMode_MEAN_POOLING
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesPoolMode() {
+  static const char * const names[3] = {
+    "MAX_POOLING",
+    "MEAN_POOLING",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNamePoolMode(PoolMode e) {
+  if (flatbuffers::IsOutRange(e, PoolMode_MAX_POOLING, PoolMode_MEAN_POOLING)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesPoolMode()[index];
+}
+
+enum EltwiseMode : int8_t {
+  EltwiseMode_PROD = 0,
+  EltwiseMode_SUM = 1,
+  EltwiseMode_MAXIMUM = 2,
+  EltwiseMode_UNKNOWN = 3,
+  EltwiseMode_MIN = EltwiseMode_PROD,
+  EltwiseMode_MAX = EltwiseMode_UNKNOWN
+};
+
+inline const EltwiseMode (&EnumValuesEltwiseMode())[4] {
+  static const EltwiseMode values[] = {
+    EltwiseMode_PROD,
+    EltwiseMode_SUM,
+    EltwiseMode_MAXIMUM,
+    EltwiseMode_UNKNOWN
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesEltwiseMode() {
+  static const char * const names[5] = {
+    "PROD",
+    "SUM",
+    "MAXIMUM",
+    "UNKNOWN",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameEltwiseMode(EltwiseMode e) {
+  if (flatbuffers::IsOutRange(e, EltwiseMode_PROD, EltwiseMode_UNKNOWN)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesEltwiseMode()[index];
+}
+
+enum PadMode : int8_t {
+  PadMode_PAD = 0,
+  PadMode_SAME = 1,
+  PadMode_VALID = 2,
+  PadMode_MIN = PadMode_PAD,
+  PadMode_MAX = PadMode_VALID
+};
+
+inline const PadMode (&EnumValuesPadMode())[3] {
+  static const PadMode values[] = {
+    PadMode_PAD,
+    PadMode_SAME,
+    PadMode_VALID
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesPadMode() {
+  static const char * const names[4] = {
+    "PAD",
+    "SAME",
+    "VALID",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNamePadMode(PadMode e) {
+  if (flatbuffers::IsOutRange(e, PadMode_PAD, PadMode_VALID)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesPadMode()[index];
+}
+
+enum RoundMode : int8_t {
+  RoundMode_FLOOR = 0,
+  RoundMode_CEIL = 1,
+  RoundMode_MIN = RoundMode_FLOOR,
+  RoundMode_MAX = RoundMode_CEIL
+};
+
+inline const RoundMode (&EnumValuesRoundMode())[2] {
+  static const RoundMode values[] = {
+    RoundMode_FLOOR,
+    RoundMode_CEIL
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesRoundMode() {
+  static const char * const names[3] = {
+    "FLOOR",
+    "CEIL",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameRoundMode(RoundMode e) {
+  if (flatbuffers::IsOutRange(e, RoundMode_FLOOR, RoundMode_CEIL)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesRoundMode()[index];
+}
+
+enum PaddingMode : int8_t {
+  PaddingMode_CONSTANT = 0,
+  PaddingMode_REFLECT = 1,
+  PaddingMode_SYMMETRIC = 2,
+  PaddingMode_MODE_RESERVED = 3,
+  PaddingMode_MIN = PaddingMode_CONSTANT,
+  PaddingMode_MAX = PaddingMode_MODE_RESERVED
+};
+
+inline const PaddingMode (&EnumValuesPaddingMode())[4] {
+  static const PaddingMode values[] = {
+    PaddingMode_CONSTANT,
+    PaddingMode_REFLECT,
+    PaddingMode_SYMMETRIC,
+    PaddingMode_MODE_RESERVED
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesPaddingMode() {
+  static const char * const names[5] = {
+    "CONSTANT",
+    "REFLECT",
+    "SYMMETRIC",
+    "MODE_RESERVED",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNamePaddingMode(PaddingMode e) {
+  if (flatbuffers::IsOutRange(e, PaddingMode_CONSTANT, PaddingMode_MODE_RESERVED)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesPaddingMode()[index];
+}
+
+enum LshProjectionType : int8_t {
+  LshProjectionType_UNKNOWN = 0,
+  LshProjectionType_SPARSE = 1,
+  LshProjectionType_DENSE = 2,
+  LshProjectionType_MIN = LshProjectionType_UNKNOWN,
+  LshProjectionType_MAX = LshProjectionType_DENSE
+};
+
+inline const LshProjectionType (&EnumValuesLshProjectionType())[3] {
+  static const LshProjectionType values[] = {
+    LshProjectionType_UNKNOWN,
+    LshProjectionType_SPARSE,
+    LshProjectionType_DENSE
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesLshProjectionType() {
+  static const char * const names[4] = {
+    "UNKNOWN",
+    "SPARSE",
+    "DENSE",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameLshProjectionType(LshProjectionType e) {
+  if (flatbuffers::IsOutRange(e, LshProjectionType_UNKNOWN, LshProjectionType_DENSE)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesLshProjectionType()[index];
+}
+
+enum Reduction : int8_t {
+  Reduction_REDUCTION_SUM = 0,
+  Reduction_MEAN = 1,
+  Reduction_NONE = 2,
+  Reduction_MIN = Reduction_REDUCTION_SUM,
+  Reduction_MAX = Reduction_NONE
+};
+
+inline const Reduction (&EnumValuesReduction())[3] {
+  static const Reduction values[] = {
+    Reduction_REDUCTION_SUM,
+    Reduction_MEAN,
+    Reduction_NONE
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesReduction() {
+  static const char * const names[4] = {
+    "REDUCTION_SUM",
+    "MEAN",
+    "NONE",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameReduction(Reduction e) {
+  if (flatbuffers::IsOutRange(e, Reduction_REDUCTION_SUM, Reduction_NONE)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesReduction()[index];
+}
+
+struct VecT : public flatbuffers::NativeTable {
+  typedef Vec TableType;
+  std::vector<int64_t> data{};
+};
+
+struct Vec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef VecT NativeTableType;
+  typedef VecBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return VecTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DATA = 4
+  };
+  const flatbuffers::Vector<int64_t> *data() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DATA);
+  }
+  flatbuffers::Vector<int64_t> *mutable_data() {
+    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DATA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_DATA) &&
+           verifier.VerifyVector(data()) &&
+           verifier.EndTable();
+  }
+  VecT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(VecT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Vec> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VecT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct VecBuilder {
+  typedef Vec Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_data(flatbuffers::Offset<flatbuffers::Vector<int64_t>> data) {
+    fbb_.AddOffset(Vec::VT_DATA, data);
+  }
+  explicit VecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Vec> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Vec>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Vec> CreateVec(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> data = 0) {
+  VecBuilder builder_(_fbb);
+  builder_.add_data(data);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Vec> CreateVecDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *data = nullptr) {
+  auto data__ = data ? _fbb.CreateVector<int64_t>(*data) : 0;
+  return mindspore::schema::CreateVec(
+      _fbb,
+      data__);
+}
+
+flatbuffers::Offset<Vec> CreateVec(flatbuffers::FlatBufferBuilder &_fbb, const VecT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct Vec2DT : public flatbuffers::NativeTable {
+  typedef Vec2D TableType;
+  std::vector<std::unique_ptr<mindspore::schema::VecT>> data{};
+};
+
+struct Vec2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef Vec2DT NativeTableType;
+  typedef Vec2DBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return Vec2DTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DATA = 4
+  };
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>> *data() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>> *>(VT_DATA);
+  }
+  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>> *mutable_data() {
+    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>> *>(VT_DATA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_DATA) &&
+           verifier.VerifyVector(data()) &&
+           verifier.VerifyVectorOfTables(data()) &&
+           verifier.EndTable();
+  }
+  Vec2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(Vec2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Vec2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Vec2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct Vec2DBuilder {
+  typedef Vec2D Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>>> data) {
+    fbb_.AddOffset(Vec2D::VT_DATA, data);
+  }
+  explicit Vec2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Vec2D> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Vec2D>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Vec2D> CreateVec2D(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>>> data = 0) {
+  Vec2DBuilder builder_(_fbb);
+  builder_.add_data(data);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Vec2D> CreateVec2DDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<flatbuffers::Offset<mindspore::schema::Vec>> *data = nullptr) {
+  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Vec>>(*data) : 0;
+  return mindspore::schema::CreateVec2D(
+      _fbb,
+      data__);
+}
+
+flatbuffers::Offset<Vec2D> CreateVec2D(flatbuffers::FlatBufferBuilder &_fbb, const Vec2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+struct AttributeT : public flatbuffers::NativeTable {
+  typedef Attribute TableType;
+  std::string name{};
+  std::vector<uint8_t> data{};
+};
+
+struct Attribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AttributeT NativeTableType;
+  typedef AttributeBuilder Builder;
+  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+    return AttributeTypeTable();
+  }
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NAME = 4,
+    VT_DATA = 6
+  };
+  const flatbuffers::String *name() const {
+    return GetPointer<const flatbuffers::String *>(VT_NAME);
+  }
+  flatbuffers::String *mutable_name() {
+    return GetPointer<flatbuffers::String *>(VT_NAME);
+  }
+  const flatbuffers::Vector<uint8_t> *data() const {
+    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
+  }
+  flatbuffers::Vector<uint8_t> *mutable_data() {
+    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_NAME) &&
+           verifier.VerifyString(name()) &&
+           VerifyOffset(verifier, VT_DATA) &&
+           verifier.VerifyVector(data()) &&
+           verifier.EndTable();
+  }
+  AttributeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  void UnPackTo(AttributeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
+  static flatbuffers::Offset<Attribute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+};
+
+struct AttributeBuilder {
+  typedef Attribute Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
+    fbb_.AddOffset(Attribute::VT_NAME, name);
+  }
+  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
+    fbb_.AddOffset(Attribute::VT_DATA, data);
+  }
+  explicit AttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Attribute> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Attribute>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Attribute> CreateAttribute(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> name = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
+  AttributeBuilder builder_(_fbb);
+  builder_.add_data(data);
+  builder_.add_name(name);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Attribute> CreateAttributeDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *name = nullptr,
+    const std::vector<uint8_t> *data = nullptr) {
+  auto name__ = name ? _fbb.CreateString(name) : 0;
+  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
+  return mindspore::schema::CreateAttribute(
+      _fbb,
+      name__,
+      data__);
+}
+
+flatbuffers::Offset<Attribute> CreateAttribute(flatbuffers::FlatBufferBuilder &_fbb, const AttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
+
+inline VecT *Vec::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<VecT>(new VecT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Vec::UnPackTo(VecT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
+}
+
+inline flatbuffers::Offset<Vec> Vec::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VecT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateVec(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Vec> CreateVec(flatbuffers::FlatBufferBuilder &_fbb, const VecT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VecT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
+  return mindspore::schema::CreateVec(
+      _fbb,
+      _data);
+}
+
+inline Vec2DT *Vec2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<Vec2DT>(new Vec2DT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Vec2D::UnPackTo(Vec2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = std::unique_ptr<mindspore::schema::VecT>(_e->Get(_i)->UnPack(_resolver)); } } }
+}
+
+inline flatbuffers::Offset<Vec2D> Vec2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Vec2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateVec2D(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Vec2D> CreateVec2D(flatbuffers::FlatBufferBuilder &_fbb, const Vec2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Vec2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _data = _o->data.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Vec>> (_o->data.size(), [](size_t i, _VectorArgs *__va) { return CreateVec(*__va->__fbb, __va->__o->data[i].get(), __va->__rehasher); }, &_va ) : 0;
+  return mindspore::schema::CreateVec2D(
+      _fbb,
+      _data);
+}
+
+inline AttributeT *Attribute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
+  auto _o = std::unique_ptr<AttributeT>(new AttributeT());
+  UnPackTo(_o.get(), _resolver);
+  return _o.release();
+}
+
+inline void Attribute::UnPackTo(AttributeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
+  (void)_o;
+  (void)_resolver;
+  { auto _e = name(); if (_e) _o->name = _e->str(); }
+  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
+}
+
+inline flatbuffers::Offset<Attribute> Attribute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
+  return CreateAttribute(_fbb, _o, _rehasher);
+}
+
+inline flatbuffers::Offset<Attribute> CreateAttribute(flatbuffers::FlatBufferBuilder &_fbb, const AttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
+  (void)_rehasher;
+  (void)_o;
+  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttributeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
+  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
+  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
+  return mindspore::schema::CreateAttribute(
+      _fbb,
+      _name,
+      _data);
+}
+
+inline const flatbuffers::TypeTable *ResizeMethodTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ResizeMethodTypeTable
+  };
+  static const int64_t values[] = { -1, 0, 1, 2 };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, values, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *CoordinateTransformModeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::CoordinateTransformModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *NearestModeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::NearestModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *FormatTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 },
+    { flatbuffers::ET_INT, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::FormatTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 18, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ActivationTypeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ActivationTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 21, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ReduceModeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ReduceModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 9, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *PoolModeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::PoolModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *EltwiseModeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::EltwiseModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *PadModeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::PadModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *RoundModeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::RoundModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *PaddingModeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::PaddingModeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *LshProjectionTypeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::LshProjectionTypeTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *ReductionTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 },
+    { flatbuffers::ET_CHAR, 0, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::ReductionTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *VecTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_LONG, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *Vec2DTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_SEQUENCE, 1, 0 }
+  };
+  static const flatbuffers::TypeFunction type_refs[] = {
+    mindspore::schema::VecTypeTable
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+inline const flatbuffers::TypeTable *AttributeTypeTable() {
+  static const flatbuffers::TypeCode type_codes[] = {
+    { flatbuffers::ET_STRING, 0, -1 },
+    { flatbuffers::ET_UCHAR, 1, -1 }
+  };
+  static const flatbuffers::TypeTable tt = {
+    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
+  };
+  return &tt;
+}
+
+}  // namespace schema
+}  // namespace mindspore
+
+#endif  // FLATBUFFERS_GENERATED_OPSTYPES_MINDSPORE_SCHEMA_H_
diff --git a/mindspore/lite/schema/model_generated.h b/mindspore/lite/schema/model_generated.h
new file mode 100644
index 00000000..cf8d3349
--- /dev/null
+++ b/mindspore/lite/schema/model_generated.h
@@ -0,0 +1,2551 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+
+
+#ifndef FLATBUFFERS_GENERATED_MODEL_MINDSPORE_SCHEMA_H_
+#define FLATBUFFERS_GENERATED_MODEL_MINDSPORE_SCHEMA_H_
+
+#include "flatbuffers/flatbuffers.h"
+
+#include "ops_types_generated.h"
+#include "ops_generated.h"
+
+namespace mindspore {
+namespace schema {
+
+struct QuantParam;
+struct QuantParamBuilder;
+
+struct ExternalData;
+struct ExternalDataBuilder;
+
+struct Tensor;
+struct TensorBuilder;
+
+struct Primitive;
+struct PrimitiveBuilder;
+
+struct CNode;
+struct CNodeBuilder;
+
+struct SubGraph;
+struct SubGraphBuilder;
+
+struct MetaGraph;
+struct MetaGraphBuilder;
+
+enum WeightQunatCompressType : int32_t {
+  WeightQunatCompressType_NONE = 0,
+  WeightQunatCompressType_INDEXING = 1,
+  WeightQunatCompressType_SPARSE = 2,
+  WeightQunatCompressType_FSE = 3,
+  WeightQunatCompressType_MIN = WeightQunatCompressType_NONE,
+  WeightQunatCompressType_MAX = WeightQunatCompressType_FSE
+};
+
+inline const WeightQunatCompressType (&EnumValuesWeightQunatCompressType())[4] {
+  static const WeightQunatCompressType values[] = {
+    WeightQunatCompressType_NONE,
+    WeightQunatCompressType_INDEXING,
+    WeightQunatCompressType_SPARSE,
+    WeightQunatCompressType_FSE
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesWeightQunatCompressType() {
+  static const char * const names[5] = {
+    "NONE",
+    "INDEXING",
+    "SPARSE",
+    "FSE",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameWeightQunatCompressType(WeightQunatCompressType e) {
+  if (flatbuffers::IsOutRange(e, WeightQunatCompressType_NONE, WeightQunatCompressType_FSE)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesWeightQunatCompressType()[index];
+}
+
+enum QuantType : int32_t {
+  QuantType_QUANT_NONE = 0,
+  QuantType_AwareTraining = 1,
+  QuantType_WeightQuant = 2,
+  QuantType_PostTraining = 3,
+  QuantType_QUANT_WEIGHT = 4,
+  QuantType_QUANT_ALL = 5,
+  QuantType_QUANT_DYNAMIC = 6,
+  QuantType_MIN = QuantType_QUANT_NONE,
+  QuantType_MAX = QuantType_QUANT_DYNAMIC
+};
+
+inline const QuantType (&EnumValuesQuantType())[7] {
+  static const QuantType values[] = {
+    QuantType_QUANT_NONE,
+    QuantType_AwareTraining,
+    QuantType_WeightQuant,
+    QuantType_PostTraining,
+    QuantType_QUANT_WEIGHT,
+    QuantType_QUANT_ALL,
+    QuantType_QUANT_DYNAMIC
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesQuantType() {
+  static const char * const names[8] = {
+    "QUANT_NONE",
+    "AwareTraining",
+    "WeightQuant",
+    "PostTraining",
+    "QUANT_WEIGHT",
+    "QUANT_ALL",
+    "QUANT_DYNAMIC",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameQuantType(QuantType e) {
+  if (flatbuffers::IsOutRange(e, QuantType_QUANT_NONE, QuantType_QUANT_DYNAMIC)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesQuantType()[index];
+}
+
+struct QuantParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef QuantParamBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SCALE = 4,
+    VT_ZEROPOINT = 6,
+    VT_MIN = 8,
+    VT_MAX = 10,
+    VT_NARROWRANGE = 12,
+    VT_NUMBITS = 14,
+    VT_INITED = 16,
+    VT_VARCORR = 18,
+    VT_MEANCORR = 20,
+    VT_DSTDTYPE = 22,
+    VT_ROUNDTYPE = 24,
+    VT_MULTIPLIER = 26
+  };
+  double scale() const {
+    return GetField<double>(VT_SCALE, 1.0);
+  }
+  int32_t zeroPoint() const {
+    return GetField<int32_t>(VT_ZEROPOINT, 0);
+  }
+  double min() const {
+    return GetField<double>(VT_MIN, 0.0);
+  }
+  double max() const {
+    return GetField<double>(VT_MAX, 0.0);
+  }
+  bool narrowRange() const {
+    return GetField<uint8_t>(VT_NARROWRANGE, 1) != 0;
+  }
+  int32_t numBits() const {
+    return GetField<int32_t>(VT_NUMBITS, 8);
+  }
+  bool inited() const {
+    return GetField<uint8_t>(VT_INITED, 0) != 0;
+  }
+  float varCorr() const {
+    return GetField<float>(VT_VARCORR, 1.0f);
+  }
+  float meanCorr() const {
+    return GetField<float>(VT_MEANCORR, 0.0f);
+  }
+  int32_t dstDtype() const {
+    return GetField<int32_t>(VT_DSTDTYPE, 32);
+  }
+  int32_t roundType() const {
+    return GetField<int32_t>(VT_ROUNDTYPE, 1);
+  }
+  int32_t multiplier() const {
+    return GetField<int32_t>(VT_MULTIPLIER, 1);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<double>(verifier, VT_SCALE) &&
+           VerifyField<int32_t>(verifier, VT_ZEROPOINT) &&
+           VerifyField<double>(verifier, VT_MIN) &&
+           VerifyField<double>(verifier, VT_MAX) &&
+           VerifyField<uint8_t>(verifier, VT_NARROWRANGE) &&
+           VerifyField<int32_t>(verifier, VT_NUMBITS) &&
+           VerifyField<uint8_t>(verifier, VT_INITED) &&
+           VerifyField<float>(verifier, VT_VARCORR) &&
+           VerifyField<float>(verifier, VT_MEANCORR) &&
+           VerifyField<int32_t>(verifier, VT_DSTDTYPE) &&
+           VerifyField<int32_t>(verifier, VT_ROUNDTYPE) &&
+           VerifyField<int32_t>(verifier, VT_MULTIPLIER) &&
+           verifier.EndTable();
+  }
+};
+
+struct QuantParamBuilder {
+  typedef QuantParam Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_scale(double scale) {
+    fbb_.AddElement<double>(QuantParam::VT_SCALE, scale, 1.0);
+  }
+  void add_zeroPoint(int32_t zeroPoint) {
+    fbb_.AddElement<int32_t>(QuantParam::VT_ZEROPOINT, zeroPoint, 0);
+  }
+  void add_min(double min) {
+    fbb_.AddElement<double>(QuantParam::VT_MIN, min, 0.0);
+  }
+  void add_max(double max) {
+    fbb_.AddElement<double>(QuantParam::VT_MAX, max, 0.0);
+  }
+  void add_narrowRange(bool narrowRange) {
+    fbb_.AddElement<uint8_t>(QuantParam::VT_NARROWRANGE, static_cast<uint8_t>(narrowRange), 1);
+  }
+  void add_numBits(int32_t numBits) {
+    fbb_.AddElement<int32_t>(QuantParam::VT_NUMBITS, numBits, 8);
+  }
+  void add_inited(bool inited) {
+    fbb_.AddElement<uint8_t>(QuantParam::VT_INITED, static_cast<uint8_t>(inited), 0);
+  }
+  void add_varCorr(float varCorr) {
+    fbb_.AddElement<float>(QuantParam::VT_VARCORR, varCorr, 1.0f);
+  }
+  void add_meanCorr(float meanCorr) {
+    fbb_.AddElement<float>(QuantParam::VT_MEANCORR, meanCorr, 0.0f);
+  }
+  void add_dstDtype(int32_t dstDtype) {
+    fbb_.AddElement<int32_t>(QuantParam::VT_DSTDTYPE, dstDtype, 32);
+  }
+  void add_roundType(int32_t roundType) {
+    fbb_.AddElement<int32_t>(QuantParam::VT_ROUNDTYPE, roundType, 1);
+  }
+  void add_multiplier(int32_t multiplier) {
+    fbb_.AddElement<int32_t>(QuantParam::VT_MULTIPLIER, multiplier, 1);
+  }
+  explicit QuantParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<QuantParam> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<QuantParam>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<QuantParam> CreateQuantParam(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    double scale = 1.0,
+    int32_t zeroPoint = 0,
+    double min = 0.0,
+    double max = 0.0,
+    bool narrowRange = true,
+    int32_t numBits = 8,
+    bool inited = false,
+    float varCorr = 1.0f,
+    float meanCorr = 0.0f,
+    int32_t dstDtype = 32,
+    int32_t roundType = 1,
+    int32_t multiplier = 1) {
+  QuantParamBuilder builder_(_fbb);
+  builder_.add_max(max);
+  builder_.add_min(min);
+  builder_.add_scale(scale);
+  builder_.add_multiplier(multiplier);
+  builder_.add_roundType(roundType);
+  builder_.add_dstDtype(dstDtype);
+  builder_.add_meanCorr(meanCorr);
+  builder_.add_varCorr(varCorr);
+  builder_.add_numBits(numBits);
+  builder_.add_zeroPoint(zeroPoint);
+  builder_.add_inited(inited);
+  builder_.add_narrowRange(narrowRange);
+  return builder_.Finish();
+}
+
+struct ExternalData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ExternalDataBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_CHECKSUM = 4,
+    VT_LOCATION = 6,
+    VT_OFFSET = 8,
+    VT_LENGTH = 10
+  };
+  const flatbuffers::String *checkSum() const {
+    return GetPointer<const flatbuffers::String *>(VT_CHECKSUM);
+  }
+  const flatbuffers::String *location() const {
+    return GetPointer<const flatbuffers::String *>(VT_LOCATION);
+  }
+  int64_t offset() const {
+    return GetField<int64_t>(VT_OFFSET, 0);
+  }
+  int64_t length() const {
+    return GetField<int64_t>(VT_LENGTH, -1LL);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_CHECKSUM) &&
+           verifier.VerifyString(checkSum()) &&
+           VerifyOffset(verifier, VT_LOCATION) &&
+           verifier.VerifyString(location()) &&
+           VerifyField<int64_t>(verifier, VT_OFFSET) &&
+           VerifyField<int64_t>(verifier, VT_LENGTH) &&
+           verifier.EndTable();
+  }
+};
+
+struct ExternalDataBuilder {
+  typedef ExternalData Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_checkSum(flatbuffers::Offset<flatbuffers::String> checkSum) {
+    fbb_.AddOffset(ExternalData::VT_CHECKSUM, checkSum);
+  }
+  void add_location(flatbuffers::Offset<flatbuffers::String> location) {
+    fbb_.AddOffset(ExternalData::VT_LOCATION, location);
+  }
+  void add_offset(int64_t offset) {
+    fbb_.AddElement<int64_t>(ExternalData::VT_OFFSET, offset, 0);
+  }
+  void add_length(int64_t length) {
+    fbb_.AddElement<int64_t>(ExternalData::VT_LENGTH, length, -1LL);
+  }
+  explicit ExternalDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ExternalData> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ExternalData>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ExternalData> CreateExternalData(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> checkSum = 0,
+    flatbuffers::Offset<flatbuffers::String> location = 0,
+    int64_t offset = 0,
+    int64_t length = -1LL) {
+  ExternalDataBuilder builder_(_fbb);
+  builder_.add_length(length);
+  builder_.add_offset(offset);
+  builder_.add_location(location);
+  builder_.add_checkSum(checkSum);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<ExternalData> CreateExternalDataDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *checkSum = nullptr,
+    const char *location = nullptr,
+    int64_t offset = 0,
+    int64_t length = -1LL) {
+  auto checkSum__ = checkSum ? _fbb.CreateString(checkSum) : 0;
+  auto location__ = location ? _fbb.CreateString(location) : 0;
+  return mindspore::schema::CreateExternalData(
+      _fbb,
+      checkSum__,
+      location__,
+      offset,
+      length);
+}
+
+struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NODETYPE = 4,
+    VT_DATATYPE = 6,
+    VT_DIMS = 8,
+    VT_FORMAT = 10,
+    VT_REFCOUNT = 12,
+    VT_OFFSET = 14,
+    VT_DATA = 16,
+    VT_QUANTPARAMS = 18,
+    VT_QUANTCLUSTERS = 20,
+    VT_NAME = 22,
+    VT_ENABLEHUFFMANCODE = 24,
+    VT_WEIGHTQUNATCOMPRESSTYPE = 26,
+    VT_EXTERNALDATA = 28
+  };
+  int32_t nodeType() const {
+    return GetField<int32_t>(VT_NODETYPE, 0);
+  }
+  int32_t dataType() const {
+    return GetField<int32_t>(VT_DATATYPE, 0);
+  }
+  const flatbuffers::Vector<int32_t> *dims() const {
+    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  int32_t refCount() const {
+    return GetField<int32_t>(VT_REFCOUNT, 0);
+  }
+  int32_t offset() const {
+    return GetField<int32_t>(VT_OFFSET, 0);
+  }
+  const flatbuffers::Vector<uint8_t> *data() const {
+    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::QuantParam>> *quantParams() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::QuantParam>> *>(VT_QUANTPARAMS);
+  }
+  const flatbuffers::Vector<float> *quantClusters() const {
+    return GetPointer<const flatbuffers::Vector<float> *>(VT_QUANTCLUSTERS);
+  }
+  const flatbuffers::String *name() const {
+    return GetPointer<const flatbuffers::String *>(VT_NAME);
+  }
+  bool enableHuffmanCode() const {
+    return GetField<uint8_t>(VT_ENABLEHUFFMANCODE, 0) != 0;
+  }
+  mindspore::schema::WeightQunatCompressType weightQunatCompressType() const {
+    return static_cast<mindspore::schema::WeightQunatCompressType>(GetField<int32_t>(VT_WEIGHTQUNATCOMPRESSTYPE, 0));
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ExternalData>> *externalData() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ExternalData>> *>(VT_EXTERNALDATA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_NODETYPE) &&
+           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
+           VerifyOffset(verifier, VT_DIMS) &&
+           verifier.VerifyVector(dims()) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<int32_t>(verifier, VT_REFCOUNT) &&
+           VerifyField<int32_t>(verifier, VT_OFFSET) &&
+           VerifyOffset(verifier, VT_DATA) &&
+           verifier.VerifyVector(data()) &&
+           VerifyOffset(verifier, VT_QUANTPARAMS) &&
+           verifier.VerifyVector(quantParams()) &&
+           verifier.VerifyVectorOfTables(quantParams()) &&
+           VerifyOffset(verifier, VT_QUANTCLUSTERS) &&
+           verifier.VerifyVector(quantClusters()) &&
+           VerifyOffset(verifier, VT_NAME) &&
+           verifier.VerifyString(name()) &&
+           VerifyField<uint8_t>(verifier, VT_ENABLEHUFFMANCODE) &&
+           VerifyField<int32_t>(verifier, VT_WEIGHTQUNATCOMPRESSTYPE) &&
+           VerifyOffset(verifier, VT_EXTERNALDATA) &&
+           verifier.VerifyVector(externalData()) &&
+           verifier.VerifyVectorOfTables(externalData()) &&
+           verifier.EndTable();
+  }
+};
+
+struct TensorBuilder {
+  typedef Tensor Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_nodeType(int32_t nodeType) {
+    fbb_.AddElement<int32_t>(Tensor::VT_NODETYPE, nodeType, 0);
+  }
+  void add_dataType(int32_t dataType) {
+    fbb_.AddElement<int32_t>(Tensor::VT_DATATYPE, dataType, 0);
+  }
+  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
+    fbb_.AddOffset(Tensor::VT_DIMS, dims);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(Tensor::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_refCount(int32_t refCount) {
+    fbb_.AddElement<int32_t>(Tensor::VT_REFCOUNT, refCount, 0);
+  }
+  void add_offset(int32_t offset) {
+    fbb_.AddElement<int32_t>(Tensor::VT_OFFSET, offset, 0);
+  }
+  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
+    fbb_.AddOffset(Tensor::VT_DATA, data);
+  }
+  void add_quantParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::QuantParam>>> quantParams) {
+    fbb_.AddOffset(Tensor::VT_QUANTPARAMS, quantParams);
+  }
+  void add_quantClusters(flatbuffers::Offset<flatbuffers::Vector<float>> quantClusters) {
+    fbb_.AddOffset(Tensor::VT_QUANTCLUSTERS, quantClusters);
+  }
+  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
+    fbb_.AddOffset(Tensor::VT_NAME, name);
+  }
+  void add_enableHuffmanCode(bool enableHuffmanCode) {
+    fbb_.AddElement<uint8_t>(Tensor::VT_ENABLEHUFFMANCODE, static_cast<uint8_t>(enableHuffmanCode), 0);
+  }
+  void add_weightQunatCompressType(mindspore::schema::WeightQunatCompressType weightQunatCompressType) {
+    fbb_.AddElement<int32_t>(Tensor::VT_WEIGHTQUNATCOMPRESSTYPE, static_cast<int32_t>(weightQunatCompressType), 0);
+  }
+  void add_externalData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ExternalData>>> externalData) {
+    fbb_.AddOffset(Tensor::VT_EXTERNALDATA, externalData);
+  }
+  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Tensor> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Tensor>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Tensor> CreateTensor(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int32_t nodeType = 0,
+    int32_t dataType = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    int32_t refCount = 0,
+    int32_t offset = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::QuantParam>>> quantParams = 0,
+    flatbuffers::Offset<flatbuffers::Vector<float>> quantClusters = 0,
+    flatbuffers::Offset<flatbuffers::String> name = 0,
+    bool enableHuffmanCode = false,
+    mindspore::schema::WeightQunatCompressType weightQunatCompressType = mindspore::schema::WeightQunatCompressType_NONE,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::ExternalData>>> externalData = 0) {
+  TensorBuilder builder_(_fbb);
+  builder_.add_externalData(externalData);
+  builder_.add_weightQunatCompressType(weightQunatCompressType);
+  builder_.add_name(name);
+  builder_.add_quantClusters(quantClusters);
+  builder_.add_quantParams(quantParams);
+  builder_.add_data(data);
+  builder_.add_offset(offset);
+  builder_.add_refCount(refCount);
+  builder_.add_format(format);
+  builder_.add_dims(dims);
+  builder_.add_dataType(dataType);
+  builder_.add_nodeType(nodeType);
+  builder_.add_enableHuffmanCode(enableHuffmanCode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Tensor> CreateTensorDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int32_t nodeType = 0,
+    int32_t dataType = 0,
+    const std::vector<int32_t> *dims = nullptr,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    int32_t refCount = 0,
+    int32_t offset = 0,
+    const std::vector<uint8_t> *data = nullptr,
+    const std::vector<flatbuffers::Offset<mindspore::schema::QuantParam>> *quantParams = nullptr,
+    const std::vector<float> *quantClusters = nullptr,
+    const char *name = nullptr,
+    bool enableHuffmanCode = false,
+    mindspore::schema::WeightQunatCompressType weightQunatCompressType = mindspore::schema::WeightQunatCompressType_NONE,
+    const std::vector<flatbuffers::Offset<mindspore::schema::ExternalData>> *externalData = nullptr) {
+  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
+  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
+  auto quantParams__ = quantParams ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::QuantParam>>(*quantParams) : 0;
+  auto quantClusters__ = quantClusters ? _fbb.CreateVector<float>(*quantClusters) : 0;
+  auto name__ = name ? _fbb.CreateString(name) : 0;
+  auto externalData__ = externalData ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::ExternalData>>(*externalData) : 0;
+  return mindspore::schema::CreateTensor(
+      _fbb,
+      nodeType,
+      dataType,
+      dims__,
+      format,
+      refCount,
+      offset,
+      data__,
+      quantParams__,
+      quantClusters__,
+      name__,
+      enableHuffmanCode,
+      weightQunatCompressType,
+      externalData__);
+}
+
+struct Primitive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PrimitiveBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_VALUE_TYPE = 4,
+    VT_VALUE = 6
+  };
+  mindspore::schema::PrimitiveType value_type() const {
+    return static_cast<mindspore::schema::PrimitiveType>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
+  }
+  const void *value() const {
+    return GetPointer<const void *>(VT_VALUE);
+  }
+  template<typename T> const T *value_as() const;
+  const mindspore::schema::Abs *value_as_Abs() const {
+    return value_type() == mindspore::schema::PrimitiveType_Abs ? static_cast<const mindspore::schema::Abs *>(value()) : nullptr;
+  }
+  const mindspore::schema::Activation *value_as_Activation() const {
+    return value_type() == mindspore::schema::PrimitiveType_Activation ? static_cast<const mindspore::schema::Activation *>(value()) : nullptr;
+  }
+  const mindspore::schema::ActivationGrad *value_as_ActivationGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_ActivationGrad ? static_cast<const mindspore::schema::ActivationGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Adam *value_as_Adam() const {
+    return value_type() == mindspore::schema::PrimitiveType_Adam ? static_cast<const mindspore::schema::Adam *>(value()) : nullptr;
+  }
+  const mindspore::schema::AddFusion *value_as_AddFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_AddFusion ? static_cast<const mindspore::schema::AddFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::AdderFusion *value_as_AdderFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_AdderFusion ? static_cast<const mindspore::schema::AdderFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::AddGrad *value_as_AddGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_AddGrad ? static_cast<const mindspore::schema::AddGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::AddN *value_as_AddN() const {
+    return value_type() == mindspore::schema::PrimitiveType_AddN ? static_cast<const mindspore::schema::AddN *>(value()) : nullptr;
+  }
+  const mindspore::schema::All *value_as_All() const {
+    return value_type() == mindspore::schema::PrimitiveType_All ? static_cast<const mindspore::schema::All *>(value()) : nullptr;
+  }
+  const mindspore::schema::ApplyMomentum *value_as_ApplyMomentum() const {
+    return value_type() == mindspore::schema::PrimitiveType_ApplyMomentum ? static_cast<const mindspore::schema::ApplyMomentum *>(value()) : nullptr;
+  }
+  const mindspore::schema::ArgMaxFusion *value_as_ArgMaxFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_ArgMaxFusion ? static_cast<const mindspore::schema::ArgMaxFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::ArgMinFusion *value_as_ArgMinFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_ArgMinFusion ? static_cast<const mindspore::schema::ArgMinFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Assert *value_as_Assert() const {
+    return value_type() == mindspore::schema::PrimitiveType_Assert ? static_cast<const mindspore::schema::Assert *>(value()) : nullptr;
+  }
+  const mindspore::schema::Assign *value_as_Assign() const {
+    return value_type() == mindspore::schema::PrimitiveType_Assign ? static_cast<const mindspore::schema::Assign *>(value()) : nullptr;
+  }
+  const mindspore::schema::AssignAdd *value_as_AssignAdd() const {
+    return value_type() == mindspore::schema::PrimitiveType_AssignAdd ? static_cast<const mindspore::schema::AssignAdd *>(value()) : nullptr;
+  }
+  const mindspore::schema::AudioSpectrogram *value_as_AudioSpectrogram() const {
+    return value_type() == mindspore::schema::PrimitiveType_AudioSpectrogram ? static_cast<const mindspore::schema::AudioSpectrogram *>(value()) : nullptr;
+  }
+  const mindspore::schema::AvgPoolFusion *value_as_AvgPoolFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_AvgPoolFusion ? static_cast<const mindspore::schema::AvgPoolFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::AvgPoolGrad *value_as_AvgPoolGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_AvgPoolGrad ? static_cast<const mindspore::schema::AvgPoolGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::BatchNorm *value_as_BatchNorm() const {
+    return value_type() == mindspore::schema::PrimitiveType_BatchNorm ? static_cast<const mindspore::schema::BatchNorm *>(value()) : nullptr;
+  }
+  const mindspore::schema::BatchNormGrad *value_as_BatchNormGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_BatchNormGrad ? static_cast<const mindspore::schema::BatchNormGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::BatchToSpace *value_as_BatchToSpace() const {
+    return value_type() == mindspore::schema::PrimitiveType_BatchToSpace ? static_cast<const mindspore::schema::BatchToSpace *>(value()) : nullptr;
+  }
+  const mindspore::schema::BatchToSpaceND *value_as_BatchToSpaceND() const {
+    return value_type() == mindspore::schema::PrimitiveType_BatchToSpaceND ? static_cast<const mindspore::schema::BatchToSpaceND *>(value()) : nullptr;
+  }
+  const mindspore::schema::BiasAdd *value_as_BiasAdd() const {
+    return value_type() == mindspore::schema::PrimitiveType_BiasAdd ? static_cast<const mindspore::schema::BiasAdd *>(value()) : nullptr;
+  }
+  const mindspore::schema::BinaryCrossEntropy *value_as_BinaryCrossEntropy() const {
+    return value_type() == mindspore::schema::PrimitiveType_BinaryCrossEntropy ? static_cast<const mindspore::schema::BinaryCrossEntropy *>(value()) : nullptr;
+  }
+  const mindspore::schema::BinaryCrossEntropyGrad *value_as_BinaryCrossEntropyGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_BinaryCrossEntropyGrad ? static_cast<const mindspore::schema::BinaryCrossEntropyGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::BiasAddGrad *value_as_BiasAddGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_BiasAddGrad ? static_cast<const mindspore::schema::BiasAddGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::BroadcastTo *value_as_BroadcastTo() const {
+    return value_type() == mindspore::schema::PrimitiveType_BroadcastTo ? static_cast<const mindspore::schema::BroadcastTo *>(value()) : nullptr;
+  }
+  const mindspore::schema::Cast *value_as_Cast() const {
+    return value_type() == mindspore::schema::PrimitiveType_Cast ? static_cast<const mindspore::schema::Cast *>(value()) : nullptr;
+  }
+  const mindspore::schema::Ceil *value_as_Ceil() const {
+    return value_type() == mindspore::schema::PrimitiveType_Ceil ? static_cast<const mindspore::schema::Ceil *>(value()) : nullptr;
+  }
+  const mindspore::schema::Clip *value_as_Clip() const {
+    return value_type() == mindspore::schema::PrimitiveType_Clip ? static_cast<const mindspore::schema::Clip *>(value()) : nullptr;
+  }
+  const mindspore::schema::Concat *value_as_Concat() const {
+    return value_type() == mindspore::schema::PrimitiveType_Concat ? static_cast<const mindspore::schema::Concat *>(value()) : nullptr;
+  }
+  const mindspore::schema::Attention *value_as_Attention() const {
+    return value_type() == mindspore::schema::PrimitiveType_Attention ? static_cast<const mindspore::schema::Attention *>(value()) : nullptr;
+  }
+  const mindspore::schema::Conv2DBackpropFilterFusion *value_as_Conv2DBackpropFilterFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_Conv2DBackpropFilterFusion ? static_cast<const mindspore::schema::Conv2DBackpropFilterFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Conv2DBackpropInputFusion *value_as_Conv2DBackpropInputFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_Conv2DBackpropInputFusion ? static_cast<const mindspore::schema::Conv2DBackpropInputFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Conv2DFusion *value_as_Conv2DFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_Conv2DFusion ? static_cast<const mindspore::schema::Conv2DFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Conv2dTransposeFusion *value_as_Conv2dTransposeFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_Conv2dTransposeFusion ? static_cast<const mindspore::schema::Conv2dTransposeFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Cos *value_as_Cos() const {
+    return value_type() == mindspore::schema::PrimitiveType_Cos ? static_cast<const mindspore::schema::Cos *>(value()) : nullptr;
+  }
+  const mindspore::schema::ConstantOfShape *value_as_ConstantOfShape() const {
+    return value_type() == mindspore::schema::PrimitiveType_ConstantOfShape ? static_cast<const mindspore::schema::ConstantOfShape *>(value()) : nullptr;
+  }
+  const mindspore::schema::Crop *value_as_Crop() const {
+    return value_type() == mindspore::schema::PrimitiveType_Crop ? static_cast<const mindspore::schema::Crop *>(value()) : nullptr;
+  }
+  const mindspore::schema::CustomExtractFeatures *value_as_CustomExtractFeatures() const {
+    return value_type() == mindspore::schema::PrimitiveType_CustomExtractFeatures ? static_cast<const mindspore::schema::CustomExtractFeatures *>(value()) : nullptr;
+  }
+  const mindspore::schema::CustomNormalize *value_as_CustomNormalize() const {
+    return value_type() == mindspore::schema::PrimitiveType_CustomNormalize ? static_cast<const mindspore::schema::CustomNormalize *>(value()) : nullptr;
+  }
+  const mindspore::schema::CustomPredict *value_as_CustomPredict() const {
+    return value_type() == mindspore::schema::PrimitiveType_CustomPredict ? static_cast<const mindspore::schema::CustomPredict *>(value()) : nullptr;
+  }
+  const mindspore::schema::DeConv2DGradFilter *value_as_DeConv2DGradFilter() const {
+    return value_type() == mindspore::schema::PrimitiveType_DeConv2DGradFilter ? static_cast<const mindspore::schema::DeConv2DGradFilter *>(value()) : nullptr;
+  }
+  const mindspore::schema::Depend *value_as_Depend() const {
+    return value_type() == mindspore::schema::PrimitiveType_Depend ? static_cast<const mindspore::schema::Depend *>(value()) : nullptr;
+  }
+  const mindspore::schema::DepthToSpace *value_as_DepthToSpace() const {
+    return value_type() == mindspore::schema::PrimitiveType_DepthToSpace ? static_cast<const mindspore::schema::DepthToSpace *>(value()) : nullptr;
+  }
+  const mindspore::schema::DetectionPostProcess *value_as_DetectionPostProcess() const {
+    return value_type() == mindspore::schema::PrimitiveType_DetectionPostProcess ? static_cast<const mindspore::schema::DetectionPostProcess *>(value()) : nullptr;
+  }
+  const mindspore::schema::DivFusion *value_as_DivFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_DivFusion ? static_cast<const mindspore::schema::DivFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::DivGrad *value_as_DivGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_DivGrad ? static_cast<const mindspore::schema::DivGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Dropout *value_as_Dropout() const {
+    return value_type() == mindspore::schema::PrimitiveType_Dropout ? static_cast<const mindspore::schema::Dropout *>(value()) : nullptr;
+  }
+  const mindspore::schema::DropoutGrad *value_as_DropoutGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_DropoutGrad ? static_cast<const mindspore::schema::DropoutGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Elu *value_as_Elu() const {
+    return value_type() == mindspore::schema::PrimitiveType_Elu ? static_cast<const mindspore::schema::Elu *>(value()) : nullptr;
+  }
+  const mindspore::schema::Eltwise *value_as_Eltwise() const {
+    return value_type() == mindspore::schema::PrimitiveType_Eltwise ? static_cast<const mindspore::schema::Eltwise *>(value()) : nullptr;
+  }
+  const mindspore::schema::Equal *value_as_Equal() const {
+    return value_type() == mindspore::schema::PrimitiveType_Equal ? static_cast<const mindspore::schema::Equal *>(value()) : nullptr;
+  }
+  const mindspore::schema::EmbeddingLookupFusion *value_as_EmbeddingLookupFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_EmbeddingLookupFusion ? static_cast<const mindspore::schema::EmbeddingLookupFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::ExpFusion *value_as_ExpFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_ExpFusion ? static_cast<const mindspore::schema::ExpFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::ExpandDims *value_as_ExpandDims() const {
+    return value_type() == mindspore::schema::PrimitiveType_ExpandDims ? static_cast<const mindspore::schema::ExpandDims *>(value()) : nullptr;
+  }
+  const mindspore::schema::FakeQuantWithMinMaxVars *value_as_FakeQuantWithMinMaxVars() const {
+    return value_type() == mindspore::schema::PrimitiveType_FakeQuantWithMinMaxVars ? static_cast<const mindspore::schema::FakeQuantWithMinMaxVars *>(value()) : nullptr;
+  }
+  const mindspore::schema::FakeQuantWithMinMaxVarsPerChannel *value_as_FakeQuantWithMinMaxVarsPerChannel() const {
+    return value_type() == mindspore::schema::PrimitiveType_FakeQuantWithMinMaxVarsPerChannel ? static_cast<const mindspore::schema::FakeQuantWithMinMaxVarsPerChannel *>(value()) : nullptr;
+  }
+  const mindspore::schema::FftReal *value_as_FftReal() const {
+    return value_type() == mindspore::schema::PrimitiveType_FftReal ? static_cast<const mindspore::schema::FftReal *>(value()) : nullptr;
+  }
+  const mindspore::schema::FftImag *value_as_FftImag() const {
+    return value_type() == mindspore::schema::PrimitiveType_FftImag ? static_cast<const mindspore::schema::FftImag *>(value()) : nullptr;
+  }
+  const mindspore::schema::Flatten *value_as_Flatten() const {
+    return value_type() == mindspore::schema::PrimitiveType_Flatten ? static_cast<const mindspore::schema::Flatten *>(value()) : nullptr;
+  }
+  const mindspore::schema::FlattenGrad *value_as_FlattenGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_FlattenGrad ? static_cast<const mindspore::schema::FlattenGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Floor *value_as_Floor() const {
+    return value_type() == mindspore::schema::PrimitiveType_Floor ? static_cast<const mindspore::schema::Floor *>(value()) : nullptr;
+  }
+  const mindspore::schema::FloorDiv *value_as_FloorDiv() const {
+    return value_type() == mindspore::schema::PrimitiveType_FloorDiv ? static_cast<const mindspore::schema::FloorDiv *>(value()) : nullptr;
+  }
+  const mindspore::schema::FloorMod *value_as_FloorMod() const {
+    return value_type() == mindspore::schema::PrimitiveType_FloorMod ? static_cast<const mindspore::schema::FloorMod *>(value()) : nullptr;
+  }
+  const mindspore::schema::Fill *value_as_Fill() const {
+    return value_type() == mindspore::schema::PrimitiveType_Fill ? static_cast<const mindspore::schema::Fill *>(value()) : nullptr;
+  }
+  const mindspore::schema::FullConnection *value_as_FullConnection() const {
+    return value_type() == mindspore::schema::PrimitiveType_FullConnection ? static_cast<const mindspore::schema::FullConnection *>(value()) : nullptr;
+  }
+  const mindspore::schema::FusedBatchNorm *value_as_FusedBatchNorm() const {
+    return value_type() == mindspore::schema::PrimitiveType_FusedBatchNorm ? static_cast<const mindspore::schema::FusedBatchNorm *>(value()) : nullptr;
+  }
+  const mindspore::schema::Gather *value_as_Gather() const {
+    return value_type() == mindspore::schema::PrimitiveType_Gather ? static_cast<const mindspore::schema::Gather *>(value()) : nullptr;
+  }
+  const mindspore::schema::GatherNd *value_as_GatherNd() const {
+    return value_type() == mindspore::schema::PrimitiveType_GatherNd ? static_cast<const mindspore::schema::GatherNd *>(value()) : nullptr;
+  }
+  const mindspore::schema::Greater *value_as_Greater() const {
+    return value_type() == mindspore::schema::PrimitiveType_Greater ? static_cast<const mindspore::schema::Greater *>(value()) : nullptr;
+  }
+  const mindspore::schema::GreaterEqual *value_as_GreaterEqual() const {
+    return value_type() == mindspore::schema::PrimitiveType_GreaterEqual ? static_cast<const mindspore::schema::GreaterEqual *>(value()) : nullptr;
+  }
+  const mindspore::schema::HashtableLookup *value_as_HashtableLookup() const {
+    return value_type() == mindspore::schema::PrimitiveType_HashtableLookup ? static_cast<const mindspore::schema::HashtableLookup *>(value()) : nullptr;
+  }
+  const mindspore::schema::InstanceNorm *value_as_InstanceNorm() const {
+    return value_type() == mindspore::schema::PrimitiveType_InstanceNorm ? static_cast<const mindspore::schema::InstanceNorm *>(value()) : nullptr;
+  }
+  const mindspore::schema::LayerNormFusion *value_as_LayerNormFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_LayerNormFusion ? static_cast<const mindspore::schema::LayerNormFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::LeakyRelu *value_as_LeakyRelu() const {
+    return value_type() == mindspore::schema::PrimitiveType_LeakyRelu ? static_cast<const mindspore::schema::LeakyRelu *>(value()) : nullptr;
+  }
+  const mindspore::schema::Less *value_as_Less() const {
+    return value_type() == mindspore::schema::PrimitiveType_Less ? static_cast<const mindspore::schema::Less *>(value()) : nullptr;
+  }
+  const mindspore::schema::LessEqual *value_as_LessEqual() const {
+    return value_type() == mindspore::schema::PrimitiveType_LessEqual ? static_cast<const mindspore::schema::LessEqual *>(value()) : nullptr;
+  }
+  const mindspore::schema::Log *value_as_Log() const {
+    return value_type() == mindspore::schema::PrimitiveType_Log ? static_cast<const mindspore::schema::Log *>(value()) : nullptr;
+  }
+  const mindspore::schema::LogGrad *value_as_LogGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_LogGrad ? static_cast<const mindspore::schema::LogGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::LogicalAnd *value_as_LogicalAnd() const {
+    return value_type() == mindspore::schema::PrimitiveType_LogicalAnd ? static_cast<const mindspore::schema::LogicalAnd *>(value()) : nullptr;
+  }
+  const mindspore::schema::LogicalNot *value_as_LogicalNot() const {
+    return value_type() == mindspore::schema::PrimitiveType_LogicalNot ? static_cast<const mindspore::schema::LogicalNot *>(value()) : nullptr;
+  }
+  const mindspore::schema::LogicalOr *value_as_LogicalOr() const {
+    return value_type() == mindspore::schema::PrimitiveType_LogicalOr ? static_cast<const mindspore::schema::LogicalOr *>(value()) : nullptr;
+  }
+  const mindspore::schema::LpNormalization *value_as_LpNormalization() const {
+    return value_type() == mindspore::schema::PrimitiveType_LpNormalization ? static_cast<const mindspore::schema::LpNormalization *>(value()) : nullptr;
+  }
+  const mindspore::schema::LRN *value_as_LRN() const {
+    return value_type() == mindspore::schema::PrimitiveType_LRN ? static_cast<const mindspore::schema::LRN *>(value()) : nullptr;
+  }
+  const mindspore::schema::LshProjection *value_as_LshProjection() const {
+    return value_type() == mindspore::schema::PrimitiveType_LshProjection ? static_cast<const mindspore::schema::LshProjection *>(value()) : nullptr;
+  }
+  const mindspore::schema::LSTM *value_as_LSTM() const {
+    return value_type() == mindspore::schema::PrimitiveType_LSTM ? static_cast<const mindspore::schema::LSTM *>(value()) : nullptr;
+  }
+  const mindspore::schema::L2NormalizeFusion *value_as_L2NormalizeFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_L2NormalizeFusion ? static_cast<const mindspore::schema::L2NormalizeFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::MatMulFusion *value_as_MatMulFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_MatMulFusion ? static_cast<const mindspore::schema::MatMulFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Maximum *value_as_Maximum() const {
+    return value_type() == mindspore::schema::PrimitiveType_Maximum ? static_cast<const mindspore::schema::Maximum *>(value()) : nullptr;
+  }
+  const mindspore::schema::MaximumGrad *value_as_MaximumGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_MaximumGrad ? static_cast<const mindspore::schema::MaximumGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::MaxPoolFusion *value_as_MaxPoolFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_MaxPoolFusion ? static_cast<const mindspore::schema::MaxPoolFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::MaxPoolGrad *value_as_MaxPoolGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_MaxPoolGrad ? static_cast<const mindspore::schema::MaxPoolGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::SwitchLayer *value_as_SwitchLayer() const {
+    return value_type() == mindspore::schema::PrimitiveType_SwitchLayer ? static_cast<const mindspore::schema::SwitchLayer *>(value()) : nullptr;
+  }
+  const mindspore::schema::Mfcc *value_as_Mfcc() const {
+    return value_type() == mindspore::schema::PrimitiveType_Mfcc ? static_cast<const mindspore::schema::Mfcc *>(value()) : nullptr;
+  }
+  const mindspore::schema::Minimum *value_as_Minimum() const {
+    return value_type() == mindspore::schema::PrimitiveType_Minimum ? static_cast<const mindspore::schema::Minimum *>(value()) : nullptr;
+  }
+  const mindspore::schema::MinimumGrad *value_as_MinimumGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_MinimumGrad ? static_cast<const mindspore::schema::MinimumGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Mod *value_as_Mod() const {
+    return value_type() == mindspore::schema::PrimitiveType_Mod ? static_cast<const mindspore::schema::Mod *>(value()) : nullptr;
+  }
+  const mindspore::schema::MulFusion *value_as_MulFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_MulFusion ? static_cast<const mindspore::schema::MulFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::MulGrad *value_as_MulGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_MulGrad ? static_cast<const mindspore::schema::MulGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Neg *value_as_Neg() const {
+    return value_type() == mindspore::schema::PrimitiveType_Neg ? static_cast<const mindspore::schema::Neg *>(value()) : nullptr;
+  }
+  const mindspore::schema::NegGrad *value_as_NegGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_NegGrad ? static_cast<const mindspore::schema::NegGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::NotEqual *value_as_NotEqual() const {
+    return value_type() == mindspore::schema::PrimitiveType_NotEqual ? static_cast<const mindspore::schema::NotEqual *>(value()) : nullptr;
+  }
+  const mindspore::schema::NonMaxSuppression *value_as_NonMaxSuppression() const {
+    return value_type() == mindspore::schema::PrimitiveType_NonMaxSuppression ? static_cast<const mindspore::schema::NonMaxSuppression *>(value()) : nullptr;
+  }
+  const mindspore::schema::OneHot *value_as_OneHot() const {
+    return value_type() == mindspore::schema::PrimitiveType_OneHot ? static_cast<const mindspore::schema::OneHot *>(value()) : nullptr;
+  }
+  const mindspore::schema::OnesLike *value_as_OnesLike() const {
+    return value_type() == mindspore::schema::PrimitiveType_OnesLike ? static_cast<const mindspore::schema::OnesLike *>(value()) : nullptr;
+  }
+  const mindspore::schema::PadFusion *value_as_PadFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_PadFusion ? static_cast<const mindspore::schema::PadFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::PartialFusion *value_as_PartialFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_PartialFusion ? static_cast<const mindspore::schema::PartialFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::PowerGrad *value_as_PowerGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_PowerGrad ? static_cast<const mindspore::schema::PowerGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::PowFusion *value_as_PowFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_PowFusion ? static_cast<const mindspore::schema::PowFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::PriorBox *value_as_PriorBox() const {
+    return value_type() == mindspore::schema::PrimitiveType_PriorBox ? static_cast<const mindspore::schema::PriorBox *>(value()) : nullptr;
+  }
+  const mindspore::schema::PReLUFusion *value_as_PReLUFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_PReLUFusion ? static_cast<const mindspore::schema::PReLUFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::QuantDTypeCast *value_as_QuantDTypeCast() const {
+    return value_type() == mindspore::schema::PrimitiveType_QuantDTypeCast ? static_cast<const mindspore::schema::QuantDTypeCast *>(value()) : nullptr;
+  }
+  const mindspore::schema::Rank *value_as_Rank() const {
+    return value_type() == mindspore::schema::PrimitiveType_Rank ? static_cast<const mindspore::schema::Rank *>(value()) : nullptr;
+  }
+  const mindspore::schema::Range *value_as_Range() const {
+    return value_type() == mindspore::schema::PrimitiveType_Range ? static_cast<const mindspore::schema::Range *>(value()) : nullptr;
+  }
+  const mindspore::schema::Reciprocal *value_as_Reciprocal() const {
+    return value_type() == mindspore::schema::PrimitiveType_Reciprocal ? static_cast<const mindspore::schema::Reciprocal *>(value()) : nullptr;
+  }
+  const mindspore::schema::RealDiv *value_as_RealDiv() const {
+    return value_type() == mindspore::schema::PrimitiveType_RealDiv ? static_cast<const mindspore::schema::RealDiv *>(value()) : nullptr;
+  }
+  const mindspore::schema::ReduceFusion *value_as_ReduceFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_ReduceFusion ? static_cast<const mindspore::schema::ReduceFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Reshape *value_as_Reshape() const {
+    return value_type() == mindspore::schema::PrimitiveType_Reshape ? static_cast<const mindspore::schema::Reshape *>(value()) : nullptr;
+  }
+  const mindspore::schema::Resize *value_as_Resize() const {
+    return value_type() == mindspore::schema::PrimitiveType_Resize ? static_cast<const mindspore::schema::Resize *>(value()) : nullptr;
+  }
+  const mindspore::schema::ReverseSequence *value_as_ReverseSequence() const {
+    return value_type() == mindspore::schema::PrimitiveType_ReverseSequence ? static_cast<const mindspore::schema::ReverseSequence *>(value()) : nullptr;
+  }
+  const mindspore::schema::ReverseV2 *value_as_ReverseV2() const {
+    return value_type() == mindspore::schema::PrimitiveType_ReverseV2 ? static_cast<const mindspore::schema::ReverseV2 *>(value()) : nullptr;
+  }
+  const mindspore::schema::Rfft *value_as_Rfft() const {
+    return value_type() == mindspore::schema::PrimitiveType_Rfft ? static_cast<const mindspore::schema::Rfft *>(value()) : nullptr;
+  }
+  const mindspore::schema::ROIPooling *value_as_ROIPooling() const {
+    return value_type() == mindspore::schema::PrimitiveType_ROIPooling ? static_cast<const mindspore::schema::ROIPooling *>(value()) : nullptr;
+  }
+  const mindspore::schema::Round *value_as_Round() const {
+    return value_type() == mindspore::schema::PrimitiveType_Round ? static_cast<const mindspore::schema::Round *>(value()) : nullptr;
+  }
+  const mindspore::schema::Rsqrt *value_as_Rsqrt() const {
+    return value_type() == mindspore::schema::PrimitiveType_Rsqrt ? static_cast<const mindspore::schema::Rsqrt *>(value()) : nullptr;
+  }
+  const mindspore::schema::ScaleFusion *value_as_ScaleFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_ScaleFusion ? static_cast<const mindspore::schema::ScaleFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::ScatterNd *value_as_ScatterNd() const {
+    return value_type() == mindspore::schema::PrimitiveType_ScatterNd ? static_cast<const mindspore::schema::ScatterNd *>(value()) : nullptr;
+  }
+  const mindspore::schema::SGD *value_as_SGD() const {
+    return value_type() == mindspore::schema::PrimitiveType_SGD ? static_cast<const mindspore::schema::SGD *>(value()) : nullptr;
+  }
+  const mindspore::schema::Shape *value_as_Shape() const {
+    return value_type() == mindspore::schema::PrimitiveType_Shape ? static_cast<const mindspore::schema::Shape *>(value()) : nullptr;
+  }
+  const mindspore::schema::SigmoidCrossEntropyWithLogits *value_as_SigmoidCrossEntropyWithLogits() const {
+    return value_type() == mindspore::schema::PrimitiveType_SigmoidCrossEntropyWithLogits ? static_cast<const mindspore::schema::SigmoidCrossEntropyWithLogits *>(value()) : nullptr;
+  }
+  const mindspore::schema::SigmoidCrossEntropyWithLogitsGrad *value_as_SigmoidCrossEntropyWithLogitsGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_SigmoidCrossEntropyWithLogitsGrad ? static_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Sin *value_as_Sin() const {
+    return value_type() == mindspore::schema::PrimitiveType_Sin ? static_cast<const mindspore::schema::Sin *>(value()) : nullptr;
+  }
+  const mindspore::schema::SkipGram *value_as_SkipGram() const {
+    return value_type() == mindspore::schema::PrimitiveType_SkipGram ? static_cast<const mindspore::schema::SkipGram *>(value()) : nullptr;
+  }
+  const mindspore::schema::SliceFusion *value_as_SliceFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_SliceFusion ? static_cast<const mindspore::schema::SliceFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::SmoothL1Loss *value_as_SmoothL1Loss() const {
+    return value_type() == mindspore::schema::PrimitiveType_SmoothL1Loss ? static_cast<const mindspore::schema::SmoothL1Loss *>(value()) : nullptr;
+  }
+  const mindspore::schema::SmoothL1LossGrad *value_as_SmoothL1LossGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_SmoothL1LossGrad ? static_cast<const mindspore::schema::SmoothL1LossGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Softmax *value_as_Softmax() const {
+    return value_type() == mindspore::schema::PrimitiveType_Softmax ? static_cast<const mindspore::schema::Softmax *>(value()) : nullptr;
+  }
+  const mindspore::schema::SoftmaxCrossEntropyWithLogits *value_as_SoftmaxCrossEntropyWithLogits() const {
+    return value_type() == mindspore::schema::PrimitiveType_SoftmaxCrossEntropyWithLogits ? static_cast<const mindspore::schema::SoftmaxCrossEntropyWithLogits *>(value()) : nullptr;
+  }
+  const mindspore::schema::SpaceToBatch *value_as_SpaceToBatch() const {
+    return value_type() == mindspore::schema::PrimitiveType_SpaceToBatch ? static_cast<const mindspore::schema::SpaceToBatch *>(value()) : nullptr;
+  }
+  const mindspore::schema::SpaceToBatchND *value_as_SpaceToBatchND() const {
+    return value_type() == mindspore::schema::PrimitiveType_SpaceToBatchND ? static_cast<const mindspore::schema::SpaceToBatchND *>(value()) : nullptr;
+  }
+  const mindspore::schema::SpaceToDepth *value_as_SpaceToDepth() const {
+    return value_type() == mindspore::schema::PrimitiveType_SpaceToDepth ? static_cast<const mindspore::schema::SpaceToDepth *>(value()) : nullptr;
+  }
+  const mindspore::schema::SparseSoftmaxCrossEntropyWithLogits *value_as_SparseSoftmaxCrossEntropyWithLogits() const {
+    return value_type() == mindspore::schema::PrimitiveType_SparseSoftmaxCrossEntropyWithLogits ? static_cast<const mindspore::schema::SparseSoftmaxCrossEntropyWithLogits *>(value()) : nullptr;
+  }
+  const mindspore::schema::SparseToDense *value_as_SparseToDense() const {
+    return value_type() == mindspore::schema::PrimitiveType_SparseToDense ? static_cast<const mindspore::schema::SparseToDense *>(value()) : nullptr;
+  }
+  const mindspore::schema::Split *value_as_Split() const {
+    return value_type() == mindspore::schema::PrimitiveType_Split ? static_cast<const mindspore::schema::Split *>(value()) : nullptr;
+  }
+  const mindspore::schema::Sqrt *value_as_Sqrt() const {
+    return value_type() == mindspore::schema::PrimitiveType_Sqrt ? static_cast<const mindspore::schema::Sqrt *>(value()) : nullptr;
+  }
+  const mindspore::schema::Squeeze *value_as_Squeeze() const {
+    return value_type() == mindspore::schema::PrimitiveType_Squeeze ? static_cast<const mindspore::schema::Squeeze *>(value()) : nullptr;
+  }
+  const mindspore::schema::Square *value_as_Square() const {
+    return value_type() == mindspore::schema::PrimitiveType_Square ? static_cast<const mindspore::schema::Square *>(value()) : nullptr;
+  }
+  const mindspore::schema::SquaredDifference *value_as_SquaredDifference() const {
+    return value_type() == mindspore::schema::PrimitiveType_SquaredDifference ? static_cast<const mindspore::schema::SquaredDifference *>(value()) : nullptr;
+  }
+  const mindspore::schema::Stack *value_as_Stack() const {
+    return value_type() == mindspore::schema::PrimitiveType_Stack ? static_cast<const mindspore::schema::Stack *>(value()) : nullptr;
+  }
+  const mindspore::schema::StridedSlice *value_as_StridedSlice() const {
+    return value_type() == mindspore::schema::PrimitiveType_StridedSlice ? static_cast<const mindspore::schema::StridedSlice *>(value()) : nullptr;
+  }
+  const mindspore::schema::SubFusion *value_as_SubFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_SubFusion ? static_cast<const mindspore::schema::SubFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::SubGrad *value_as_SubGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_SubGrad ? static_cast<const mindspore::schema::SubGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Switch *value_as_Switch() const {
+    return value_type() == mindspore::schema::PrimitiveType_Switch ? static_cast<const mindspore::schema::Switch *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorListFromTensor *value_as_TensorListFromTensor() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorListFromTensor ? static_cast<const mindspore::schema::TensorListFromTensor *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorListGetItem *value_as_TensorListGetItem() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorListGetItem ? static_cast<const mindspore::schema::TensorListGetItem *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorListReserve *value_as_TensorListReserve() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorListReserve ? static_cast<const mindspore::schema::TensorListReserve *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorListSetItem *value_as_TensorListSetItem() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorListSetItem ? static_cast<const mindspore::schema::TensorListSetItem *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorListStack *value_as_TensorListStack() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorListStack ? static_cast<const mindspore::schema::TensorListStack *>(value()) : nullptr;
+  }
+  const mindspore::schema::TileFusion *value_as_TileFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_TileFusion ? static_cast<const mindspore::schema::TileFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::TopKFusion *value_as_TopKFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_TopKFusion ? static_cast<const mindspore::schema::TopKFusion *>(value()) : nullptr;
+  }
+  const mindspore::schema::Transpose *value_as_Transpose() const {
+    return value_type() == mindspore::schema::PrimitiveType_Transpose ? static_cast<const mindspore::schema::Transpose *>(value()) : nullptr;
+  }
+  const mindspore::schema::Unique *value_as_Unique() const {
+    return value_type() == mindspore::schema::PrimitiveType_Unique ? static_cast<const mindspore::schema::Unique *>(value()) : nullptr;
+  }
+  const mindspore::schema::UnsortedSegmentSum *value_as_UnsortedSegmentSum() const {
+    return value_type() == mindspore::schema::PrimitiveType_UnsortedSegmentSum ? static_cast<const mindspore::schema::UnsortedSegmentSum *>(value()) : nullptr;
+  }
+  const mindspore::schema::Unsqueeze *value_as_Unsqueeze() const {
+    return value_type() == mindspore::schema::PrimitiveType_Unsqueeze ? static_cast<const mindspore::schema::Unsqueeze *>(value()) : nullptr;
+  }
+  const mindspore::schema::Unstack *value_as_Unstack() const {
+    return value_type() == mindspore::schema::PrimitiveType_Unstack ? static_cast<const mindspore::schema::Unstack *>(value()) : nullptr;
+  }
+  const mindspore::schema::LSTMGrad *value_as_LSTMGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_LSTMGrad ? static_cast<const mindspore::schema::LSTMGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Where *value_as_Where() const {
+    return value_type() == mindspore::schema::PrimitiveType_Where ? static_cast<const mindspore::schema::Where *>(value()) : nullptr;
+  }
+  const mindspore::schema::ZerosLike *value_as_ZerosLike() const {
+    return value_type() == mindspore::schema::PrimitiveType_ZerosLike ? static_cast<const mindspore::schema::ZerosLike *>(value()) : nullptr;
+  }
+  const mindspore::schema::Select *value_as_Select() const {
+    return value_type() == mindspore::schema::PrimitiveType_Select ? static_cast<const mindspore::schema::Select *>(value()) : nullptr;
+  }
+  const mindspore::schema::ScatterNdUpdate *value_as_ScatterNdUpdate() const {
+    return value_type() == mindspore::schema::PrimitiveType_ScatterNdUpdate ? static_cast<const mindspore::schema::ScatterNdUpdate *>(value()) : nullptr;
+  }
+  const mindspore::schema::GRU *value_as_GRU() const {
+    return value_type() == mindspore::schema::PrimitiveType_GRU ? static_cast<const mindspore::schema::GRU *>(value()) : nullptr;
+  }
+  const mindspore::schema::NonZero *value_as_NonZero() const {
+    return value_type() == mindspore::schema::PrimitiveType_NonZero ? static_cast<const mindspore::schema::NonZero *>(value()) : nullptr;
+  }
+  const mindspore::schema::InvertPermutation *value_as_InvertPermutation() const {
+    return value_type() == mindspore::schema::PrimitiveType_InvertPermutation ? static_cast<const mindspore::schema::InvertPermutation *>(value()) : nullptr;
+  }
+  const mindspore::schema::Size *value_as_Size() const {
+    return value_type() == mindspore::schema::PrimitiveType_Size ? static_cast<const mindspore::schema::Size *>(value()) : nullptr;
+  }
+  const mindspore::schema::RandomStandardNormal *value_as_RandomStandardNormal() const {
+    return value_type() == mindspore::schema::PrimitiveType_RandomStandardNormal ? static_cast<const mindspore::schema::RandomStandardNormal *>(value()) : nullptr;
+  }
+  const mindspore::schema::CropAndResize *value_as_CropAndResize() const {
+    return value_type() == mindspore::schema::PrimitiveType_CropAndResize ? static_cast<const mindspore::schema::CropAndResize *>(value()) : nullptr;
+  }
+  const mindspore::schema::Erf *value_as_Erf() const {
+    return value_type() == mindspore::schema::PrimitiveType_Erf ? static_cast<const mindspore::schema::Erf *>(value()) : nullptr;
+  }
+  const mindspore::schema::StridedSliceGrad *value_as_StridedSliceGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_StridedSliceGrad ? static_cast<const mindspore::schema::StridedSliceGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::IsFinite *value_as_IsFinite() const {
+    return value_type() == mindspore::schema::PrimitiveType_IsFinite ? static_cast<const mindspore::schema::IsFinite *>(value()) : nullptr;
+  }
+  const mindspore::schema::LinSpace *value_as_LinSpace() const {
+    return value_type() == mindspore::schema::PrimitiveType_LinSpace ? static_cast<const mindspore::schema::LinSpace *>(value()) : nullptr;
+  }
+  const mindspore::schema::UniformReal *value_as_UniformReal() const {
+    return value_type() == mindspore::schema::PrimitiveType_UniformReal ? static_cast<const mindspore::schema::UniformReal *>(value()) : nullptr;
+  }
+  const mindspore::schema::AbsGrad *value_as_AbsGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_AbsGrad ? static_cast<const mindspore::schema::AbsGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::RsqrtGrad *value_as_RsqrtGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_RsqrtGrad ? static_cast<const mindspore::schema::RsqrtGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::SqrtGrad *value_as_SqrtGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_SqrtGrad ? static_cast<const mindspore::schema::SqrtGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::LayerNormGrad *value_as_LayerNormGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_LayerNormGrad ? static_cast<const mindspore::schema::LayerNormGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::ResizeGrad *value_as_ResizeGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_ResizeGrad ? static_cast<const mindspore::schema::ResizeGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::Splice *value_as_Splice() const {
+    return value_type() == mindspore::schema::PrimitiveType_Splice ? static_cast<const mindspore::schema::Splice *>(value()) : nullptr;
+  }
+  const mindspore::schema::LogSoftmax *value_as_LogSoftmax() const {
+    return value_type() == mindspore::schema::PrimitiveType_LogSoftmax ? static_cast<const mindspore::schema::LogSoftmax *>(value()) : nullptr;
+  }
+  const mindspore::schema::Call *value_as_Call() const {
+    return value_type() == mindspore::schema::PrimitiveType_Call ? static_cast<const mindspore::schema::Call *>(value()) : nullptr;
+  }
+  const mindspore::schema::Custom *value_as_Custom() const {
+    return value_type() == mindspore::schema::PrimitiveType_Custom ? static_cast<const mindspore::schema::Custom *>(value()) : nullptr;
+  }
+  const mindspore::schema::CumSum *value_as_CumSum() const {
+    return value_type() == mindspore::schema::PrimitiveType_CumSum ? static_cast<const mindspore::schema::CumSum *>(value()) : nullptr;
+  }
+  const mindspore::schema::SplitWithOverlap *value_as_SplitWithOverlap() const {
+    return value_type() == mindspore::schema::PrimitiveType_SplitWithOverlap ? static_cast<const mindspore::schema::SplitWithOverlap *>(value()) : nullptr;
+  }
+  const mindspore::schema::GenOP *value_as_GenOP() const {
+    return value_type() == mindspore::schema::PrimitiveType_GenOP ? static_cast<const mindspore::schema::GenOP *>(value()) : nullptr;
+  }
+  const mindspore::schema::RaggedRange *value_as_RaggedRange() const {
+    return value_type() == mindspore::schema::PrimitiveType_RaggedRange ? static_cast<const mindspore::schema::RaggedRange *>(value()) : nullptr;
+  }
+  const mindspore::schema::GLU *value_as_GLU() const {
+    return value_type() == mindspore::schema::PrimitiveType_GLU ? static_cast<const mindspore::schema::GLU *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorArray *value_as_TensorArray() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorArray ? static_cast<const mindspore::schema::TensorArray *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorArrayRead *value_as_TensorArrayRead() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorArrayRead ? static_cast<const mindspore::schema::TensorArrayRead *>(value()) : nullptr;
+  }
+  const mindspore::schema::TensorArrayWrite *value_as_TensorArrayWrite() const {
+    return value_type() == mindspore::schema::PrimitiveType_TensorArrayWrite ? static_cast<const mindspore::schema::TensorArrayWrite *>(value()) : nullptr;
+  }
+  const mindspore::schema::Affine *value_as_Affine() const {
+    return value_type() == mindspore::schema::PrimitiveType_Affine ? static_cast<const mindspore::schema::Affine *>(value()) : nullptr;
+  }
+  const mindspore::schema::AllGather *value_as_AllGather() const {
+    return value_type() == mindspore::schema::PrimitiveType_AllGather ? static_cast<const mindspore::schema::AllGather *>(value()) : nullptr;
+  }
+  const mindspore::schema::ReduceScatter *value_as_ReduceScatter() const {
+    return value_type() == mindspore::schema::PrimitiveType_ReduceScatter ? static_cast<const mindspore::schema::ReduceScatter *>(value()) : nullptr;
+  }
+  const mindspore::schema::DynamicQuant *value_as_DynamicQuant() const {
+    return value_type() == mindspore::schema::PrimitiveType_DynamicQuant ? static_cast<const mindspore::schema::DynamicQuant *>(value()) : nullptr;
+  }
+  const mindspore::schema::LSTMGradData *value_as_LSTMGradData() const {
+    return value_type() == mindspore::schema::PrimitiveType_LSTMGradData ? static_cast<const mindspore::schema::LSTMGradData *>(value()) : nullptr;
+  }
+  const mindspore::schema::LSTMGradWeight *value_as_LSTMGradWeight() const {
+    return value_type() == mindspore::schema::PrimitiveType_LSTMGradWeight ? static_cast<const mindspore::schema::LSTMGradWeight *>(value()) : nullptr;
+  }
+  const mindspore::schema::RandomNormal *value_as_RandomNormal() const {
+    return value_type() == mindspore::schema::PrimitiveType_RandomNormal ? static_cast<const mindspore::schema::RandomNormal *>(value()) : nullptr;
+  }
+  const mindspore::schema::NLLLoss *value_as_NLLLoss() const {
+    return value_type() == mindspore::schema::PrimitiveType_NLLLoss ? static_cast<const mindspore::schema::NLLLoss *>(value()) : nullptr;
+  }
+  const mindspore::schema::NLLLossGrad *value_as_NLLLossGrad() const {
+    return value_type() == mindspore::schema::PrimitiveType_NLLLossGrad ? static_cast<const mindspore::schema::NLLLossGrad *>(value()) : nullptr;
+  }
+  const mindspore::schema::FormatTranspose *value_as_FormatTranspose() const {
+    return value_type() == mindspore::schema::PrimitiveType_FormatTranspose ? static_cast<const mindspore::schema::FormatTranspose *>(value()) : nullptr;
+  }
+  const mindspore::schema::GatherD *value_as_GatherD() const {
+    return value_type() == mindspore::schema::PrimitiveType_GatherD ? static_cast<const mindspore::schema::GatherD *>(value()) : nullptr;
+  }
+  const mindspore::schema::GroupNormFusion *value_as_GroupNormFusion() const {
+    return value_type() == mindspore::schema::PrimitiveType_GroupNormFusion ? static_cast<const mindspore::schema::GroupNormFusion *>(value()) : nullptr;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
+           VerifyOffset(verifier, VT_VALUE) &&
+           VerifyPrimitiveType(verifier, value(), value_type()) &&
+           verifier.EndTable();
+  }
+};
+
+template<> inline const mindspore::schema::Abs *Primitive::value_as<mindspore::schema::Abs>() const {
+  return value_as_Abs();
+}
+
+template<> inline const mindspore::schema::Activation *Primitive::value_as<mindspore::schema::Activation>() const {
+  return value_as_Activation();
+}
+
+template<> inline const mindspore::schema::ActivationGrad *Primitive::value_as<mindspore::schema::ActivationGrad>() const {
+  return value_as_ActivationGrad();
+}
+
+template<> inline const mindspore::schema::Adam *Primitive::value_as<mindspore::schema::Adam>() const {
+  return value_as_Adam();
+}
+
+template<> inline const mindspore::schema::AddFusion *Primitive::value_as<mindspore::schema::AddFusion>() const {
+  return value_as_AddFusion();
+}
+
+template<> inline const mindspore::schema::AdderFusion *Primitive::value_as<mindspore::schema::AdderFusion>() const {
+  return value_as_AdderFusion();
+}
+
+template<> inline const mindspore::schema::AddGrad *Primitive::value_as<mindspore::schema::AddGrad>() const {
+  return value_as_AddGrad();
+}
+
+template<> inline const mindspore::schema::AddN *Primitive::value_as<mindspore::schema::AddN>() const {
+  return value_as_AddN();
+}
+
+template<> inline const mindspore::schema::All *Primitive::value_as<mindspore::schema::All>() const {
+  return value_as_All();
+}
+
+template<> inline const mindspore::schema::ApplyMomentum *Primitive::value_as<mindspore::schema::ApplyMomentum>() const {
+  return value_as_ApplyMomentum();
+}
+
+template<> inline const mindspore::schema::ArgMaxFusion *Primitive::value_as<mindspore::schema::ArgMaxFusion>() const {
+  return value_as_ArgMaxFusion();
+}
+
+template<> inline const mindspore::schema::ArgMinFusion *Primitive::value_as<mindspore::schema::ArgMinFusion>() const {
+  return value_as_ArgMinFusion();
+}
+
+template<> inline const mindspore::schema::Assert *Primitive::value_as<mindspore::schema::Assert>() const {
+  return value_as_Assert();
+}
+
+template<> inline const mindspore::schema::Assign *Primitive::value_as<mindspore::schema::Assign>() const {
+  return value_as_Assign();
+}
+
+template<> inline const mindspore::schema::AssignAdd *Primitive::value_as<mindspore::schema::AssignAdd>() const {
+  return value_as_AssignAdd();
+}
+
+template<> inline const mindspore::schema::AudioSpectrogram *Primitive::value_as<mindspore::schema::AudioSpectrogram>() const {
+  return value_as_AudioSpectrogram();
+}
+
+template<> inline const mindspore::schema::AvgPoolFusion *Primitive::value_as<mindspore::schema::AvgPoolFusion>() const {
+  return value_as_AvgPoolFusion();
+}
+
+template<> inline const mindspore::schema::AvgPoolGrad *Primitive::value_as<mindspore::schema::AvgPoolGrad>() const {
+  return value_as_AvgPoolGrad();
+}
+
+template<> inline const mindspore::schema::BatchNorm *Primitive::value_as<mindspore::schema::BatchNorm>() const {
+  return value_as_BatchNorm();
+}
+
+template<> inline const mindspore::schema::BatchNormGrad *Primitive::value_as<mindspore::schema::BatchNormGrad>() const {
+  return value_as_BatchNormGrad();
+}
+
+template<> inline const mindspore::schema::BatchToSpace *Primitive::value_as<mindspore::schema::BatchToSpace>() const {
+  return value_as_BatchToSpace();
+}
+
+template<> inline const mindspore::schema::BatchToSpaceND *Primitive::value_as<mindspore::schema::BatchToSpaceND>() const {
+  return value_as_BatchToSpaceND();
+}
+
+template<> inline const mindspore::schema::BiasAdd *Primitive::value_as<mindspore::schema::BiasAdd>() const {
+  return value_as_BiasAdd();
+}
+
+template<> inline const mindspore::schema::BinaryCrossEntropy *Primitive::value_as<mindspore::schema::BinaryCrossEntropy>() const {
+  return value_as_BinaryCrossEntropy();
+}
+
+template<> inline const mindspore::schema::BinaryCrossEntropyGrad *Primitive::value_as<mindspore::schema::BinaryCrossEntropyGrad>() const {
+  return value_as_BinaryCrossEntropyGrad();
+}
+
+template<> inline const mindspore::schema::BiasAddGrad *Primitive::value_as<mindspore::schema::BiasAddGrad>() const {
+  return value_as_BiasAddGrad();
+}
+
+template<> inline const mindspore::schema::BroadcastTo *Primitive::value_as<mindspore::schema::BroadcastTo>() const {
+  return value_as_BroadcastTo();
+}
+
+template<> inline const mindspore::schema::Cast *Primitive::value_as<mindspore::schema::Cast>() const {
+  return value_as_Cast();
+}
+
+template<> inline const mindspore::schema::Ceil *Primitive::value_as<mindspore::schema::Ceil>() const {
+  return value_as_Ceil();
+}
+
+template<> inline const mindspore::schema::Clip *Primitive::value_as<mindspore::schema::Clip>() const {
+  return value_as_Clip();
+}
+
+template<> inline const mindspore::schema::Concat *Primitive::value_as<mindspore::schema::Concat>() const {
+  return value_as_Concat();
+}
+
+template<> inline const mindspore::schema::Attention *Primitive::value_as<mindspore::schema::Attention>() const {
+  return value_as_Attention();
+}
+
+template<> inline const mindspore::schema::Conv2DBackpropFilterFusion *Primitive::value_as<mindspore::schema::Conv2DBackpropFilterFusion>() const {
+  return value_as_Conv2DBackpropFilterFusion();
+}
+
+template<> inline const mindspore::schema::Conv2DBackpropInputFusion *Primitive::value_as<mindspore::schema::Conv2DBackpropInputFusion>() const {
+  return value_as_Conv2DBackpropInputFusion();
+}
+
+template<> inline const mindspore::schema::Conv2DFusion *Primitive::value_as<mindspore::schema::Conv2DFusion>() const {
+  return value_as_Conv2DFusion();
+}
+
+template<> inline const mindspore::schema::Conv2dTransposeFusion *Primitive::value_as<mindspore::schema::Conv2dTransposeFusion>() const {
+  return value_as_Conv2dTransposeFusion();
+}
+
+template<> inline const mindspore::schema::Cos *Primitive::value_as<mindspore::schema::Cos>() const {
+  return value_as_Cos();
+}
+
+template<> inline const mindspore::schema::ConstantOfShape *Primitive::value_as<mindspore::schema::ConstantOfShape>() const {
+  return value_as_ConstantOfShape();
+}
+
+template<> inline const mindspore::schema::Crop *Primitive::value_as<mindspore::schema::Crop>() const {
+  return value_as_Crop();
+}
+
+template<> inline const mindspore::schema::CustomExtractFeatures *Primitive::value_as<mindspore::schema::CustomExtractFeatures>() const {
+  return value_as_CustomExtractFeatures();
+}
+
+template<> inline const mindspore::schema::CustomNormalize *Primitive::value_as<mindspore::schema::CustomNormalize>() const {
+  return value_as_CustomNormalize();
+}
+
+template<> inline const mindspore::schema::CustomPredict *Primitive::value_as<mindspore::schema::CustomPredict>() const {
+  return value_as_CustomPredict();
+}
+
+template<> inline const mindspore::schema::DeConv2DGradFilter *Primitive::value_as<mindspore::schema::DeConv2DGradFilter>() const {
+  return value_as_DeConv2DGradFilter();
+}
+
+template<> inline const mindspore::schema::Depend *Primitive::value_as<mindspore::schema::Depend>() const {
+  return value_as_Depend();
+}
+
+template<> inline const mindspore::schema::DepthToSpace *Primitive::value_as<mindspore::schema::DepthToSpace>() const {
+  return value_as_DepthToSpace();
+}
+
+template<> inline const mindspore::schema::DetectionPostProcess *Primitive::value_as<mindspore::schema::DetectionPostProcess>() const {
+  return value_as_DetectionPostProcess();
+}
+
+template<> inline const mindspore::schema::DivFusion *Primitive::value_as<mindspore::schema::DivFusion>() const {
+  return value_as_DivFusion();
+}
+
+template<> inline const mindspore::schema::DivGrad *Primitive::value_as<mindspore::schema::DivGrad>() const {
+  return value_as_DivGrad();
+}
+
+template<> inline const mindspore::schema::Dropout *Primitive::value_as<mindspore::schema::Dropout>() const {
+  return value_as_Dropout();
+}
+
+template<> inline const mindspore::schema::DropoutGrad *Primitive::value_as<mindspore::schema::DropoutGrad>() const {
+  return value_as_DropoutGrad();
+}
+
+template<> inline const mindspore::schema::Elu *Primitive::value_as<mindspore::schema::Elu>() const {
+  return value_as_Elu();
+}
+
+template<> inline const mindspore::schema::Eltwise *Primitive::value_as<mindspore::schema::Eltwise>() const {
+  return value_as_Eltwise();
+}
+
+template<> inline const mindspore::schema::Equal *Primitive::value_as<mindspore::schema::Equal>() const {
+  return value_as_Equal();
+}
+
+template<> inline const mindspore::schema::EmbeddingLookupFusion *Primitive::value_as<mindspore::schema::EmbeddingLookupFusion>() const {
+  return value_as_EmbeddingLookupFusion();
+}
+
+template<> inline const mindspore::schema::ExpFusion *Primitive::value_as<mindspore::schema::ExpFusion>() const {
+  return value_as_ExpFusion();
+}
+
+template<> inline const mindspore::schema::ExpandDims *Primitive::value_as<mindspore::schema::ExpandDims>() const {
+  return value_as_ExpandDims();
+}
+
+template<> inline const mindspore::schema::FakeQuantWithMinMaxVars *Primitive::value_as<mindspore::schema::FakeQuantWithMinMaxVars>() const {
+  return value_as_FakeQuantWithMinMaxVars();
+}
+
+template<> inline const mindspore::schema::FakeQuantWithMinMaxVarsPerChannel *Primitive::value_as<mindspore::schema::FakeQuantWithMinMaxVarsPerChannel>() const {
+  return value_as_FakeQuantWithMinMaxVarsPerChannel();
+}
+
+template<> inline const mindspore::schema::FftReal *Primitive::value_as<mindspore::schema::FftReal>() const {
+  return value_as_FftReal();
+}
+
+template<> inline const mindspore::schema::FftImag *Primitive::value_as<mindspore::schema::FftImag>() const {
+  return value_as_FftImag();
+}
+
+template<> inline const mindspore::schema::Flatten *Primitive::value_as<mindspore::schema::Flatten>() const {
+  return value_as_Flatten();
+}
+
+template<> inline const mindspore::schema::FlattenGrad *Primitive::value_as<mindspore::schema::FlattenGrad>() const {
+  return value_as_FlattenGrad();
+}
+
+template<> inline const mindspore::schema::Floor *Primitive::value_as<mindspore::schema::Floor>() const {
+  return value_as_Floor();
+}
+
+template<> inline const mindspore::schema::FloorDiv *Primitive::value_as<mindspore::schema::FloorDiv>() const {
+  return value_as_FloorDiv();
+}
+
+template<> inline const mindspore::schema::FloorMod *Primitive::value_as<mindspore::schema::FloorMod>() const {
+  return value_as_FloorMod();
+}
+
+template<> inline const mindspore::schema::Fill *Primitive::value_as<mindspore::schema::Fill>() const {
+  return value_as_Fill();
+}
+
+template<> inline const mindspore::schema::FullConnection *Primitive::value_as<mindspore::schema::FullConnection>() const {
+  return value_as_FullConnection();
+}
+
+template<> inline const mindspore::schema::FusedBatchNorm *Primitive::value_as<mindspore::schema::FusedBatchNorm>() const {
+  return value_as_FusedBatchNorm();
+}
+
+template<> inline const mindspore::schema::Gather *Primitive::value_as<mindspore::schema::Gather>() const {
+  return value_as_Gather();
+}
+
+template<> inline const mindspore::schema::GatherNd *Primitive::value_as<mindspore::schema::GatherNd>() const {
+  return value_as_GatherNd();
+}
+
+template<> inline const mindspore::schema::Greater *Primitive::value_as<mindspore::schema::Greater>() const {
+  return value_as_Greater();
+}
+
+template<> inline const mindspore::schema::GreaterEqual *Primitive::value_as<mindspore::schema::GreaterEqual>() const {
+  return value_as_GreaterEqual();
+}
+
+template<> inline const mindspore::schema::HashtableLookup *Primitive::value_as<mindspore::schema::HashtableLookup>() const {
+  return value_as_HashtableLookup();
+}
+
+template<> inline const mindspore::schema::InstanceNorm *Primitive::value_as<mindspore::schema::InstanceNorm>() const {
+  return value_as_InstanceNorm();
+}
+
+template<> inline const mindspore::schema::LayerNormFusion *Primitive::value_as<mindspore::schema::LayerNormFusion>() const {
+  return value_as_LayerNormFusion();
+}
+
+template<> inline const mindspore::schema::LeakyRelu *Primitive::value_as<mindspore::schema::LeakyRelu>() const {
+  return value_as_LeakyRelu();
+}
+
+template<> inline const mindspore::schema::Less *Primitive::value_as<mindspore::schema::Less>() const {
+  return value_as_Less();
+}
+
+template<> inline const mindspore::schema::LessEqual *Primitive::value_as<mindspore::schema::LessEqual>() const {
+  return value_as_LessEqual();
+}
+
+template<> inline const mindspore::schema::Log *Primitive::value_as<mindspore::schema::Log>() const {
+  return value_as_Log();
+}
+
+template<> inline const mindspore::schema::LogGrad *Primitive::value_as<mindspore::schema::LogGrad>() const {
+  return value_as_LogGrad();
+}
+
+template<> inline const mindspore::schema::LogicalAnd *Primitive::value_as<mindspore::schema::LogicalAnd>() const {
+  return value_as_LogicalAnd();
+}
+
+template<> inline const mindspore::schema::LogicalNot *Primitive::value_as<mindspore::schema::LogicalNot>() const {
+  return value_as_LogicalNot();
+}
+
+template<> inline const mindspore::schema::LogicalOr *Primitive::value_as<mindspore::schema::LogicalOr>() const {
+  return value_as_LogicalOr();
+}
+
+template<> inline const mindspore::schema::LpNormalization *Primitive::value_as<mindspore::schema::LpNormalization>() const {
+  return value_as_LpNormalization();
+}
+
+template<> inline const mindspore::schema::LRN *Primitive::value_as<mindspore::schema::LRN>() const {
+  return value_as_LRN();
+}
+
+template<> inline const mindspore::schema::LshProjection *Primitive::value_as<mindspore::schema::LshProjection>() const {
+  return value_as_LshProjection();
+}
+
+template<> inline const mindspore::schema::LSTM *Primitive::value_as<mindspore::schema::LSTM>() const {
+  return value_as_LSTM();
+}
+
+template<> inline const mindspore::schema::L2NormalizeFusion *Primitive::value_as<mindspore::schema::L2NormalizeFusion>() const {
+  return value_as_L2NormalizeFusion();
+}
+
+template<> inline const mindspore::schema::MatMulFusion *Primitive::value_as<mindspore::schema::MatMulFusion>() const {
+  return value_as_MatMulFusion();
+}
+
+template<> inline const mindspore::schema::Maximum *Primitive::value_as<mindspore::schema::Maximum>() const {
+  return value_as_Maximum();
+}
+
+template<> inline const mindspore::schema::MaximumGrad *Primitive::value_as<mindspore::schema::MaximumGrad>() const {
+  return value_as_MaximumGrad();
+}
+
+template<> inline const mindspore::schema::MaxPoolFusion *Primitive::value_as<mindspore::schema::MaxPoolFusion>() const {
+  return value_as_MaxPoolFusion();
+}
+
+template<> inline const mindspore::schema::MaxPoolGrad *Primitive::value_as<mindspore::schema::MaxPoolGrad>() const {
+  return value_as_MaxPoolGrad();
+}
+
+template<> inline const mindspore::schema::SwitchLayer *Primitive::value_as<mindspore::schema::SwitchLayer>() const {
+  return value_as_SwitchLayer();
+}
+
+template<> inline const mindspore::schema::Mfcc *Primitive::value_as<mindspore::schema::Mfcc>() const {
+  return value_as_Mfcc();
+}
+
+template<> inline const mindspore::schema::Minimum *Primitive::value_as<mindspore::schema::Minimum>() const {
+  return value_as_Minimum();
+}
+
+template<> inline const mindspore::schema::MinimumGrad *Primitive::value_as<mindspore::schema::MinimumGrad>() const {
+  return value_as_MinimumGrad();
+}
+
+template<> inline const mindspore::schema::Mod *Primitive::value_as<mindspore::schema::Mod>() const {
+  return value_as_Mod();
+}
+
+template<> inline const mindspore::schema::MulFusion *Primitive::value_as<mindspore::schema::MulFusion>() const {
+  return value_as_MulFusion();
+}
+
+template<> inline const mindspore::schema::MulGrad *Primitive::value_as<mindspore::schema::MulGrad>() const {
+  return value_as_MulGrad();
+}
+
+template<> inline const mindspore::schema::Neg *Primitive::value_as<mindspore::schema::Neg>() const {
+  return value_as_Neg();
+}
+
+template<> inline const mindspore::schema::NegGrad *Primitive::value_as<mindspore::schema::NegGrad>() const {
+  return value_as_NegGrad();
+}
+
+template<> inline const mindspore::schema::NotEqual *Primitive::value_as<mindspore::schema::NotEqual>() const {
+  return value_as_NotEqual();
+}
+
+template<> inline const mindspore::schema::NonMaxSuppression *Primitive::value_as<mindspore::schema::NonMaxSuppression>() const {
+  return value_as_NonMaxSuppression();
+}
+
+template<> inline const mindspore::schema::OneHot *Primitive::value_as<mindspore::schema::OneHot>() const {
+  return value_as_OneHot();
+}
+
+template<> inline const mindspore::schema::OnesLike *Primitive::value_as<mindspore::schema::OnesLike>() const {
+  return value_as_OnesLike();
+}
+
+template<> inline const mindspore::schema::PadFusion *Primitive::value_as<mindspore::schema::PadFusion>() const {
+  return value_as_PadFusion();
+}
+
+template<> inline const mindspore::schema::PartialFusion *Primitive::value_as<mindspore::schema::PartialFusion>() const {
+  return value_as_PartialFusion();
+}
+
+template<> inline const mindspore::schema::PowerGrad *Primitive::value_as<mindspore::schema::PowerGrad>() const {
+  return value_as_PowerGrad();
+}
+
+template<> inline const mindspore::schema::PowFusion *Primitive::value_as<mindspore::schema::PowFusion>() const {
+  return value_as_PowFusion();
+}
+
+template<> inline const mindspore::schema::PriorBox *Primitive::value_as<mindspore::schema::PriorBox>() const {
+  return value_as_PriorBox();
+}
+
+template<> inline const mindspore::schema::PReLUFusion *Primitive::value_as<mindspore::schema::PReLUFusion>() const {
+  return value_as_PReLUFusion();
+}
+
+template<> inline const mindspore::schema::QuantDTypeCast *Primitive::value_as<mindspore::schema::QuantDTypeCast>() const {
+  return value_as_QuantDTypeCast();
+}
+
+template<> inline const mindspore::schema::Rank *Primitive::value_as<mindspore::schema::Rank>() const {
+  return value_as_Rank();
+}
+
+template<> inline const mindspore::schema::Range *Primitive::value_as<mindspore::schema::Range>() const {
+  return value_as_Range();
+}
+
+template<> inline const mindspore::schema::Reciprocal *Primitive::value_as<mindspore::schema::Reciprocal>() const {
+  return value_as_Reciprocal();
+}
+
+template<> inline const mindspore::schema::RealDiv *Primitive::value_as<mindspore::schema::RealDiv>() const {
+  return value_as_RealDiv();
+}
+
+template<> inline const mindspore::schema::ReduceFusion *Primitive::value_as<mindspore::schema::ReduceFusion>() const {
+  return value_as_ReduceFusion();
+}
+
+template<> inline const mindspore::schema::Reshape *Primitive::value_as<mindspore::schema::Reshape>() const {
+  return value_as_Reshape();
+}
+
+template<> inline const mindspore::schema::Resize *Primitive::value_as<mindspore::schema::Resize>() const {
+  return value_as_Resize();
+}
+
+template<> inline const mindspore::schema::ReverseSequence *Primitive::value_as<mindspore::schema::ReverseSequence>() const {
+  return value_as_ReverseSequence();
+}
+
+template<> inline const mindspore::schema::ReverseV2 *Primitive::value_as<mindspore::schema::ReverseV2>() const {
+  return value_as_ReverseV2();
+}
+
+template<> inline const mindspore::schema::Rfft *Primitive::value_as<mindspore::schema::Rfft>() const {
+  return value_as_Rfft();
+}
+
+template<> inline const mindspore::schema::ROIPooling *Primitive::value_as<mindspore::schema::ROIPooling>() const {
+  return value_as_ROIPooling();
+}
+
+template<> inline const mindspore::schema::Round *Primitive::value_as<mindspore::schema::Round>() const {
+  return value_as_Round();
+}
+
+template<> inline const mindspore::schema::Rsqrt *Primitive::value_as<mindspore::schema::Rsqrt>() const {
+  return value_as_Rsqrt();
+}
+
+template<> inline const mindspore::schema::ScaleFusion *Primitive::value_as<mindspore::schema::ScaleFusion>() const {
+  return value_as_ScaleFusion();
+}
+
+template<> inline const mindspore::schema::ScatterNd *Primitive::value_as<mindspore::schema::ScatterNd>() const {
+  return value_as_ScatterNd();
+}
+
+template<> inline const mindspore::schema::SGD *Primitive::value_as<mindspore::schema::SGD>() const {
+  return value_as_SGD();
+}
+
+template<> inline const mindspore::schema::Shape *Primitive::value_as<mindspore::schema::Shape>() const {
+  return value_as_Shape();
+}
+
+template<> inline const mindspore::schema::SigmoidCrossEntropyWithLogits *Primitive::value_as<mindspore::schema::SigmoidCrossEntropyWithLogits>() const {
+  return value_as_SigmoidCrossEntropyWithLogits();
+}
+
+template<> inline const mindspore::schema::SigmoidCrossEntropyWithLogitsGrad *Primitive::value_as<mindspore::schema::SigmoidCrossEntropyWithLogitsGrad>() const {
+  return value_as_SigmoidCrossEntropyWithLogitsGrad();
+}
+
+template<> inline const mindspore::schema::Sin *Primitive::value_as<mindspore::schema::Sin>() const {
+  return value_as_Sin();
+}
+
+template<> inline const mindspore::schema::SkipGram *Primitive::value_as<mindspore::schema::SkipGram>() const {
+  return value_as_SkipGram();
+}
+
+template<> inline const mindspore::schema::SliceFusion *Primitive::value_as<mindspore::schema::SliceFusion>() const {
+  return value_as_SliceFusion();
+}
+
+template<> inline const mindspore::schema::SmoothL1Loss *Primitive::value_as<mindspore::schema::SmoothL1Loss>() const {
+  return value_as_SmoothL1Loss();
+}
+
+template<> inline const mindspore::schema::SmoothL1LossGrad *Primitive::value_as<mindspore::schema::SmoothL1LossGrad>() const {
+  return value_as_SmoothL1LossGrad();
+}
+
+template<> inline const mindspore::schema::Softmax *Primitive::value_as<mindspore::schema::Softmax>() const {
+  return value_as_Softmax();
+}
+
+template<> inline const mindspore::schema::SoftmaxCrossEntropyWithLogits *Primitive::value_as<mindspore::schema::SoftmaxCrossEntropyWithLogits>() const {
+  return value_as_SoftmaxCrossEntropyWithLogits();
+}
+
+template<> inline const mindspore::schema::SpaceToBatch *Primitive::value_as<mindspore::schema::SpaceToBatch>() const {
+  return value_as_SpaceToBatch();
+}
+
+template<> inline const mindspore::schema::SpaceToBatchND *Primitive::value_as<mindspore::schema::SpaceToBatchND>() const {
+  return value_as_SpaceToBatchND();
+}
+
+template<> inline const mindspore::schema::SpaceToDepth *Primitive::value_as<mindspore::schema::SpaceToDepth>() const {
+  return value_as_SpaceToDepth();
+}
+
+template<> inline const mindspore::schema::SparseSoftmaxCrossEntropyWithLogits *Primitive::value_as<mindspore::schema::SparseSoftmaxCrossEntropyWithLogits>() const {
+  return value_as_SparseSoftmaxCrossEntropyWithLogits();
+}
+
+template<> inline const mindspore::schema::SparseToDense *Primitive::value_as<mindspore::schema::SparseToDense>() const {
+  return value_as_SparseToDense();
+}
+
+template<> inline const mindspore::schema::Split *Primitive::value_as<mindspore::schema::Split>() const {
+  return value_as_Split();
+}
+
+template<> inline const mindspore::schema::Sqrt *Primitive::value_as<mindspore::schema::Sqrt>() const {
+  return value_as_Sqrt();
+}
+
+template<> inline const mindspore::schema::Squeeze *Primitive::value_as<mindspore::schema::Squeeze>() const {
+  return value_as_Squeeze();
+}
+
+template<> inline const mindspore::schema::Square *Primitive::value_as<mindspore::schema::Square>() const {
+  return value_as_Square();
+}
+
+template<> inline const mindspore::schema::SquaredDifference *Primitive::value_as<mindspore::schema::SquaredDifference>() const {
+  return value_as_SquaredDifference();
+}
+
+template<> inline const mindspore::schema::Stack *Primitive::value_as<mindspore::schema::Stack>() const {
+  return value_as_Stack();
+}
+
+template<> inline const mindspore::schema::StridedSlice *Primitive::value_as<mindspore::schema::StridedSlice>() const {
+  return value_as_StridedSlice();
+}
+
+template<> inline const mindspore::schema::SubFusion *Primitive::value_as<mindspore::schema::SubFusion>() const {
+  return value_as_SubFusion();
+}
+
+template<> inline const mindspore::schema::SubGrad *Primitive::value_as<mindspore::schema::SubGrad>() const {
+  return value_as_SubGrad();
+}
+
+template<> inline const mindspore::schema::Switch *Primitive::value_as<mindspore::schema::Switch>() const {
+  return value_as_Switch();
+}
+
+template<> inline const mindspore::schema::TensorListFromTensor *Primitive::value_as<mindspore::schema::TensorListFromTensor>() const {
+  return value_as_TensorListFromTensor();
+}
+
+template<> inline const mindspore::schema::TensorListGetItem *Primitive::value_as<mindspore::schema::TensorListGetItem>() const {
+  return value_as_TensorListGetItem();
+}
+
+template<> inline const mindspore::schema::TensorListReserve *Primitive::value_as<mindspore::schema::TensorListReserve>() const {
+  return value_as_TensorListReserve();
+}
+
+template<> inline const mindspore::schema::TensorListSetItem *Primitive::value_as<mindspore::schema::TensorListSetItem>() const {
+  return value_as_TensorListSetItem();
+}
+
+template<> inline const mindspore::schema::TensorListStack *Primitive::value_as<mindspore::schema::TensorListStack>() const {
+  return value_as_TensorListStack();
+}
+
+template<> inline const mindspore::schema::TileFusion *Primitive::value_as<mindspore::schema::TileFusion>() const {
+  return value_as_TileFusion();
+}
+
+template<> inline const mindspore::schema::TopKFusion *Primitive::value_as<mindspore::schema::TopKFusion>() const {
+  return value_as_TopKFusion();
+}
+
+template<> inline const mindspore::schema::Transpose *Primitive::value_as<mindspore::schema::Transpose>() const {
+  return value_as_Transpose();
+}
+
+template<> inline const mindspore::schema::Unique *Primitive::value_as<mindspore::schema::Unique>() const {
+  return value_as_Unique();
+}
+
+template<> inline const mindspore::schema::UnsortedSegmentSum *Primitive::value_as<mindspore::schema::UnsortedSegmentSum>() const {
+  return value_as_UnsortedSegmentSum();
+}
+
+template<> inline const mindspore::schema::Unsqueeze *Primitive::value_as<mindspore::schema::Unsqueeze>() const {
+  return value_as_Unsqueeze();
+}
+
+template<> inline const mindspore::schema::Unstack *Primitive::value_as<mindspore::schema::Unstack>() const {
+  return value_as_Unstack();
+}
+
+template<> inline const mindspore::schema::LSTMGrad *Primitive::value_as<mindspore::schema::LSTMGrad>() const {
+  return value_as_LSTMGrad();
+}
+
+template<> inline const mindspore::schema::Where *Primitive::value_as<mindspore::schema::Where>() const {
+  return value_as_Where();
+}
+
+template<> inline const mindspore::schema::ZerosLike *Primitive::value_as<mindspore::schema::ZerosLike>() const {
+  return value_as_ZerosLike();
+}
+
+template<> inline const mindspore::schema::Select *Primitive::value_as<mindspore::schema::Select>() const {
+  return value_as_Select();
+}
+
+template<> inline const mindspore::schema::ScatterNdUpdate *Primitive::value_as<mindspore::schema::ScatterNdUpdate>() const {
+  return value_as_ScatterNdUpdate();
+}
+
+template<> inline const mindspore::schema::GRU *Primitive::value_as<mindspore::schema::GRU>() const {
+  return value_as_GRU();
+}
+
+template<> inline const mindspore::schema::NonZero *Primitive::value_as<mindspore::schema::NonZero>() const {
+  return value_as_NonZero();
+}
+
+template<> inline const mindspore::schema::InvertPermutation *Primitive::value_as<mindspore::schema::InvertPermutation>() const {
+  return value_as_InvertPermutation();
+}
+
+template<> inline const mindspore::schema::Size *Primitive::value_as<mindspore::schema::Size>() const {
+  return value_as_Size();
+}
+
+template<> inline const mindspore::schema::RandomStandardNormal *Primitive::value_as<mindspore::schema::RandomStandardNormal>() const {
+  return value_as_RandomStandardNormal();
+}
+
+template<> inline const mindspore::schema::CropAndResize *Primitive::value_as<mindspore::schema::CropAndResize>() const {
+  return value_as_CropAndResize();
+}
+
+template<> inline const mindspore::schema::Erf *Primitive::value_as<mindspore::schema::Erf>() const {
+  return value_as_Erf();
+}
+
+template<> inline const mindspore::schema::StridedSliceGrad *Primitive::value_as<mindspore::schema::StridedSliceGrad>() const {
+  return value_as_StridedSliceGrad();
+}
+
+template<> inline const mindspore::schema::IsFinite *Primitive::value_as<mindspore::schema::IsFinite>() const {
+  return value_as_IsFinite();
+}
+
+template<> inline const mindspore::schema::LinSpace *Primitive::value_as<mindspore::schema::LinSpace>() const {
+  return value_as_LinSpace();
+}
+
+template<> inline const mindspore::schema::UniformReal *Primitive::value_as<mindspore::schema::UniformReal>() const {
+  return value_as_UniformReal();
+}
+
+template<> inline const mindspore::schema::AbsGrad *Primitive::value_as<mindspore::schema::AbsGrad>() const {
+  return value_as_AbsGrad();
+}
+
+template<> inline const mindspore::schema::RsqrtGrad *Primitive::value_as<mindspore::schema::RsqrtGrad>() const {
+  return value_as_RsqrtGrad();
+}
+
+template<> inline const mindspore::schema::SqrtGrad *Primitive::value_as<mindspore::schema::SqrtGrad>() const {
+  return value_as_SqrtGrad();
+}
+
+template<> inline const mindspore::schema::LayerNormGrad *Primitive::value_as<mindspore::schema::LayerNormGrad>() const {
+  return value_as_LayerNormGrad();
+}
+
+template<> inline const mindspore::schema::ResizeGrad *Primitive::value_as<mindspore::schema::ResizeGrad>() const {
+  return value_as_ResizeGrad();
+}
+
+template<> inline const mindspore::schema::Splice *Primitive::value_as<mindspore::schema::Splice>() const {
+  return value_as_Splice();
+}
+
+template<> inline const mindspore::schema::LogSoftmax *Primitive::value_as<mindspore::schema::LogSoftmax>() const {
+  return value_as_LogSoftmax();
+}
+
+template<> inline const mindspore::schema::Call *Primitive::value_as<mindspore::schema::Call>() const {
+  return value_as_Call();
+}
+
+template<> inline const mindspore::schema::Custom *Primitive::value_as<mindspore::schema::Custom>() const {
+  return value_as_Custom();
+}
+
+template<> inline const mindspore::schema::CumSum *Primitive::value_as<mindspore::schema::CumSum>() const {
+  return value_as_CumSum();
+}
+
+template<> inline const mindspore::schema::SplitWithOverlap *Primitive::value_as<mindspore::schema::SplitWithOverlap>() const {
+  return value_as_SplitWithOverlap();
+}
+
+template<> inline const mindspore::schema::GenOP *Primitive::value_as<mindspore::schema::GenOP>() const {
+  return value_as_GenOP();
+}
+
+template<> inline const mindspore::schema::RaggedRange *Primitive::value_as<mindspore::schema::RaggedRange>() const {
+  return value_as_RaggedRange();
+}
+
+template<> inline const mindspore::schema::GLU *Primitive::value_as<mindspore::schema::GLU>() const {
+  return value_as_GLU();
+}
+
+template<> inline const mindspore::schema::TensorArray *Primitive::value_as<mindspore::schema::TensorArray>() const {
+  return value_as_TensorArray();
+}
+
+template<> inline const mindspore::schema::TensorArrayRead *Primitive::value_as<mindspore::schema::TensorArrayRead>() const {
+  return value_as_TensorArrayRead();
+}
+
+template<> inline const mindspore::schema::TensorArrayWrite *Primitive::value_as<mindspore::schema::TensorArrayWrite>() const {
+  return value_as_TensorArrayWrite();
+}
+
+template<> inline const mindspore::schema::Affine *Primitive::value_as<mindspore::schema::Affine>() const {
+  return value_as_Affine();
+}
+
+template<> inline const mindspore::schema::AllGather *Primitive::value_as<mindspore::schema::AllGather>() const {
+  return value_as_AllGather();
+}
+
+template<> inline const mindspore::schema::ReduceScatter *Primitive::value_as<mindspore::schema::ReduceScatter>() const {
+  return value_as_ReduceScatter();
+}
+
+template<> inline const mindspore::schema::DynamicQuant *Primitive::value_as<mindspore::schema::DynamicQuant>() const {
+  return value_as_DynamicQuant();
+}
+
+template<> inline const mindspore::schema::LSTMGradData *Primitive::value_as<mindspore::schema::LSTMGradData>() const {
+  return value_as_LSTMGradData();
+}
+
+template<> inline const mindspore::schema::LSTMGradWeight *Primitive::value_as<mindspore::schema::LSTMGradWeight>() const {
+  return value_as_LSTMGradWeight();
+}
+
+template<> inline const mindspore::schema::RandomNormal *Primitive::value_as<mindspore::schema::RandomNormal>() const {
+  return value_as_RandomNormal();
+}
+
+template<> inline const mindspore::schema::NLLLoss *Primitive::value_as<mindspore::schema::NLLLoss>() const {
+  return value_as_NLLLoss();
+}
+
+template<> inline const mindspore::schema::NLLLossGrad *Primitive::value_as<mindspore::schema::NLLLossGrad>() const {
+  return value_as_NLLLossGrad();
+}
+
+template<> inline const mindspore::schema::FormatTranspose *Primitive::value_as<mindspore::schema::FormatTranspose>() const {
+  return value_as_FormatTranspose();
+}
+
+template<> inline const mindspore::schema::GatherD *Primitive::value_as<mindspore::schema::GatherD>() const {
+  return value_as_GatherD();
+}
+
+template<> inline const mindspore::schema::GroupNormFusion *Primitive::value_as<mindspore::schema::GroupNormFusion>() const {
+  return value_as_GroupNormFusion();
+}
+
+struct PrimitiveBuilder {
+  typedef Primitive Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_value_type(mindspore::schema::PrimitiveType value_type) {
+    fbb_.AddElement<uint8_t>(Primitive::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
+  }
+  void add_value(flatbuffers::Offset<void> value) {
+    fbb_.AddOffset(Primitive::VT_VALUE, value);
+  }
+  explicit PrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Primitive> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Primitive>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Primitive> CreatePrimitive(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::PrimitiveType value_type = mindspore::schema::PrimitiveType_NONE,
+    flatbuffers::Offset<void> value = 0) {
+  PrimitiveBuilder builder_(_fbb);
+  builder_.add_value(value);
+  builder_.add_value_type(value_type);
+  return builder_.Finish();
+}
+
+struct CNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CNodeBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NAME = 4,
+    VT_PRIMITIVE = 8,
+    VT_INPUTINDEX = 10,
+    VT_OUTPUTINDEX = 12,
+    VT_QUANTTYPE = 14,
+    VT_DEVICETYPE = 16
+  };
+  const flatbuffers::String *name() const {
+    return GetPointer<const flatbuffers::String *>(VT_NAME);
+  }
+  const mindspore::schema::Primitive *primitive() const {
+    return GetPointer<const mindspore::schema::Primitive *>(VT_PRIMITIVE);
+  }
+  const flatbuffers::Vector<uint32_t> *inputIndex() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
+  }
+  const flatbuffers::Vector<uint32_t> *outputIndex() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
+  }
+  mindspore::schema::QuantType quantType() const {
+    return static_cast<mindspore::schema::QuantType>(GetField<int32_t>(VT_QUANTTYPE, 0));
+  }
+  int32_t deviceType() const {
+    return GetField<int32_t>(VT_DEVICETYPE, -1);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_NAME) &&
+           verifier.VerifyString(name()) &&
+           VerifyOffset(verifier, VT_PRIMITIVE) &&
+           verifier.VerifyTable(primitive()) &&
+           VerifyOffset(verifier, VT_INPUTINDEX) &&
+           verifier.VerifyVector(inputIndex()) &&
+           VerifyOffset(verifier, VT_OUTPUTINDEX) &&
+           verifier.VerifyVector(outputIndex()) &&
+           VerifyField<int32_t>(verifier, VT_QUANTTYPE) &&
+           VerifyField<int32_t>(verifier, VT_DEVICETYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct CNodeBuilder {
+  typedef CNode Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
+    fbb_.AddOffset(CNode::VT_NAME, name);
+  }
+  void add_primitive(flatbuffers::Offset<mindspore::schema::Primitive> primitive) {
+    fbb_.AddOffset(CNode::VT_PRIMITIVE, primitive);
+  }
+  void add_inputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex) {
+    fbb_.AddOffset(CNode::VT_INPUTINDEX, inputIndex);
+  }
+  void add_outputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex) {
+    fbb_.AddOffset(CNode::VT_OUTPUTINDEX, outputIndex);
+  }
+  void add_quantType(mindspore::schema::QuantType quantType) {
+    fbb_.AddElement<int32_t>(CNode::VT_QUANTTYPE, static_cast<int32_t>(quantType), 0);
+  }
+  void add_deviceType(int32_t deviceType) {
+    fbb_.AddElement<int32_t>(CNode::VT_DEVICETYPE, deviceType, -1);
+  }
+  explicit CNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<CNode> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<CNode>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<CNode> CreateCNode(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> name = 0,
+    flatbuffers::Offset<mindspore::schema::Primitive> primitive = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex = 0,
+    mindspore::schema::QuantType quantType = mindspore::schema::QuantType_QUANT_NONE,
+    int32_t deviceType = -1) {
+  CNodeBuilder builder_(_fbb);
+  builder_.add_deviceType(deviceType);
+  builder_.add_quantType(quantType);
+  builder_.add_outputIndex(outputIndex);
+  builder_.add_inputIndex(inputIndex);
+  builder_.add_primitive(primitive);
+  builder_.add_name(name);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<CNode> CreateCNodeDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *name = nullptr,
+    flatbuffers::Offset<mindspore::schema::Primitive> primitive = 0,
+    const std::vector<uint32_t> *inputIndex = nullptr,
+    const std::vector<uint32_t> *outputIndex = nullptr,
+    mindspore::schema::QuantType quantType = mindspore::schema::QuantType_QUANT_NONE,
+    int32_t deviceType = -1) {
+  auto name__ = name ? _fbb.CreateString(name) : 0;
+  auto inputIndex__ = inputIndex ? _fbb.CreateVector<uint32_t>(*inputIndex) : 0;
+  auto outputIndex__ = outputIndex ? _fbb.CreateVector<uint32_t>(*outputIndex) : 0;
+  return mindspore::schema::CreateCNode(
+      _fbb,
+      name__,
+      primitive,
+      inputIndex__,
+      outputIndex__,
+      quantType,
+      deviceType);
+}
+
+struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SubGraphBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NAME = 4,
+    VT_INPUTINDICES = 6,
+    VT_OUTPUTINDICES = 8,
+    VT_NODEINDICES = 10,
+    VT_TENSORINDICES = 12
+  };
+  const flatbuffers::String *name() const {
+    return GetPointer<const flatbuffers::String *>(VT_NAME);
+  }
+  const flatbuffers::Vector<uint32_t> *inputIndices() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDICES);
+  }
+  const flatbuffers::Vector<uint32_t> *outputIndices() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDICES);
+  }
+  const flatbuffers::Vector<uint32_t> *nodeIndices() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NODEINDICES);
+  }
+  const flatbuffers::Vector<uint32_t> *tensorIndices() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_TENSORINDICES);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_NAME) &&
+           verifier.VerifyString(name()) &&
+           VerifyOffset(verifier, VT_INPUTINDICES) &&
+           verifier.VerifyVector(inputIndices()) &&
+           VerifyOffset(verifier, VT_OUTPUTINDICES) &&
+           verifier.VerifyVector(outputIndices()) &&
+           VerifyOffset(verifier, VT_NODEINDICES) &&
+           verifier.VerifyVector(nodeIndices()) &&
+           VerifyOffset(verifier, VT_TENSORINDICES) &&
+           verifier.VerifyVector(tensorIndices()) &&
+           verifier.EndTable();
+  }
+};
+
+struct SubGraphBuilder {
+  typedef SubGraph Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
+    fbb_.AddOffset(SubGraph::VT_NAME, name);
+  }
+  void add_inputIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndices) {
+    fbb_.AddOffset(SubGraph::VT_INPUTINDICES, inputIndices);
+  }
+  void add_outputIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndices) {
+    fbb_.AddOffset(SubGraph::VT_OUTPUTINDICES, outputIndices);
+  }
+  void add_nodeIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> nodeIndices) {
+    fbb_.AddOffset(SubGraph::VT_NODEINDICES, nodeIndices);
+  }
+  void add_tensorIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tensorIndices) {
+    fbb_.AddOffset(SubGraph::VT_TENSORINDICES, tensorIndices);
+  }
+  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SubGraph> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SubGraph>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SubGraph> CreateSubGraph(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> name = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndices = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndices = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> nodeIndices = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tensorIndices = 0) {
+  SubGraphBuilder builder_(_fbb);
+  builder_.add_tensorIndices(tensorIndices);
+  builder_.add_nodeIndices(nodeIndices);
+  builder_.add_outputIndices(outputIndices);
+  builder_.add_inputIndices(inputIndices);
+  builder_.add_name(name);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *name = nullptr,
+    const std::vector<uint32_t> *inputIndices = nullptr,
+    const std::vector<uint32_t> *outputIndices = nullptr,
+    const std::vector<uint32_t> *nodeIndices = nullptr,
+    const std::vector<uint32_t> *tensorIndices = nullptr) {
+  auto name__ = name ? _fbb.CreateString(name) : 0;
+  auto inputIndices__ = inputIndices ? _fbb.CreateVector<uint32_t>(*inputIndices) : 0;
+  auto outputIndices__ = outputIndices ? _fbb.CreateVector<uint32_t>(*outputIndices) : 0;
+  auto nodeIndices__ = nodeIndices ? _fbb.CreateVector<uint32_t>(*nodeIndices) : 0;
+  auto tensorIndices__ = tensorIndices ? _fbb.CreateVector<uint32_t>(*tensorIndices) : 0;
+  return mindspore::schema::CreateSubGraph(
+      _fbb,
+      name__,
+      inputIndices__,
+      outputIndices__,
+      nodeIndices__,
+      tensorIndices__);
+}
+
+struct MetaGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MetaGraphBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NAME = 4,
+    VT_VERSION = 6,
+    VT_FMKTYPE = 8,
+    VT_INPUTINDEX = 10,
+    VT_OUTPUTINDEX = 12,
+    VT_MEMPOOLSIZE = 14,
+    VT_NODES = 16,
+    VT_ALLTENSORS = 18,
+    VT_SUBGRAPH = 20,
+    VT_OBFUSCATE = 22,
+    VT_OBFMETADATA = 24
+  };
+  const flatbuffers::String *name() const {
+    return GetPointer<const flatbuffers::String *>(VT_NAME);
+  }
+  const flatbuffers::String *version() const {
+    return GetPointer<const flatbuffers::String *>(VT_VERSION);
+  }
+  int32_t fmkType() const {
+    return GetField<int32_t>(VT_FMKTYPE, 0);
+  }
+  const flatbuffers::Vector<uint32_t> *inputIndex() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
+  }
+  const flatbuffers::Vector<uint32_t> *outputIndex() const {
+    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
+  }
+  uint32_t mempoolSize() const {
+    return GetField<uint32_t>(VT_MEMPOOLSIZE, 0);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::CNode>> *nodes() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::CNode>> *>(VT_NODES);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Tensor>> *allTensors() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Tensor>> *>(VT_ALLTENSORS);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::SubGraph>> *subGraph() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::SubGraph>> *>(VT_SUBGRAPH);
+  }
+  bool obfuscate() const {
+    return GetField<uint8_t>(VT_OBFUSCATE, 0) != 0;
+  }
+  const flatbuffers::Vector<uint8_t> *obfMetaData() const {
+    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OBFMETADATA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_NAME) &&
+           verifier.VerifyString(name()) &&
+           VerifyOffset(verifier, VT_VERSION) &&
+           verifier.VerifyString(version()) &&
+           VerifyField<int32_t>(verifier, VT_FMKTYPE) &&
+           VerifyOffset(verifier, VT_INPUTINDEX) &&
+           verifier.VerifyVector(inputIndex()) &&
+           VerifyOffset(verifier, VT_OUTPUTINDEX) &&
+           verifier.VerifyVector(outputIndex()) &&
+           VerifyField<uint32_t>(verifier, VT_MEMPOOLSIZE) &&
+           VerifyOffset(verifier, VT_NODES) &&
+           verifier.VerifyVector(nodes()) &&
+           verifier.VerifyVectorOfTables(nodes()) &&
+           VerifyOffset(verifier, VT_ALLTENSORS) &&
+           verifier.VerifyVector(allTensors()) &&
+           verifier.VerifyVectorOfTables(allTensors()) &&
+           VerifyOffset(verifier, VT_SUBGRAPH) &&
+           verifier.VerifyVector(subGraph()) &&
+           verifier.VerifyVectorOfTables(subGraph()) &&
+           VerifyField<uint8_t>(verifier, VT_OBFUSCATE) &&
+           VerifyOffset(verifier, VT_OBFMETADATA) &&
+           verifier.VerifyVector(obfMetaData()) &&
+           verifier.EndTable();
+  }
+};
+
+struct MetaGraphBuilder {
+  typedef MetaGraph Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
+    fbb_.AddOffset(MetaGraph::VT_NAME, name);
+  }
+  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
+    fbb_.AddOffset(MetaGraph::VT_VERSION, version);
+  }
+  void add_fmkType(int32_t fmkType) {
+    fbb_.AddElement<int32_t>(MetaGraph::VT_FMKTYPE, fmkType, 0);
+  }
+  void add_inputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex) {
+    fbb_.AddOffset(MetaGraph::VT_INPUTINDEX, inputIndex);
+  }
+  void add_outputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex) {
+    fbb_.AddOffset(MetaGraph::VT_OUTPUTINDEX, outputIndex);
+  }
+  void add_mempoolSize(uint32_t mempoolSize) {
+    fbb_.AddElement<uint32_t>(MetaGraph::VT_MEMPOOLSIZE, mempoolSize, 0);
+  }
+  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::CNode>>> nodes) {
+    fbb_.AddOffset(MetaGraph::VT_NODES, nodes);
+  }
+  void add_allTensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Tensor>>> allTensors) {
+    fbb_.AddOffset(MetaGraph::VT_ALLTENSORS, allTensors);
+  }
+  void add_subGraph(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::SubGraph>>> subGraph) {
+    fbb_.AddOffset(MetaGraph::VT_SUBGRAPH, subGraph);
+  }
+  void add_obfuscate(bool obfuscate) {
+    fbb_.AddElement<uint8_t>(MetaGraph::VT_OBFUSCATE, static_cast<uint8_t>(obfuscate), 0);
+  }
+  void add_obfMetaData(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> obfMetaData) {
+    fbb_.AddOffset(MetaGraph::VT_OBFMETADATA, obfMetaData);
+  }
+  explicit MetaGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MetaGraph> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MetaGraph>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MetaGraph> CreateMetaGraph(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> name = 0,
+    flatbuffers::Offset<flatbuffers::String> version = 0,
+    int32_t fmkType = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex = 0,
+    uint32_t mempoolSize = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::CNode>>> nodes = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Tensor>>> allTensors = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::SubGraph>>> subGraph = 0,
+    bool obfuscate = false,
+    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> obfMetaData = 0) {
+  MetaGraphBuilder builder_(_fbb);
+  builder_.add_obfMetaData(obfMetaData);
+  builder_.add_subGraph(subGraph);
+  builder_.add_allTensors(allTensors);
+  builder_.add_nodes(nodes);
+  builder_.add_mempoolSize(mempoolSize);
+  builder_.add_outputIndex(outputIndex);
+  builder_.add_inputIndex(inputIndex);
+  builder_.add_fmkType(fmkType);
+  builder_.add_version(version);
+  builder_.add_name(name);
+  builder_.add_obfuscate(obfuscate);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<MetaGraph> CreateMetaGraphDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *name = nullptr,
+    const char *version = nullptr,
+    int32_t fmkType = 0,
+    const std::vector<uint32_t> *inputIndex = nullptr,
+    const std::vector<uint32_t> *outputIndex = nullptr,
+    uint32_t mempoolSize = 0,
+    const std::vector<flatbuffers::Offset<mindspore::schema::CNode>> *nodes = nullptr,
+    const std::vector<flatbuffers::Offset<mindspore::schema::Tensor>> *allTensors = nullptr,
+    const std::vector<flatbuffers::Offset<mindspore::schema::SubGraph>> *subGraph = nullptr,
+    bool obfuscate = false,
+    const std::vector<uint8_t> *obfMetaData = nullptr) {
+  auto name__ = name ? _fbb.CreateString(name) : 0;
+  auto version__ = version ? _fbb.CreateString(version) : 0;
+  auto inputIndex__ = inputIndex ? _fbb.CreateVector<uint32_t>(*inputIndex) : 0;
+  auto outputIndex__ = outputIndex ? _fbb.CreateVector<uint32_t>(*outputIndex) : 0;
+  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::CNode>>(*nodes) : 0;
+  auto allTensors__ = allTensors ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Tensor>>(*allTensors) : 0;
+  auto subGraph__ = subGraph ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::SubGraph>>(*subGraph) : 0;
+  auto obfMetaData__ = obfMetaData ? _fbb.CreateVector<uint8_t>(*obfMetaData) : 0;
+  return mindspore::schema::CreateMetaGraph(
+      _fbb,
+      name__,
+      version__,
+      fmkType,
+      inputIndex__,
+      outputIndex__,
+      mempoolSize,
+      nodes__,
+      allTensors__,
+      subGraph__,
+      obfuscate,
+      obfMetaData__);
+}
+
+inline const mindspore::schema::MetaGraph *GetMetaGraph(const void *buf) {
+  return flatbuffers::GetRoot<mindspore::schema::MetaGraph>(buf);
+}
+
+inline const mindspore::schema::MetaGraph *GetSizePrefixedMetaGraph(const void *buf) {
+  return flatbuffers::GetSizePrefixedRoot<mindspore::schema::MetaGraph>(buf);
+}
+
+inline const char *MetaGraphIdentifier() {
+  return "MSL2";
+}
+
+inline bool MetaGraphBufferHasIdentifier(const void *buf) {
+  return flatbuffers::BufferHasIdentifier(
+      buf, MetaGraphIdentifier());
+}
+
+inline bool VerifyMetaGraphBuffer(
+    flatbuffers::Verifier &verifier) {
+  return verifier.VerifyBuffer<mindspore::schema::MetaGraph>(MetaGraphIdentifier());
+}
+
+inline bool VerifySizePrefixedMetaGraphBuffer(
+    flatbuffers::Verifier &verifier) {
+  return verifier.VerifySizePrefixedBuffer<mindspore::schema::MetaGraph>(MetaGraphIdentifier());
+}
+
+inline const char *MetaGraphExtension() {
+  return "ms";
+}
+
+inline void FinishMetaGraphBuffer(
+    flatbuffers::FlatBufferBuilder &fbb,
+    flatbuffers::Offset<mindspore::schema::MetaGraph> root) {
+  fbb.Finish(root, MetaGraphIdentifier());
+}
+
+inline void FinishSizePrefixedMetaGraphBuffer(
+    flatbuffers::FlatBufferBuilder &fbb,
+    flatbuffers::Offset<mindspore::schema::MetaGraph> root) {
+  fbb.FinishSizePrefixed(root, MetaGraphIdentifier());
+}
+
+}  // namespace schema
+}  // namespace mindspore
+
+#endif  // FLATBUFFERS_GENERATED_MODEL_MINDSPORE_SCHEMA_H_
diff --git a/mindspore/lite/schema/ops_generated.h b/mindspore/lite/schema/ops_generated.h
new file mode 100644
index 00000000..5b15211a
--- /dev/null
+++ b/mindspore/lite/schema/ops_generated.h
@@ -0,0 +1,14383 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+
+
+#ifndef FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
+#define FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
+
+#include "flatbuffers/flatbuffers.h"
+
+#include "ops_types_generated.h"
+
+namespace mindspore {
+namespace schema {
+
+struct Abs;
+struct AbsBuilder;
+
+struct Activation;
+struct ActivationBuilder;
+
+struct ActivationGrad;
+struct ActivationGradBuilder;
+
+struct Adam;
+struct AdamBuilder;
+
+struct AddFusion;
+struct AddFusionBuilder;
+
+struct AdderFusion;
+struct AdderFusionBuilder;
+
+struct AddGrad;
+struct AddGradBuilder;
+
+struct AddN;
+struct AddNBuilder;
+
+struct All;
+struct AllBuilder;
+
+struct ApplyMomentum;
+struct ApplyMomentumBuilder;
+
+struct ArgMaxFusion;
+struct ArgMaxFusionBuilder;
+
+struct ArgMinFusion;
+struct ArgMinFusionBuilder;
+
+struct Assert;
+struct AssertBuilder;
+
+struct Assign;
+struct AssignBuilder;
+
+struct AssignAdd;
+struct AssignAddBuilder;
+
+struct AudioSpectrogram;
+struct AudioSpectrogramBuilder;
+
+struct AvgPoolFusion;
+struct AvgPoolFusionBuilder;
+
+struct AvgPoolGrad;
+struct AvgPoolGradBuilder;
+
+struct BatchNorm;
+struct BatchNormBuilder;
+
+struct BatchNormGrad;
+struct BatchNormGradBuilder;
+
+struct BatchToSpace;
+struct BatchToSpaceBuilder;
+
+struct BatchToSpaceND;
+struct BatchToSpaceNDBuilder;
+
+struct BiasAdd;
+struct BiasAddBuilder;
+
+struct BinaryCrossEntropy;
+struct BinaryCrossEntropyBuilder;
+
+struct BinaryCrossEntropyGrad;
+struct BinaryCrossEntropyGradBuilder;
+
+struct BiasAddGrad;
+struct BiasAddGradBuilder;
+
+struct BroadcastTo;
+struct BroadcastToBuilder;
+
+struct Cast;
+struct CastBuilder;
+
+struct Ceil;
+struct CeilBuilder;
+
+struct Clip;
+struct ClipBuilder;
+
+struct Concat;
+struct ConcatBuilder;
+
+struct Attention;
+struct AttentionBuilder;
+
+struct Conv2DBackpropFilterFusion;
+struct Conv2DBackpropFilterFusionBuilder;
+
+struct Conv2DBackpropInputFusion;
+struct Conv2DBackpropInputFusionBuilder;
+
+struct Conv2DFusion;
+struct Conv2DFusionBuilder;
+
+struct Conv2dTransposeFusion;
+struct Conv2dTransposeFusionBuilder;
+
+struct Cos;
+struct CosBuilder;
+
+struct ConstantOfShape;
+struct ConstantOfShapeBuilder;
+
+struct Crop;
+struct CropBuilder;
+
+struct CustomExtractFeatures;
+struct CustomExtractFeaturesBuilder;
+
+struct CustomNormalize;
+struct CustomNormalizeBuilder;
+
+struct CustomPredict;
+struct CustomPredictBuilder;
+
+struct DeConv2DGradFilter;
+struct DeConv2DGradFilterBuilder;
+
+struct Depend;
+struct DependBuilder;
+
+struct DepthToSpace;
+struct DepthToSpaceBuilder;
+
+struct DetectionPostProcess;
+struct DetectionPostProcessBuilder;
+
+struct DivFusion;
+struct DivFusionBuilder;
+
+struct DivGrad;
+struct DivGradBuilder;
+
+struct Dropout;
+struct DropoutBuilder;
+
+struct DropoutGrad;
+struct DropoutGradBuilder;
+
+struct Elu;
+struct EluBuilder;
+
+struct Eltwise;
+struct EltwiseBuilder;
+
+struct Equal;
+struct EqualBuilder;
+
+struct EmbeddingLookupFusion;
+struct EmbeddingLookupFusionBuilder;
+
+struct ExpFusion;
+struct ExpFusionBuilder;
+
+struct ExpandDims;
+struct ExpandDimsBuilder;
+
+struct FakeQuantWithMinMaxVars;
+struct FakeQuantWithMinMaxVarsBuilder;
+
+struct FakeQuantWithMinMaxVarsPerChannel;
+struct FakeQuantWithMinMaxVarsPerChannelBuilder;
+
+struct FftReal;
+struct FftRealBuilder;
+
+struct FftImag;
+struct FftImagBuilder;
+
+struct Flatten;
+struct FlattenBuilder;
+
+struct FlattenGrad;
+struct FlattenGradBuilder;
+
+struct Floor;
+struct FloorBuilder;
+
+struct FloorDiv;
+struct FloorDivBuilder;
+
+struct FloorMod;
+struct FloorModBuilder;
+
+struct Fill;
+struct FillBuilder;
+
+struct FullConnection;
+struct FullConnectionBuilder;
+
+struct FusedBatchNorm;
+struct FusedBatchNormBuilder;
+
+struct Gather;
+struct GatherBuilder;
+
+struct GatherNd;
+struct GatherNdBuilder;
+
+struct Greater;
+struct GreaterBuilder;
+
+struct GreaterEqual;
+struct GreaterEqualBuilder;
+
+struct HashtableLookup;
+struct HashtableLookupBuilder;
+
+struct InstanceNorm;
+struct InstanceNormBuilder;
+
+struct LayerNormFusion;
+struct LayerNormFusionBuilder;
+
+struct LeakyRelu;
+struct LeakyReluBuilder;
+
+struct Less;
+struct LessBuilder;
+
+struct LessEqual;
+struct LessEqualBuilder;
+
+struct Log;
+struct LogBuilder;
+
+struct LogGrad;
+struct LogGradBuilder;
+
+struct LogicalAnd;
+struct LogicalAndBuilder;
+
+struct LogicalNot;
+struct LogicalNotBuilder;
+
+struct LogicalOr;
+struct LogicalOrBuilder;
+
+struct LpNormalization;
+struct LpNormalizationBuilder;
+
+struct LRN;
+struct LRNBuilder;
+
+struct LshProjection;
+struct LshProjectionBuilder;
+
+struct LSTM;
+struct LSTMBuilder;
+
+struct LSTMGrad;
+struct LSTMGradBuilder;
+
+struct L2NormalizeFusion;
+struct L2NormalizeFusionBuilder;
+
+struct MatMulFusion;
+struct MatMulFusionBuilder;
+
+struct Maximum;
+struct MaximumBuilder;
+
+struct MaximumGrad;
+struct MaximumGradBuilder;
+
+struct MaxPoolFusion;
+struct MaxPoolFusionBuilder;
+
+struct MaxPoolGrad;
+struct MaxPoolGradBuilder;
+
+struct SwitchLayer;
+struct SwitchLayerBuilder;
+
+struct Mfcc;
+struct MfccBuilder;
+
+struct Minimum;
+struct MinimumBuilder;
+
+struct MinimumGrad;
+struct MinimumGradBuilder;
+
+struct Mod;
+struct ModBuilder;
+
+struct MulFusion;
+struct MulFusionBuilder;
+
+struct MulGrad;
+struct MulGradBuilder;
+
+struct Neg;
+struct NegBuilder;
+
+struct NegGrad;
+struct NegGradBuilder;
+
+struct NotEqual;
+struct NotEqualBuilder;
+
+struct NonMaxSuppression;
+struct NonMaxSuppressionBuilder;
+
+struct OneHot;
+struct OneHotBuilder;
+
+struct OnesLike;
+struct OnesLikeBuilder;
+
+struct PadFusion;
+struct PadFusionBuilder;
+
+struct PartialFusion;
+struct PartialFusionBuilder;
+
+struct PowerGrad;
+struct PowerGradBuilder;
+
+struct PowFusion;
+struct PowFusionBuilder;
+
+struct PriorBox;
+struct PriorBoxBuilder;
+
+struct PReLUFusion;
+struct PReLUFusionBuilder;
+
+struct Rank;
+struct RankBuilder;
+
+struct Range;
+struct RangeBuilder;
+
+struct Reciprocal;
+struct ReciprocalBuilder;
+
+struct RealDiv;
+struct RealDivBuilder;
+
+struct ReduceFusion;
+struct ReduceFusionBuilder;
+
+struct Reshape;
+struct ReshapeBuilder;
+
+struct Resize;
+struct ResizeBuilder;
+
+struct ReverseSequence;
+struct ReverseSequenceBuilder;
+
+struct ReverseV2;
+struct ReverseV2Builder;
+
+struct Rfft;
+struct RfftBuilder;
+
+struct ROIPooling;
+struct ROIPoolingBuilder;
+
+struct Round;
+struct RoundBuilder;
+
+struct Rsqrt;
+struct RsqrtBuilder;
+
+struct QuantDTypeCast;
+struct QuantDTypeCastBuilder;
+
+struct ScaleFusion;
+struct ScaleFusionBuilder;
+
+struct ScatterNd;
+struct ScatterNdBuilder;
+
+struct SGD;
+struct SGDBuilder;
+
+struct Shape;
+struct ShapeBuilder;
+
+struct SigmoidCrossEntropyWithLogits;
+struct SigmoidCrossEntropyWithLogitsBuilder;
+
+struct SigmoidCrossEntropyWithLogitsGrad;
+struct SigmoidCrossEntropyWithLogitsGradBuilder;
+
+struct Sin;
+struct SinBuilder;
+
+struct SkipGram;
+struct SkipGramBuilder;
+
+struct SliceFusion;
+struct SliceFusionBuilder;
+
+struct SmoothL1Loss;
+struct SmoothL1LossBuilder;
+
+struct SmoothL1LossGrad;
+struct SmoothL1LossGradBuilder;
+
+struct Softmax;
+struct SoftmaxBuilder;
+
+struct SoftmaxCrossEntropyWithLogits;
+struct SoftmaxCrossEntropyWithLogitsBuilder;
+
+struct SpaceToBatch;
+struct SpaceToBatchBuilder;
+
+struct SpaceToBatchND;
+struct SpaceToBatchNDBuilder;
+
+struct SpaceToDepth;
+struct SpaceToDepthBuilder;
+
+struct SparseSoftmaxCrossEntropyWithLogits;
+struct SparseSoftmaxCrossEntropyWithLogitsBuilder;
+
+struct SparseToDense;
+struct SparseToDenseBuilder;
+
+struct Split;
+struct SplitBuilder;
+
+struct Sqrt;
+struct SqrtBuilder;
+
+struct Squeeze;
+struct SqueezeBuilder;
+
+struct Square;
+struct SquareBuilder;
+
+struct SquaredDifference;
+struct SquaredDifferenceBuilder;
+
+struct Stack;
+struct StackBuilder;
+
+struct StridedSlice;
+struct StridedSliceBuilder;
+
+struct SubFusion;
+struct SubFusionBuilder;
+
+struct SubGrad;
+struct SubGradBuilder;
+
+struct Switch;
+struct SwitchBuilder;
+
+struct TensorListFromTensor;
+struct TensorListFromTensorBuilder;
+
+struct TensorListGetItem;
+struct TensorListGetItemBuilder;
+
+struct TensorListReserve;
+struct TensorListReserveBuilder;
+
+struct TensorListSetItem;
+struct TensorListSetItemBuilder;
+
+struct TensorListStack;
+struct TensorListStackBuilder;
+
+struct TileFusion;
+struct TileFusionBuilder;
+
+struct TopKFusion;
+struct TopKFusionBuilder;
+
+struct Transpose;
+struct TransposeBuilder;
+
+struct Unique;
+struct UniqueBuilder;
+
+struct UnsortedSegmentSum;
+struct UnsortedSegmentSumBuilder;
+
+struct Unsqueeze;
+struct UnsqueezeBuilder;
+
+struct Unstack;
+struct UnstackBuilder;
+
+struct Where;
+struct WhereBuilder;
+
+struct ZerosLike;
+struct ZerosLikeBuilder;
+
+struct Select;
+struct SelectBuilder;
+
+struct GRU;
+struct GRUBuilder;
+
+struct NonZero;
+struct NonZeroBuilder;
+
+struct InvertPermutation;
+struct InvertPermutationBuilder;
+
+struct Size;
+struct SizeBuilder;
+
+struct RandomStandardNormal;
+struct RandomStandardNormalBuilder;
+
+struct CropAndResize;
+struct CropAndResizeBuilder;
+
+struct Erf;
+struct ErfBuilder;
+
+struct StridedSliceGrad;
+struct StridedSliceGradBuilder;
+
+struct IsFinite;
+struct IsFiniteBuilder;
+
+struct LinSpace;
+struct LinSpaceBuilder;
+
+struct UniformReal;
+struct UniformRealBuilder;
+
+struct AbsGrad;
+struct AbsGradBuilder;
+
+struct RsqrtGrad;
+struct RsqrtGradBuilder;
+
+struct SqrtGrad;
+struct SqrtGradBuilder;
+
+struct LayerNormGrad;
+struct LayerNormGradBuilder;
+
+struct ResizeGrad;
+struct ResizeGradBuilder;
+
+struct Splice;
+struct SpliceBuilder;
+
+struct LogSoftmax;
+struct LogSoftmaxBuilder;
+
+struct Call;
+struct CallBuilder;
+
+struct CumSum;
+struct CumSumBuilder;
+
+struct Custom;
+struct CustomBuilder;
+
+struct SplitWithOverlap;
+struct SplitWithOverlapBuilder;
+
+struct GenOP;
+struct GenOPBuilder;
+
+struct RaggedRange;
+struct RaggedRangeBuilder;
+
+struct GLU;
+struct GLUBuilder;
+
+struct TensorArray;
+struct TensorArrayBuilder;
+
+struct TensorArrayRead;
+struct TensorArrayReadBuilder;
+
+struct TensorArrayWrite;
+struct TensorArrayWriteBuilder;
+
+struct Affine;
+struct AffineBuilder;
+
+struct ScatterNdUpdate;
+struct ScatterNdUpdateBuilder;
+
+struct AllGather;
+struct AllGatherBuilder;
+
+struct ReduceScatter;
+struct ReduceScatterBuilder;
+
+struct DynamicQuant;
+struct DynamicQuantBuilder;
+
+struct LSTMGradData;
+struct LSTMGradDataBuilder;
+
+struct LSTMGradWeight;
+struct LSTMGradWeightBuilder;
+
+struct RandomNormal;
+struct RandomNormalBuilder;
+
+struct NLLLoss;
+struct NLLLossBuilder;
+
+struct NLLLossGrad;
+struct NLLLossGradBuilder;
+
+struct FormatTranspose;
+struct FormatTransposeBuilder;
+
+struct GatherD;
+struct GatherDBuilder;
+
+struct GroupNormFusion;
+struct GroupNormFusionBuilder;
+
+enum PrimitiveType : uint8_t {
+  PrimitiveType_NONE = 0,
+  PrimitiveType_Abs = 1,
+  PrimitiveType_Activation = 2,
+  PrimitiveType_ActivationGrad = 3,
+  PrimitiveType_Adam = 4,
+  PrimitiveType_AddFusion = 5,
+  PrimitiveType_AdderFusion = 6,
+  PrimitiveType_AddGrad = 7,
+  PrimitiveType_AddN = 8,
+  PrimitiveType_All = 9,
+  PrimitiveType_ApplyMomentum = 10,
+  PrimitiveType_ArgMaxFusion = 11,
+  PrimitiveType_ArgMinFusion = 12,
+  PrimitiveType_Assert = 13,
+  PrimitiveType_Assign = 14,
+  PrimitiveType_AssignAdd = 15,
+  PrimitiveType_AudioSpectrogram = 16,
+  PrimitiveType_AvgPoolFusion = 17,
+  PrimitiveType_AvgPoolGrad = 18,
+  PrimitiveType_BatchNorm = 19,
+  PrimitiveType_BatchNormGrad = 20,
+  PrimitiveType_BatchToSpace = 21,
+  PrimitiveType_BatchToSpaceND = 22,
+  PrimitiveType_BiasAdd = 23,
+  PrimitiveType_BinaryCrossEntropy = 24,
+  PrimitiveType_BinaryCrossEntropyGrad = 25,
+  PrimitiveType_BiasAddGrad = 26,
+  PrimitiveType_BroadcastTo = 27,
+  PrimitiveType_Cast = 28,
+  PrimitiveType_Ceil = 29,
+  PrimitiveType_Clip = 30,
+  PrimitiveType_Concat = 31,
+  PrimitiveType_Attention = 32,
+  PrimitiveType_Conv2DBackpropFilterFusion = 33,
+  PrimitiveType_Conv2DBackpropInputFusion = 34,
+  PrimitiveType_Conv2DFusion = 35,
+  PrimitiveType_Conv2dTransposeFusion = 36,
+  PrimitiveType_Cos = 37,
+  PrimitiveType_ConstantOfShape = 38,
+  PrimitiveType_Crop = 39,
+  PrimitiveType_CustomExtractFeatures = 40,
+  PrimitiveType_CustomNormalize = 41,
+  PrimitiveType_CustomPredict = 42,
+  PrimitiveType_DeConv2DGradFilter = 43,
+  PrimitiveType_Depend = 44,
+  PrimitiveType_DepthToSpace = 45,
+  PrimitiveType_DetectionPostProcess = 46,
+  PrimitiveType_DivFusion = 47,
+  PrimitiveType_DivGrad = 48,
+  PrimitiveType_Dropout = 49,
+  PrimitiveType_DropoutGrad = 50,
+  PrimitiveType_Elu = 51,
+  PrimitiveType_Eltwise = 52,
+  PrimitiveType_Equal = 53,
+  PrimitiveType_EmbeddingLookupFusion = 54,
+  PrimitiveType_ExpFusion = 55,
+  PrimitiveType_ExpandDims = 56,
+  PrimitiveType_FakeQuantWithMinMaxVars = 57,
+  PrimitiveType_FakeQuantWithMinMaxVarsPerChannel = 58,
+  PrimitiveType_FftReal = 59,
+  PrimitiveType_FftImag = 60,
+  PrimitiveType_Flatten = 61,
+  PrimitiveType_FlattenGrad = 62,
+  PrimitiveType_Floor = 63,
+  PrimitiveType_FloorDiv = 64,
+  PrimitiveType_FloorMod = 65,
+  PrimitiveType_Fill = 66,
+  PrimitiveType_FullConnection = 67,
+  PrimitiveType_FusedBatchNorm = 68,
+  PrimitiveType_Gather = 69,
+  PrimitiveType_GatherNd = 70,
+  PrimitiveType_Greater = 71,
+  PrimitiveType_GreaterEqual = 72,
+  PrimitiveType_HashtableLookup = 73,
+  PrimitiveType_InstanceNorm = 74,
+  PrimitiveType_LayerNormFusion = 75,
+  PrimitiveType_LeakyRelu = 76,
+  PrimitiveType_Less = 77,
+  PrimitiveType_LessEqual = 78,
+  PrimitiveType_Log = 79,
+  PrimitiveType_LogGrad = 80,
+  PrimitiveType_LogicalAnd = 81,
+  PrimitiveType_LogicalNot = 82,
+  PrimitiveType_LogicalOr = 83,
+  PrimitiveType_LpNormalization = 84,
+  PrimitiveType_LRN = 85,
+  PrimitiveType_LshProjection = 86,
+  PrimitiveType_LSTM = 87,
+  PrimitiveType_L2NormalizeFusion = 88,
+  PrimitiveType_MatMulFusion = 89,
+  PrimitiveType_Maximum = 90,
+  PrimitiveType_MaximumGrad = 91,
+  PrimitiveType_MaxPoolFusion = 92,
+  PrimitiveType_MaxPoolGrad = 93,
+  PrimitiveType_SwitchLayer = 94,
+  PrimitiveType_Mfcc = 95,
+  PrimitiveType_Minimum = 96,
+  PrimitiveType_MinimumGrad = 97,
+  PrimitiveType_Mod = 98,
+  PrimitiveType_MulFusion = 99,
+  PrimitiveType_MulGrad = 100,
+  PrimitiveType_Neg = 101,
+  PrimitiveType_NegGrad = 102,
+  PrimitiveType_NotEqual = 103,
+  PrimitiveType_NonMaxSuppression = 104,
+  PrimitiveType_OneHot = 105,
+  PrimitiveType_OnesLike = 106,
+  PrimitiveType_PadFusion = 107,
+  PrimitiveType_PartialFusion = 108,
+  PrimitiveType_PowerGrad = 109,
+  PrimitiveType_PowFusion = 110,
+  PrimitiveType_PriorBox = 111,
+  PrimitiveType_PReLUFusion = 112,
+  PrimitiveType_QuantDTypeCast = 113,
+  PrimitiveType_Rank = 114,
+  PrimitiveType_Range = 115,
+  PrimitiveType_Reciprocal = 116,
+  PrimitiveType_RealDiv = 117,
+  PrimitiveType_ReduceFusion = 118,
+  PrimitiveType_Reshape = 119,
+  PrimitiveType_Resize = 120,
+  PrimitiveType_ReverseSequence = 121,
+  PrimitiveType_ReverseV2 = 122,
+  PrimitiveType_Rfft = 123,
+  PrimitiveType_ROIPooling = 124,
+  PrimitiveType_Round = 125,
+  PrimitiveType_Rsqrt = 126,
+  PrimitiveType_ScaleFusion = 127,
+  PrimitiveType_ScatterNd = 128,
+  PrimitiveType_SGD = 129,
+  PrimitiveType_Shape = 130,
+  PrimitiveType_SigmoidCrossEntropyWithLogits = 131,
+  PrimitiveType_SigmoidCrossEntropyWithLogitsGrad = 132,
+  PrimitiveType_Sin = 133,
+  PrimitiveType_SkipGram = 134,
+  PrimitiveType_SliceFusion = 135,
+  PrimitiveType_SmoothL1Loss = 136,
+  PrimitiveType_SmoothL1LossGrad = 137,
+  PrimitiveType_Softmax = 138,
+  PrimitiveType_SoftmaxCrossEntropyWithLogits = 139,
+  PrimitiveType_SpaceToBatch = 140,
+  PrimitiveType_SpaceToBatchND = 141,
+  PrimitiveType_SpaceToDepth = 142,
+  PrimitiveType_SparseSoftmaxCrossEntropyWithLogits = 143,
+  PrimitiveType_SparseToDense = 144,
+  PrimitiveType_Split = 145,
+  PrimitiveType_Sqrt = 146,
+  PrimitiveType_Squeeze = 147,
+  PrimitiveType_Square = 148,
+  PrimitiveType_SquaredDifference = 149,
+  PrimitiveType_Stack = 150,
+  PrimitiveType_StridedSlice = 151,
+  PrimitiveType_SubFusion = 152,
+  PrimitiveType_SubGrad = 153,
+  PrimitiveType_Switch = 154,
+  PrimitiveType_TensorListFromTensor = 155,
+  PrimitiveType_TensorListGetItem = 156,
+  PrimitiveType_TensorListReserve = 157,
+  PrimitiveType_TensorListSetItem = 158,
+  PrimitiveType_TensorListStack = 159,
+  PrimitiveType_TileFusion = 160,
+  PrimitiveType_TopKFusion = 161,
+  PrimitiveType_Transpose = 162,
+  PrimitiveType_Unique = 163,
+  PrimitiveType_UnsortedSegmentSum = 164,
+  PrimitiveType_Unsqueeze = 165,
+  PrimitiveType_Unstack = 166,
+  PrimitiveType_LSTMGrad = 167,
+  PrimitiveType_Where = 168,
+  PrimitiveType_ZerosLike = 169,
+  PrimitiveType_Select = 170,
+  PrimitiveType_ScatterNdUpdate = 171,
+  PrimitiveType_GRU = 172,
+  PrimitiveType_NonZero = 173,
+  PrimitiveType_InvertPermutation = 174,
+  PrimitiveType_Size = 175,
+  PrimitiveType_RandomStandardNormal = 176,
+  PrimitiveType_CropAndResize = 177,
+  PrimitiveType_Erf = 178,
+  PrimitiveType_StridedSliceGrad = 179,
+  PrimitiveType_IsFinite = 180,
+  PrimitiveType_LinSpace = 181,
+  PrimitiveType_UniformReal = 182,
+  PrimitiveType_AbsGrad = 183,
+  PrimitiveType_RsqrtGrad = 184,
+  PrimitiveType_SqrtGrad = 185,
+  PrimitiveType_LayerNormGrad = 186,
+  PrimitiveType_ResizeGrad = 187,
+  PrimitiveType_Splice = 188,
+  PrimitiveType_LogSoftmax = 189,
+  PrimitiveType_Call = 190,
+  PrimitiveType_Custom = 191,
+  PrimitiveType_CumSum = 192,
+  PrimitiveType_SplitWithOverlap = 193,
+  PrimitiveType_GenOP = 194,
+  PrimitiveType_RaggedRange = 195,
+  PrimitiveType_GLU = 196,
+  PrimitiveType_TensorArray = 197,
+  PrimitiveType_TensorArrayRead = 198,
+  PrimitiveType_TensorArrayWrite = 199,
+  PrimitiveType_Affine = 200,
+  PrimitiveType_AllGather = 201,
+  PrimitiveType_ReduceScatter = 202,
+  PrimitiveType_DynamicQuant = 203,
+  PrimitiveType_LSTMGradData = 204,
+  PrimitiveType_LSTMGradWeight = 205,
+  PrimitiveType_RandomNormal = 206,
+  PrimitiveType_NLLLoss = 207,
+  PrimitiveType_NLLLossGrad = 208,
+  PrimitiveType_FormatTranspose = 209,
+  PrimitiveType_GatherD = 210,
+  PrimitiveType_GroupNormFusion = 211,
+  PrimitiveType_MIN = PrimitiveType_NONE,
+  PrimitiveType_MAX = PrimitiveType_GroupNormFusion
+};
+
+inline const PrimitiveType (&EnumValuesPrimitiveType())[212] {
+  static const PrimitiveType values[] = {
+    PrimitiveType_NONE,
+    PrimitiveType_Abs,
+    PrimitiveType_Activation,
+    PrimitiveType_ActivationGrad,
+    PrimitiveType_Adam,
+    PrimitiveType_AddFusion,
+    PrimitiveType_AdderFusion,
+    PrimitiveType_AddGrad,
+    PrimitiveType_AddN,
+    PrimitiveType_All,
+    PrimitiveType_ApplyMomentum,
+    PrimitiveType_ArgMaxFusion,
+    PrimitiveType_ArgMinFusion,
+    PrimitiveType_Assert,
+    PrimitiveType_Assign,
+    PrimitiveType_AssignAdd,
+    PrimitiveType_AudioSpectrogram,
+    PrimitiveType_AvgPoolFusion,
+    PrimitiveType_AvgPoolGrad,
+    PrimitiveType_BatchNorm,
+    PrimitiveType_BatchNormGrad,
+    PrimitiveType_BatchToSpace,
+    PrimitiveType_BatchToSpaceND,
+    PrimitiveType_BiasAdd,
+    PrimitiveType_BinaryCrossEntropy,
+    PrimitiveType_BinaryCrossEntropyGrad,
+    PrimitiveType_BiasAddGrad,
+    PrimitiveType_BroadcastTo,
+    PrimitiveType_Cast,
+    PrimitiveType_Ceil,
+    PrimitiveType_Clip,
+    PrimitiveType_Concat,
+    PrimitiveType_Attention,
+    PrimitiveType_Conv2DBackpropFilterFusion,
+    PrimitiveType_Conv2DBackpropInputFusion,
+    PrimitiveType_Conv2DFusion,
+    PrimitiveType_Conv2dTransposeFusion,
+    PrimitiveType_Cos,
+    PrimitiveType_ConstantOfShape,
+    PrimitiveType_Crop,
+    PrimitiveType_CustomExtractFeatures,
+    PrimitiveType_CustomNormalize,
+    PrimitiveType_CustomPredict,
+    PrimitiveType_DeConv2DGradFilter,
+    PrimitiveType_Depend,
+    PrimitiveType_DepthToSpace,
+    PrimitiveType_DetectionPostProcess,
+    PrimitiveType_DivFusion,
+    PrimitiveType_DivGrad,
+    PrimitiveType_Dropout,
+    PrimitiveType_DropoutGrad,
+    PrimitiveType_Elu,
+    PrimitiveType_Eltwise,
+    PrimitiveType_Equal,
+    PrimitiveType_EmbeddingLookupFusion,
+    PrimitiveType_ExpFusion,
+    PrimitiveType_ExpandDims,
+    PrimitiveType_FakeQuantWithMinMaxVars,
+    PrimitiveType_FakeQuantWithMinMaxVarsPerChannel,
+    PrimitiveType_FftReal,
+    PrimitiveType_FftImag,
+    PrimitiveType_Flatten,
+    PrimitiveType_FlattenGrad,
+    PrimitiveType_Floor,
+    PrimitiveType_FloorDiv,
+    PrimitiveType_FloorMod,
+    PrimitiveType_Fill,
+    PrimitiveType_FullConnection,
+    PrimitiveType_FusedBatchNorm,
+    PrimitiveType_Gather,
+    PrimitiveType_GatherNd,
+    PrimitiveType_Greater,
+    PrimitiveType_GreaterEqual,
+    PrimitiveType_HashtableLookup,
+    PrimitiveType_InstanceNorm,
+    PrimitiveType_LayerNormFusion,
+    PrimitiveType_LeakyRelu,
+    PrimitiveType_Less,
+    PrimitiveType_LessEqual,
+    PrimitiveType_Log,
+    PrimitiveType_LogGrad,
+    PrimitiveType_LogicalAnd,
+    PrimitiveType_LogicalNot,
+    PrimitiveType_LogicalOr,
+    PrimitiveType_LpNormalization,
+    PrimitiveType_LRN,
+    PrimitiveType_LshProjection,
+    PrimitiveType_LSTM,
+    PrimitiveType_L2NormalizeFusion,
+    PrimitiveType_MatMulFusion,
+    PrimitiveType_Maximum,
+    PrimitiveType_MaximumGrad,
+    PrimitiveType_MaxPoolFusion,
+    PrimitiveType_MaxPoolGrad,
+    PrimitiveType_SwitchLayer,
+    PrimitiveType_Mfcc,
+    PrimitiveType_Minimum,
+    PrimitiveType_MinimumGrad,
+    PrimitiveType_Mod,
+    PrimitiveType_MulFusion,
+    PrimitiveType_MulGrad,
+    PrimitiveType_Neg,
+    PrimitiveType_NegGrad,
+    PrimitiveType_NotEqual,
+    PrimitiveType_NonMaxSuppression,
+    PrimitiveType_OneHot,
+    PrimitiveType_OnesLike,
+    PrimitiveType_PadFusion,
+    PrimitiveType_PartialFusion,
+    PrimitiveType_PowerGrad,
+    PrimitiveType_PowFusion,
+    PrimitiveType_PriorBox,
+    PrimitiveType_PReLUFusion,
+    PrimitiveType_QuantDTypeCast,
+    PrimitiveType_Rank,
+    PrimitiveType_Range,
+    PrimitiveType_Reciprocal,
+    PrimitiveType_RealDiv,
+    PrimitiveType_ReduceFusion,
+    PrimitiveType_Reshape,
+    PrimitiveType_Resize,
+    PrimitiveType_ReverseSequence,
+    PrimitiveType_ReverseV2,
+    PrimitiveType_Rfft,
+    PrimitiveType_ROIPooling,
+    PrimitiveType_Round,
+    PrimitiveType_Rsqrt,
+    PrimitiveType_ScaleFusion,
+    PrimitiveType_ScatterNd,
+    PrimitiveType_SGD,
+    PrimitiveType_Shape,
+    PrimitiveType_SigmoidCrossEntropyWithLogits,
+    PrimitiveType_SigmoidCrossEntropyWithLogitsGrad,
+    PrimitiveType_Sin,
+    PrimitiveType_SkipGram,
+    PrimitiveType_SliceFusion,
+    PrimitiveType_SmoothL1Loss,
+    PrimitiveType_SmoothL1LossGrad,
+    PrimitiveType_Softmax,
+    PrimitiveType_SoftmaxCrossEntropyWithLogits,
+    PrimitiveType_SpaceToBatch,
+    PrimitiveType_SpaceToBatchND,
+    PrimitiveType_SpaceToDepth,
+    PrimitiveType_SparseSoftmaxCrossEntropyWithLogits,
+    PrimitiveType_SparseToDense,
+    PrimitiveType_Split,
+    PrimitiveType_Sqrt,
+    PrimitiveType_Squeeze,
+    PrimitiveType_Square,
+    PrimitiveType_SquaredDifference,
+    PrimitiveType_Stack,
+    PrimitiveType_StridedSlice,
+    PrimitiveType_SubFusion,
+    PrimitiveType_SubGrad,
+    PrimitiveType_Switch,
+    PrimitiveType_TensorListFromTensor,
+    PrimitiveType_TensorListGetItem,
+    PrimitiveType_TensorListReserve,
+    PrimitiveType_TensorListSetItem,
+    PrimitiveType_TensorListStack,
+    PrimitiveType_TileFusion,
+    PrimitiveType_TopKFusion,
+    PrimitiveType_Transpose,
+    PrimitiveType_Unique,
+    PrimitiveType_UnsortedSegmentSum,
+    PrimitiveType_Unsqueeze,
+    PrimitiveType_Unstack,
+    PrimitiveType_LSTMGrad,
+    PrimitiveType_Where,
+    PrimitiveType_ZerosLike,
+    PrimitiveType_Select,
+    PrimitiveType_ScatterNdUpdate,
+    PrimitiveType_GRU,
+    PrimitiveType_NonZero,
+    PrimitiveType_InvertPermutation,
+    PrimitiveType_Size,
+    PrimitiveType_RandomStandardNormal,
+    PrimitiveType_CropAndResize,
+    PrimitiveType_Erf,
+    PrimitiveType_StridedSliceGrad,
+    PrimitiveType_IsFinite,
+    PrimitiveType_LinSpace,
+    PrimitiveType_UniformReal,
+    PrimitiveType_AbsGrad,
+    PrimitiveType_RsqrtGrad,
+    PrimitiveType_SqrtGrad,
+    PrimitiveType_LayerNormGrad,
+    PrimitiveType_ResizeGrad,
+    PrimitiveType_Splice,
+    PrimitiveType_LogSoftmax,
+    PrimitiveType_Call,
+    PrimitiveType_Custom,
+    PrimitiveType_CumSum,
+    PrimitiveType_SplitWithOverlap,
+    PrimitiveType_GenOP,
+    PrimitiveType_RaggedRange,
+    PrimitiveType_GLU,
+    PrimitiveType_TensorArray,
+    PrimitiveType_TensorArrayRead,
+    PrimitiveType_TensorArrayWrite,
+    PrimitiveType_Affine,
+    PrimitiveType_AllGather,
+    PrimitiveType_ReduceScatter,
+    PrimitiveType_DynamicQuant,
+    PrimitiveType_LSTMGradData,
+    PrimitiveType_LSTMGradWeight,
+    PrimitiveType_RandomNormal,
+    PrimitiveType_NLLLoss,
+    PrimitiveType_NLLLossGrad,
+    PrimitiveType_FormatTranspose,
+    PrimitiveType_GatherD,
+    PrimitiveType_GroupNormFusion
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesPrimitiveType() {
+  static const char * const names[213] = {
+    "NONE",
+    "Abs",
+    "Activation",
+    "ActivationGrad",
+    "Adam",
+    "AddFusion",
+    "AdderFusion",
+    "AddGrad",
+    "AddN",
+    "All",
+    "ApplyMomentum",
+    "ArgMaxFusion",
+    "ArgMinFusion",
+    "Assert",
+    "Assign",
+    "AssignAdd",
+    "AudioSpectrogram",
+    "AvgPoolFusion",
+    "AvgPoolGrad",
+    "BatchNorm",
+    "BatchNormGrad",
+    "BatchToSpace",
+    "BatchToSpaceND",
+    "BiasAdd",
+    "BinaryCrossEntropy",
+    "BinaryCrossEntropyGrad",
+    "BiasAddGrad",
+    "BroadcastTo",
+    "Cast",
+    "Ceil",
+    "Clip",
+    "Concat",
+    "Attention",
+    "Conv2DBackpropFilterFusion",
+    "Conv2DBackpropInputFusion",
+    "Conv2DFusion",
+    "Conv2dTransposeFusion",
+    "Cos",
+    "ConstantOfShape",
+    "Crop",
+    "CustomExtractFeatures",
+    "CustomNormalize",
+    "CustomPredict",
+    "DeConv2DGradFilter",
+    "Depend",
+    "DepthToSpace",
+    "DetectionPostProcess",
+    "DivFusion",
+    "DivGrad",
+    "Dropout",
+    "DropoutGrad",
+    "Elu",
+    "Eltwise",
+    "Equal",
+    "EmbeddingLookupFusion",
+    "ExpFusion",
+    "ExpandDims",
+    "FakeQuantWithMinMaxVars",
+    "FakeQuantWithMinMaxVarsPerChannel",
+    "FftReal",
+    "FftImag",
+    "Flatten",
+    "FlattenGrad",
+    "Floor",
+    "FloorDiv",
+    "FloorMod",
+    "Fill",
+    "FullConnection",
+    "FusedBatchNorm",
+    "Gather",
+    "GatherNd",
+    "Greater",
+    "GreaterEqual",
+    "HashtableLookup",
+    "InstanceNorm",
+    "LayerNormFusion",
+    "LeakyRelu",
+    "Less",
+    "LessEqual",
+    "Log",
+    "LogGrad",
+    "LogicalAnd",
+    "LogicalNot",
+    "LogicalOr",
+    "LpNormalization",
+    "LRN",
+    "LshProjection",
+    "LSTM",
+    "L2NormalizeFusion",
+    "MatMulFusion",
+    "Maximum",
+    "MaximumGrad",
+    "MaxPoolFusion",
+    "MaxPoolGrad",
+    "SwitchLayer",
+    "Mfcc",
+    "Minimum",
+    "MinimumGrad",
+    "Mod",
+    "MulFusion",
+    "MulGrad",
+    "Neg",
+    "NegGrad",
+    "NotEqual",
+    "NonMaxSuppression",
+    "OneHot",
+    "OnesLike",
+    "PadFusion",
+    "PartialFusion",
+    "PowerGrad",
+    "PowFusion",
+    "PriorBox",
+    "PReLUFusion",
+    "QuantDTypeCast",
+    "Rank",
+    "Range",
+    "Reciprocal",
+    "RealDiv",
+    "ReduceFusion",
+    "Reshape",
+    "Resize",
+    "ReverseSequence",
+    "ReverseV2",
+    "Rfft",
+    "ROIPooling",
+    "Round",
+    "Rsqrt",
+    "ScaleFusion",
+    "ScatterNd",
+    "SGD",
+    "Shape",
+    "SigmoidCrossEntropyWithLogits",
+    "SigmoidCrossEntropyWithLogitsGrad",
+    "Sin",
+    "SkipGram",
+    "SliceFusion",
+    "SmoothL1Loss",
+    "SmoothL1LossGrad",
+    "Softmax",
+    "SoftmaxCrossEntropyWithLogits",
+    "SpaceToBatch",
+    "SpaceToBatchND",
+    "SpaceToDepth",
+    "SparseSoftmaxCrossEntropyWithLogits",
+    "SparseToDense",
+    "Split",
+    "Sqrt",
+    "Squeeze",
+    "Square",
+    "SquaredDifference",
+    "Stack",
+    "StridedSlice",
+    "SubFusion",
+    "SubGrad",
+    "Switch",
+    "TensorListFromTensor",
+    "TensorListGetItem",
+    "TensorListReserve",
+    "TensorListSetItem",
+    "TensorListStack",
+    "TileFusion",
+    "TopKFusion",
+    "Transpose",
+    "Unique",
+    "UnsortedSegmentSum",
+    "Unsqueeze",
+    "Unstack",
+    "LSTMGrad",
+    "Where",
+    "ZerosLike",
+    "Select",
+    "ScatterNdUpdate",
+    "GRU",
+    "NonZero",
+    "InvertPermutation",
+    "Size",
+    "RandomStandardNormal",
+    "CropAndResize",
+    "Erf",
+    "StridedSliceGrad",
+    "IsFinite",
+    "LinSpace",
+    "UniformReal",
+    "AbsGrad",
+    "RsqrtGrad",
+    "SqrtGrad",
+    "LayerNormGrad",
+    "ResizeGrad",
+    "Splice",
+    "LogSoftmax",
+    "Call",
+    "Custom",
+    "CumSum",
+    "SplitWithOverlap",
+    "GenOP",
+    "RaggedRange",
+    "GLU",
+    "TensorArray",
+    "TensorArrayRead",
+    "TensorArrayWrite",
+    "Affine",
+    "AllGather",
+    "ReduceScatter",
+    "DynamicQuant",
+    "LSTMGradData",
+    "LSTMGradWeight",
+    "RandomNormal",
+    "NLLLoss",
+    "NLLLossGrad",
+    "FormatTranspose",
+    "GatherD",
+    "GroupNormFusion",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNamePrimitiveType(PrimitiveType e) {
+  if (flatbuffers::IsOutRange(e, PrimitiveType_NONE, PrimitiveType_GroupNormFusion)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesPrimitiveType()[index];
+}
+
+template<typename T> struct PrimitiveTypeTraits {
+  static const PrimitiveType enum_value = PrimitiveType_NONE;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Abs> {
+  static const PrimitiveType enum_value = PrimitiveType_Abs;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Activation> {
+  static const PrimitiveType enum_value = PrimitiveType_Activation;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ActivationGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_ActivationGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Adam> {
+  static const PrimitiveType enum_value = PrimitiveType_Adam;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AddFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_AddFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AdderFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_AdderFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AddGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_AddGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AddN> {
+  static const PrimitiveType enum_value = PrimitiveType_AddN;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::All> {
+  static const PrimitiveType enum_value = PrimitiveType_All;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ApplyMomentum> {
+  static const PrimitiveType enum_value = PrimitiveType_ApplyMomentum;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ArgMaxFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_ArgMaxFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ArgMinFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_ArgMinFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Assert> {
+  static const PrimitiveType enum_value = PrimitiveType_Assert;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Assign> {
+  static const PrimitiveType enum_value = PrimitiveType_Assign;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AssignAdd> {
+  static const PrimitiveType enum_value = PrimitiveType_AssignAdd;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AudioSpectrogram> {
+  static const PrimitiveType enum_value = PrimitiveType_AudioSpectrogram;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AvgPoolFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_AvgPoolFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AvgPoolGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_AvgPoolGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BatchNorm> {
+  static const PrimitiveType enum_value = PrimitiveType_BatchNorm;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BatchNormGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_BatchNormGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BatchToSpace> {
+  static const PrimitiveType enum_value = PrimitiveType_BatchToSpace;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BatchToSpaceND> {
+  static const PrimitiveType enum_value = PrimitiveType_BatchToSpaceND;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BiasAdd> {
+  static const PrimitiveType enum_value = PrimitiveType_BiasAdd;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BinaryCrossEntropy> {
+  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropy;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BinaryCrossEntropyGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropyGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BiasAddGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_BiasAddGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::BroadcastTo> {
+  static const PrimitiveType enum_value = PrimitiveType_BroadcastTo;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Cast> {
+  static const PrimitiveType enum_value = PrimitiveType_Cast;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Ceil> {
+  static const PrimitiveType enum_value = PrimitiveType_Ceil;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Clip> {
+  static const PrimitiveType enum_value = PrimitiveType_Clip;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Concat> {
+  static const PrimitiveType enum_value = PrimitiveType_Concat;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Attention> {
+  static const PrimitiveType enum_value = PrimitiveType_Attention;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2DBackpropFilterFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_Conv2DBackpropFilterFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2DBackpropInputFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_Conv2DBackpropInputFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2DFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_Conv2DFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2dTransposeFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_Conv2dTransposeFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Cos> {
+  static const PrimitiveType enum_value = PrimitiveType_Cos;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ConstantOfShape> {
+  static const PrimitiveType enum_value = PrimitiveType_ConstantOfShape;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Crop> {
+  static const PrimitiveType enum_value = PrimitiveType_Crop;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::CustomExtractFeatures> {
+  static const PrimitiveType enum_value = PrimitiveType_CustomExtractFeatures;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::CustomNormalize> {
+  static const PrimitiveType enum_value = PrimitiveType_CustomNormalize;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::CustomPredict> {
+  static const PrimitiveType enum_value = PrimitiveType_CustomPredict;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DeConv2DGradFilter> {
+  static const PrimitiveType enum_value = PrimitiveType_DeConv2DGradFilter;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Depend> {
+  static const PrimitiveType enum_value = PrimitiveType_Depend;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DepthToSpace> {
+  static const PrimitiveType enum_value = PrimitiveType_DepthToSpace;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DetectionPostProcess> {
+  static const PrimitiveType enum_value = PrimitiveType_DetectionPostProcess;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DivFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_DivFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DivGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_DivGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Dropout> {
+  static const PrimitiveType enum_value = PrimitiveType_Dropout;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DropoutGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_DropoutGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Elu> {
+  static const PrimitiveType enum_value = PrimitiveType_Elu;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Eltwise> {
+  static const PrimitiveType enum_value = PrimitiveType_Eltwise;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Equal> {
+  static const PrimitiveType enum_value = PrimitiveType_Equal;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::EmbeddingLookupFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_EmbeddingLookupFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ExpFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_ExpFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ExpandDims> {
+  static const PrimitiveType enum_value = PrimitiveType_ExpandDims;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FakeQuantWithMinMaxVars> {
+  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxVars;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FakeQuantWithMinMaxVarsPerChannel> {
+  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxVarsPerChannel;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FftReal> {
+  static const PrimitiveType enum_value = PrimitiveType_FftReal;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FftImag> {
+  static const PrimitiveType enum_value = PrimitiveType_FftImag;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Flatten> {
+  static const PrimitiveType enum_value = PrimitiveType_Flatten;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FlattenGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_FlattenGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Floor> {
+  static const PrimitiveType enum_value = PrimitiveType_Floor;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FloorDiv> {
+  static const PrimitiveType enum_value = PrimitiveType_FloorDiv;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FloorMod> {
+  static const PrimitiveType enum_value = PrimitiveType_FloorMod;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Fill> {
+  static const PrimitiveType enum_value = PrimitiveType_Fill;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FullConnection> {
+  static const PrimitiveType enum_value = PrimitiveType_FullConnection;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FusedBatchNorm> {
+  static const PrimitiveType enum_value = PrimitiveType_FusedBatchNorm;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Gather> {
+  static const PrimitiveType enum_value = PrimitiveType_Gather;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GatherNd> {
+  static const PrimitiveType enum_value = PrimitiveType_GatherNd;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Greater> {
+  static const PrimitiveType enum_value = PrimitiveType_Greater;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GreaterEqual> {
+  static const PrimitiveType enum_value = PrimitiveType_GreaterEqual;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::HashtableLookup> {
+  static const PrimitiveType enum_value = PrimitiveType_HashtableLookup;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::InstanceNorm> {
+  static const PrimitiveType enum_value = PrimitiveType_InstanceNorm;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LayerNormFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_LayerNormFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LeakyRelu> {
+  static const PrimitiveType enum_value = PrimitiveType_LeakyRelu;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Less> {
+  static const PrimitiveType enum_value = PrimitiveType_Less;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LessEqual> {
+  static const PrimitiveType enum_value = PrimitiveType_LessEqual;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Log> {
+  static const PrimitiveType enum_value = PrimitiveType_Log;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LogGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_LogGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LogicalAnd> {
+  static const PrimitiveType enum_value = PrimitiveType_LogicalAnd;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LogicalNot> {
+  static const PrimitiveType enum_value = PrimitiveType_LogicalNot;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LogicalOr> {
+  static const PrimitiveType enum_value = PrimitiveType_LogicalOr;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LpNormalization> {
+  static const PrimitiveType enum_value = PrimitiveType_LpNormalization;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LRN> {
+  static const PrimitiveType enum_value = PrimitiveType_LRN;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LshProjection> {
+  static const PrimitiveType enum_value = PrimitiveType_LshProjection;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LSTM> {
+  static const PrimitiveType enum_value = PrimitiveType_LSTM;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::L2NormalizeFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_L2NormalizeFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MatMulFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_MatMulFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Maximum> {
+  static const PrimitiveType enum_value = PrimitiveType_Maximum;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MaximumGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_MaximumGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MaxPoolFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_MaxPoolFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MaxPoolGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_MaxPoolGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SwitchLayer> {
+  static const PrimitiveType enum_value = PrimitiveType_SwitchLayer;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Mfcc> {
+  static const PrimitiveType enum_value = PrimitiveType_Mfcc;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Minimum> {
+  static const PrimitiveType enum_value = PrimitiveType_Minimum;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MinimumGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_MinimumGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Mod> {
+  static const PrimitiveType enum_value = PrimitiveType_Mod;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MulFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_MulFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::MulGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_MulGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Neg> {
+  static const PrimitiveType enum_value = PrimitiveType_Neg;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::NegGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_NegGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::NotEqual> {
+  static const PrimitiveType enum_value = PrimitiveType_NotEqual;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::NonMaxSuppression> {
+  static const PrimitiveType enum_value = PrimitiveType_NonMaxSuppression;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::OneHot> {
+  static const PrimitiveType enum_value = PrimitiveType_OneHot;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::OnesLike> {
+  static const PrimitiveType enum_value = PrimitiveType_OnesLike;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::PadFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_PadFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::PartialFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_PartialFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::PowerGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_PowerGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::PowFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_PowFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::PriorBox> {
+  static const PrimitiveType enum_value = PrimitiveType_PriorBox;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::PReLUFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_PReLUFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::QuantDTypeCast> {
+  static const PrimitiveType enum_value = PrimitiveType_QuantDTypeCast;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Rank> {
+  static const PrimitiveType enum_value = PrimitiveType_Rank;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Range> {
+  static const PrimitiveType enum_value = PrimitiveType_Range;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Reciprocal> {
+  static const PrimitiveType enum_value = PrimitiveType_Reciprocal;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::RealDiv> {
+  static const PrimitiveType enum_value = PrimitiveType_RealDiv;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ReduceFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_ReduceFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Reshape> {
+  static const PrimitiveType enum_value = PrimitiveType_Reshape;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Resize> {
+  static const PrimitiveType enum_value = PrimitiveType_Resize;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ReverseSequence> {
+  static const PrimitiveType enum_value = PrimitiveType_ReverseSequence;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ReverseV2> {
+  static const PrimitiveType enum_value = PrimitiveType_ReverseV2;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Rfft> {
+  static const PrimitiveType enum_value = PrimitiveType_Rfft;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ROIPooling> {
+  static const PrimitiveType enum_value = PrimitiveType_ROIPooling;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Round> {
+  static const PrimitiveType enum_value = PrimitiveType_Round;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Rsqrt> {
+  static const PrimitiveType enum_value = PrimitiveType_Rsqrt;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ScaleFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_ScaleFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ScatterNd> {
+  static const PrimitiveType enum_value = PrimitiveType_ScatterNd;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SGD> {
+  static const PrimitiveType enum_value = PrimitiveType_SGD;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Shape> {
+  static const PrimitiveType enum_value = PrimitiveType_Shape;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SigmoidCrossEntropyWithLogits> {
+  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogits;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SigmoidCrossEntropyWithLogitsGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogitsGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Sin> {
+  static const PrimitiveType enum_value = PrimitiveType_Sin;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SkipGram> {
+  static const PrimitiveType enum_value = PrimitiveType_SkipGram;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SliceFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_SliceFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SmoothL1Loss> {
+  static const PrimitiveType enum_value = PrimitiveType_SmoothL1Loss;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SmoothL1LossGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_SmoothL1LossGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Softmax> {
+  static const PrimitiveType enum_value = PrimitiveType_Softmax;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SoftmaxCrossEntropyWithLogits> {
+  static const PrimitiveType enum_value = PrimitiveType_SoftmaxCrossEntropyWithLogits;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SpaceToBatch> {
+  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatch;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SpaceToBatchND> {
+  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatchND;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SpaceToDepth> {
+  static const PrimitiveType enum_value = PrimitiveType_SpaceToDepth;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SparseSoftmaxCrossEntropyWithLogits> {
+  static const PrimitiveType enum_value = PrimitiveType_SparseSoftmaxCrossEntropyWithLogits;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SparseToDense> {
+  static const PrimitiveType enum_value = PrimitiveType_SparseToDense;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Split> {
+  static const PrimitiveType enum_value = PrimitiveType_Split;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Sqrt> {
+  static const PrimitiveType enum_value = PrimitiveType_Sqrt;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Squeeze> {
+  static const PrimitiveType enum_value = PrimitiveType_Squeeze;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Square> {
+  static const PrimitiveType enum_value = PrimitiveType_Square;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SquaredDifference> {
+  static const PrimitiveType enum_value = PrimitiveType_SquaredDifference;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Stack> {
+  static const PrimitiveType enum_value = PrimitiveType_Stack;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::StridedSlice> {
+  static const PrimitiveType enum_value = PrimitiveType_StridedSlice;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SubFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_SubFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SubGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_SubGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Switch> {
+  static const PrimitiveType enum_value = PrimitiveType_Switch;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListFromTensor> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorListFromTensor;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListGetItem> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorListGetItem;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListReserve> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorListReserve;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListSetItem> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorListSetItem;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListStack> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorListStack;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TileFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_TileFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TopKFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_TopKFusion;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Transpose> {
+  static const PrimitiveType enum_value = PrimitiveType_Transpose;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Unique> {
+  static const PrimitiveType enum_value = PrimitiveType_Unique;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::UnsortedSegmentSum> {
+  static const PrimitiveType enum_value = PrimitiveType_UnsortedSegmentSum;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Unsqueeze> {
+  static const PrimitiveType enum_value = PrimitiveType_Unsqueeze;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Unstack> {
+  static const PrimitiveType enum_value = PrimitiveType_Unstack;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LSTMGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_LSTMGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Where> {
+  static const PrimitiveType enum_value = PrimitiveType_Where;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ZerosLike> {
+  static const PrimitiveType enum_value = PrimitiveType_ZerosLike;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Select> {
+  static const PrimitiveType enum_value = PrimitiveType_Select;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ScatterNdUpdate> {
+  static const PrimitiveType enum_value = PrimitiveType_ScatterNdUpdate;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GRU> {
+  static const PrimitiveType enum_value = PrimitiveType_GRU;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::NonZero> {
+  static const PrimitiveType enum_value = PrimitiveType_NonZero;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::InvertPermutation> {
+  static const PrimitiveType enum_value = PrimitiveType_InvertPermutation;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Size> {
+  static const PrimitiveType enum_value = PrimitiveType_Size;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::RandomStandardNormal> {
+  static const PrimitiveType enum_value = PrimitiveType_RandomStandardNormal;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::CropAndResize> {
+  static const PrimitiveType enum_value = PrimitiveType_CropAndResize;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Erf> {
+  static const PrimitiveType enum_value = PrimitiveType_Erf;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::StridedSliceGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_StridedSliceGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::IsFinite> {
+  static const PrimitiveType enum_value = PrimitiveType_IsFinite;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LinSpace> {
+  static const PrimitiveType enum_value = PrimitiveType_LinSpace;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::UniformReal> {
+  static const PrimitiveType enum_value = PrimitiveType_UniformReal;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AbsGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_AbsGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::RsqrtGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_RsqrtGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SqrtGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_SqrtGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LayerNormGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_LayerNormGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ResizeGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_ResizeGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Splice> {
+  static const PrimitiveType enum_value = PrimitiveType_Splice;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LogSoftmax> {
+  static const PrimitiveType enum_value = PrimitiveType_LogSoftmax;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Call> {
+  static const PrimitiveType enum_value = PrimitiveType_Call;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Custom> {
+  static const PrimitiveType enum_value = PrimitiveType_Custom;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::CumSum> {
+  static const PrimitiveType enum_value = PrimitiveType_CumSum;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::SplitWithOverlap> {
+  static const PrimitiveType enum_value = PrimitiveType_SplitWithOverlap;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GenOP> {
+  static const PrimitiveType enum_value = PrimitiveType_GenOP;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::RaggedRange> {
+  static const PrimitiveType enum_value = PrimitiveType_RaggedRange;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GLU> {
+  static const PrimitiveType enum_value = PrimitiveType_GLU;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorArray> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorArray;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorArrayRead> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorArrayRead;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::TensorArrayWrite> {
+  static const PrimitiveType enum_value = PrimitiveType_TensorArrayWrite;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::Affine> {
+  static const PrimitiveType enum_value = PrimitiveType_Affine;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::AllGather> {
+  static const PrimitiveType enum_value = PrimitiveType_AllGather;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::ReduceScatter> {
+  static const PrimitiveType enum_value = PrimitiveType_ReduceScatter;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::DynamicQuant> {
+  static const PrimitiveType enum_value = PrimitiveType_DynamicQuant;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LSTMGradData> {
+  static const PrimitiveType enum_value = PrimitiveType_LSTMGradData;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::LSTMGradWeight> {
+  static const PrimitiveType enum_value = PrimitiveType_LSTMGradWeight;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::RandomNormal> {
+  static const PrimitiveType enum_value = PrimitiveType_RandomNormal;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::NLLLoss> {
+  static const PrimitiveType enum_value = PrimitiveType_NLLLoss;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::NLLLossGrad> {
+  static const PrimitiveType enum_value = PrimitiveType_NLLLossGrad;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::FormatTranspose> {
+  static const PrimitiveType enum_value = PrimitiveType_FormatTranspose;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GatherD> {
+  static const PrimitiveType enum_value = PrimitiveType_GatherD;
+};
+
+template<> struct PrimitiveTypeTraits<mindspore::schema::GroupNormFusion> {
+  static const PrimitiveType enum_value = PrimitiveType_GroupNormFusion;
+};
+
+bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type);
+bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);
+
+struct Abs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AbsBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct AbsBuilder {
+  typedef Abs Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Abs> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Abs>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Abs> CreateAbs(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AbsBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Activation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ActivationBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4,
+    VT_ALPHA = 6,
+    VT_MIN_VAL = 8,
+    VT_MAX_VAL = 10,
+    VT_APPROXIMATE = 12
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  float alpha() const {
+    return GetField<float>(VT_ALPHA, 0.0f);
+  }
+  float min_val() const {
+    return GetField<float>(VT_MIN_VAL, 0.0f);
+  }
+  float max_val() const {
+    return GetField<float>(VT_MAX_VAL, 0.0f);
+  }
+  bool approximate() const {
+    return GetField<uint8_t>(VT_APPROXIMATE, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           VerifyField<float>(verifier, VT_ALPHA) &&
+           VerifyField<float>(verifier, VT_MIN_VAL) &&
+           VerifyField<float>(verifier, VT_MAX_VAL) &&
+           VerifyField<uint8_t>(verifier, VT_APPROXIMATE) &&
+           verifier.EndTable();
+  }
+};
+
+struct ActivationBuilder {
+  typedef Activation Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(Activation::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  void add_alpha(float alpha) {
+    fbb_.AddElement<float>(Activation::VT_ALPHA, alpha, 0.0f);
+  }
+  void add_min_val(float min_val) {
+    fbb_.AddElement<float>(Activation::VT_MIN_VAL, min_val, 0.0f);
+  }
+  void add_max_val(float max_val) {
+    fbb_.AddElement<float>(Activation::VT_MAX_VAL, max_val, 0.0f);
+  }
+  void add_approximate(bool approximate) {
+    fbb_.AddElement<uint8_t>(Activation::VT_APPROXIMATE, static_cast<uint8_t>(approximate), 0);
+  }
+  explicit ActivationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Activation> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Activation>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Activation> CreateActivation(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    float alpha = 0.0f,
+    float min_val = 0.0f,
+    float max_val = 0.0f,
+    bool approximate = false) {
+  ActivationBuilder builder_(_fbb);
+  builder_.add_max_val(max_val);
+  builder_.add_min_val(min_val);
+  builder_.add_alpha(alpha);
+  builder_.add_approximate(approximate);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+struct ActivationGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ActivationGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4,
+    VT_ALPHA = 6
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  float alpha() const {
+    return GetField<float>(VT_ALPHA, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           VerifyField<float>(verifier, VT_ALPHA) &&
+           verifier.EndTable();
+  }
+};
+
+struct ActivationGradBuilder {
+  typedef ActivationGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(ActivationGrad::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  void add_alpha(float alpha) {
+    fbb_.AddElement<float>(ActivationGrad::VT_ALPHA, alpha, 0.0f);
+  }
+  explicit ActivationGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ActivationGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ActivationGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ActivationGrad> CreateActivationGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    float alpha = 0.0f) {
+  ActivationGradBuilder builder_(_fbb);
+  builder_.add_alpha(alpha);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+struct Adam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AdamBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_USE_LOCKING = 4,
+    VT_USE_NESTEROV = 6
+  };
+  bool use_locking() const {
+    return GetField<uint8_t>(VT_USE_LOCKING, 0) != 0;
+  }
+  bool use_nesterov() const {
+    return GetField<uint8_t>(VT_USE_NESTEROV, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_USE_LOCKING) &&
+           VerifyField<uint8_t>(verifier, VT_USE_NESTEROV) &&
+           verifier.EndTable();
+  }
+};
+
+struct AdamBuilder {
+  typedef Adam Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_use_locking(bool use_locking) {
+    fbb_.AddElement<uint8_t>(Adam::VT_USE_LOCKING, static_cast<uint8_t>(use_locking), 0);
+  }
+  void add_use_nesterov(bool use_nesterov) {
+    fbb_.AddElement<uint8_t>(Adam::VT_USE_NESTEROV, static_cast<uint8_t>(use_nesterov), 0);
+  }
+  explicit AdamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Adam> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Adam>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Adam> CreateAdam(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool use_locking = false,
+    bool use_nesterov = false) {
+  AdamBuilder builder_(_fbb);
+  builder_.add_use_nesterov(use_nesterov);
+  builder_.add_use_locking(use_locking);
+  return builder_.Finish();
+}
+
+struct AddFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AddFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct AddFusionBuilder {
+  typedef AddFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(AddFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit AddFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AddFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AddFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AddFusion> CreateAddFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  AddFusionBuilder builder_(_fbb);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+struct AdderFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AdderFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_KERNEL_SIZE = 6,
+    VT_STRIDE = 8,
+    VT_DILATION = 10,
+    VT_PAD_MODE = 12,
+    VT_PAD_LIST = 14,
+    VT_GROUP = 16,
+    VT_IN_CHANNEL = 18,
+    VT_OUT_CHANNEL = 20,
+    VT_ACTIVATION_TYPE = 22
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct AdderFusionBuilder {
+  typedef AdderFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(AdderFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(AdderFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(AdderFusion::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(AdderFusion::VT_DILATION, dilation);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(AdderFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(AdderFusion::VT_PAD_LIST, pad_list);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(AdderFusion::VT_GROUP, group, 0);
+  }
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(AdderFusion::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(AdderFusion::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(AdderFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit AdderFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AdderFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AdderFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AdderFusion> CreateAdderFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  AdderFusionBuilder builder_(_fbb);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_group(group);
+  builder_.add_pad_list(pad_list);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_format(format);
+  builder_.add_activation_type(activation_type);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<AdderFusion> CreateAdderFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad_list = nullptr,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  return mindspore::schema::CreateAdderFusion(
+      _fbb,
+      format,
+      kernel_size__,
+      stride__,
+      dilation__,
+      pad_mode,
+      pad_list__,
+      group,
+      in_channel,
+      out_channel,
+      activation_type);
+}
+
+struct AddGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AddGradBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct AddGradBuilder {
+  typedef AddGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AddGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AddGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AddGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AddGrad> CreateAddGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AddGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct AddN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AddNBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct AddNBuilder {
+  typedef AddN Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AddNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AddN> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AddN>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AddN> CreateAddN(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AddNBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct All FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AllBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KEEP_DIMS = 4
+  };
+  int64_t keep_dims() const {
+    return GetField<int64_t>(VT_KEEP_DIMS, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_KEEP_DIMS) &&
+           verifier.EndTable();
+  }
+};
+
+struct AllBuilder {
+  typedef All Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_keep_dims(int64_t keep_dims) {
+    fbb_.AddElement<int64_t>(All::VT_KEEP_DIMS, keep_dims, 0);
+  }
+  explicit AllBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<All> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<All>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<All> CreateAll(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t keep_dims = 0) {
+  AllBuilder builder_(_fbb);
+  builder_.add_keep_dims(keep_dims);
+  return builder_.Finish();
+}
+
+struct ApplyMomentum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ApplyMomentumBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_USE_NESTEROV = 4,
+    VT_USE_LOCKING = 6,
+    VT_GRADIENT_SCALE = 8
+  };
+  bool use_nesterov() const {
+    return GetField<uint8_t>(VT_USE_NESTEROV, 0) != 0;
+  }
+  bool use_locking() const {
+    return GetField<uint8_t>(VT_USE_LOCKING, 0) != 0;
+  }
+  float gradient_scale() const {
+    return GetField<float>(VT_GRADIENT_SCALE, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_USE_NESTEROV) &&
+           VerifyField<uint8_t>(verifier, VT_USE_LOCKING) &&
+           VerifyField<float>(verifier, VT_GRADIENT_SCALE) &&
+           verifier.EndTable();
+  }
+};
+
+struct ApplyMomentumBuilder {
+  typedef ApplyMomentum Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_use_nesterov(bool use_nesterov) {
+    fbb_.AddElement<uint8_t>(ApplyMomentum::VT_USE_NESTEROV, static_cast<uint8_t>(use_nesterov), 0);
+  }
+  void add_use_locking(bool use_locking) {
+    fbb_.AddElement<uint8_t>(ApplyMomentum::VT_USE_LOCKING, static_cast<uint8_t>(use_locking), 0);
+  }
+  void add_gradient_scale(float gradient_scale) {
+    fbb_.AddElement<float>(ApplyMomentum::VT_GRADIENT_SCALE, gradient_scale, 0.0f);
+  }
+  explicit ApplyMomentumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ApplyMomentum> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ApplyMomentum>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ApplyMomentum> CreateApplyMomentum(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool use_nesterov = false,
+    bool use_locking = false,
+    float gradient_scale = 0.0f) {
+  ApplyMomentumBuilder builder_(_fbb);
+  builder_.add_gradient_scale(gradient_scale);
+  builder_.add_use_locking(use_locking);
+  builder_.add_use_nesterov(use_nesterov);
+  return builder_.Finish();
+}
+
+struct ArgMaxFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ArgMaxFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4,
+    VT_TOP_K = 6,
+    VT_KEEP_DIMS = 8,
+    VT_OUT_MAX_VALUE = 10
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  int64_t top_k() const {
+    return GetField<int64_t>(VT_TOP_K, 1LL);
+  }
+  bool keep_dims() const {
+    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
+  }
+  bool out_max_value() const {
+    return GetField<uint8_t>(VT_OUT_MAX_VALUE, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_TOP_K) &&
+           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
+           VerifyField<uint8_t>(verifier, VT_OUT_MAX_VALUE) &&
+           verifier.EndTable();
+  }
+};
+
+struct ArgMaxFusionBuilder {
+  typedef ArgMaxFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(ArgMaxFusion::VT_AXIS, axis, 0);
+  }
+  void add_top_k(int64_t top_k) {
+    fbb_.AddElement<int64_t>(ArgMaxFusion::VT_TOP_K, top_k, 1LL);
+  }
+  void add_keep_dims(bool keep_dims) {
+    fbb_.AddElement<uint8_t>(ArgMaxFusion::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
+  }
+  void add_out_max_value(bool out_max_value) {
+    fbb_.AddElement<uint8_t>(ArgMaxFusion::VT_OUT_MAX_VALUE, static_cast<uint8_t>(out_max_value), 0);
+  }
+  explicit ArgMaxFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ArgMaxFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ArgMaxFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ArgMaxFusion> CreateArgMaxFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0,
+    int64_t top_k = 1LL,
+    bool keep_dims = false,
+    bool out_max_value = false) {
+  ArgMaxFusionBuilder builder_(_fbb);
+  builder_.add_top_k(top_k);
+  builder_.add_axis(axis);
+  builder_.add_out_max_value(out_max_value);
+  builder_.add_keep_dims(keep_dims);
+  return builder_.Finish();
+}
+
+struct ArgMinFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ArgMinFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4,
+    VT_TOP_K = 6,
+    VT_KEEP_DIMS = 8,
+    VT_OUT_MAX_VALUE = 10
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  int64_t top_k() const {
+    return GetField<int64_t>(VT_TOP_K, 0);
+  }
+  bool keep_dims() const {
+    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
+  }
+  bool out_max_value() const {
+    return GetField<uint8_t>(VT_OUT_MAX_VALUE, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_TOP_K) &&
+           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
+           VerifyField<uint8_t>(verifier, VT_OUT_MAX_VALUE) &&
+           verifier.EndTable();
+  }
+};
+
+struct ArgMinFusionBuilder {
+  typedef ArgMinFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(ArgMinFusion::VT_AXIS, axis, 0);
+  }
+  void add_top_k(int64_t top_k) {
+    fbb_.AddElement<int64_t>(ArgMinFusion::VT_TOP_K, top_k, 0);
+  }
+  void add_keep_dims(bool keep_dims) {
+    fbb_.AddElement<uint8_t>(ArgMinFusion::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
+  }
+  void add_out_max_value(bool out_max_value) {
+    fbb_.AddElement<uint8_t>(ArgMinFusion::VT_OUT_MAX_VALUE, static_cast<uint8_t>(out_max_value), 0);
+  }
+  explicit ArgMinFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ArgMinFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ArgMinFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ArgMinFusion> CreateArgMinFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0,
+    int64_t top_k = 0,
+    bool keep_dims = false,
+    bool out_max_value = false) {
+  ArgMinFusionBuilder builder_(_fbb);
+  builder_.add_top_k(top_k);
+  builder_.add_axis(axis);
+  builder_.add_out_max_value(out_max_value);
+  builder_.add_keep_dims(keep_dims);
+  return builder_.Finish();
+}
+
+struct Assert FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AssertBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SUMMARIZE = 4
+  };
+  int64_t summarize() const {
+    return GetField<int64_t>(VT_SUMMARIZE, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SUMMARIZE) &&
+           verifier.EndTable();
+  }
+};
+
+struct AssertBuilder {
+  typedef Assert Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_summarize(int64_t summarize) {
+    fbb_.AddElement<int64_t>(Assert::VT_SUMMARIZE, summarize, 0);
+  }
+  explicit AssertBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Assert> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Assert>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Assert> CreateAssert(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t summarize = 0) {
+  AssertBuilder builder_(_fbb);
+  builder_.add_summarize(summarize);
+  return builder_.Finish();
+}
+
+struct Assign FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AssignBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct AssignBuilder {
+  typedef Assign Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AssignBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Assign> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Assign>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Assign> CreateAssign(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AssignBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct AssignAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AssignAddBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct AssignAddBuilder {
+  typedef AssignAdd Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AssignAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AssignAdd> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AssignAdd>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AssignAdd> CreateAssignAdd(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AssignAddBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct AudioSpectrogram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AudioSpectrogramBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_WINDOW_SIZE = 4,
+    VT_STRIDE = 6,
+    VT_MAG_SQUARE = 8
+  };
+  int64_t window_size() const {
+    return GetField<int64_t>(VT_WINDOW_SIZE, 0);
+  }
+  int64_t stride() const {
+    return GetField<int64_t>(VT_STRIDE, 0);
+  }
+  bool mag_square() const {
+    return GetField<uint8_t>(VT_MAG_SQUARE, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_WINDOW_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_STRIDE) &&
+           VerifyField<uint8_t>(verifier, VT_MAG_SQUARE) &&
+           verifier.EndTable();
+  }
+};
+
+struct AudioSpectrogramBuilder {
+  typedef AudioSpectrogram Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_window_size(int64_t window_size) {
+    fbb_.AddElement<int64_t>(AudioSpectrogram::VT_WINDOW_SIZE, window_size, 0);
+  }
+  void add_stride(int64_t stride) {
+    fbb_.AddElement<int64_t>(AudioSpectrogram::VT_STRIDE, stride, 0);
+  }
+  void add_mag_square(bool mag_square) {
+    fbb_.AddElement<uint8_t>(AudioSpectrogram::VT_MAG_SQUARE, static_cast<uint8_t>(mag_square), 0);
+  }
+  explicit AudioSpectrogramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AudioSpectrogram> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AudioSpectrogram>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AudioSpectrogram> CreateAudioSpectrogram(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t window_size = 0,
+    int64_t stride = 0,
+    bool mag_square = false) {
+  AudioSpectrogramBuilder builder_(_fbb);
+  builder_.add_stride(stride);
+  builder_.add_window_size(window_size);
+  builder_.add_mag_square(mag_square);
+  return builder_.Finish();
+}
+
+struct AvgPoolFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AvgPoolFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KERNEL_SIZE = 4,
+    VT_STRIDES = 6,
+    VT_PAD = 8,
+    VT_PAD_MODE = 10,
+    VT_ROUND_MODE = 12,
+    VT_FORMAT = 14,
+    VT_GLOBAL = 16,
+    VT_ACTIVATION_TYPE = 18
+  };
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *strides() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
+  }
+  const flatbuffers::Vector<int64_t> *pad() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  mindspore::schema::RoundMode round_mode() const {
+    return static_cast<mindspore::schema::RoundMode>(GetField<int8_t>(VT_ROUND_MODE, 0));
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool global() const {
+    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDES) &&
+           verifier.VerifyVector(strides()) &&
+           VerifyOffset(verifier, VT_PAD) &&
+           verifier.VerifyVector(pad()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyField<int8_t>(verifier, VT_ROUND_MODE) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct AvgPoolFusionBuilder {
+  typedef AvgPoolFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(AvgPoolFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
+    fbb_.AddOffset(AvgPoolFusion::VT_STRIDES, strides);
+  }
+  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
+    fbb_.AddOffset(AvgPoolFusion::VT_PAD, pad);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(AvgPoolFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_round_mode(mindspore::schema::RoundMode round_mode) {
+    fbb_.AddElement<int8_t>(AvgPoolFusion::VT_ROUND_MODE, static_cast<int8_t>(round_mode), 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(AvgPoolFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_global(bool global) {
+    fbb_.AddElement<uint8_t>(AvgPoolFusion::VT_GLOBAL, static_cast<uint8_t>(global), 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(AvgPoolFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit AvgPoolFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AvgPoolFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AvgPoolFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AvgPoolFusion> CreateAvgPoolFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    bool global = false,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  AvgPoolFusionBuilder builder_(_fbb);
+  builder_.add_format(format);
+  builder_.add_pad(pad);
+  builder_.add_strides(strides);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_activation_type(activation_type);
+  builder_.add_global(global);
+  builder_.add_round_mode(round_mode);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<AvgPoolFusion> CreateAvgPoolFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *strides = nullptr,
+    const std::vector<int64_t> *pad = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    bool global = false,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
+  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
+  return mindspore::schema::CreateAvgPoolFusion(
+      _fbb,
+      kernel_size__,
+      strides__,
+      pad__,
+      pad_mode,
+      round_mode,
+      format,
+      global,
+      activation_type);
+}
+
+struct AvgPoolGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AvgPoolGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KERNEL_SIZE = 4,
+    VT_STRIDES = 6,
+    VT_PAD_MODE = 8,
+    VT_FORMAT = 10
+  };
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *strides() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDES) &&
+           verifier.VerifyVector(strides()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           verifier.EndTable();
+  }
+};
+
+struct AvgPoolGradBuilder {
+  typedef AvgPoolGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(AvgPoolGrad::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
+    fbb_.AddOffset(AvgPoolGrad::VT_STRIDES, strides);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(AvgPoolGrad::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(AvgPoolGrad::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  explicit AvgPoolGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AvgPoolGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AvgPoolGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AvgPoolGrad> CreateAvgPoolGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  AvgPoolGradBuilder builder_(_fbb);
+  builder_.add_format(format);
+  builder_.add_strides(strides);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<AvgPoolGrad> CreateAvgPoolGradDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *strides = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
+  return mindspore::schema::CreateAvgPoolGrad(
+      _fbb,
+      kernel_size__,
+      strides__,
+      pad_mode,
+      format);
+}
+
+struct BatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BatchNormBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_EPSILON = 4,
+    VT_FORMAT = 6,
+    VT_IS_TRAINING = 8
+  };
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.0f);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool is_training() const {
+    return GetField<uint8_t>(VT_IS_TRAINING, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<uint8_t>(verifier, VT_IS_TRAINING) &&
+           verifier.EndTable();
+  }
+};
+
+struct BatchNormBuilder {
+  typedef BatchNorm Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(BatchNorm::VT_EPSILON, epsilon, 0.0f);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(BatchNorm::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_is_training(bool is_training) {
+    fbb_.AddElement<uint8_t>(BatchNorm::VT_IS_TRAINING, static_cast<uint8_t>(is_training), 0);
+  }
+  explicit BatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BatchNorm> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BatchNorm>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float epsilon = 0.0f,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    bool is_training = false) {
+  BatchNormBuilder builder_(_fbb);
+  builder_.add_format(format);
+  builder_.add_epsilon(epsilon);
+  builder_.add_is_training(is_training);
+  return builder_.Finish();
+}
+
+struct BatchNormGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BatchNormGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_EPSILON = 4,
+    VT_IS_TRAINING = 6
+  };
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.0f);
+  }
+  bool is_training() const {
+    return GetField<uint8_t>(VT_IS_TRAINING, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<uint8_t>(verifier, VT_IS_TRAINING) &&
+           verifier.EndTable();
+  }
+};
+
+struct BatchNormGradBuilder {
+  typedef BatchNormGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(BatchNormGrad::VT_EPSILON, epsilon, 0.0f);
+  }
+  void add_is_training(bool is_training) {
+    fbb_.AddElement<uint8_t>(BatchNormGrad::VT_IS_TRAINING, static_cast<uint8_t>(is_training), 0);
+  }
+  explicit BatchNormGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BatchNormGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BatchNormGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BatchNormGrad> CreateBatchNormGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float epsilon = 0.0f,
+    bool is_training = false) {
+  BatchNormGradBuilder builder_(_fbb);
+  builder_.add_epsilon(epsilon);
+  builder_.add_is_training(is_training);
+  return builder_.Finish();
+}
+
+struct BatchToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BatchToSpaceBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BLOCK_SIZE = 4,
+    VT_CROPS = 6
+  };
+  const flatbuffers::Vector<int64_t> *block_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SIZE);
+  }
+  const mindspore::schema::Vec2D *crops() const {
+    return GetPointer<const mindspore::schema::Vec2D *>(VT_CROPS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_BLOCK_SIZE) &&
+           verifier.VerifyVector(block_size()) &&
+           VerifyOffset(verifier, VT_CROPS) &&
+           verifier.VerifyTable(crops()) &&
+           verifier.EndTable();
+  }
+};
+
+struct BatchToSpaceBuilder {
+  typedef BatchToSpace Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_block_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size) {
+    fbb_.AddOffset(BatchToSpace::VT_BLOCK_SIZE, block_size);
+  }
+  void add_crops(flatbuffers::Offset<mindspore::schema::Vec2D> crops) {
+    fbb_.AddOffset(BatchToSpace::VT_CROPS, crops);
+  }
+  explicit BatchToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BatchToSpace> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BatchToSpace>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size = 0,
+    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
+  BatchToSpaceBuilder builder_(_fbb);
+  builder_.add_crops(crops);
+  builder_.add_block_size(block_size);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpaceDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *block_size = nullptr,
+    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
+  auto block_size__ = block_size ? _fbb.CreateVector<int64_t>(*block_size) : 0;
+  return mindspore::schema::CreateBatchToSpace(
+      _fbb,
+      block_size__,
+      crops);
+}
+
+struct BatchToSpaceND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BatchToSpaceNDBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BLOCK_SHAPE = 4,
+    VT_CROPS = 6
+  };
+  const flatbuffers::Vector<int64_t> *block_shape() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SHAPE);
+  }
+  const mindspore::schema::Vec2D *crops() const {
+    return GetPointer<const mindspore::schema::Vec2D *>(VT_CROPS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_BLOCK_SHAPE) &&
+           verifier.VerifyVector(block_shape()) &&
+           VerifyOffset(verifier, VT_CROPS) &&
+           verifier.VerifyTable(crops()) &&
+           verifier.EndTable();
+  }
+};
+
+struct BatchToSpaceNDBuilder {
+  typedef BatchToSpaceND Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_block_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape) {
+    fbb_.AddOffset(BatchToSpaceND::VT_BLOCK_SHAPE, block_shape);
+  }
+  void add_crops(flatbuffers::Offset<mindspore::schema::Vec2D> crops) {
+    fbb_.AddOffset(BatchToSpaceND::VT_CROPS, crops);
+  }
+  explicit BatchToSpaceNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BatchToSpaceND> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BatchToSpaceND>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceND(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape = 0,
+    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
+  BatchToSpaceNDBuilder builder_(_fbb);
+  builder_.add_crops(crops);
+  builder_.add_block_shape(block_shape);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceNDDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *block_shape = nullptr,
+    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
+  auto block_shape__ = block_shape ? _fbb.CreateVector<int64_t>(*block_shape) : 0;
+  return mindspore::schema::CreateBatchToSpaceND(
+      _fbb,
+      block_shape__,
+      crops);
+}
+
+struct BiasAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BiasAddBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           verifier.EndTable();
+  }
+};
+
+struct BiasAddBuilder {
+  typedef BiasAdd Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(BiasAdd::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  explicit BiasAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BiasAdd> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BiasAdd>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BiasAdd> CreateBiasAdd(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  BiasAddBuilder builder_(_fbb);
+  builder_.add_format(format);
+  return builder_.Finish();
+}
+
+struct BinaryCrossEntropy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BinaryCrossEntropyBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_REDUCTION = 4
+  };
+  mindspore::schema::Reduction reduction() const {
+    return static_cast<mindspore::schema::Reduction>(GetField<int8_t>(VT_REDUCTION, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_REDUCTION) &&
+           verifier.EndTable();
+  }
+};
+
+struct BinaryCrossEntropyBuilder {
+  typedef BinaryCrossEntropy Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_reduction(mindspore::schema::Reduction reduction) {
+    fbb_.AddElement<int8_t>(BinaryCrossEntropy::VT_REDUCTION, static_cast<int8_t>(reduction), 0);
+  }
+  explicit BinaryCrossEntropyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BinaryCrossEntropy> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BinaryCrossEntropy>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BinaryCrossEntropy> CreateBinaryCrossEntropy(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Reduction reduction = mindspore::schema::Reduction_REDUCTION_SUM) {
+  BinaryCrossEntropyBuilder builder_(_fbb);
+  builder_.add_reduction(reduction);
+  return builder_.Finish();
+}
+
+struct BinaryCrossEntropyGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BinaryCrossEntropyGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_REDUCTION = 4
+  };
+  mindspore::schema::Reduction reduction() const {
+    return static_cast<mindspore::schema::Reduction>(GetField<int8_t>(VT_REDUCTION, 1));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_REDUCTION) &&
+           verifier.EndTable();
+  }
+};
+
+struct BinaryCrossEntropyGradBuilder {
+  typedef BinaryCrossEntropyGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_reduction(mindspore::schema::Reduction reduction) {
+    fbb_.AddElement<int8_t>(BinaryCrossEntropyGrad::VT_REDUCTION, static_cast<int8_t>(reduction), 1);
+  }
+  explicit BinaryCrossEntropyGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BinaryCrossEntropyGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BinaryCrossEntropyGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BinaryCrossEntropyGrad> CreateBinaryCrossEntropyGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Reduction reduction = mindspore::schema::Reduction_MEAN) {
+  BinaryCrossEntropyGradBuilder builder_(_fbb);
+  builder_.add_reduction(reduction);
+  return builder_.Finish();
+}
+
+struct BiasAddGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BiasAddGradBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct BiasAddGradBuilder {
+  typedef BiasAddGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit BiasAddGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BiasAddGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BiasAddGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BiasAddGrad> CreateBiasAddGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  BiasAddGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct BroadcastTo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef BroadcastToBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SHAPE = 4
+  };
+  const flatbuffers::Vector<int64_t> *shape() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SHAPE);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_SHAPE) &&
+           verifier.VerifyVector(shape()) &&
+           verifier.EndTable();
+  }
+};
+
+struct BroadcastToBuilder {
+  typedef BroadcastTo Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape) {
+    fbb_.AddOffset(BroadcastTo::VT_SHAPE, shape);
+  }
+  explicit BroadcastToBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<BroadcastTo> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<BroadcastTo>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape = 0) {
+  BroadcastToBuilder builder_(_fbb);
+  builder_.add_shape(shape);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<BroadcastTo> CreateBroadcastToDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *shape = nullptr) {
+  auto shape__ = shape ? _fbb.CreateVector<int64_t>(*shape) : 0;
+  return mindspore::schema::CreateBroadcastTo(
+      _fbb,
+      shape__);
+}
+
+struct Cast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CastBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct CastBuilder {
+  typedef Cast Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit CastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Cast> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Cast>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Cast> CreateCast(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  CastBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Ceil FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CeilBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct CeilBuilder {
+  typedef Ceil Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit CeilBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Ceil> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Ceil>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Ceil> CreateCeil(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  CeilBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Clip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ClipBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_MAX = 4,
+    VT_MIN = 6
+  };
+  float max() const {
+    return GetField<float>(VT_MAX, 0.0f);
+  }
+  float min() const {
+    return GetField<float>(VT_MIN, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_MAX) &&
+           VerifyField<float>(verifier, VT_MIN) &&
+           verifier.EndTable();
+  }
+};
+
+struct ClipBuilder {
+  typedef Clip Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_max(float max) {
+    fbb_.AddElement<float>(Clip::VT_MAX, max, 0.0f);
+  }
+  void add_min(float min) {
+    fbb_.AddElement<float>(Clip::VT_MIN, min, 0.0f);
+  }
+  explicit ClipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Clip> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Clip>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Clip> CreateClip(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float max = 0.0f,
+    float min = 0.0f) {
+  ClipBuilder builder_(_fbb);
+  builder_.add_min(min);
+  builder_.add_max(max);
+  return builder_.Finish();
+}
+
+struct Concat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ConcatBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+};
+
+struct ConcatBuilder {
+  typedef Concat Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(Concat::VT_AXIS, axis, 0);
+  }
+  explicit ConcatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Concat> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Concat>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Concat> CreateConcat(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0) {
+  ConcatBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+struct Attention FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AttentionBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct AttentionBuilder {
+  typedef Attention Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AttentionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Attention> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Attention>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Attention> CreateAttention(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AttentionBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Conv2DBackpropFilterFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef Conv2DBackpropFilterFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_KERNEL_SIZE = 6,
+    VT_STRIDE = 8,
+    VT_DILATION = 10,
+    VT_PAD_MODE = 12,
+    VT_PAD_LIST = 14,
+    VT_MODE = 16,
+    VT_GROUP = 18,
+    VT_IN_CHANNEL = 20,
+    VT_OUT_CHANNEL = 22,
+    VT_ACTIVATION_TYPE = 24
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  int64_t mode() const {
+    return GetField<int64_t>(VT_MODE, 0);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyField<int64_t>(verifier, VT_MODE) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct Conv2DBackpropFilterFusionBuilder {
+  typedef Conv2DBackpropFilterFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(Conv2DBackpropFilterFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_DILATION, dilation);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(Conv2DBackpropFilterFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_PAD_LIST, pad_list);
+  }
+  void add_mode(int64_t mode) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_MODE, mode, 0);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_GROUP, group, 0);
+  }
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(Conv2DBackpropFilterFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit Conv2DBackpropFilterFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Conv2DBackpropFilterFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Conv2DBackpropFilterFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Conv2DBackpropFilterFusion> CreateConv2DBackpropFilterFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  Conv2DBackpropFilterFusionBuilder builder_(_fbb);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_group(group);
+  builder_.add_mode(mode);
+  builder_.add_pad_list(pad_list);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_format(format);
+  builder_.add_activation_type(activation_type);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Conv2DBackpropFilterFusion> CreateConv2DBackpropFilterFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad_list = nullptr,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  return mindspore::schema::CreateConv2DBackpropFilterFusion(
+      _fbb,
+      format,
+      kernel_size__,
+      stride__,
+      dilation__,
+      pad_mode,
+      pad_list__,
+      mode,
+      group,
+      in_channel,
+      out_channel,
+      activation_type);
+}
+
+struct Conv2DBackpropInputFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef Conv2DBackpropInputFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_KERNEL_SIZE = 6,
+    VT_STRIDE = 8,
+    VT_DILATION = 10,
+    VT_PAD_MODE = 12,
+    VT_PAD = 14,
+    VT_PAD_LIST = 16,
+    VT_MODE = 18,
+    VT_GROUP = 20,
+    VT_IN_CHANNEL = 22,
+    VT_OUT_CHANNEL = 24,
+    VT_ACTIVATION_TYPE = 26
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  const flatbuffers::Vector<int64_t> *pad() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  int64_t mode() const {
+    return GetField<int64_t>(VT_MODE, 0);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD) &&
+           verifier.VerifyVector(pad()) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyField<int64_t>(verifier, VT_MODE) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct Conv2DBackpropInputFusionBuilder {
+  typedef Conv2DBackpropInputFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(Conv2DBackpropInputFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_DILATION, dilation);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(Conv2DBackpropInputFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
+    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_PAD, pad);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_PAD_LIST, pad_list);
+  }
+  void add_mode(int64_t mode) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_MODE, mode, 0);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_GROUP, group, 0);
+  }
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(Conv2DBackpropInputFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit Conv2DBackpropInputFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Conv2DBackpropInputFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Conv2DBackpropInputFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Conv2DBackpropInputFusion> CreateConv2DBackpropInputFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  Conv2DBackpropInputFusionBuilder builder_(_fbb);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_group(group);
+  builder_.add_mode(mode);
+  builder_.add_pad_list(pad_list);
+  builder_.add_pad(pad);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_format(format);
+  builder_.add_activation_type(activation_type);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Conv2DBackpropInputFusion> CreateConv2DBackpropInputFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad = nullptr,
+    const std::vector<int64_t> *pad_list = nullptr,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  return mindspore::schema::CreateConv2DBackpropInputFusion(
+      _fbb,
+      format,
+      kernel_size__,
+      stride__,
+      dilation__,
+      pad_mode,
+      pad__,
+      pad_list__,
+      mode,
+      group,
+      in_channel,
+      out_channel,
+      activation_type);
+}
+
+struct Conv2DFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef Conv2DFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_KERNEL_SIZE = 6,
+    VT_STRIDE = 8,
+    VT_DILATION = 10,
+    VT_PAD_MODE = 12,
+    VT_PAD_LIST = 14,
+    VT_MODE = 16,
+    VT_GROUP = 18,
+    VT_IN_CHANNEL = 20,
+    VT_OUT_CHANNEL = 22,
+    VT_ACTIVATION_TYPE = 24
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  int64_t mode() const {
+    return GetField<int64_t>(VT_MODE, 0);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyField<int64_t>(verifier, VT_MODE) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct Conv2DFusionBuilder {
+  typedef Conv2DFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(Conv2DFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(Conv2DFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(Conv2DFusion::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(Conv2DFusion::VT_DILATION, dilation);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(Conv2DFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(Conv2DFusion::VT_PAD_LIST, pad_list);
+  }
+  void add_mode(int64_t mode) {
+    fbb_.AddElement<int64_t>(Conv2DFusion::VT_MODE, mode, 0);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(Conv2DFusion::VT_GROUP, group, 0);
+  }
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(Conv2DFusion::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(Conv2DFusion::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(Conv2DFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit Conv2DFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Conv2DFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Conv2DFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Conv2DFusion> CreateConv2DFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  Conv2DFusionBuilder builder_(_fbb);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_group(group);
+  builder_.add_mode(mode);
+  builder_.add_pad_list(pad_list);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_format(format);
+  builder_.add_activation_type(activation_type);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Conv2DFusion> CreateConv2DFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad_list = nullptr,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  return mindspore::schema::CreateConv2DFusion(
+      _fbb,
+      format,
+      kernel_size__,
+      stride__,
+      dilation__,
+      pad_mode,
+      pad_list__,
+      mode,
+      group,
+      in_channel,
+      out_channel,
+      activation_type);
+}
+
+struct Conv2dTransposeFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef Conv2dTransposeFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_KERNEL_SIZE = 6,
+    VT_STRIDE = 8,
+    VT_DILATION = 10,
+    VT_PAD_MODE = 12,
+    VT_PAD = 14,
+    VT_PAD_LIST = 16,
+    VT_MODE = 18,
+    VT_GROUP = 20,
+    VT_IN_CHANNEL = 22,
+    VT_OUT_CHANNEL = 24,
+    VT_ACTIVATION_TYPE = 26,
+    VT_OUTPUT_PADDINGS = 28
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  const flatbuffers::Vector<int64_t> *pad() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  int64_t mode() const {
+    return GetField<int64_t>(VT_MODE, 0);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  const flatbuffers::Vector<int64_t> *output_paddings() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OUTPUT_PADDINGS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD) &&
+           verifier.VerifyVector(pad()) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyField<int64_t>(verifier, VT_MODE) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           VerifyOffset(verifier, VT_OUTPUT_PADDINGS) &&
+           verifier.VerifyVector(output_paddings()) &&
+           verifier.EndTable();
+  }
+};
+
+struct Conv2dTransposeFusionBuilder {
+  typedef Conv2dTransposeFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(Conv2dTransposeFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(Conv2dTransposeFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(Conv2dTransposeFusion::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(Conv2dTransposeFusion::VT_DILATION, dilation);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(Conv2dTransposeFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
+    fbb_.AddOffset(Conv2dTransposeFusion::VT_PAD, pad);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(Conv2dTransposeFusion::VT_PAD_LIST, pad_list);
+  }
+  void add_mode(int64_t mode) {
+    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_MODE, mode, 0);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_GROUP, group, 0);
+  }
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(Conv2dTransposeFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  void add_output_paddings(flatbuffers::Offset<flatbuffers::Vector<int64_t>> output_paddings) {
+    fbb_.AddOffset(Conv2dTransposeFusion::VT_OUTPUT_PADDINGS, output_paddings);
+  }
+  explicit Conv2dTransposeFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Conv2dTransposeFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Conv2dTransposeFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Conv2dTransposeFusion> CreateConv2dTransposeFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> output_paddings = 0) {
+  Conv2dTransposeFusionBuilder builder_(_fbb);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_group(group);
+  builder_.add_mode(mode);
+  builder_.add_output_paddings(output_paddings);
+  builder_.add_pad_list(pad_list);
+  builder_.add_pad(pad);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_format(format);
+  builder_.add_activation_type(activation_type);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Conv2dTransposeFusion> CreateConv2dTransposeFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad = nullptr,
+    const std::vector<int64_t> *pad_list = nullptr,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    const std::vector<int64_t> *output_paddings = nullptr) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  auto output_paddings__ = output_paddings ? _fbb.CreateVector<int64_t>(*output_paddings) : 0;
+  return mindspore::schema::CreateConv2dTransposeFusion(
+      _fbb,
+      format,
+      kernel_size__,
+      stride__,
+      dilation__,
+      pad_mode,
+      pad__,
+      pad_list__,
+      mode,
+      group,
+      in_channel,
+      out_channel,
+      activation_type,
+      output_paddings__);
+}
+
+struct Cos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CosBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct CosBuilder {
+  typedef Cos Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit CosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Cos> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Cos>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Cos> CreateCos(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  CosBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct ConstantOfShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ConstantOfShapeBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DATA_TYPE = 4,
+    VT_VALUE = 6
+  };
+  int64_t data_type() const {
+    return GetField<int64_t>(VT_DATA_TYPE, 0);
+  }
+  const flatbuffers::Vector<float> *value() const {
+    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUE);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_DATA_TYPE) &&
+           VerifyOffset(verifier, VT_VALUE) &&
+           verifier.VerifyVector(value()) &&
+           verifier.EndTable();
+  }
+};
+
+struct ConstantOfShapeBuilder {
+  typedef ConstantOfShape Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_data_type(int64_t data_type) {
+    fbb_.AddElement<int64_t>(ConstantOfShape::VT_DATA_TYPE, data_type, 0);
+  }
+  void add_value(flatbuffers::Offset<flatbuffers::Vector<float>> value) {
+    fbb_.AddOffset(ConstantOfShape::VT_VALUE, value);
+  }
+  explicit ConstantOfShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ConstantOfShape> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ConstantOfShape>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShape(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t data_type = 0,
+    flatbuffers::Offset<flatbuffers::Vector<float>> value = 0) {
+  ConstantOfShapeBuilder builder_(_fbb);
+  builder_.add_data_type(data_type);
+  builder_.add_value(value);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShapeDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t data_type = 0,
+    const std::vector<float> *value = nullptr) {
+  auto value__ = value ? _fbb.CreateVector<float>(*value) : 0;
+  return mindspore::schema::CreateConstantOfShape(
+      _fbb,
+      data_type,
+      value__);
+}
+
+struct Crop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CropBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4,
+    VT_OFFSETS = 6
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  const flatbuffers::Vector<int64_t> *offsets() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OFFSETS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyOffset(verifier, VT_OFFSETS) &&
+           verifier.VerifyVector(offsets()) &&
+           verifier.EndTable();
+  }
+};
+
+struct CropBuilder {
+  typedef Crop Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(Crop::VT_AXIS, axis, 0);
+  }
+  void add_offsets(flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets) {
+    fbb_.AddOffset(Crop::VT_OFFSETS, offsets);
+  }
+  explicit CropBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Crop> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Crop>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Crop> CreateCrop(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets = 0) {
+  CropBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  builder_.add_offsets(offsets);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Crop> CreateCropDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0,
+    const std::vector<int64_t> *offsets = nullptr) {
+  auto offsets__ = offsets ? _fbb.CreateVector<int64_t>(*offsets) : 0;
+  return mindspore::schema::CreateCrop(
+      _fbb,
+      axis,
+      offsets__);
+}
+
+struct CustomExtractFeatures FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CustomExtractFeaturesBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct CustomExtractFeaturesBuilder {
+  typedef CustomExtractFeatures Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit CustomExtractFeaturesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<CustomExtractFeatures> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<CustomExtractFeatures>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<CustomExtractFeatures> CreateCustomExtractFeatures(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  CustomExtractFeaturesBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct CustomNormalize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CustomNormalizeBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct CustomNormalizeBuilder {
+  typedef CustomNormalize Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit CustomNormalizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<CustomNormalize> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<CustomNormalize>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<CustomNormalize> CreateCustomNormalize(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  CustomNormalizeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct CustomPredict FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CustomPredictBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_OUTPUT_NUM = 4,
+    VT_WEIGHT_THRESHOLD = 6
+  };
+  int64_t output_num() const {
+    return GetField<int64_t>(VT_OUTPUT_NUM, 0);
+  }
+  float weight_threshold() const {
+    return GetField<float>(VT_WEIGHT_THRESHOLD, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_OUTPUT_NUM) &&
+           VerifyField<float>(verifier, VT_WEIGHT_THRESHOLD) &&
+           verifier.EndTable();
+  }
+};
+
+struct CustomPredictBuilder {
+  typedef CustomPredict Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_output_num(int64_t output_num) {
+    fbb_.AddElement<int64_t>(CustomPredict::VT_OUTPUT_NUM, output_num, 0);
+  }
+  void add_weight_threshold(float weight_threshold) {
+    fbb_.AddElement<float>(CustomPredict::VT_WEIGHT_THRESHOLD, weight_threshold, 0.0f);
+  }
+  explicit CustomPredictBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<CustomPredict> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<CustomPredict>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<CustomPredict> CreateCustomPredict(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t output_num = 0,
+    float weight_threshold = 0.0f) {
+  CustomPredictBuilder builder_(_fbb);
+  builder_.add_output_num(output_num);
+  builder_.add_weight_threshold(weight_threshold);
+  return builder_.Finish();
+}
+
+struct DeConv2DGradFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DeConv2DGradFilterBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_IN_CHANNEL = 4,
+    VT_OUT_CHANNEL = 6,
+    VT_KERNEL_SIZE = 8,
+    VT_PAD_MODE = 10,
+    VT_PAD_LIST = 12,
+    VT_STRIDE = 14,
+    VT_DILATION = 16,
+    VT_GROUP = 18,
+    VT_FORMAT = 20,
+    VT_ACTIVATION_TYPE = 22
+  };
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct DeConv2DGradFilterBuilder {
+  typedef DeConv2DGradFilter Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(DeConv2DGradFilter::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(DeConv2DGradFilter::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(DeConv2DGradFilter::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(DeConv2DGradFilter::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(DeConv2DGradFilter::VT_PAD_LIST, pad_list);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(DeConv2DGradFilter::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(DeConv2DGradFilter::VT_DILATION, dilation);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(DeConv2DGradFilter::VT_GROUP, group, 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(DeConv2DGradFilter::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit DeConv2DGradFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DeConv2DGradFilter> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DeConv2DGradFilter>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilter(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    int64_t group = 0,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  DeConv2DGradFilterBuilder builder_(_fbb);
+  builder_.add_group(group);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_format(format);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_pad_list(pad_list);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_activation_type(activation_type);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilterDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad_list = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    int64_t group = 0,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  return mindspore::schema::CreateDeConv2DGradFilter(
+      _fbb,
+      in_channel,
+      out_channel,
+      kernel_size__,
+      pad_mode,
+      pad_list__,
+      stride__,
+      dilation__,
+      group,
+      format,
+      activation_type);
+}
+
+struct Depend FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DependBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct DependBuilder {
+  typedef Depend Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit DependBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Depend> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Depend>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Depend> CreateDepend(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  DependBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct DepthToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DepthToSpaceBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BLOCK_SIZE = 4,
+    VT_FORMAT = 6
+  };
+  int64_t block_size() const {
+    return GetField<int64_t>(VT_BLOCK_SIZE, 0);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_BLOCK_SIZE) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           verifier.EndTable();
+  }
+};
+
+struct DepthToSpaceBuilder {
+  typedef DepthToSpace Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_block_size(int64_t block_size) {
+    fbb_.AddElement<int64_t>(DepthToSpace::VT_BLOCK_SIZE, block_size, 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(DepthToSpace::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  explicit DepthToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DepthToSpace> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DepthToSpace>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t block_size = 0,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  DepthToSpaceBuilder builder_(_fbb);
+  builder_.add_block_size(block_size);
+  builder_.add_format(format);
+  return builder_.Finish();
+}
+
+struct DetectionPostProcess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DetectionPostProcessBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_INPUT_SIZE = 6,
+    VT_SCALE = 8,
+    VT_NMS_IOU_THRESHOLD = 10,
+    VT_NMS_SCORE_THRESHOLD = 12,
+    VT_MAX_DETECTIONS = 14,
+    VT_DETECTIONS_PER_CLASS = 16,
+    VT_MAX_CLASSES_PER_DETECTION = 18,
+    VT_NUM_CLASSES = 20,
+    VT_USE_REGULAR_NMS = 22,
+    VT_OUT_QUANTIZED = 24
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  int64_t input_size() const {
+    return GetField<int64_t>(VT_INPUT_SIZE, 0);
+  }
+  const flatbuffers::Vector<float> *scale() const {
+    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
+  }
+  float nms_iou_threshold() const {
+    return GetField<float>(VT_NMS_IOU_THRESHOLD, 0.0f);
+  }
+  float nms_score_threshold() const {
+    return GetField<float>(VT_NMS_SCORE_THRESHOLD, 0.0f);
+  }
+  int64_t max_detections() const {
+    return GetField<int64_t>(VT_MAX_DETECTIONS, 0);
+  }
+  int64_t detections_per_class() const {
+    return GetField<int64_t>(VT_DETECTIONS_PER_CLASS, 0);
+  }
+  int64_t max_classes_per_detection() const {
+    return GetField<int64_t>(VT_MAX_CLASSES_PER_DETECTION, 0);
+  }
+  int64_t num_classes() const {
+    return GetField<int64_t>(VT_NUM_CLASSES, 0);
+  }
+  bool use_regular_nms() const {
+    return GetField<uint8_t>(VT_USE_REGULAR_NMS, 0) != 0;
+  }
+  bool out_quantized() const {
+    return GetField<uint8_t>(VT_OUT_QUANTIZED, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
+           VerifyOffset(verifier, VT_SCALE) &&
+           verifier.VerifyVector(scale()) &&
+           VerifyField<float>(verifier, VT_NMS_IOU_THRESHOLD) &&
+           VerifyField<float>(verifier, VT_NMS_SCORE_THRESHOLD) &&
+           VerifyField<int64_t>(verifier, VT_MAX_DETECTIONS) &&
+           VerifyField<int64_t>(verifier, VT_DETECTIONS_PER_CLASS) &&
+           VerifyField<int64_t>(verifier, VT_MAX_CLASSES_PER_DETECTION) &&
+           VerifyField<int64_t>(verifier, VT_NUM_CLASSES) &&
+           VerifyField<uint8_t>(verifier, VT_USE_REGULAR_NMS) &&
+           VerifyField<uint8_t>(verifier, VT_OUT_QUANTIZED) &&
+           verifier.EndTable();
+  }
+};
+
+struct DetectionPostProcessBuilder {
+  typedef DetectionPostProcess Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(DetectionPostProcess::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_input_size(int64_t input_size) {
+    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_INPUT_SIZE, input_size, 0);
+  }
+  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
+    fbb_.AddOffset(DetectionPostProcess::VT_SCALE, scale);
+  }
+  void add_nms_iou_threshold(float nms_iou_threshold) {
+    fbb_.AddElement<float>(DetectionPostProcess::VT_NMS_IOU_THRESHOLD, nms_iou_threshold, 0.0f);
+  }
+  void add_nms_score_threshold(float nms_score_threshold) {
+    fbb_.AddElement<float>(DetectionPostProcess::VT_NMS_SCORE_THRESHOLD, nms_score_threshold, 0.0f);
+  }
+  void add_max_detections(int64_t max_detections) {
+    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAX_DETECTIONS, max_detections, 0);
+  }
+  void add_detections_per_class(int64_t detections_per_class) {
+    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_DETECTIONS_PER_CLASS, detections_per_class, 0);
+  }
+  void add_max_classes_per_detection(int64_t max_classes_per_detection) {
+    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAX_CLASSES_PER_DETECTION, max_classes_per_detection, 0);
+  }
+  void add_num_classes(int64_t num_classes) {
+    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_NUM_CLASSES, num_classes, 0);
+  }
+  void add_use_regular_nms(bool use_regular_nms) {
+    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_USE_REGULAR_NMS, static_cast<uint8_t>(use_regular_nms), 0);
+  }
+  void add_out_quantized(bool out_quantized) {
+    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_OUT_QUANTIZED, static_cast<uint8_t>(out_quantized), 0);
+  }
+  explicit DetectionPostProcessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DetectionPostProcess> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DetectionPostProcess>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    int64_t input_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
+    float nms_iou_threshold = 0.0f,
+    float nms_score_threshold = 0.0f,
+    int64_t max_detections = 0,
+    int64_t detections_per_class = 0,
+    int64_t max_classes_per_detection = 0,
+    int64_t num_classes = 0,
+    bool use_regular_nms = false,
+    bool out_quantized = false) {
+  DetectionPostProcessBuilder builder_(_fbb);
+  builder_.add_num_classes(num_classes);
+  builder_.add_max_classes_per_detection(max_classes_per_detection);
+  builder_.add_detections_per_class(detections_per_class);
+  builder_.add_max_detections(max_detections);
+  builder_.add_input_size(input_size);
+  builder_.add_nms_score_threshold(nms_score_threshold);
+  builder_.add_nms_iou_threshold(nms_iou_threshold);
+  builder_.add_scale(scale);
+  builder_.add_format(format);
+  builder_.add_out_quantized(out_quantized);
+  builder_.add_use_regular_nms(use_regular_nms);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcessDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    int64_t input_size = 0,
+    const std::vector<float> *scale = nullptr,
+    float nms_iou_threshold = 0.0f,
+    float nms_score_threshold = 0.0f,
+    int64_t max_detections = 0,
+    int64_t detections_per_class = 0,
+    int64_t max_classes_per_detection = 0,
+    int64_t num_classes = 0,
+    bool use_regular_nms = false,
+    bool out_quantized = false) {
+  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
+  return mindspore::schema::CreateDetectionPostProcess(
+      _fbb,
+      format,
+      input_size,
+      scale__,
+      nms_iou_threshold,
+      nms_score_threshold,
+      max_detections,
+      detections_per_class,
+      max_classes_per_detection,
+      num_classes,
+      use_regular_nms,
+      out_quantized);
+}
+
+struct DivFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DivFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct DivFusionBuilder {
+  typedef DivFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(DivFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit DivFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DivFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DivFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DivFusion> CreateDivFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  DivFusionBuilder builder_(_fbb);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+struct DivGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DivGradBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct DivGradBuilder {
+  typedef DivGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit DivGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DivGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DivGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DivGrad> CreateDivGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  DivGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Dropout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DropoutBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KEEP_PROB = 4
+  };
+  float keep_prob() const {
+    return GetField<float>(VT_KEEP_PROB, 0.5f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_KEEP_PROB) &&
+           verifier.EndTable();
+  }
+};
+
+struct DropoutBuilder {
+  typedef Dropout Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_keep_prob(float keep_prob) {
+    fbb_.AddElement<float>(Dropout::VT_KEEP_PROB, keep_prob, 0.5f);
+  }
+  explicit DropoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Dropout> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Dropout>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Dropout> CreateDropout(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float keep_prob = 0.5f) {
+  DropoutBuilder builder_(_fbb);
+  builder_.add_keep_prob(keep_prob);
+  return builder_.Finish();
+}
+
+struct DropoutGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DropoutGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KEEP_PROB = 4
+  };
+  float keep_prob() const {
+    return GetField<float>(VT_KEEP_PROB, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_KEEP_PROB) &&
+           verifier.EndTable();
+  }
+};
+
+struct DropoutGradBuilder {
+  typedef DropoutGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_keep_prob(float keep_prob) {
+    fbb_.AddElement<float>(DropoutGrad::VT_KEEP_PROB, keep_prob, 0.0f);
+  }
+  explicit DropoutGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DropoutGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DropoutGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DropoutGrad> CreateDropoutGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float keep_prob = 0.0f) {
+  DropoutGradBuilder builder_(_fbb);
+  builder_.add_keep_prob(keep_prob);
+  return builder_.Finish();
+}
+
+struct Elu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef EluBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ALPHA = 4
+  };
+  float alpha() const {
+    return GetField<float>(VT_ALPHA, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_ALPHA) &&
+           verifier.EndTable();
+  }
+};
+
+struct EluBuilder {
+  typedef Elu Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_alpha(float alpha) {
+    fbb_.AddElement<float>(Elu::VT_ALPHA, alpha, 0.0f);
+  }
+  explicit EluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Elu> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Elu>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Elu> CreateElu(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float alpha = 0.0f) {
+  EluBuilder builder_(_fbb);
+  builder_.add_alpha(alpha);
+  return builder_.Finish();
+}
+
+struct Eltwise FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef EltwiseBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_MODE = 4
+  };
+  mindspore::schema::EltwiseMode mode() const {
+    return static_cast<mindspore::schema::EltwiseMode>(GetField<int8_t>(VT_MODE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_MODE) &&
+           verifier.EndTable();
+  }
+};
+
+struct EltwiseBuilder {
+  typedef Eltwise Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_mode(mindspore::schema::EltwiseMode mode) {
+    fbb_.AddElement<int8_t>(Eltwise::VT_MODE, static_cast<int8_t>(mode), 0);
+  }
+  explicit EltwiseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Eltwise> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Eltwise>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Eltwise> CreateEltwise(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::EltwiseMode mode = mindspore::schema::EltwiseMode_PROD) {
+  EltwiseBuilder builder_(_fbb);
+  builder_.add_mode(mode);
+  return builder_.Finish();
+}
+
+struct Equal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef EqualBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct EqualBuilder {
+  typedef Equal Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit EqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Equal> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Equal>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Equal> CreateEqual(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  EqualBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct EmbeddingLookupFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef EmbeddingLookupFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_MAX_NORM = 4
+  };
+  float max_norm() const {
+    return GetField<float>(VT_MAX_NORM, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_MAX_NORM) &&
+           verifier.EndTable();
+  }
+};
+
+struct EmbeddingLookupFusionBuilder {
+  typedef EmbeddingLookupFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_max_norm(float max_norm) {
+    fbb_.AddElement<float>(EmbeddingLookupFusion::VT_MAX_NORM, max_norm, 0.0f);
+  }
+  explicit EmbeddingLookupFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<EmbeddingLookupFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<EmbeddingLookupFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<EmbeddingLookupFusion> CreateEmbeddingLookupFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float max_norm = 0.0f) {
+  EmbeddingLookupFusionBuilder builder_(_fbb);
+  builder_.add_max_norm(max_norm);
+  return builder_.Finish();
+}
+
+struct ExpFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ExpFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BASE = 4,
+    VT_SCALE = 6,
+    VT_SHIFT = 8
+  };
+  float base() const {
+    return GetField<float>(VT_BASE, -1.0f);
+  }
+  float scale() const {
+    return GetField<float>(VT_SCALE, 1.0f);
+  }
+  float shift() const {
+    return GetField<float>(VT_SHIFT, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_BASE) &&
+           VerifyField<float>(verifier, VT_SCALE) &&
+           VerifyField<float>(verifier, VT_SHIFT) &&
+           verifier.EndTable();
+  }
+};
+
+struct ExpFusionBuilder {
+  typedef ExpFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_base(float base) {
+    fbb_.AddElement<float>(ExpFusion::VT_BASE, base, -1.0f);
+  }
+  void add_scale(float scale) {
+    fbb_.AddElement<float>(ExpFusion::VT_SCALE, scale, 1.0f);
+  }
+  void add_shift(float shift) {
+    fbb_.AddElement<float>(ExpFusion::VT_SHIFT, shift, 0.0f);
+  }
+  explicit ExpFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ExpFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ExpFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ExpFusion> CreateExpFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float base = -1.0f,
+    float scale = 1.0f,
+    float shift = 0.0f) {
+  ExpFusionBuilder builder_(_fbb);
+  builder_.add_shift(shift);
+  builder_.add_scale(scale);
+  builder_.add_base(base);
+  return builder_.Finish();
+}
+
+struct ExpandDims FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ExpandDimsBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct ExpandDimsBuilder {
+  typedef ExpandDims Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ExpandDimsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ExpandDims> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ExpandDims>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ExpandDims> CreateExpandDims(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ExpandDimsBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct FakeQuantWithMinMaxVars FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FakeQuantWithMinMaxVarsBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUM_BITS = 4,
+    VT_NARROW_RANGE = 6
+  };
+  int64_t num_bits() const {
+    return GetField<int64_t>(VT_NUM_BITS, 0);
+  }
+  bool narrow_range() const {
+    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_NUM_BITS) &&
+           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
+           verifier.EndTable();
+  }
+};
+
+struct FakeQuantWithMinMaxVarsBuilder {
+  typedef FakeQuantWithMinMaxVars Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_num_bits(int64_t num_bits) {
+    fbb_.AddElement<int64_t>(FakeQuantWithMinMaxVars::VT_NUM_BITS, num_bits, 0);
+  }
+  void add_narrow_range(bool narrow_range) {
+    fbb_.AddElement<uint8_t>(FakeQuantWithMinMaxVars::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
+  }
+  explicit FakeQuantWithMinMaxVarsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FakeQuantWithMinMaxVars> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FakeQuantWithMinMaxVars>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t num_bits = 0,
+    bool narrow_range = false) {
+  FakeQuantWithMinMaxVarsBuilder builder_(_fbb);
+  builder_.add_num_bits(num_bits);
+  builder_.add_narrow_range(narrow_range);
+  return builder_.Finish();
+}
+
+struct FakeQuantWithMinMaxVarsPerChannel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FakeQuantWithMinMaxVarsPerChannelBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUM_BITS = 4,
+    VT_NARROW_RANGE = 6
+  };
+  int64_t num_bits() const {
+    return GetField<int64_t>(VT_NUM_BITS, 0);
+  }
+  bool narrow_range() const {
+    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_NUM_BITS) &&
+           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
+           verifier.EndTable();
+  }
+};
+
+struct FakeQuantWithMinMaxVarsPerChannelBuilder {
+  typedef FakeQuantWithMinMaxVarsPerChannel Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_num_bits(int64_t num_bits) {
+    fbb_.AddElement<int64_t>(FakeQuantWithMinMaxVarsPerChannel::VT_NUM_BITS, num_bits, 0);
+  }
+  void add_narrow_range(bool narrow_range) {
+    fbb_.AddElement<uint8_t>(FakeQuantWithMinMaxVarsPerChannel::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
+  }
+  explicit FakeQuantWithMinMaxVarsPerChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> CreateFakeQuantWithMinMaxVarsPerChannel(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t num_bits = 0,
+    bool narrow_range = false) {
+  FakeQuantWithMinMaxVarsPerChannelBuilder builder_(_fbb);
+  builder_.add_num_bits(num_bits);
+  builder_.add_narrow_range(narrow_range);
+  return builder_.Finish();
+}
+
+struct FftReal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FftRealBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct FftRealBuilder {
+  typedef FftReal Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FftRealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FftReal> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FftReal>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FftReal> CreateFftReal(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FftRealBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct FftImag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FftImagBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct FftImagBuilder {
+  typedef FftImag Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FftImagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FftImag> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FftImag>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FftImag> CreateFftImag(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FftImagBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Flatten FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FlattenBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 1LL);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+};
+
+struct FlattenBuilder {
+  typedef Flatten Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(Flatten::VT_AXIS, axis, 1LL);
+  }
+  explicit FlattenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Flatten> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Flatten>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Flatten> CreateFlatten(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 1LL) {
+  FlattenBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+struct FlattenGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FlattenGradBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct FlattenGradBuilder {
+  typedef FlattenGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FlattenGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FlattenGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FlattenGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FlattenGrad> CreateFlattenGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FlattenGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Floor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FloorBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct FloorBuilder {
+  typedef Floor Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FloorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Floor> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Floor>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Floor> CreateFloor(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FloorBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct FloorDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FloorDivBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct FloorDivBuilder {
+  typedef FloorDiv Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FloorDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FloorDiv> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FloorDiv>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FloorDiv> CreateFloorDiv(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FloorDivBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct FloorMod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FloorModBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct FloorModBuilder {
+  typedef FloorMod Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FloorModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FloorMod> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FloorMod>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FloorMod> CreateFloorMod(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FloorModBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Fill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FillBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct FillBuilder {
+  typedef Fill Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit FillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Fill> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Fill>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Fill> CreateFill(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  FillBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct FullConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FullConnectionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_HAS_BIAS = 4,
+    VT_USE_AXIS = 6,
+    VT_AXIS = 8,
+    VT_ACTIVATION_TYPE = 10
+  };
+  bool has_bias() const {
+    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
+  }
+  bool use_axis() const {
+    return GetField<uint8_t>(VT_USE_AXIS, 0) != 0;
+  }
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
+           VerifyField<uint8_t>(verifier, VT_USE_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct FullConnectionBuilder {
+  typedef FullConnection Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_has_bias(bool has_bias) {
+    fbb_.AddElement<uint8_t>(FullConnection::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
+  }
+  void add_use_axis(bool use_axis) {
+    fbb_.AddElement<uint8_t>(FullConnection::VT_USE_AXIS, static_cast<uint8_t>(use_axis), 0);
+  }
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(FullConnection::VT_AXIS, axis, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(FullConnection::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit FullConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FullConnection> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FullConnection>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FullConnection> CreateFullConnection(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool has_bias = false,
+    bool use_axis = false,
+    int64_t axis = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  FullConnectionBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  builder_.add_activation_type(activation_type);
+  builder_.add_use_axis(use_axis);
+  builder_.add_has_bias(has_bias);
+  return builder_.Finish();
+}
+
+struct FusedBatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FusedBatchNormBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_EPSILON = 4,
+    VT_MOMENTUM = 6,
+    VT_MODE = 8
+  };
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.0001f);
+  }
+  float momentum() const {
+    return GetField<float>(VT_MOMENTUM, 0.9f);
+  }
+  int64_t mode() const {
+    return GetField<int64_t>(VT_MODE, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<float>(verifier, VT_MOMENTUM) &&
+           VerifyField<int64_t>(verifier, VT_MODE) &&
+           verifier.EndTable();
+  }
+};
+
+struct FusedBatchNormBuilder {
+  typedef FusedBatchNorm Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(FusedBatchNorm::VT_EPSILON, epsilon, 0.0001f);
+  }
+  void add_momentum(float momentum) {
+    fbb_.AddElement<float>(FusedBatchNorm::VT_MOMENTUM, momentum, 0.9f);
+  }
+  void add_mode(int64_t mode) {
+    fbb_.AddElement<int64_t>(FusedBatchNorm::VT_MODE, mode, 0);
+  }
+  explicit FusedBatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FusedBatchNorm> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FusedBatchNorm>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float epsilon = 0.0001f,
+    float momentum = 0.9f,
+    int64_t mode = 0) {
+  FusedBatchNormBuilder builder_(_fbb);
+  builder_.add_mode(mode);
+  builder_.add_momentum(momentum);
+  builder_.add_epsilon(epsilon);
+  return builder_.Finish();
+}
+
+struct Gather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GatherBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct GatherBuilder {
+  typedef Gather Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit GatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Gather> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Gather>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Gather> CreateGather(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  GatherBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct GatherNd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GatherNdBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct GatherNdBuilder {
+  typedef GatherNd Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit GatherNdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GatherNd> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GatherNd>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GatherNd> CreateGatherNd(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  GatherNdBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Greater FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GreaterBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct GreaterBuilder {
+  typedef Greater Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit GreaterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Greater> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Greater>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Greater> CreateGreater(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  GreaterBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct GreaterEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GreaterEqualBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct GreaterEqualBuilder {
+  typedef GreaterEqual Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit GreaterEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GreaterEqual> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GreaterEqual>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  GreaterEqualBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct HashtableLookup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef HashtableLookupBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct HashtableLookupBuilder {
+  typedef HashtableLookup Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit HashtableLookupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<HashtableLookup> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<HashtableLookup>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<HashtableLookup> CreateHashtableLookup(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  HashtableLookupBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct InstanceNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef InstanceNormBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_EPSILON = 4
+  };
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           verifier.EndTable();
+  }
+};
+
+struct InstanceNormBuilder {
+  typedef InstanceNorm Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(InstanceNorm::VT_EPSILON, epsilon, 0.0f);
+  }
+  explicit InstanceNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<InstanceNorm> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<InstanceNorm>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<InstanceNorm> CreateInstanceNorm(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float epsilon = 0.0f) {
+  InstanceNormBuilder builder_(_fbb);
+  builder_.add_epsilon(epsilon);
+  return builder_.Finish();
+}
+
+struct LayerNormFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LayerNormFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BEGIN_NORM_AXIS = 4,
+    VT_EPSILON = 6,
+    VT_ELEMENTWISE_AFFINE = 8,
+    VT_BEGIN_PARAMS_AXIS = 10
+  };
+  int64_t begin_norm_axis() const {
+    return GetField<int64_t>(VT_BEGIN_NORM_AXIS, 0);
+  }
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.00001f);
+  }
+  bool elementwise_affine() const {
+    return GetField<uint8_t>(VT_ELEMENTWISE_AFFINE, 0) != 0;
+  }
+  int64_t begin_params_axis() const {
+    return GetField<int64_t>(VT_BEGIN_PARAMS_AXIS, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_BEGIN_NORM_AXIS) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<uint8_t>(verifier, VT_ELEMENTWISE_AFFINE) &&
+           VerifyField<int64_t>(verifier, VT_BEGIN_PARAMS_AXIS) &&
+           verifier.EndTable();
+  }
+};
+
+struct LayerNormFusionBuilder {
+  typedef LayerNormFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_begin_norm_axis(int64_t begin_norm_axis) {
+    fbb_.AddElement<int64_t>(LayerNormFusion::VT_BEGIN_NORM_AXIS, begin_norm_axis, 0);
+  }
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(LayerNormFusion::VT_EPSILON, epsilon, 0.00001f);
+  }
+  void add_elementwise_affine(bool elementwise_affine) {
+    fbb_.AddElement<uint8_t>(LayerNormFusion::VT_ELEMENTWISE_AFFINE, static_cast<uint8_t>(elementwise_affine), 0);
+  }
+  void add_begin_params_axis(int64_t begin_params_axis) {
+    fbb_.AddElement<int64_t>(LayerNormFusion::VT_BEGIN_PARAMS_AXIS, begin_params_axis, 0);
+  }
+  explicit LayerNormFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LayerNormFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LayerNormFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LayerNormFusion> CreateLayerNormFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t begin_norm_axis = 0,
+    float epsilon = 0.00001f,
+    bool elementwise_affine = false,
+    int64_t begin_params_axis = 0) {
+  LayerNormFusionBuilder builder_(_fbb);
+  builder_.add_begin_params_axis(begin_params_axis);
+  builder_.add_begin_norm_axis(begin_norm_axis);
+  builder_.add_epsilon(epsilon);
+  builder_.add_elementwise_affine(elementwise_affine);
+  return builder_.Finish();
+}
+
+struct LeakyRelu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LeakyReluBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NEGATIVE_SLOPE = 4
+  };
+  float negative_slope() const {
+    return GetField<float>(VT_NEGATIVE_SLOPE, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_NEGATIVE_SLOPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct LeakyReluBuilder {
+  typedef LeakyRelu Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_negative_slope(float negative_slope) {
+    fbb_.AddElement<float>(LeakyRelu::VT_NEGATIVE_SLOPE, negative_slope, 0.0f);
+  }
+  explicit LeakyReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LeakyRelu> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LeakyRelu>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LeakyRelu> CreateLeakyRelu(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float negative_slope = 0.0f) {
+  LeakyReluBuilder builder_(_fbb);
+  builder_.add_negative_slope(negative_slope);
+  return builder_.Finish();
+}
+
+struct Less FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LessBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct LessBuilder {
+  typedef Less Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Less> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Less>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Less> CreateLess(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LessBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct LessEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LessEqualBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct LessEqualBuilder {
+  typedef LessEqual Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LessEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LessEqual> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LessEqual>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LessEqual> CreateLessEqual(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LessEqualBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Log FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LogBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct LogBuilder {
+  typedef Log Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Log> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Log>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Log> CreateLog(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LogBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct LogGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LogGradBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct LogGradBuilder {
+  typedef LogGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LogGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LogGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LogGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LogGrad> CreateLogGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LogGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct LogicalAnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LogicalAndBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct LogicalAndBuilder {
+  typedef LogicalAnd Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LogicalAndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LogicalAnd> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LogicalAnd>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LogicalAndBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct LogicalNot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LogicalNotBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct LogicalNotBuilder {
+  typedef LogicalNot Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LogicalNotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LogicalNot> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LogicalNot>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LogicalNot> CreateLogicalNot(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LogicalNotBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct LogicalOr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LogicalOrBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct LogicalOrBuilder {
+  typedef LogicalOr Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LogicalOrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LogicalOr> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LogicalOr>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LogicalOr> CreateLogicalOr(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LogicalOrBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct LpNormalization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LpNormalizationBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4,
+    VT_P = 6
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  int64_t p() const {
+    return GetField<int64_t>(VT_P, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_P) &&
+           verifier.EndTable();
+  }
+};
+
+struct LpNormalizationBuilder {
+  typedef LpNormalization Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(LpNormalization::VT_AXIS, axis, 0);
+  }
+  void add_p(int64_t p) {
+    fbb_.AddElement<int64_t>(LpNormalization::VT_P, p, 0);
+  }
+  explicit LpNormalizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LpNormalization> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LpNormalization>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LpNormalization> CreateLpNormalization(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0,
+    int64_t p = 0) {
+  LpNormalizationBuilder builder_(_fbb);
+  builder_.add_p(p);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+struct LRN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LRNBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DEPTH_RADIUS = 4,
+    VT_BIAS = 6,
+    VT_ALPHA = 8,
+    VT_BETA = 10,
+    VT_NORM_REGION = 12
+  };
+  int64_t depth_radius() const {
+    return GetField<int64_t>(VT_DEPTH_RADIUS, 0);
+  }
+  float bias() const {
+    return GetField<float>(VT_BIAS, 0.0f);
+  }
+  float alpha() const {
+    return GetField<float>(VT_ALPHA, 0.0f);
+  }
+  float beta() const {
+    return GetField<float>(VT_BETA, 0.0f);
+  }
+  const flatbuffers::String *norm_region() const {
+    return GetPointer<const flatbuffers::String *>(VT_NORM_REGION);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_DEPTH_RADIUS) &&
+           VerifyField<float>(verifier, VT_BIAS) &&
+           VerifyField<float>(verifier, VT_ALPHA) &&
+           VerifyField<float>(verifier, VT_BETA) &&
+           VerifyOffset(verifier, VT_NORM_REGION) &&
+           verifier.VerifyString(norm_region()) &&
+           verifier.EndTable();
+  }
+};
+
+struct LRNBuilder {
+  typedef LRN Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_depth_radius(int64_t depth_radius) {
+    fbb_.AddElement<int64_t>(LRN::VT_DEPTH_RADIUS, depth_radius, 0);
+  }
+  void add_bias(float bias) {
+    fbb_.AddElement<float>(LRN::VT_BIAS, bias, 0.0f);
+  }
+  void add_alpha(float alpha) {
+    fbb_.AddElement<float>(LRN::VT_ALPHA, alpha, 0.0f);
+  }
+  void add_beta(float beta) {
+    fbb_.AddElement<float>(LRN::VT_BETA, beta, 0.0f);
+  }
+  void add_norm_region(flatbuffers::Offset<flatbuffers::String> norm_region) {
+    fbb_.AddOffset(LRN::VT_NORM_REGION, norm_region);
+  }
+  explicit LRNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LRN> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LRN>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LRN> CreateLRN(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t depth_radius = 0,
+    float bias = 0.0f,
+    float alpha = 0.0f,
+    float beta = 0.0f,
+    flatbuffers::Offset<flatbuffers::String> norm_region = 0) {
+  LRNBuilder builder_(_fbb);
+  builder_.add_depth_radius(depth_radius);
+  builder_.add_norm_region(norm_region);
+  builder_.add_beta(beta);
+  builder_.add_alpha(alpha);
+  builder_.add_bias(bias);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<LRN> CreateLRNDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t depth_radius = 0,
+    float bias = 0.0f,
+    float alpha = 0.0f,
+    float beta = 0.0f,
+    const char *norm_region = nullptr) {
+  auto norm_region__ = norm_region ? _fbb.CreateString(norm_region) : 0;
+  return mindspore::schema::CreateLRN(
+      _fbb,
+      depth_radius,
+      bias,
+      alpha,
+      beta,
+      norm_region__);
+}
+
+struct LshProjection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LshProjectionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_TYPE = 4
+  };
+  mindspore::schema::LshProjectionType type() const {
+    return static_cast<mindspore::schema::LshProjectionType>(GetField<int8_t>(VT_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct LshProjectionBuilder {
+  typedef LshProjection Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_type(mindspore::schema::LshProjectionType type) {
+    fbb_.AddElement<int8_t>(LshProjection::VT_TYPE, static_cast<int8_t>(type), 0);
+  }
+  explicit LshProjectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LshProjection> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LshProjection>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LshProjection> CreateLshProjection(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::LshProjectionType type = mindspore::schema::LshProjectionType_UNKNOWN) {
+  LshProjectionBuilder builder_(_fbb);
+  builder_.add_type(type);
+  return builder_.Finish();
+}
+
+struct LSTM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LSTMBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BIDIRECTIONAL = 4,
+    VT_HAS_BIAS = 6,
+    VT_INPUT_SIZE = 8,
+    VT_HIDDEN_SIZE = 10,
+    VT_NUM_LAYERS = 12,
+    VT_NUM_DIRECTIONS = 14,
+    VT_DROPOUT = 16,
+    VT_ZONEOUT_CELL = 18,
+    VT_ZONEOUT_HIDDEN = 20
+  };
+  bool bidirectional() const {
+    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
+  }
+  bool has_bias() const {
+    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
+  }
+  int64_t input_size() const {
+    return GetField<int64_t>(VT_INPUT_SIZE, 0);
+  }
+  int64_t hidden_size() const {
+    return GetField<int64_t>(VT_HIDDEN_SIZE, 0);
+  }
+  int64_t num_layers() const {
+    return GetField<int64_t>(VT_NUM_LAYERS, 0);
+  }
+  int64_t num_directions() const {
+    return GetField<int64_t>(VT_NUM_DIRECTIONS, 0);
+  }
+  float dropout() const {
+    return GetField<float>(VT_DROPOUT, 0.0f);
+  }
+  float zoneout_cell() const {
+    return GetField<float>(VT_ZONEOUT_CELL, 0.0f);
+  }
+  float zoneout_hidden() const {
+    return GetField<float>(VT_ZONEOUT_HIDDEN, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
+           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_HIDDEN_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_NUM_LAYERS) &&
+           VerifyField<int64_t>(verifier, VT_NUM_DIRECTIONS) &&
+           VerifyField<float>(verifier, VT_DROPOUT) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_CELL) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_HIDDEN) &&
+           verifier.EndTable();
+  }
+};
+
+struct LSTMBuilder {
+  typedef LSTM Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_bidirectional(bool bidirectional) {
+    fbb_.AddElement<uint8_t>(LSTM::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
+  }
+  void add_has_bias(bool has_bias) {
+    fbb_.AddElement<uint8_t>(LSTM::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
+  }
+  void add_input_size(int64_t input_size) {
+    fbb_.AddElement<int64_t>(LSTM::VT_INPUT_SIZE, input_size, 0);
+  }
+  void add_hidden_size(int64_t hidden_size) {
+    fbb_.AddElement<int64_t>(LSTM::VT_HIDDEN_SIZE, hidden_size, 0);
+  }
+  void add_num_layers(int64_t num_layers) {
+    fbb_.AddElement<int64_t>(LSTM::VT_NUM_LAYERS, num_layers, 0);
+  }
+  void add_num_directions(int64_t num_directions) {
+    fbb_.AddElement<int64_t>(LSTM::VT_NUM_DIRECTIONS, num_directions, 0);
+  }
+  void add_dropout(float dropout) {
+    fbb_.AddElement<float>(LSTM::VT_DROPOUT, dropout, 0.0f);
+  }
+  void add_zoneout_cell(float zoneout_cell) {
+    fbb_.AddElement<float>(LSTM::VT_ZONEOUT_CELL, zoneout_cell, 0.0f);
+  }
+  void add_zoneout_hidden(float zoneout_hidden) {
+    fbb_.AddElement<float>(LSTM::VT_ZONEOUT_HIDDEN, zoneout_hidden, 0.0f);
+  }
+  explicit LSTMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LSTM> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LSTM>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LSTM> CreateLSTM(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool bidirectional = false,
+    bool has_bias = false,
+    int64_t input_size = 0,
+    int64_t hidden_size = 0,
+    int64_t num_layers = 0,
+    int64_t num_directions = 0,
+    float dropout = 0.0f,
+    float zoneout_cell = 0.0f,
+    float zoneout_hidden = 0.0f) {
+  LSTMBuilder builder_(_fbb);
+  builder_.add_num_directions(num_directions);
+  builder_.add_num_layers(num_layers);
+  builder_.add_hidden_size(hidden_size);
+  builder_.add_input_size(input_size);
+  builder_.add_zoneout_hidden(zoneout_hidden);
+  builder_.add_zoneout_cell(zoneout_cell);
+  builder_.add_dropout(dropout);
+  builder_.add_has_bias(has_bias);
+  builder_.add_bidirectional(bidirectional);
+  return builder_.Finish();
+}
+
+struct LSTMGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LSTMGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BIDIRECTIONAL = 4,
+    VT_HAS_BIAS = 6,
+    VT_INPUT_SIZE = 8,
+    VT_HIDDEN_SIZE = 10,
+    VT_NUM_LAYERS = 12,
+    VT_NUM_DIRECTIONS = 14,
+    VT_DROPOUT = 16,
+    VT_ZONEOUT_CELL = 18,
+    VT_ZONEOUT_HIDDEN = 20
+  };
+  bool bidirectional() const {
+    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
+  }
+  bool has_bias() const {
+    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
+  }
+  int64_t input_size() const {
+    return GetField<int64_t>(VT_INPUT_SIZE, 0);
+  }
+  int64_t hidden_size() const {
+    return GetField<int64_t>(VT_HIDDEN_SIZE, 0);
+  }
+  int64_t num_layers() const {
+    return GetField<int64_t>(VT_NUM_LAYERS, 0);
+  }
+  int64_t num_directions() const {
+    return GetField<int64_t>(VT_NUM_DIRECTIONS, 0);
+  }
+  float dropout() const {
+    return GetField<float>(VT_DROPOUT, 0.0f);
+  }
+  float zoneout_cell() const {
+    return GetField<float>(VT_ZONEOUT_CELL, 0.0f);
+  }
+  float zoneout_hidden() const {
+    return GetField<float>(VT_ZONEOUT_HIDDEN, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
+           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_HIDDEN_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_NUM_LAYERS) &&
+           VerifyField<int64_t>(verifier, VT_NUM_DIRECTIONS) &&
+           VerifyField<float>(verifier, VT_DROPOUT) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_CELL) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_HIDDEN) &&
+           verifier.EndTable();
+  }
+};
+
+struct LSTMGradBuilder {
+  typedef LSTMGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_bidirectional(bool bidirectional) {
+    fbb_.AddElement<uint8_t>(LSTMGrad::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
+  }
+  void add_has_bias(bool has_bias) {
+    fbb_.AddElement<uint8_t>(LSTMGrad::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
+  }
+  void add_input_size(int64_t input_size) {
+    fbb_.AddElement<int64_t>(LSTMGrad::VT_INPUT_SIZE, input_size, 0);
+  }
+  void add_hidden_size(int64_t hidden_size) {
+    fbb_.AddElement<int64_t>(LSTMGrad::VT_HIDDEN_SIZE, hidden_size, 0);
+  }
+  void add_num_layers(int64_t num_layers) {
+    fbb_.AddElement<int64_t>(LSTMGrad::VT_NUM_LAYERS, num_layers, 0);
+  }
+  void add_num_directions(int64_t num_directions) {
+    fbb_.AddElement<int64_t>(LSTMGrad::VT_NUM_DIRECTIONS, num_directions, 0);
+  }
+  void add_dropout(float dropout) {
+    fbb_.AddElement<float>(LSTMGrad::VT_DROPOUT, dropout, 0.0f);
+  }
+  void add_zoneout_cell(float zoneout_cell) {
+    fbb_.AddElement<float>(LSTMGrad::VT_ZONEOUT_CELL, zoneout_cell, 0.0f);
+  }
+  void add_zoneout_hidden(float zoneout_hidden) {
+    fbb_.AddElement<float>(LSTMGrad::VT_ZONEOUT_HIDDEN, zoneout_hidden, 0.0f);
+  }
+  explicit LSTMGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LSTMGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LSTMGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LSTMGrad> CreateLSTMGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool bidirectional = false,
+    bool has_bias = false,
+    int64_t input_size = 0,
+    int64_t hidden_size = 0,
+    int64_t num_layers = 0,
+    int64_t num_directions = 0,
+    float dropout = 0.0f,
+    float zoneout_cell = 0.0f,
+    float zoneout_hidden = 0.0f) {
+  LSTMGradBuilder builder_(_fbb);
+  builder_.add_num_directions(num_directions);
+  builder_.add_num_layers(num_layers);
+  builder_.add_hidden_size(hidden_size);
+  builder_.add_input_size(input_size);
+  builder_.add_zoneout_hidden(zoneout_hidden);
+  builder_.add_zoneout_cell(zoneout_cell);
+  builder_.add_dropout(dropout);
+  builder_.add_has_bias(has_bias);
+  builder_.add_bidirectional(bidirectional);
+  return builder_.Finish();
+}
+
+struct L2NormalizeFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef L2NormalizeFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4,
+    VT_EPSILON = 6,
+    VT_ACTIVATION_TYPE = 8
+  };
+  const flatbuffers::Vector<int64_t> *axis() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.0f);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_AXIS) &&
+           verifier.VerifyVector(axis()) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct L2NormalizeFusionBuilder {
+  typedef L2NormalizeFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
+    fbb_.AddOffset(L2NormalizeFusion::VT_AXIS, axis);
+  }
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(L2NormalizeFusion::VT_EPSILON, epsilon, 0.0f);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(L2NormalizeFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit L2NormalizeFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<L2NormalizeFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<L2NormalizeFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<L2NormalizeFusion> CreateL2NormalizeFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0,
+    float epsilon = 0.0f,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  L2NormalizeFusionBuilder builder_(_fbb);
+  builder_.add_epsilon(epsilon);
+  builder_.add_axis(axis);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<L2NormalizeFusion> CreateL2NormalizeFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *axis = nullptr,
+    float epsilon = 0.0f,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
+  return mindspore::schema::CreateL2NormalizeFusion(
+      _fbb,
+      axis__,
+      epsilon,
+      activation_type);
+}
+
+struct MatMulFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MatMulFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_TRANSPOSE_A = 4,
+    VT_TRANSPOSE_B = 6,
+    VT_ACTIVATION_TYPE = 8
+  };
+  bool transpose_a() const {
+    return GetField<uint8_t>(VT_TRANSPOSE_A, 0) != 0;
+  }
+  bool transpose_b() const {
+    return GetField<uint8_t>(VT_TRANSPOSE_B, 0) != 0;
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_A) &&
+           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_B) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct MatMulFusionBuilder {
+  typedef MatMulFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_transpose_a(bool transpose_a) {
+    fbb_.AddElement<uint8_t>(MatMulFusion::VT_TRANSPOSE_A, static_cast<uint8_t>(transpose_a), 0);
+  }
+  void add_transpose_b(bool transpose_b) {
+    fbb_.AddElement<uint8_t>(MatMulFusion::VT_TRANSPOSE_B, static_cast<uint8_t>(transpose_b), 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(MatMulFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit MatMulFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MatMulFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MatMulFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MatMulFusion> CreateMatMulFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool transpose_a = false,
+    bool transpose_b = false,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  MatMulFusionBuilder builder_(_fbb);
+  builder_.add_activation_type(activation_type);
+  builder_.add_transpose_b(transpose_b);
+  builder_.add_transpose_a(transpose_a);
+  return builder_.Finish();
+}
+
+struct Maximum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MaximumBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct MaximumBuilder {
+  typedef Maximum Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit MaximumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Maximum> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Maximum>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Maximum> CreateMaximum(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  MaximumBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct MaximumGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MaximumGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_GRAD_X = 4,
+    VT_GRAD_Y = 6
+  };
+  bool grad_x() const {
+    return GetField<uint8_t>(VT_GRAD_X, 0) != 0;
+  }
+  bool grad_y() const {
+    return GetField<uint8_t>(VT_GRAD_Y, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_GRAD_X) &&
+           VerifyField<uint8_t>(verifier, VT_GRAD_Y) &&
+           verifier.EndTable();
+  }
+};
+
+struct MaximumGradBuilder {
+  typedef MaximumGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_grad_x(bool grad_x) {
+    fbb_.AddElement<uint8_t>(MaximumGrad::VT_GRAD_X, static_cast<uint8_t>(grad_x), 0);
+  }
+  void add_grad_y(bool grad_y) {
+    fbb_.AddElement<uint8_t>(MaximumGrad::VT_GRAD_Y, static_cast<uint8_t>(grad_y), 0);
+  }
+  explicit MaximumGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MaximumGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MaximumGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MaximumGrad> CreateMaximumGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool grad_x = false,
+    bool grad_y = false) {
+  MaximumGradBuilder builder_(_fbb);
+  builder_.add_grad_y(grad_y);
+  builder_.add_grad_x(grad_x);
+  return builder_.Finish();
+}
+
+struct MaxPoolFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MaxPoolFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KERNEL_SIZE = 4,
+    VT_STRIDES = 6,
+    VT_PAD = 8,
+    VT_PAD_MODE = 10,
+    VT_ROUND_MODE = 12,
+    VT_FORMAT = 14,
+    VT_GLOBAL = 16,
+    VT_ACTIVATION_TYPE = 18
+  };
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *strides() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
+  }
+  const flatbuffers::Vector<int64_t> *pad() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  mindspore::schema::RoundMode round_mode() const {
+    return static_cast<mindspore::schema::RoundMode>(GetField<int8_t>(VT_ROUND_MODE, 0));
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool global() const {
+    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDES) &&
+           verifier.VerifyVector(strides()) &&
+           VerifyOffset(verifier, VT_PAD) &&
+           verifier.VerifyVector(pad()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyField<int8_t>(verifier, VT_ROUND_MODE) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct MaxPoolFusionBuilder {
+  typedef MaxPoolFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(MaxPoolFusion::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
+    fbb_.AddOffset(MaxPoolFusion::VT_STRIDES, strides);
+  }
+  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
+    fbb_.AddOffset(MaxPoolFusion::VT_PAD, pad);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(MaxPoolFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_round_mode(mindspore::schema::RoundMode round_mode) {
+    fbb_.AddElement<int8_t>(MaxPoolFusion::VT_ROUND_MODE, static_cast<int8_t>(round_mode), 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(MaxPoolFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_global(bool global) {
+    fbb_.AddElement<uint8_t>(MaxPoolFusion::VT_GLOBAL, static_cast<uint8_t>(global), 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(MaxPoolFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit MaxPoolFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MaxPoolFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MaxPoolFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MaxPoolFusion> CreateMaxPoolFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    bool global = false,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  MaxPoolFusionBuilder builder_(_fbb);
+  builder_.add_format(format);
+  builder_.add_pad(pad);
+  builder_.add_strides(strides);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_activation_type(activation_type);
+  builder_.add_global(global);
+  builder_.add_round_mode(round_mode);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<MaxPoolFusion> CreateMaxPoolFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *strides = nullptr,
+    const std::vector<int64_t> *pad = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    bool global = false,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
+  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
+  return mindspore::schema::CreateMaxPoolFusion(
+      _fbb,
+      kernel_size__,
+      strides__,
+      pad__,
+      pad_mode,
+      round_mode,
+      format,
+      global,
+      activation_type);
+}
+
+struct MaxPoolGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MaxPoolGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KERNEL_SIZE = 4,
+    VT_STRIDES = 6,
+    VT_PAD_MODE = 8,
+    VT_FORMAT = 10
+  };
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *strides() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDES) &&
+           verifier.VerifyVector(strides()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           verifier.EndTable();
+  }
+};
+
+struct MaxPoolGradBuilder {
+  typedef MaxPoolGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(MaxPoolGrad::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
+    fbb_.AddOffset(MaxPoolGrad::VT_STRIDES, strides);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(MaxPoolGrad::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(MaxPoolGrad::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  explicit MaxPoolGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MaxPoolGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MaxPoolGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MaxPoolGrad> CreateMaxPoolGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  MaxPoolGradBuilder builder_(_fbb);
+  builder_.add_format(format);
+  builder_.add_strides(strides);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_pad_mode(pad_mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<MaxPoolGrad> CreateMaxPoolGradDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *strides = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
+  return mindspore::schema::CreateMaxPoolGrad(
+      _fbb,
+      kernel_size__,
+      strides__,
+      pad_mode,
+      format);
+}
+
+struct SwitchLayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SwitchLayerBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SwitchLayerBuilder {
+  typedef SwitchLayer Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SwitchLayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SwitchLayer> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SwitchLayer>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SwitchLayer> CreateSwitchLayer(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SwitchLayerBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Mfcc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MfccBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FREQ_UPPER_LIMIT = 4,
+    VT_FREQ_LOWER_LIMIT = 6,
+    VT_FILTER_BANK_CHANNEL_NUM = 8,
+    VT_DCT_COEFF_NUM = 10
+  };
+  float freq_upper_limit() const {
+    return GetField<float>(VT_FREQ_UPPER_LIMIT, 0.0f);
+  }
+  float freq_lower_limit() const {
+    return GetField<float>(VT_FREQ_LOWER_LIMIT, 0.0f);
+  }
+  int64_t filter_bank_channel_num() const {
+    return GetField<int64_t>(VT_FILTER_BANK_CHANNEL_NUM, 0);
+  }
+  int64_t dct_coeff_num() const {
+    return GetField<int64_t>(VT_DCT_COEFF_NUM, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_FREQ_UPPER_LIMIT) &&
+           VerifyField<float>(verifier, VT_FREQ_LOWER_LIMIT) &&
+           VerifyField<int64_t>(verifier, VT_FILTER_BANK_CHANNEL_NUM) &&
+           VerifyField<int64_t>(verifier, VT_DCT_COEFF_NUM) &&
+           verifier.EndTable();
+  }
+};
+
+struct MfccBuilder {
+  typedef Mfcc Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_freq_upper_limit(float freq_upper_limit) {
+    fbb_.AddElement<float>(Mfcc::VT_FREQ_UPPER_LIMIT, freq_upper_limit, 0.0f);
+  }
+  void add_freq_lower_limit(float freq_lower_limit) {
+    fbb_.AddElement<float>(Mfcc::VT_FREQ_LOWER_LIMIT, freq_lower_limit, 0.0f);
+  }
+  void add_filter_bank_channel_num(int64_t filter_bank_channel_num) {
+    fbb_.AddElement<int64_t>(Mfcc::VT_FILTER_BANK_CHANNEL_NUM, filter_bank_channel_num, 0);
+  }
+  void add_dct_coeff_num(int64_t dct_coeff_num) {
+    fbb_.AddElement<int64_t>(Mfcc::VT_DCT_COEFF_NUM, dct_coeff_num, 0);
+  }
+  explicit MfccBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Mfcc> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Mfcc>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Mfcc> CreateMfcc(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float freq_upper_limit = 0.0f,
+    float freq_lower_limit = 0.0f,
+    int64_t filter_bank_channel_num = 0,
+    int64_t dct_coeff_num = 0) {
+  MfccBuilder builder_(_fbb);
+  builder_.add_dct_coeff_num(dct_coeff_num);
+  builder_.add_filter_bank_channel_num(filter_bank_channel_num);
+  builder_.add_freq_lower_limit(freq_lower_limit);
+  builder_.add_freq_upper_limit(freq_upper_limit);
+  return builder_.Finish();
+}
+
+struct Minimum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MinimumBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct MinimumBuilder {
+  typedef Minimum Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit MinimumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Minimum> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Minimum>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Minimum> CreateMinimum(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  MinimumBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct MinimumGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MinimumGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_GRAD_X = 4,
+    VT_GRAD_Y = 6
+  };
+  bool grad_x() const {
+    return GetField<uint8_t>(VT_GRAD_X, 0) != 0;
+  }
+  bool grad_y() const {
+    return GetField<uint8_t>(VT_GRAD_Y, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_GRAD_X) &&
+           VerifyField<uint8_t>(verifier, VT_GRAD_Y) &&
+           verifier.EndTable();
+  }
+};
+
+struct MinimumGradBuilder {
+  typedef MinimumGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_grad_x(bool grad_x) {
+    fbb_.AddElement<uint8_t>(MinimumGrad::VT_GRAD_X, static_cast<uint8_t>(grad_x), 0);
+  }
+  void add_grad_y(bool grad_y) {
+    fbb_.AddElement<uint8_t>(MinimumGrad::VT_GRAD_Y, static_cast<uint8_t>(grad_y), 0);
+  }
+  explicit MinimumGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MinimumGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MinimumGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MinimumGrad> CreateMinimumGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool grad_x = false,
+    bool grad_y = false) {
+  MinimumGradBuilder builder_(_fbb);
+  builder_.add_grad_y(grad_y);
+  builder_.add_grad_x(grad_x);
+  return builder_.Finish();
+}
+
+struct Mod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ModBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct ModBuilder {
+  typedef Mod Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Mod> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Mod>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Mod> CreateMod(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ModBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct MulFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MulFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct MulFusionBuilder {
+  typedef MulFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(MulFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit MulFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MulFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MulFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MulFusion> CreateMulFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  MulFusionBuilder builder_(_fbb);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+struct MulGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef MulGradBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct MulGradBuilder {
+  typedef MulGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit MulGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<MulGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<MulGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<MulGrad> CreateMulGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  MulGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Neg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NegBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct NegBuilder {
+  typedef Neg Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit NegBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Neg> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Neg>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Neg> CreateNeg(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  NegBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct NegGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NegGradBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct NegGradBuilder {
+  typedef NegGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit NegGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<NegGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<NegGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<NegGrad> CreateNegGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  NegGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct NotEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NotEqualBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct NotEqualBuilder {
+  typedef NotEqual Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit NotEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<NotEqual> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<NotEqual>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<NotEqual> CreateNotEqual(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  NotEqualBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct NonMaxSuppression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NonMaxSuppressionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_CENTER_POINT_BOX = 4
+  };
+  int64_t center_point_box() const {
+    return GetField<int64_t>(VT_CENTER_POINT_BOX, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_CENTER_POINT_BOX) &&
+           verifier.EndTable();
+  }
+};
+
+struct NonMaxSuppressionBuilder {
+  typedef NonMaxSuppression Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_center_point_box(int64_t center_point_box) {
+    fbb_.AddElement<int64_t>(NonMaxSuppression::VT_CENTER_POINT_BOX, center_point_box, 0);
+  }
+  explicit NonMaxSuppressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<NonMaxSuppression> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<NonMaxSuppression>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<NonMaxSuppression> CreateNonMaxSuppression(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t center_point_box = 0) {
+  NonMaxSuppressionBuilder builder_(_fbb);
+  builder_.add_center_point_box(center_point_box);
+  return builder_.Finish();
+}
+
+struct OneHot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef OneHotBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+};
+
+struct OneHotBuilder {
+  typedef OneHot Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(OneHot::VT_AXIS, axis, 0);
+  }
+  explicit OneHotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<OneHot> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<OneHot>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<OneHot> CreateOneHot(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0) {
+  OneHotBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+struct OnesLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef OnesLikeBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct OnesLikeBuilder {
+  typedef OnesLike Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit OnesLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<OnesLike> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<OnesLike>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<OnesLike> CreateOnesLike(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  OnesLikeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct PadFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PadFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_PADDINGS = 4,
+    VT_PADDING_MODE = 6,
+    VT_CONSTANT_VALUE = 8
+  };
+  const mindspore::schema::Vec2D *paddings() const {
+    return GetPointer<const mindspore::schema::Vec2D *>(VT_PADDINGS);
+  }
+  mindspore::schema::PaddingMode padding_mode() const {
+    return static_cast<mindspore::schema::PaddingMode>(GetField<int8_t>(VT_PADDING_MODE, 0));
+  }
+  float constant_value() const {
+    return GetField<float>(VT_CONSTANT_VALUE, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_PADDINGS) &&
+           verifier.VerifyTable(paddings()) &&
+           VerifyField<int8_t>(verifier, VT_PADDING_MODE) &&
+           VerifyField<float>(verifier, VT_CONSTANT_VALUE) &&
+           verifier.EndTable();
+  }
+};
+
+struct PadFusionBuilder {
+  typedef PadFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_paddings(flatbuffers::Offset<mindspore::schema::Vec2D> paddings) {
+    fbb_.AddOffset(PadFusion::VT_PADDINGS, paddings);
+  }
+  void add_padding_mode(mindspore::schema::PaddingMode padding_mode) {
+    fbb_.AddElement<int8_t>(PadFusion::VT_PADDING_MODE, static_cast<int8_t>(padding_mode), 0);
+  }
+  void add_constant_value(float constant_value) {
+    fbb_.AddElement<float>(PadFusion::VT_CONSTANT_VALUE, constant_value, 0.0f);
+  }
+  explicit PadFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<PadFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<PadFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<PadFusion> CreatePadFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0,
+    mindspore::schema::PaddingMode padding_mode = mindspore::schema::PaddingMode_CONSTANT,
+    float constant_value = 0.0f) {
+  PadFusionBuilder builder_(_fbb);
+  builder_.add_constant_value(constant_value);
+  builder_.add_paddings(paddings);
+  builder_.add_padding_mode(padding_mode);
+  return builder_.Finish();
+}
+
+struct PartialFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PartialFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SUB_GRAPH_INDEX = 4
+  };
+  int64_t sub_graph_index() const {
+    return GetField<int64_t>(VT_SUB_GRAPH_INDEX, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SUB_GRAPH_INDEX) &&
+           verifier.EndTable();
+  }
+};
+
+struct PartialFusionBuilder {
+  typedef PartialFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_sub_graph_index(int64_t sub_graph_index) {
+    fbb_.AddElement<int64_t>(PartialFusion::VT_SUB_GRAPH_INDEX, sub_graph_index, 0);
+  }
+  explicit PartialFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<PartialFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<PartialFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<PartialFusion> CreatePartialFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t sub_graph_index = 0) {
+  PartialFusionBuilder builder_(_fbb);
+  builder_.add_sub_graph_index(sub_graph_index);
+  return builder_.Finish();
+}
+
+struct PowerGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PowerGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_POWER = 4,
+    VT_SCALE = 6,
+    VT_SHIFT = 8
+  };
+  float power() const {
+    return GetField<float>(VT_POWER, 0.0f);
+  }
+  float scale() const {
+    return GetField<float>(VT_SCALE, 0.0f);
+  }
+  float shift() const {
+    return GetField<float>(VT_SHIFT, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_POWER) &&
+           VerifyField<float>(verifier, VT_SCALE) &&
+           VerifyField<float>(verifier, VT_SHIFT) &&
+           verifier.EndTable();
+  }
+};
+
+struct PowerGradBuilder {
+  typedef PowerGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_power(float power) {
+    fbb_.AddElement<float>(PowerGrad::VT_POWER, power, 0.0f);
+  }
+  void add_scale(float scale) {
+    fbb_.AddElement<float>(PowerGrad::VT_SCALE, scale, 0.0f);
+  }
+  void add_shift(float shift) {
+    fbb_.AddElement<float>(PowerGrad::VT_SHIFT, shift, 0.0f);
+  }
+  explicit PowerGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<PowerGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<PowerGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<PowerGrad> CreatePowerGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float power = 0.0f,
+    float scale = 0.0f,
+    float shift = 0.0f) {
+  PowerGradBuilder builder_(_fbb);
+  builder_.add_shift(shift);
+  builder_.add_scale(scale);
+  builder_.add_power(power);
+  return builder_.Finish();
+}
+
+struct PowFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PowFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SCALE = 4,
+    VT_SHIFT = 6
+  };
+  float scale() const {
+    return GetField<float>(VT_SCALE, 1.0f);
+  }
+  float shift() const {
+    return GetField<float>(VT_SHIFT, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_SCALE) &&
+           VerifyField<float>(verifier, VT_SHIFT) &&
+           verifier.EndTable();
+  }
+};
+
+struct PowFusionBuilder {
+  typedef PowFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_scale(float scale) {
+    fbb_.AddElement<float>(PowFusion::VT_SCALE, scale, 1.0f);
+  }
+  void add_shift(float shift) {
+    fbb_.AddElement<float>(PowFusion::VT_SHIFT, shift, 0.0f);
+  }
+  explicit PowFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<PowFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<PowFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<PowFusion> CreatePowFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float scale = 1.0f,
+    float shift = 0.0f) {
+  PowFusionBuilder builder_(_fbb);
+  builder_.add_shift(shift);
+  builder_.add_scale(scale);
+  return builder_.Finish();
+}
+
+struct PriorBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PriorBoxBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_MIN_SIZES = 4,
+    VT_MAX_SIZES = 6,
+    VT_ASPECT_RATIOS = 8,
+    VT_VARIANCES = 10,
+    VT_IMAGE_SIZE_W = 12,
+    VT_IMAGE_SIZE_H = 14,
+    VT_STEP_W = 16,
+    VT_STEP_H = 18,
+    VT_CLIP = 20,
+    VT_FLIP = 22,
+    VT_OFFSET = 24
+  };
+  const flatbuffers::Vector<int64_t> *min_sizes() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_MIN_SIZES);
+  }
+  const flatbuffers::Vector<int64_t> *max_sizes() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_MAX_SIZES);
+  }
+  const flatbuffers::Vector<float> *aspect_ratios() const {
+    return GetPointer<const flatbuffers::Vector<float> *>(VT_ASPECT_RATIOS);
+  }
+  const flatbuffers::Vector<float> *variances() const {
+    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARIANCES);
+  }
+  int64_t image_size_w() const {
+    return GetField<int64_t>(VT_IMAGE_SIZE_W, 0);
+  }
+  int64_t image_size_h() const {
+    return GetField<int64_t>(VT_IMAGE_SIZE_H, 0);
+  }
+  float step_w() const {
+    return GetField<float>(VT_STEP_W, 0.0f);
+  }
+  float step_h() const {
+    return GetField<float>(VT_STEP_H, 0.0f);
+  }
+  bool clip() const {
+    return GetField<uint8_t>(VT_CLIP, 0) != 0;
+  }
+  bool flip() const {
+    return GetField<uint8_t>(VT_FLIP, 0) != 0;
+  }
+  float offset() const {
+    return GetField<float>(VT_OFFSET, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_MIN_SIZES) &&
+           verifier.VerifyVector(min_sizes()) &&
+           VerifyOffset(verifier, VT_MAX_SIZES) &&
+           verifier.VerifyVector(max_sizes()) &&
+           VerifyOffset(verifier, VT_ASPECT_RATIOS) &&
+           verifier.VerifyVector(aspect_ratios()) &&
+           VerifyOffset(verifier, VT_VARIANCES) &&
+           verifier.VerifyVector(variances()) &&
+           VerifyField<int64_t>(verifier, VT_IMAGE_SIZE_W) &&
+           VerifyField<int64_t>(verifier, VT_IMAGE_SIZE_H) &&
+           VerifyField<float>(verifier, VT_STEP_W) &&
+           VerifyField<float>(verifier, VT_STEP_H) &&
+           VerifyField<uint8_t>(verifier, VT_CLIP) &&
+           VerifyField<uint8_t>(verifier, VT_FLIP) &&
+           VerifyField<float>(verifier, VT_OFFSET) &&
+           verifier.EndTable();
+  }
+};
+
+struct PriorBoxBuilder {
+  typedef PriorBox Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_min_sizes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> min_sizes) {
+    fbb_.AddOffset(PriorBox::VT_MIN_SIZES, min_sizes);
+  }
+  void add_max_sizes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> max_sizes) {
+    fbb_.AddOffset(PriorBox::VT_MAX_SIZES, max_sizes);
+  }
+  void add_aspect_ratios(flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios) {
+    fbb_.AddOffset(PriorBox::VT_ASPECT_RATIOS, aspect_ratios);
+  }
+  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
+    fbb_.AddOffset(PriorBox::VT_VARIANCES, variances);
+  }
+  void add_image_size_w(int64_t image_size_w) {
+    fbb_.AddElement<int64_t>(PriorBox::VT_IMAGE_SIZE_W, image_size_w, 0);
+  }
+  void add_image_size_h(int64_t image_size_h) {
+    fbb_.AddElement<int64_t>(PriorBox::VT_IMAGE_SIZE_H, image_size_h, 0);
+  }
+  void add_step_w(float step_w) {
+    fbb_.AddElement<float>(PriorBox::VT_STEP_W, step_w, 0.0f);
+  }
+  void add_step_h(float step_h) {
+    fbb_.AddElement<float>(PriorBox::VT_STEP_H, step_h, 0.0f);
+  }
+  void add_clip(bool clip) {
+    fbb_.AddElement<uint8_t>(PriorBox::VT_CLIP, static_cast<uint8_t>(clip), 0);
+  }
+  void add_flip(bool flip) {
+    fbb_.AddElement<uint8_t>(PriorBox::VT_FLIP, static_cast<uint8_t>(flip), 0);
+  }
+  void add_offset(float offset) {
+    fbb_.AddElement<float>(PriorBox::VT_OFFSET, offset, 0.0f);
+  }
+  explicit PriorBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<PriorBox> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<PriorBox>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<PriorBox> CreatePriorBox(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> min_sizes = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> max_sizes = 0,
+    flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios = 0,
+    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
+    int64_t image_size_w = 0,
+    int64_t image_size_h = 0,
+    float step_w = 0.0f,
+    float step_h = 0.0f,
+    bool clip = false,
+    bool flip = false,
+    float offset = 0.0f) {
+  PriorBoxBuilder builder_(_fbb);
+  builder_.add_image_size_h(image_size_h);
+  builder_.add_image_size_w(image_size_w);
+  builder_.add_offset(offset);
+  builder_.add_step_h(step_h);
+  builder_.add_step_w(step_w);
+  builder_.add_variances(variances);
+  builder_.add_aspect_ratios(aspect_ratios);
+  builder_.add_max_sizes(max_sizes);
+  builder_.add_min_sizes(min_sizes);
+  builder_.add_flip(flip);
+  builder_.add_clip(clip);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<PriorBox> CreatePriorBoxDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *min_sizes = nullptr,
+    const std::vector<int64_t> *max_sizes = nullptr,
+    const std::vector<float> *aspect_ratios = nullptr,
+    const std::vector<float> *variances = nullptr,
+    int64_t image_size_w = 0,
+    int64_t image_size_h = 0,
+    float step_w = 0.0f,
+    float step_h = 0.0f,
+    bool clip = false,
+    bool flip = false,
+    float offset = 0.0f) {
+  auto min_sizes__ = min_sizes ? _fbb.CreateVector<int64_t>(*min_sizes) : 0;
+  auto max_sizes__ = max_sizes ? _fbb.CreateVector<int64_t>(*max_sizes) : 0;
+  auto aspect_ratios__ = aspect_ratios ? _fbb.CreateVector<float>(*aspect_ratios) : 0;
+  auto variances__ = variances ? _fbb.CreateVector<float>(*variances) : 0;
+  return mindspore::schema::CreatePriorBox(
+      _fbb,
+      min_sizes__,
+      max_sizes__,
+      aspect_ratios__,
+      variances__,
+      image_size_w,
+      image_size_h,
+      step_w,
+      step_h,
+      clip,
+      flip,
+      offset);
+}
+
+struct PReLUFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef PReLUFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_CHANNEL_SHARED = 4
+  };
+  bool channel_shared() const {
+    return GetField<uint8_t>(VT_CHANNEL_SHARED, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_CHANNEL_SHARED) &&
+           verifier.EndTable();
+  }
+};
+
+struct PReLUFusionBuilder {
+  typedef PReLUFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_channel_shared(bool channel_shared) {
+    fbb_.AddElement<uint8_t>(PReLUFusion::VT_CHANNEL_SHARED, static_cast<uint8_t>(channel_shared), 0);
+  }
+  explicit PReLUFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<PReLUFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<PReLUFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<PReLUFusion> CreatePReLUFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool channel_shared = false) {
+  PReLUFusionBuilder builder_(_fbb);
+  builder_.add_channel_shared(channel_shared);
+  return builder_.Finish();
+}
+
+struct Rank FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RankBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct RankBuilder {
+  typedef Rank Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit RankBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Rank> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Rank>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Rank> CreateRank(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  RankBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Range FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RangeBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_D_TYPE = 4,
+    VT_START = 6,
+    VT_LIMIT = 8,
+    VT_DELTA = 10
+  };
+  int64_t d_type() const {
+    return GetField<int64_t>(VT_D_TYPE, 0);
+  }
+  int64_t start() const {
+    return GetField<int64_t>(VT_START, 0);
+  }
+  int64_t limit() const {
+    return GetField<int64_t>(VT_LIMIT, 0);
+  }
+  int64_t delta() const {
+    return GetField<int64_t>(VT_DELTA, 1LL);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_D_TYPE) &&
+           VerifyField<int64_t>(verifier, VT_START) &&
+           VerifyField<int64_t>(verifier, VT_LIMIT) &&
+           VerifyField<int64_t>(verifier, VT_DELTA) &&
+           verifier.EndTable();
+  }
+};
+
+struct RangeBuilder {
+  typedef Range Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_d_type(int64_t d_type) {
+    fbb_.AddElement<int64_t>(Range::VT_D_TYPE, d_type, 0);
+  }
+  void add_start(int64_t start) {
+    fbb_.AddElement<int64_t>(Range::VT_START, start, 0);
+  }
+  void add_limit(int64_t limit) {
+    fbb_.AddElement<int64_t>(Range::VT_LIMIT, limit, 0);
+  }
+  void add_delta(int64_t delta) {
+    fbb_.AddElement<int64_t>(Range::VT_DELTA, delta, 1LL);
+  }
+  explicit RangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Range> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Range>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Range> CreateRange(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t d_type = 0,
+    int64_t start = 0,
+    int64_t limit = 0,
+    int64_t delta = 1LL) {
+  RangeBuilder builder_(_fbb);
+  builder_.add_delta(delta);
+  builder_.add_limit(limit);
+  builder_.add_start(start);
+  builder_.add_d_type(d_type);
+  return builder_.Finish();
+}
+
+struct Reciprocal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ReciprocalBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct ReciprocalBuilder {
+  typedef Reciprocal Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ReciprocalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Reciprocal> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Reciprocal>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Reciprocal> CreateReciprocal(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ReciprocalBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct RealDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RealDivBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct RealDivBuilder {
+  typedef RealDiv Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit RealDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<RealDiv> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<RealDiv>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<RealDiv> CreateRealDiv(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  RealDivBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct ReduceFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ReduceFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_KEEP_DIMS = 4,
+    VT_MODE = 6,
+    VT_REDUCE_TO_END = 8,
+    VT_COEFF = 10
+  };
+  bool keep_dims() const {
+    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
+  }
+  mindspore::schema::ReduceMode mode() const {
+    return static_cast<mindspore::schema::ReduceMode>(GetField<int8_t>(VT_MODE, 0));
+  }
+  bool reduce_to_end() const {
+    return GetField<uint8_t>(VT_REDUCE_TO_END, 0) != 0;
+  }
+  float coeff() const {
+    return GetField<float>(VT_COEFF, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
+           VerifyField<int8_t>(verifier, VT_MODE) &&
+           VerifyField<uint8_t>(verifier, VT_REDUCE_TO_END) &&
+           VerifyField<float>(verifier, VT_COEFF) &&
+           verifier.EndTable();
+  }
+};
+
+struct ReduceFusionBuilder {
+  typedef ReduceFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_keep_dims(bool keep_dims) {
+    fbb_.AddElement<uint8_t>(ReduceFusion::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
+  }
+  void add_mode(mindspore::schema::ReduceMode mode) {
+    fbb_.AddElement<int8_t>(ReduceFusion::VT_MODE, static_cast<int8_t>(mode), 0);
+  }
+  void add_reduce_to_end(bool reduce_to_end) {
+    fbb_.AddElement<uint8_t>(ReduceFusion::VT_REDUCE_TO_END, static_cast<uint8_t>(reduce_to_end), 0);
+  }
+  void add_coeff(float coeff) {
+    fbb_.AddElement<float>(ReduceFusion::VT_COEFF, coeff, 0.0f);
+  }
+  explicit ReduceFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ReduceFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ReduceFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ReduceFusion> CreateReduceFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool keep_dims = false,
+    mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean,
+    bool reduce_to_end = false,
+    float coeff = 0.0f) {
+  ReduceFusionBuilder builder_(_fbb);
+  builder_.add_coeff(coeff);
+  builder_.add_reduce_to_end(reduce_to_end);
+  builder_.add_mode(mode);
+  builder_.add_keep_dims(keep_dims);
+  return builder_.Finish();
+}
+
+struct Reshape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ReshapeBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct ReshapeBuilder {
+  typedef Reshape Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ReshapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Reshape> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Reshape>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Reshape> CreateReshape(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ReshapeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Resize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ResizeBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FORMAT = 4,
+    VT_METHOD = 6,
+    VT_NEW_HEIGHT = 8,
+    VT_NEW_WIDTH = 10,
+    VT_PRESERVE_ASPECT_RATIO = 12,
+    VT_COORDINATE_TRANSFORM_MODE = 14,
+    VT_CUBIC_COEFF = 16,
+    VT_EXCLUDE_OUTSIDE = 18,
+    VT_EXTRAPOLATION_VALUE = 20,
+    VT_NEAREST_MODE = 22
+  };
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  mindspore::schema::ResizeMethod method() const {
+    return static_cast<mindspore::schema::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
+  }
+  int64_t new_height() const {
+    return GetField<int64_t>(VT_NEW_HEIGHT, 0);
+  }
+  int64_t new_width() const {
+    return GetField<int64_t>(VT_NEW_WIDTH, 0);
+  }
+  bool preserve_aspect_ratio() const {
+    return GetField<uint8_t>(VT_PRESERVE_ASPECT_RATIO, 0) != 0;
+  }
+  mindspore::schema::CoordinateTransformMode coordinate_transform_mode() const {
+    return static_cast<mindspore::schema::CoordinateTransformMode>(GetField<int8_t>(VT_COORDINATE_TRANSFORM_MODE, 0));
+  }
+  float cubic_coeff() const {
+    return GetField<float>(VT_CUBIC_COEFF, 0.0f);
+  }
+  int64_t exclude_outside() const {
+    return GetField<int64_t>(VT_EXCLUDE_OUTSIDE, 0);
+  }
+  float extrapolation_value() const {
+    return GetField<float>(VT_EXTRAPOLATION_VALUE, 0.0f);
+  }
+  mindspore::schema::NearestMode nearest_mode() const {
+    return static_cast<mindspore::schema::NearestMode>(GetField<int8_t>(VT_NEAREST_MODE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyField<int8_t>(verifier, VT_METHOD) &&
+           VerifyField<int64_t>(verifier, VT_NEW_HEIGHT) &&
+           VerifyField<int64_t>(verifier, VT_NEW_WIDTH) &&
+           VerifyField<uint8_t>(verifier, VT_PRESERVE_ASPECT_RATIO) &&
+           VerifyField<int8_t>(verifier, VT_COORDINATE_TRANSFORM_MODE) &&
+           VerifyField<float>(verifier, VT_CUBIC_COEFF) &&
+           VerifyField<int64_t>(verifier, VT_EXCLUDE_OUTSIDE) &&
+           VerifyField<float>(verifier, VT_EXTRAPOLATION_VALUE) &&
+           VerifyField<int8_t>(verifier, VT_NEAREST_MODE) &&
+           verifier.EndTable();
+  }
+};
+
+struct ResizeBuilder {
+  typedef Resize Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(Resize::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_method(mindspore::schema::ResizeMethod method) {
+    fbb_.AddElement<int8_t>(Resize::VT_METHOD, static_cast<int8_t>(method), 0);
+  }
+  void add_new_height(int64_t new_height) {
+    fbb_.AddElement<int64_t>(Resize::VT_NEW_HEIGHT, new_height, 0);
+  }
+  void add_new_width(int64_t new_width) {
+    fbb_.AddElement<int64_t>(Resize::VT_NEW_WIDTH, new_width, 0);
+  }
+  void add_preserve_aspect_ratio(bool preserve_aspect_ratio) {
+    fbb_.AddElement<uint8_t>(Resize::VT_PRESERVE_ASPECT_RATIO, static_cast<uint8_t>(preserve_aspect_ratio), 0);
+  }
+  void add_coordinate_transform_mode(mindspore::schema::CoordinateTransformMode coordinate_transform_mode) {
+    fbb_.AddElement<int8_t>(Resize::VT_COORDINATE_TRANSFORM_MODE, static_cast<int8_t>(coordinate_transform_mode), 0);
+  }
+  void add_cubic_coeff(float cubic_coeff) {
+    fbb_.AddElement<float>(Resize::VT_CUBIC_COEFF, cubic_coeff, 0.0f);
+  }
+  void add_exclude_outside(int64_t exclude_outside) {
+    fbb_.AddElement<int64_t>(Resize::VT_EXCLUDE_OUTSIDE, exclude_outside, 0);
+  }
+  void add_extrapolation_value(float extrapolation_value) {
+    fbb_.AddElement<float>(Resize::VT_EXTRAPOLATION_VALUE, extrapolation_value, 0.0f);
+  }
+  void add_nearest_mode(mindspore::schema::NearestMode nearest_mode) {
+    fbb_.AddElement<int8_t>(Resize::VT_NEAREST_MODE, static_cast<int8_t>(nearest_mode), 0);
+  }
+  explicit ResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Resize> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Resize>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Resize> CreateResize(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR,
+    int64_t new_height = 0,
+    int64_t new_width = 0,
+    bool preserve_aspect_ratio = false,
+    mindspore::schema::CoordinateTransformMode coordinate_transform_mode = mindspore::schema::CoordinateTransformMode_ASYMMETRIC,
+    float cubic_coeff = 0.0f,
+    int64_t exclude_outside = 0,
+    float extrapolation_value = 0.0f,
+    mindspore::schema::NearestMode nearest_mode = mindspore::schema::NearestMode_NORMAL) {
+  ResizeBuilder builder_(_fbb);
+  builder_.add_exclude_outside(exclude_outside);
+  builder_.add_new_width(new_width);
+  builder_.add_new_height(new_height);
+  builder_.add_extrapolation_value(extrapolation_value);
+  builder_.add_cubic_coeff(cubic_coeff);
+  builder_.add_format(format);
+  builder_.add_nearest_mode(nearest_mode);
+  builder_.add_coordinate_transform_mode(coordinate_transform_mode);
+  builder_.add_preserve_aspect_ratio(preserve_aspect_ratio);
+  builder_.add_method(method);
+  return builder_.Finish();
+}
+
+struct ReverseSequence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ReverseSequenceBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SEQ_DIM = 4,
+    VT_BATCH_DIM = 6
+  };
+  int64_t seq_dim() const {
+    return GetField<int64_t>(VT_SEQ_DIM, 0);
+  }
+  int64_t batch_dim() const {
+    return GetField<int64_t>(VT_BATCH_DIM, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SEQ_DIM) &&
+           VerifyField<int64_t>(verifier, VT_BATCH_DIM) &&
+           verifier.EndTable();
+  }
+};
+
+struct ReverseSequenceBuilder {
+  typedef ReverseSequence Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_seq_dim(int64_t seq_dim) {
+    fbb_.AddElement<int64_t>(ReverseSequence::VT_SEQ_DIM, seq_dim, 0);
+  }
+  void add_batch_dim(int64_t batch_dim) {
+    fbb_.AddElement<int64_t>(ReverseSequence::VT_BATCH_DIM, batch_dim, 0);
+  }
+  explicit ReverseSequenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ReverseSequence> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ReverseSequence>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ReverseSequence> CreateReverseSequence(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t seq_dim = 0,
+    int64_t batch_dim = 0) {
+  ReverseSequenceBuilder builder_(_fbb);
+  builder_.add_batch_dim(batch_dim);
+  builder_.add_seq_dim(seq_dim);
+  return builder_.Finish();
+}
+
+struct ReverseV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ReverseV2Builder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  const flatbuffers::Vector<int64_t> *axis() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_AXIS) &&
+           verifier.VerifyVector(axis()) &&
+           verifier.EndTable();
+  }
+};
+
+struct ReverseV2Builder {
+  typedef ReverseV2 Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
+    fbb_.AddOffset(ReverseV2::VT_AXIS, axis);
+  }
+  explicit ReverseV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ReverseV2> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ReverseV2>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ReverseV2> CreateReverseV2(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
+  ReverseV2Builder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<ReverseV2> CreateReverseV2Direct(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *axis = nullptr) {
+  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
+  return mindspore::schema::CreateReverseV2(
+      _fbb,
+      axis__);
+}
+
+struct Rfft FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RfftBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FFT_LENGTH = 4
+  };
+  int64_t fft_length() const {
+    return GetField<int64_t>(VT_FFT_LENGTH, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_FFT_LENGTH) &&
+           verifier.EndTable();
+  }
+};
+
+struct RfftBuilder {
+  typedef Rfft Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_fft_length(int64_t fft_length) {
+    fbb_.AddElement<int64_t>(Rfft::VT_FFT_LENGTH, fft_length, 0);
+  }
+  explicit RfftBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Rfft> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Rfft>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Rfft> CreateRfft(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t fft_length = 0) {
+  RfftBuilder builder_(_fbb);
+  builder_.add_fft_length(fft_length);
+  return builder_.Finish();
+}
+
+struct ROIPooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ROIPoolingBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_POOLED_H = 4,
+    VT_POOLED_W = 6,
+    VT_SCALE = 8
+  };
+  int64_t pooled_h() const {
+    return GetField<int64_t>(VT_POOLED_H, 0);
+  }
+  int64_t pooled_w() const {
+    return GetField<int64_t>(VT_POOLED_W, 0);
+  }
+  float scale() const {
+    return GetField<float>(VT_SCALE, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_POOLED_H) &&
+           VerifyField<int64_t>(verifier, VT_POOLED_W) &&
+           VerifyField<float>(verifier, VT_SCALE) &&
+           verifier.EndTable();
+  }
+};
+
+struct ROIPoolingBuilder {
+  typedef ROIPooling Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_pooled_h(int64_t pooled_h) {
+    fbb_.AddElement<int64_t>(ROIPooling::VT_POOLED_H, pooled_h, 0);
+  }
+  void add_pooled_w(int64_t pooled_w) {
+    fbb_.AddElement<int64_t>(ROIPooling::VT_POOLED_W, pooled_w, 0);
+  }
+  void add_scale(float scale) {
+    fbb_.AddElement<float>(ROIPooling::VT_SCALE, scale, 0.0f);
+  }
+  explicit ROIPoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ROIPooling> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ROIPooling>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ROIPooling> CreateROIPooling(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t pooled_h = 0,
+    int64_t pooled_w = 0,
+    float scale = 0.0f) {
+  ROIPoolingBuilder builder_(_fbb);
+  builder_.add_pooled_w(pooled_w);
+  builder_.add_pooled_h(pooled_h);
+  builder_.add_scale(scale);
+  return builder_.Finish();
+}
+
+struct Round FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RoundBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct RoundBuilder {
+  typedef Round Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit RoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Round> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Round>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Round> CreateRound(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  RoundBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Rsqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RsqrtBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct RsqrtBuilder {
+  typedef Rsqrt Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit RsqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Rsqrt> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Rsqrt>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Rsqrt> CreateRsqrt(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  RsqrtBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct QuantDTypeCast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef QuantDTypeCastBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SRC_T = 4,
+    VT_DST_T = 6
+  };
+  int64_t src_t() const {
+    return GetField<int64_t>(VT_SRC_T, 0);
+  }
+  int64_t dst_t() const {
+    return GetField<int64_t>(VT_DST_T, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SRC_T) &&
+           VerifyField<int64_t>(verifier, VT_DST_T) &&
+           verifier.EndTable();
+  }
+};
+
+struct QuantDTypeCastBuilder {
+  typedef QuantDTypeCast Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_src_t(int64_t src_t) {
+    fbb_.AddElement<int64_t>(QuantDTypeCast::VT_SRC_T, src_t, 0);
+  }
+  void add_dst_t(int64_t dst_t) {
+    fbb_.AddElement<int64_t>(QuantDTypeCast::VT_DST_T, dst_t, 0);
+  }
+  explicit QuantDTypeCastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<QuantDTypeCast> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<QuantDTypeCast>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t src_t = 0,
+    int64_t dst_t = 0) {
+  QuantDTypeCastBuilder builder_(_fbb);
+  builder_.add_dst_t(dst_t);
+  builder_.add_src_t(src_t);
+  return builder_.Finish();
+}
+
+struct ScaleFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ScaleFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4,
+    VT_ACTIVATION_TYPE = 6
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct ScaleFusionBuilder {
+  typedef ScaleFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(ScaleFusion::VT_AXIS, axis, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(ScaleFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit ScaleFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ScaleFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ScaleFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ScaleFusion> CreateScaleFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  ScaleFusionBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+struct ScatterNd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ScatterNdBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct ScatterNdBuilder {
+  typedef ScatterNd Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ScatterNdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ScatterNd> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ScatterNd>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ScatterNd> CreateScatterNd(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ScatterNdBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct SGD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SGDBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NESTEROV = 4,
+    VT_DAMPENING = 6,
+    VT_WEIGHT_DECAY = 8
+  };
+  bool nesterov() const {
+    return GetField<uint8_t>(VT_NESTEROV, 0) != 0;
+  }
+  float dampening() const {
+    return GetField<float>(VT_DAMPENING, 0.0f);
+  }
+  float weight_decay() const {
+    return GetField<float>(VT_WEIGHT_DECAY, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_NESTEROV) &&
+           VerifyField<float>(verifier, VT_DAMPENING) &&
+           VerifyField<float>(verifier, VT_WEIGHT_DECAY) &&
+           verifier.EndTable();
+  }
+};
+
+struct SGDBuilder {
+  typedef SGD Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_nesterov(bool nesterov) {
+    fbb_.AddElement<uint8_t>(SGD::VT_NESTEROV, static_cast<uint8_t>(nesterov), 0);
+  }
+  void add_dampening(float dampening) {
+    fbb_.AddElement<float>(SGD::VT_DAMPENING, dampening, 0.0f);
+  }
+  void add_weight_decay(float weight_decay) {
+    fbb_.AddElement<float>(SGD::VT_WEIGHT_DECAY, weight_decay, 0.0f);
+  }
+  explicit SGDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SGD> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SGD>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SGD> CreateSGD(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool nesterov = false,
+    float dampening = 0.0f,
+    float weight_decay = 0.0f) {
+  SGDBuilder builder_(_fbb);
+  builder_.add_weight_decay(weight_decay);
+  builder_.add_dampening(dampening);
+  builder_.add_nesterov(nesterov);
+  return builder_.Finish();
+}
+
+struct Shape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ShapeBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct ShapeBuilder {
+  typedef Shape Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Shape> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Shape>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Shape> CreateShape(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ShapeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct SigmoidCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SigmoidCrossEntropyWithLogitsBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SigmoidCrossEntropyWithLogitsBuilder {
+  typedef SigmoidCrossEntropyWithLogits Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SigmoidCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SigmoidCrossEntropyWithLogits> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SigmoidCrossEntropyWithLogits>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SigmoidCrossEntropyWithLogits> CreateSigmoidCrossEntropyWithLogits(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SigmoidCrossEntropyWithLogitsBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct SigmoidCrossEntropyWithLogitsGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SigmoidCrossEntropyWithLogitsGradBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SigmoidCrossEntropyWithLogitsGradBuilder {
+  typedef SigmoidCrossEntropyWithLogitsGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SigmoidCrossEntropyWithLogitsGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> CreateSigmoidCrossEntropyWithLogitsGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SigmoidCrossEntropyWithLogitsGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Sin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SinBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SinBuilder {
+  typedef Sin Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Sin> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Sin>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Sin> CreateSin(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SinBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct SkipGram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SkipGramBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_INCLUDE_ALL_GRAMS = 4,
+    VT_MAX_SKIP_SIZE = 6,
+    VT_NGRAM_SIZE = 8
+  };
+  bool include_all_grams() const {
+    return GetField<uint8_t>(VT_INCLUDE_ALL_GRAMS, 0) != 0;
+  }
+  int64_t max_skip_size() const {
+    return GetField<int64_t>(VT_MAX_SKIP_SIZE, 0);
+  }
+  int64_t ngram_size() const {
+    return GetField<int64_t>(VT_NGRAM_SIZE, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_GRAMS) &&
+           VerifyField<int64_t>(verifier, VT_MAX_SKIP_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_NGRAM_SIZE) &&
+           verifier.EndTable();
+  }
+};
+
+struct SkipGramBuilder {
+  typedef SkipGram Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_include_all_grams(bool include_all_grams) {
+    fbb_.AddElement<uint8_t>(SkipGram::VT_INCLUDE_ALL_GRAMS, static_cast<uint8_t>(include_all_grams), 0);
+  }
+  void add_max_skip_size(int64_t max_skip_size) {
+    fbb_.AddElement<int64_t>(SkipGram::VT_MAX_SKIP_SIZE, max_skip_size, 0);
+  }
+  void add_ngram_size(int64_t ngram_size) {
+    fbb_.AddElement<int64_t>(SkipGram::VT_NGRAM_SIZE, ngram_size, 0);
+  }
+  explicit SkipGramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SkipGram> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SkipGram>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SkipGram> CreateSkipGram(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool include_all_grams = false,
+    int64_t max_skip_size = 0,
+    int64_t ngram_size = 0) {
+  SkipGramBuilder builder_(_fbb);
+  builder_.add_ngram_size(ngram_size);
+  builder_.add_max_skip_size(max_skip_size);
+  builder_.add_include_all_grams(include_all_grams);
+  return builder_.Finish();
+}
+
+struct SliceFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SliceFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXES = 4
+  };
+  const flatbuffers::Vector<int64_t> *axes() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXES);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_AXES) &&
+           verifier.VerifyVector(axes()) &&
+           verifier.EndTable();
+  }
+};
+
+struct SliceFusionBuilder {
+  typedef SliceFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes) {
+    fbb_.AddOffset(SliceFusion::VT_AXES, axes);
+  }
+  explicit SliceFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SliceFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SliceFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SliceFusion> CreateSliceFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes = 0) {
+  SliceFusionBuilder builder_(_fbb);
+  builder_.add_axes(axes);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<SliceFusion> CreateSliceFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *axes = nullptr) {
+  auto axes__ = axes ? _fbb.CreateVector<int64_t>(*axes) : 0;
+  return mindspore::schema::CreateSliceFusion(
+      _fbb,
+      axes__);
+}
+
+struct SmoothL1Loss FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SmoothL1LossBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BETA = 4
+  };
+  float beta() const {
+    return GetField<float>(VT_BETA, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_BETA) &&
+           verifier.EndTable();
+  }
+};
+
+struct SmoothL1LossBuilder {
+  typedef SmoothL1Loss Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_beta(float beta) {
+    fbb_.AddElement<float>(SmoothL1Loss::VT_BETA, beta, 0.0f);
+  }
+  explicit SmoothL1LossBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SmoothL1Loss> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SmoothL1Loss>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SmoothL1Loss> CreateSmoothL1Loss(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float beta = 0.0f) {
+  SmoothL1LossBuilder builder_(_fbb);
+  builder_.add_beta(beta);
+  return builder_.Finish();
+}
+
+struct SmoothL1LossGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SmoothL1LossGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BETA = 4
+  };
+  float beta() const {
+    return GetField<float>(VT_BETA, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_BETA) &&
+           verifier.EndTable();
+  }
+};
+
+struct SmoothL1LossGradBuilder {
+  typedef SmoothL1LossGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_beta(float beta) {
+    fbb_.AddElement<float>(SmoothL1LossGrad::VT_BETA, beta, 0.0f);
+  }
+  explicit SmoothL1LossGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SmoothL1LossGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SmoothL1LossGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SmoothL1LossGrad> CreateSmoothL1LossGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float beta = 0.0f) {
+  SmoothL1LossGradBuilder builder_(_fbb);
+  builder_.add_beta(beta);
+  return builder_.Finish();
+}
+
+struct Softmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SoftmaxBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  const flatbuffers::Vector<int64_t> *axis() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_AXIS) &&
+           verifier.VerifyVector(axis()) &&
+           verifier.EndTable();
+  }
+};
+
+struct SoftmaxBuilder {
+  typedef Softmax Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
+    fbb_.AddOffset(Softmax::VT_AXIS, axis);
+  }
+  explicit SoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Softmax> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Softmax>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Softmax> CreateSoftmax(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
+  SoftmaxBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Softmax> CreateSoftmaxDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *axis = nullptr) {
+  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
+  return mindspore::schema::CreateSoftmax(
+      _fbb,
+      axis__);
+}
+
+struct SoftmaxCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SoftmaxCrossEntropyWithLogitsBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SoftmaxCrossEntropyWithLogitsBuilder {
+  typedef SoftmaxCrossEntropyWithLogits Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SoftmaxCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SoftmaxCrossEntropyWithLogits>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> CreateSoftmaxCrossEntropyWithLogits(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SoftmaxCrossEntropyWithLogitsBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct SpaceToBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SpaceToBatchBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BLOCK_SIZE = 4,
+    VT_PADDINGS = 6
+  };
+  const flatbuffers::Vector<int64_t> *block_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SIZE);
+  }
+  const mindspore::schema::Vec2D *paddings() const {
+    return GetPointer<const mindspore::schema::Vec2D *>(VT_PADDINGS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_BLOCK_SIZE) &&
+           verifier.VerifyVector(block_size()) &&
+           VerifyOffset(verifier, VT_PADDINGS) &&
+           verifier.VerifyTable(paddings()) &&
+           verifier.EndTable();
+  }
+};
+
+struct SpaceToBatchBuilder {
+  typedef SpaceToBatch Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_block_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size) {
+    fbb_.AddOffset(SpaceToBatch::VT_BLOCK_SIZE, block_size);
+  }
+  void add_paddings(flatbuffers::Offset<mindspore::schema::Vec2D> paddings) {
+    fbb_.AddOffset(SpaceToBatch::VT_PADDINGS, paddings);
+  }
+  explicit SpaceToBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SpaceToBatch> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SpaceToBatch>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size = 0,
+    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
+  SpaceToBatchBuilder builder_(_fbb);
+  builder_.add_paddings(paddings);
+  builder_.add_block_size(block_size);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatchDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *block_size = nullptr,
+    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
+  auto block_size__ = block_size ? _fbb.CreateVector<int64_t>(*block_size) : 0;
+  return mindspore::schema::CreateSpaceToBatch(
+      _fbb,
+      block_size__,
+      paddings);
+}
+
+struct SpaceToBatchND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SpaceToBatchNDBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BLOCK_SHAPE = 4,
+    VT_PADDINGS = 6
+  };
+  const flatbuffers::Vector<int64_t> *block_shape() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SHAPE);
+  }
+  const mindspore::schema::Vec2D *paddings() const {
+    return GetPointer<const mindspore::schema::Vec2D *>(VT_PADDINGS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_BLOCK_SHAPE) &&
+           verifier.VerifyVector(block_shape()) &&
+           VerifyOffset(verifier, VT_PADDINGS) &&
+           verifier.VerifyTable(paddings()) &&
+           verifier.EndTable();
+  }
+};
+
+struct SpaceToBatchNDBuilder {
+  typedef SpaceToBatchND Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_block_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape) {
+    fbb_.AddOffset(SpaceToBatchND::VT_BLOCK_SHAPE, block_shape);
+  }
+  void add_paddings(flatbuffers::Offset<mindspore::schema::Vec2D> paddings) {
+    fbb_.AddOffset(SpaceToBatchND::VT_PADDINGS, paddings);
+  }
+  explicit SpaceToBatchNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SpaceToBatchND> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SpaceToBatchND>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape = 0,
+    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
+  SpaceToBatchNDBuilder builder_(_fbb);
+  builder_.add_paddings(paddings);
+  builder_.add_block_shape(block_shape);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchNDDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *block_shape = nullptr,
+    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
+  auto block_shape__ = block_shape ? _fbb.CreateVector<int64_t>(*block_shape) : 0;
+  return mindspore::schema::CreateSpaceToBatchND(
+      _fbb,
+      block_shape__,
+      paddings);
+}
+
+struct SpaceToDepth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SpaceToDepthBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BLOCK_SIZE = 4,
+    VT_FORMAT = 6
+  };
+  int64_t block_size() const {
+    return GetField<int64_t>(VT_BLOCK_SIZE, 0);
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_BLOCK_SIZE) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           verifier.EndTable();
+  }
+};
+
+struct SpaceToDepthBuilder {
+  typedef SpaceToDepth Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_block_size(int64_t block_size) {
+    fbb_.AddElement<int64_t>(SpaceToDepth::VT_BLOCK_SIZE, block_size, 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(SpaceToDepth::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  explicit SpaceToDepthBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SpaceToDepth> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SpaceToDepth>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t block_size = 0,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
+  SpaceToDepthBuilder builder_(_fbb);
+  builder_.add_block_size(block_size);
+  builder_.add_format(format);
+  return builder_.Finish();
+}
+
+struct SparseSoftmaxCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SparseSoftmaxCrossEntropyWithLogitsBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_IS_GRAD = 4
+  };
+  bool is_grad() const {
+    return GetField<uint8_t>(VT_IS_GRAD, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_IS_GRAD) &&
+           verifier.EndTable();
+  }
+};
+
+struct SparseSoftmaxCrossEntropyWithLogitsBuilder {
+  typedef SparseSoftmaxCrossEntropyWithLogits Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_is_grad(bool is_grad) {
+    fbb_.AddElement<uint8_t>(SparseSoftmaxCrossEntropyWithLogits::VT_IS_GRAD, static_cast<uint8_t>(is_grad), 0);
+  }
+  explicit SparseSoftmaxCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> CreateSparseSoftmaxCrossEntropyWithLogits(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool is_grad = false) {
+  SparseSoftmaxCrossEntropyWithLogitsBuilder builder_(_fbb);
+  builder_.add_is_grad(is_grad);
+  return builder_.Finish();
+}
+
+struct SparseToDense FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SparseToDenseBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SparseToDenseBuilder {
+  typedef SparseToDense Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SparseToDenseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SparseToDense> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SparseToDense>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SparseToDense> CreateSparseToDense(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SparseToDenseBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Split FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SplitBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_OUTPUT_NUM = 4,
+    VT_SIZE_SPLITS = 6,
+    VT_AXIS = 8
+  };
+  int64_t output_num() const {
+    return GetField<int64_t>(VT_OUTPUT_NUM, 0);
+  }
+  const flatbuffers::Vector<int64_t> *size_splits() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SIZE_SPLITS);
+  }
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_OUTPUT_NUM) &&
+           VerifyOffset(verifier, VT_SIZE_SPLITS) &&
+           verifier.VerifyVector(size_splits()) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+};
+
+struct SplitBuilder {
+  typedef Split Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_output_num(int64_t output_num) {
+    fbb_.AddElement<int64_t>(Split::VT_OUTPUT_NUM, output_num, 0);
+  }
+  void add_size_splits(flatbuffers::Offset<flatbuffers::Vector<int64_t>> size_splits) {
+    fbb_.AddOffset(Split::VT_SIZE_SPLITS, size_splits);
+  }
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(Split::VT_AXIS, axis, 0);
+  }
+  explicit SplitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Split> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Split>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Split> CreateSplit(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t output_num = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> size_splits = 0,
+    int64_t axis = 0) {
+  SplitBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  builder_.add_output_num(output_num);
+  builder_.add_size_splits(size_splits);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Split> CreateSplitDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t output_num = 0,
+    const std::vector<int64_t> *size_splits = nullptr,
+    int64_t axis = 0) {
+  auto size_splits__ = size_splits ? _fbb.CreateVector<int64_t>(*size_splits) : 0;
+  return mindspore::schema::CreateSplit(
+      _fbb,
+      output_num,
+      size_splits__,
+      axis);
+}
+
+struct Sqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SqrtBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SqrtBuilder {
+  typedef Sqrt Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Sqrt> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Sqrt>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Sqrt> CreateSqrt(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SqrtBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Squeeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SqueezeBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  const flatbuffers::Vector<int64_t> *axis() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_AXIS) &&
+           verifier.VerifyVector(axis()) &&
+           verifier.EndTable();
+  }
+};
+
+struct SqueezeBuilder {
+  typedef Squeeze Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
+    fbb_.AddOffset(Squeeze::VT_AXIS, axis);
+  }
+  explicit SqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Squeeze> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Squeeze>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Squeeze> CreateSqueeze(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
+  SqueezeBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Squeeze> CreateSqueezeDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *axis = nullptr) {
+  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
+  return mindspore::schema::CreateSqueeze(
+      _fbb,
+      axis__);
+}
+
+struct Square FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SquareBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SquareBuilder {
+  typedef Square Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SquareBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Square> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Square>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Square> CreateSquare(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SquareBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct SquaredDifference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SquaredDifferenceBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SquaredDifferenceBuilder {
+  typedef SquaredDifference Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SquaredDifferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SquaredDifference> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SquaredDifference>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SquaredDifferenceBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Stack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef StackBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+};
+
+struct StackBuilder {
+  typedef Stack Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(Stack::VT_AXIS, axis, 0);
+  }
+  explicit StackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Stack> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Stack>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Stack> CreateStack(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0) {
+  StackBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+struct StridedSlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef StridedSliceBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BEGIN_MASK = 4,
+    VT_END_MASK = 6,
+    VT_ELLIPSIS_MASK = 8,
+    VT_NEW_AXIS_MASK = 10,
+    VT_SHRINK_AXIS_MASK = 12
+  };
+  int64_t begin_mask() const {
+    return GetField<int64_t>(VT_BEGIN_MASK, 0);
+  }
+  int64_t end_mask() const {
+    return GetField<int64_t>(VT_END_MASK, 0);
+  }
+  int64_t ellipsis_mask() const {
+    return GetField<int64_t>(VT_ELLIPSIS_MASK, 0);
+  }
+  int64_t new_axis_mask() const {
+    return GetField<int64_t>(VT_NEW_AXIS_MASK, 0);
+  }
+  int64_t shrink_axis_mask() const {
+    return GetField<int64_t>(VT_SHRINK_AXIS_MASK, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_BEGIN_MASK) &&
+           VerifyField<int64_t>(verifier, VT_END_MASK) &&
+           VerifyField<int64_t>(verifier, VT_ELLIPSIS_MASK) &&
+           VerifyField<int64_t>(verifier, VT_NEW_AXIS_MASK) &&
+           VerifyField<int64_t>(verifier, VT_SHRINK_AXIS_MASK) &&
+           verifier.EndTable();
+  }
+};
+
+struct StridedSliceBuilder {
+  typedef StridedSlice Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_begin_mask(int64_t begin_mask) {
+    fbb_.AddElement<int64_t>(StridedSlice::VT_BEGIN_MASK, begin_mask, 0);
+  }
+  void add_end_mask(int64_t end_mask) {
+    fbb_.AddElement<int64_t>(StridedSlice::VT_END_MASK, end_mask, 0);
+  }
+  void add_ellipsis_mask(int64_t ellipsis_mask) {
+    fbb_.AddElement<int64_t>(StridedSlice::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
+  }
+  void add_new_axis_mask(int64_t new_axis_mask) {
+    fbb_.AddElement<int64_t>(StridedSlice::VT_NEW_AXIS_MASK, new_axis_mask, 0);
+  }
+  void add_shrink_axis_mask(int64_t shrink_axis_mask) {
+    fbb_.AddElement<int64_t>(StridedSlice::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
+  }
+  explicit StridedSliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<StridedSlice> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<StridedSlice>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<StridedSlice> CreateStridedSlice(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t begin_mask = 0,
+    int64_t end_mask = 0,
+    int64_t ellipsis_mask = 0,
+    int64_t new_axis_mask = 0,
+    int64_t shrink_axis_mask = 0) {
+  StridedSliceBuilder builder_(_fbb);
+  builder_.add_shrink_axis_mask(shrink_axis_mask);
+  builder_.add_new_axis_mask(new_axis_mask);
+  builder_.add_ellipsis_mask(ellipsis_mask);
+  builder_.add_end_mask(end_mask);
+  builder_.add_begin_mask(begin_mask);
+  return builder_.Finish();
+}
+
+struct SubFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SubFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct SubFusionBuilder {
+  typedef SubFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(SubFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  explicit SubFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SubFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SubFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SubFusion> CreateSubFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
+  SubFusionBuilder builder_(_fbb);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+struct SubGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SubGradBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SubGradBuilder {
+  typedef SubGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SubGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SubGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SubGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SubGrad> CreateSubGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SubGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Switch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SwitchBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SwitchBuilder {
+  typedef Switch Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SwitchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Switch> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Switch>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Switch> CreateSwitch(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SwitchBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct TensorListFromTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorListFromTensorBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ELEMENT_DTYPE = 4,
+    VT_SHAPE_TYPE = 6
+  };
+  int64_t element_dtype() const {
+    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
+  }
+  int64_t shape_type() const {
+    return GetField<int64_t>(VT_SHAPE_TYPE, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
+           VerifyField<int64_t>(verifier, VT_SHAPE_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct TensorListFromTensorBuilder {
+  typedef TensorListFromTensor Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_element_dtype(int64_t element_dtype) {
+    fbb_.AddElement<int64_t>(TensorListFromTensor::VT_ELEMENT_DTYPE, element_dtype, 0);
+  }
+  void add_shape_type(int64_t shape_type) {
+    fbb_.AddElement<int64_t>(TensorListFromTensor::VT_SHAPE_TYPE, shape_type, 0);
+  }
+  explicit TensorListFromTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorListFromTensor> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorListFromTensor>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorListFromTensor> CreateTensorListFromTensor(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t element_dtype = 0,
+    int64_t shape_type = 0) {
+  TensorListFromTensorBuilder builder_(_fbb);
+  builder_.add_shape_type(shape_type);
+  builder_.add_element_dtype(element_dtype);
+  return builder_.Finish();
+}
+
+struct TensorListGetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorListGetItemBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ELEMENT_DTYPE = 4
+  };
+  int64_t element_dtype() const {
+    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct TensorListGetItemBuilder {
+  typedef TensorListGetItem Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_element_dtype(int64_t element_dtype) {
+    fbb_.AddElement<int64_t>(TensorListGetItem::VT_ELEMENT_DTYPE, element_dtype, 0);
+  }
+  explicit TensorListGetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorListGetItem> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorListGetItem>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorListGetItem> CreateTensorListGetItem(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t element_dtype = 0) {
+  TensorListGetItemBuilder builder_(_fbb);
+  builder_.add_element_dtype(element_dtype);
+  return builder_.Finish();
+}
+
+struct TensorListReserve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorListReserveBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ELEMENT_DTYPE = 4,
+    VT_SHAPE_TYPE = 6
+  };
+  int64_t element_dtype() const {
+    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
+  }
+  int64_t shape_type() const {
+    return GetField<int64_t>(VT_SHAPE_TYPE, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
+           VerifyField<int64_t>(verifier, VT_SHAPE_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct TensorListReserveBuilder {
+  typedef TensorListReserve Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_element_dtype(int64_t element_dtype) {
+    fbb_.AddElement<int64_t>(TensorListReserve::VT_ELEMENT_DTYPE, element_dtype, 0);
+  }
+  void add_shape_type(int64_t shape_type) {
+    fbb_.AddElement<int64_t>(TensorListReserve::VT_SHAPE_TYPE, shape_type, 0);
+  }
+  explicit TensorListReserveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorListReserve> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorListReserve>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorListReserve> CreateTensorListReserve(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t element_dtype = 0,
+    int64_t shape_type = 0) {
+  TensorListReserveBuilder builder_(_fbb);
+  builder_.add_shape_type(shape_type);
+  builder_.add_element_dtype(element_dtype);
+  return builder_.Finish();
+}
+
+struct TensorListSetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorListSetItemBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ELEMENT_DTYPE = 4
+  };
+  int64_t element_dtype() const {
+    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct TensorListSetItemBuilder {
+  typedef TensorListSetItem Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_element_dtype(int64_t element_dtype) {
+    fbb_.AddElement<int64_t>(TensorListSetItem::VT_ELEMENT_DTYPE, element_dtype, 0);
+  }
+  explicit TensorListSetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorListSetItem> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorListSetItem>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorListSetItem> CreateTensorListSetItem(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t element_dtype = 0) {
+  TensorListSetItemBuilder builder_(_fbb);
+  builder_.add_element_dtype(element_dtype);
+  return builder_.Finish();
+}
+
+struct TensorListStack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorListStackBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUM_ELEMENTS = 4,
+    VT_ELEMENT_DTYPE = 6
+  };
+  int64_t num_elements() const {
+    return GetField<int64_t>(VT_NUM_ELEMENTS, 0);
+  }
+  int64_t element_dtype() const {
+    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_NUM_ELEMENTS) &&
+           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct TensorListStackBuilder {
+  typedef TensorListStack Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_num_elements(int64_t num_elements) {
+    fbb_.AddElement<int64_t>(TensorListStack::VT_NUM_ELEMENTS, num_elements, 0);
+  }
+  void add_element_dtype(int64_t element_dtype) {
+    fbb_.AddElement<int64_t>(TensorListStack::VT_ELEMENT_DTYPE, element_dtype, 0);
+  }
+  explicit TensorListStackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorListStack> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorListStack>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorListStack> CreateTensorListStack(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t num_elements = 0,
+    int64_t element_dtype = 0) {
+  TensorListStackBuilder builder_(_fbb);
+  builder_.add_element_dtype(element_dtype);
+  builder_.add_num_elements(num_elements);
+  return builder_.Finish();
+}
+
+struct TileFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TileFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DIMS = 4
+  };
+  const flatbuffers::Vector<int64_t> *dims() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DIMS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_DIMS) &&
+           verifier.VerifyVector(dims()) &&
+           verifier.EndTable();
+  }
+};
+
+struct TileFusionBuilder {
+  typedef TileFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims) {
+    fbb_.AddOffset(TileFusion::VT_DIMS, dims);
+  }
+  explicit TileFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TileFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TileFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TileFusion> CreateTileFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims = 0) {
+  TileFusionBuilder builder_(_fbb);
+  builder_.add_dims(dims);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<TileFusion> CreateTileFusionDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *dims = nullptr) {
+  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
+  return mindspore::schema::CreateTileFusion(
+      _fbb,
+      dims__);
+}
+
+struct TopKFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TopKFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SORTED = 4,
+    VT_AXIS = 6,
+    VT_LARGEST = 8
+  };
+  bool sorted() const {
+    return GetField<uint8_t>(VT_SORTED, 1) != 0;
+  }
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  int64_t largest() const {
+    return GetField<int64_t>(VT_LARGEST, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_SORTED) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_LARGEST) &&
+           verifier.EndTable();
+  }
+};
+
+struct TopKFusionBuilder {
+  typedef TopKFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_sorted(bool sorted) {
+    fbb_.AddElement<uint8_t>(TopKFusion::VT_SORTED, static_cast<uint8_t>(sorted), 1);
+  }
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(TopKFusion::VT_AXIS, axis, 0);
+  }
+  void add_largest(int64_t largest) {
+    fbb_.AddElement<int64_t>(TopKFusion::VT_LARGEST, largest, 0);
+  }
+  explicit TopKFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TopKFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TopKFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TopKFusion> CreateTopKFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool sorted = true,
+    int64_t axis = 0,
+    int64_t largest = 0) {
+  TopKFusionBuilder builder_(_fbb);
+  builder_.add_largest(largest);
+  builder_.add_axis(axis);
+  builder_.add_sorted(sorted);
+  return builder_.Finish();
+}
+
+struct Transpose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TransposeBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct TransposeBuilder {
+  typedef Transpose Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit TransposeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Transpose> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Transpose>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Transpose> CreateTranspose(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  TransposeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Unique FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef UniqueBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct UniqueBuilder {
+  typedef Unique Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit UniqueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Unique> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Unique>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Unique> CreateUnique(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  UniqueBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct UnsortedSegmentSum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef UnsortedSegmentSumBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct UnsortedSegmentSumBuilder {
+  typedef UnsortedSegmentSum Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit UnsortedSegmentSumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<UnsortedSegmentSum> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<UnsortedSegmentSum>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<UnsortedSegmentSum> CreateUnsortedSegmentSum(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  UnsortedSegmentSumBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Unsqueeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef UnsqueezeBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  const flatbuffers::Vector<int64_t> *axis() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_AXIS) &&
+           verifier.VerifyVector(axis()) &&
+           verifier.EndTable();
+  }
+};
+
+struct UnsqueezeBuilder {
+  typedef Unsqueeze Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
+    fbb_.AddOffset(Unsqueeze::VT_AXIS, axis);
+  }
+  explicit UnsqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Unsqueeze> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Unsqueeze>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
+  UnsqueezeBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Unsqueeze> CreateUnsqueezeDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *axis = nullptr) {
+  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
+  return mindspore::schema::CreateUnsqueeze(
+      _fbb,
+      axis__);
+}
+
+struct Unstack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef UnstackBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+};
+
+struct UnstackBuilder {
+  typedef Unstack Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(Unstack::VT_AXIS, axis, 0);
+  }
+  explicit UnstackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Unstack> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Unstack>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Unstack> CreateUnstack(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0) {
+  UnstackBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+struct Where FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef WhereBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct WhereBuilder {
+  typedef Where Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit WhereBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Where> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Where>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Where> CreateWhere(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  WhereBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct ZerosLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ZerosLikeBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct ZerosLikeBuilder {
+  typedef ZerosLike Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ZerosLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ZerosLike> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ZerosLike>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ZerosLike> CreateZerosLike(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ZerosLikeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Select FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SelectBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SelectBuilder {
+  typedef Select Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SelectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Select> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Select>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Select> CreateSelect(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SelectBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct GRU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GRUBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BIDIRECTIONAL = 4
+  };
+  bool bidirectional() const {
+    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
+           verifier.EndTable();
+  }
+};
+
+struct GRUBuilder {
+  typedef GRU Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_bidirectional(bool bidirectional) {
+    fbb_.AddElement<uint8_t>(GRU::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
+  }
+  explicit GRUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GRU> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GRU>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GRU> CreateGRU(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool bidirectional = false) {
+  GRUBuilder builder_(_fbb);
+  builder_.add_bidirectional(bidirectional);
+  return builder_.Finish();
+}
+
+struct NonZero FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NonZeroBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct NonZeroBuilder {
+  typedef NonZero Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit NonZeroBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<NonZero> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<NonZero>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<NonZero> CreateNonZero(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  NonZeroBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct InvertPermutation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef InvertPermutationBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct InvertPermutationBuilder {
+  typedef InvertPermutation Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit InvertPermutationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<InvertPermutation> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<InvertPermutation>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<InvertPermutation> CreateInvertPermutation(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  InvertPermutationBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Size FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SizeBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SizeBuilder {
+  typedef Size Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Size> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Size>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Size> CreateSize(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SizeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct RandomStandardNormal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RandomStandardNormalBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SEED = 4,
+    VT_SEED2 = 6
+  };
+  int64_t seed() const {
+    return GetField<int64_t>(VT_SEED, 0);
+  }
+  int64_t seed2() const {
+    return GetField<int64_t>(VT_SEED2, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SEED) &&
+           VerifyField<int64_t>(verifier, VT_SEED2) &&
+           verifier.EndTable();
+  }
+};
+
+struct RandomStandardNormalBuilder {
+  typedef RandomStandardNormal Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_seed(int64_t seed) {
+    fbb_.AddElement<int64_t>(RandomStandardNormal::VT_SEED, seed, 0);
+  }
+  void add_seed2(int64_t seed2) {
+    fbb_.AddElement<int64_t>(RandomStandardNormal::VT_SEED2, seed2, 0);
+  }
+  explicit RandomStandardNormalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<RandomStandardNormal> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<RandomStandardNormal>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<RandomStandardNormal> CreateRandomStandardNormal(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t seed = 0,
+    int64_t seed2 = 0) {
+  RandomStandardNormalBuilder builder_(_fbb);
+  builder_.add_seed2(seed2);
+  builder_.add_seed(seed);
+  return builder_.Finish();
+}
+
+struct CropAndResize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CropAndResizeBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_METHOD = 4,
+    VT_EXTRAPOLATION_VALUE = 6
+  };
+  mindspore::schema::ResizeMethod method() const {
+    return static_cast<mindspore::schema::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
+  }
+  float extrapolation_value() const {
+    return GetField<float>(VT_EXTRAPOLATION_VALUE, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_METHOD) &&
+           VerifyField<float>(verifier, VT_EXTRAPOLATION_VALUE) &&
+           verifier.EndTable();
+  }
+};
+
+struct CropAndResizeBuilder {
+  typedef CropAndResize Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_method(mindspore::schema::ResizeMethod method) {
+    fbb_.AddElement<int8_t>(CropAndResize::VT_METHOD, static_cast<int8_t>(method), 0);
+  }
+  void add_extrapolation_value(float extrapolation_value) {
+    fbb_.AddElement<float>(CropAndResize::VT_EXTRAPOLATION_VALUE, extrapolation_value, 0.0f);
+  }
+  explicit CropAndResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<CropAndResize> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<CropAndResize>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<CropAndResize> CreateCropAndResize(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR,
+    float extrapolation_value = 0.0f) {
+  CropAndResizeBuilder builder_(_fbb);
+  builder_.add_extrapolation_value(extrapolation_value);
+  builder_.add_method(method);
+  return builder_.Finish();
+}
+
+struct Erf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ErfBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct ErfBuilder {
+  typedef Erf Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ErfBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Erf> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Erf>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Erf> CreateErf(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ErfBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct StridedSliceGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef StridedSliceGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BEGIN_MASK = 4,
+    VT_END_MASK = 6,
+    VT_ELLIPSIS_MASK = 8,
+    VT_NEW_AXIS_MASK = 10,
+    VT_SHRINK_AXIS_MASK = 12
+  };
+  int64_t begin_mask() const {
+    return GetField<int64_t>(VT_BEGIN_MASK, 0);
+  }
+  int64_t end_mask() const {
+    return GetField<int64_t>(VT_END_MASK, 0);
+  }
+  int64_t ellipsis_mask() const {
+    return GetField<int64_t>(VT_ELLIPSIS_MASK, 0);
+  }
+  int64_t new_axis_mask() const {
+    return GetField<int64_t>(VT_NEW_AXIS_MASK, 0);
+  }
+  int64_t shrink_axis_mask() const {
+    return GetField<int64_t>(VT_SHRINK_AXIS_MASK, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_BEGIN_MASK) &&
+           VerifyField<int64_t>(verifier, VT_END_MASK) &&
+           VerifyField<int64_t>(verifier, VT_ELLIPSIS_MASK) &&
+           VerifyField<int64_t>(verifier, VT_NEW_AXIS_MASK) &&
+           VerifyField<int64_t>(verifier, VT_SHRINK_AXIS_MASK) &&
+           verifier.EndTable();
+  }
+};
+
+struct StridedSliceGradBuilder {
+  typedef StridedSliceGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_begin_mask(int64_t begin_mask) {
+    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_BEGIN_MASK, begin_mask, 0);
+  }
+  void add_end_mask(int64_t end_mask) {
+    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_END_MASK, end_mask, 0);
+  }
+  void add_ellipsis_mask(int64_t ellipsis_mask) {
+    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
+  }
+  void add_new_axis_mask(int64_t new_axis_mask) {
+    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_NEW_AXIS_MASK, new_axis_mask, 0);
+  }
+  void add_shrink_axis_mask(int64_t shrink_axis_mask) {
+    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
+  }
+  explicit StridedSliceGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<StridedSliceGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<StridedSliceGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<StridedSliceGrad> CreateStridedSliceGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t begin_mask = 0,
+    int64_t end_mask = 0,
+    int64_t ellipsis_mask = 0,
+    int64_t new_axis_mask = 0,
+    int64_t shrink_axis_mask = 0) {
+  StridedSliceGradBuilder builder_(_fbb);
+  builder_.add_shrink_axis_mask(shrink_axis_mask);
+  builder_.add_new_axis_mask(new_axis_mask);
+  builder_.add_ellipsis_mask(ellipsis_mask);
+  builder_.add_end_mask(end_mask);
+  builder_.add_begin_mask(begin_mask);
+  return builder_.Finish();
+}
+
+struct IsFinite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef IsFiniteBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct IsFiniteBuilder {
+  typedef IsFinite Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit IsFiniteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<IsFinite> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<IsFinite>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<IsFinite> CreateIsFinite(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  IsFiniteBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct LinSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LinSpaceBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct LinSpaceBuilder {
+  typedef LinSpace Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit LinSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LinSpace> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LinSpace>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LinSpace> CreateLinSpace(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  LinSpaceBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct UniformReal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef UniformRealBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SEED = 4,
+    VT_SEED2 = 6
+  };
+  int64_t seed() const {
+    return GetField<int64_t>(VT_SEED, 0);
+  }
+  int64_t seed2() const {
+    return GetField<int64_t>(VT_SEED2, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SEED) &&
+           VerifyField<int64_t>(verifier, VT_SEED2) &&
+           verifier.EndTable();
+  }
+};
+
+struct UniformRealBuilder {
+  typedef UniformReal Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_seed(int64_t seed) {
+    fbb_.AddElement<int64_t>(UniformReal::VT_SEED, seed, 0);
+  }
+  void add_seed2(int64_t seed2) {
+    fbb_.AddElement<int64_t>(UniformReal::VT_SEED2, seed2, 0);
+  }
+  explicit UniformRealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<UniformReal> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<UniformReal>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<UniformReal> CreateUniformReal(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t seed = 0,
+    int64_t seed2 = 0) {
+  UniformRealBuilder builder_(_fbb);
+  builder_.add_seed2(seed2);
+  builder_.add_seed(seed);
+  return builder_.Finish();
+}
+
+struct AbsGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AbsGradBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct AbsGradBuilder {
+  typedef AbsGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit AbsGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AbsGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AbsGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AbsGrad> CreateAbsGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  AbsGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct RsqrtGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RsqrtGradBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct RsqrtGradBuilder {
+  typedef RsqrtGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit RsqrtGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<RsqrtGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<RsqrtGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<RsqrtGrad> CreateRsqrtGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  RsqrtGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct SqrtGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SqrtGradBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct SqrtGradBuilder {
+  typedef SqrtGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit SqrtGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SqrtGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SqrtGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SqrtGrad> CreateSqrtGrad(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  SqrtGradBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct LayerNormGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LayerNormGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BEGIN_NORM_AXIS = 4,
+    VT_BEGIN_PARAMS_AXIS = 6
+  };
+  int64_t begin_norm_axis() const {
+    return GetField<int64_t>(VT_BEGIN_NORM_AXIS, 0);
+  }
+  int64_t begin_params_axis() const {
+    return GetField<int64_t>(VT_BEGIN_PARAMS_AXIS, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_BEGIN_NORM_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_BEGIN_PARAMS_AXIS) &&
+           verifier.EndTable();
+  }
+};
+
+struct LayerNormGradBuilder {
+  typedef LayerNormGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_begin_norm_axis(int64_t begin_norm_axis) {
+    fbb_.AddElement<int64_t>(LayerNormGrad::VT_BEGIN_NORM_AXIS, begin_norm_axis, 0);
+  }
+  void add_begin_params_axis(int64_t begin_params_axis) {
+    fbb_.AddElement<int64_t>(LayerNormGrad::VT_BEGIN_PARAMS_AXIS, begin_params_axis, 0);
+  }
+  explicit LayerNormGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LayerNormGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LayerNormGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LayerNormGrad> CreateLayerNormGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t begin_norm_axis = 0,
+    int64_t begin_params_axis = 0) {
+  LayerNormGradBuilder builder_(_fbb);
+  builder_.add_begin_params_axis(begin_params_axis);
+  builder_.add_begin_norm_axis(begin_norm_axis);
+  return builder_.Finish();
+}
+
+struct ResizeGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ResizeGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_METHOD = 4,
+    VT_ALIGN_CORNERS = 6
+  };
+  mindspore::schema::ResizeMethod method() const {
+    return static_cast<mindspore::schema::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
+  }
+  bool align_corners() const {
+    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_METHOD) &&
+           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
+           verifier.EndTable();
+  }
+};
+
+struct ResizeGradBuilder {
+  typedef ResizeGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_method(mindspore::schema::ResizeMethod method) {
+    fbb_.AddElement<int8_t>(ResizeGrad::VT_METHOD, static_cast<int8_t>(method), 0);
+  }
+  void add_align_corners(bool align_corners) {
+    fbb_.AddElement<uint8_t>(ResizeGrad::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
+  }
+  explicit ResizeGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ResizeGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ResizeGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ResizeGrad> CreateResizeGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR,
+    bool align_corners = false) {
+  ResizeGradBuilder builder_(_fbb);
+  builder_.add_align_corners(align_corners);
+  builder_.add_method(method);
+  return builder_.Finish();
+}
+
+struct Splice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SpliceBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_CONTEXT = 4,
+    VT_FORWARD_INDEXES = 6,
+    VT_OUTPUT_DIM = 8
+  };
+  const flatbuffers::Vector<int64_t> *context() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_CONTEXT);
+  }
+  const flatbuffers::Vector<int64_t> *forward_indexes() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_FORWARD_INDEXES);
+  }
+  int64_t output_dim() const {
+    return GetField<int64_t>(VT_OUTPUT_DIM, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_CONTEXT) &&
+           verifier.VerifyVector(context()) &&
+           VerifyOffset(verifier, VT_FORWARD_INDEXES) &&
+           verifier.VerifyVector(forward_indexes()) &&
+           VerifyField<int64_t>(verifier, VT_OUTPUT_DIM) &&
+           verifier.EndTable();
+  }
+};
+
+struct SpliceBuilder {
+  typedef Splice Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_context(flatbuffers::Offset<flatbuffers::Vector<int64_t>> context) {
+    fbb_.AddOffset(Splice::VT_CONTEXT, context);
+  }
+  void add_forward_indexes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> forward_indexes) {
+    fbb_.AddOffset(Splice::VT_FORWARD_INDEXES, forward_indexes);
+  }
+  void add_output_dim(int64_t output_dim) {
+    fbb_.AddElement<int64_t>(Splice::VT_OUTPUT_DIM, output_dim, 0);
+  }
+  explicit SpliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Splice> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Splice>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Splice> CreateSplice(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> context = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> forward_indexes = 0,
+    int64_t output_dim = 0) {
+  SpliceBuilder builder_(_fbb);
+  builder_.add_output_dim(output_dim);
+  builder_.add_forward_indexes(forward_indexes);
+  builder_.add_context(context);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Splice> CreateSpliceDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *context = nullptr,
+    const std::vector<int64_t> *forward_indexes = nullptr,
+    int64_t output_dim = 0) {
+  auto context__ = context ? _fbb.CreateVector<int64_t>(*context) : 0;
+  auto forward_indexes__ = forward_indexes ? _fbb.CreateVector<int64_t>(*forward_indexes) : 0;
+  return mindspore::schema::CreateSplice(
+      _fbb,
+      context__,
+      forward_indexes__,
+      output_dim);
+}
+
+struct LogSoftmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LogSoftmaxBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+};
+
+struct LogSoftmaxBuilder {
+  typedef LogSoftmax Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(LogSoftmax::VT_AXIS, axis, 0);
+  }
+  explicit LogSoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LogSoftmax> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LogSoftmax>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LogSoftmax> CreateLogSoftmax(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = 0) {
+  LogSoftmaxBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CallBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_IS_TAIL_CALL = 4
+  };
+  bool is_tail_call() const {
+    return GetField<uint8_t>(VT_IS_TAIL_CALL, 1) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_IS_TAIL_CALL) &&
+           verifier.EndTable();
+  }
+};
+
+struct CallBuilder {
+  typedef Call Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_is_tail_call(bool is_tail_call) {
+    fbb_.AddElement<uint8_t>(Call::VT_IS_TAIL_CALL, static_cast<uint8_t>(is_tail_call), 1);
+  }
+  explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Call> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Call>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Call> CreateCall(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool is_tail_call = true) {
+  CallBuilder builder_(_fbb);
+  builder_.add_is_tail_call(is_tail_call);
+  return builder_.Finish();
+}
+
+struct CumSum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CumSumBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_EXCLUSIVE = 4,
+    VT_REVERSE = 6
+  };
+  bool exclusive() const {
+    return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0;
+  }
+  bool reverse() const {
+    return GetField<uint8_t>(VT_REVERSE, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_EXCLUSIVE) &&
+           VerifyField<uint8_t>(verifier, VT_REVERSE) &&
+           verifier.EndTable();
+  }
+};
+
+struct CumSumBuilder {
+  typedef CumSum Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_exclusive(bool exclusive) {
+    fbb_.AddElement<uint8_t>(CumSum::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);
+  }
+  void add_reverse(bool reverse) {
+    fbb_.AddElement<uint8_t>(CumSum::VT_REVERSE, static_cast<uint8_t>(reverse), 0);
+  }
+  explicit CumSumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<CumSum> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<CumSum>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<CumSum> CreateCumSum(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool exclusive = false,
+    bool reverse = false) {
+  CumSumBuilder builder_(_fbb);
+  builder_.add_reverse(reverse);
+  builder_.add_exclusive(exclusive);
+  return builder_.Finish();
+}
+
+struct Custom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef CustomBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_TYPE = 4,
+    VT_ATTR = 6
+  };
+  const flatbuffers::String *type() const {
+    return GetPointer<const flatbuffers::String *>(VT_TYPE);
+  }
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>> *attr() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>> *>(VT_ATTR);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_TYPE) &&
+           verifier.VerifyString(type()) &&
+           VerifyOffset(verifier, VT_ATTR) &&
+           verifier.VerifyVector(attr()) &&
+           verifier.VerifyVectorOfTables(attr()) &&
+           verifier.EndTable();
+  }
+};
+
+struct CustomBuilder {
+  typedef Custom Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
+    fbb_.AddOffset(Custom::VT_TYPE, type);
+  }
+  void add_attr(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>>> attr) {
+    fbb_.AddOffset(Custom::VT_ATTR, attr);
+  }
+  explicit CustomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Custom> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Custom>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Custom> CreateCustom(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> type = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>>> attr = 0) {
+  CustomBuilder builder_(_fbb);
+  builder_.add_attr(attr);
+  builder_.add_type(type);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Custom> CreateCustomDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *type = nullptr,
+    const std::vector<flatbuffers::Offset<mindspore::schema::Attribute>> *attr = nullptr) {
+  auto type__ = type ? _fbb.CreateString(type) : 0;
+  auto attr__ = attr ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Attribute>>(*attr) : 0;
+  return mindspore::schema::CreateCustom(
+      _fbb,
+      type__,
+      attr__);
+}
+
+struct SplitWithOverlap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SplitWithOverlapBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SPLIT_DIM = 4,
+    VT_NUMBER_SPLIT = 6,
+    VT_RATIO = 8,
+    VT_EXTEND_TOP = 10,
+    VT_EXTEND_BOTTOM = 12
+  };
+  int64_t split_dim() const {
+    return GetField<int64_t>(VT_SPLIT_DIM, 0);
+  }
+  int64_t number_split() const {
+    return GetField<int64_t>(VT_NUMBER_SPLIT, 0);
+  }
+  const flatbuffers::Vector<int64_t> *ratio() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_RATIO);
+  }
+  const flatbuffers::Vector<int64_t> *extend_top() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EXTEND_TOP);
+  }
+  const flatbuffers::Vector<int64_t> *extend_bottom() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EXTEND_BOTTOM);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_SPLIT_DIM) &&
+           VerifyField<int64_t>(verifier, VT_NUMBER_SPLIT) &&
+           VerifyOffset(verifier, VT_RATIO) &&
+           verifier.VerifyVector(ratio()) &&
+           VerifyOffset(verifier, VT_EXTEND_TOP) &&
+           verifier.VerifyVector(extend_top()) &&
+           VerifyOffset(verifier, VT_EXTEND_BOTTOM) &&
+           verifier.VerifyVector(extend_bottom()) &&
+           verifier.EndTable();
+  }
+};
+
+struct SplitWithOverlapBuilder {
+  typedef SplitWithOverlap Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_split_dim(int64_t split_dim) {
+    fbb_.AddElement<int64_t>(SplitWithOverlap::VT_SPLIT_DIM, split_dim, 0);
+  }
+  void add_number_split(int64_t number_split) {
+    fbb_.AddElement<int64_t>(SplitWithOverlap::VT_NUMBER_SPLIT, number_split, 0);
+  }
+  void add_ratio(flatbuffers::Offset<flatbuffers::Vector<int64_t>> ratio) {
+    fbb_.AddOffset(SplitWithOverlap::VT_RATIO, ratio);
+  }
+  void add_extend_top(flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_top) {
+    fbb_.AddOffset(SplitWithOverlap::VT_EXTEND_TOP, extend_top);
+  }
+  void add_extend_bottom(flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_bottom) {
+    fbb_.AddOffset(SplitWithOverlap::VT_EXTEND_BOTTOM, extend_bottom);
+  }
+  explicit SplitWithOverlapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SplitWithOverlap> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SplitWithOverlap>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SplitWithOverlap> CreateSplitWithOverlap(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t split_dim = 0,
+    int64_t number_split = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> ratio = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_top = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_bottom = 0) {
+  SplitWithOverlapBuilder builder_(_fbb);
+  builder_.add_number_split(number_split);
+  builder_.add_split_dim(split_dim);
+  builder_.add_extend_bottom(extend_bottom);
+  builder_.add_extend_top(extend_top);
+  builder_.add_ratio(ratio);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<SplitWithOverlap> CreateSplitWithOverlapDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t split_dim = 0,
+    int64_t number_split = 0,
+    const std::vector<int64_t> *ratio = nullptr,
+    const std::vector<int64_t> *extend_top = nullptr,
+    const std::vector<int64_t> *extend_bottom = nullptr) {
+  auto ratio__ = ratio ? _fbb.CreateVector<int64_t>(*ratio) : 0;
+  auto extend_top__ = extend_top ? _fbb.CreateVector<int64_t>(*extend_top) : 0;
+  auto extend_bottom__ = extend_bottom ? _fbb.CreateVector<int64_t>(*extend_bottom) : 0;
+  return mindspore::schema::CreateSplitWithOverlap(
+      _fbb,
+      split_dim,
+      number_split,
+      ratio__,
+      extend_top__,
+      extend_bottom__);
+}
+
+struct GenOP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GenOPBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_ACTIVATION_TYPE = 4,
+    VT_ALPHA = 6,
+    VT_MIN_VAL = 8,
+    VT_MAX_VAL = 10,
+    VT_IS_TRAINING = 12,
+    VT_FORMAT = 14,
+    VT_KERNEL_SIZE = 16,
+    VT_STRIDE = 18,
+    VT_DILATION = 20,
+    VT_PAD_MODE = 22,
+    VT_PAD_LIST = 24,
+    VT_MODE = 26,
+    VT_GROUP = 28,
+    VT_IN_CHANNEL = 30,
+    VT_OUT_CHANNEL = 32,
+    VT_ELTWISE_MODE = 34,
+    VT_HAS_BIAS = 36,
+    VT_USE_AXIS = 38,
+    VT_AXIS = 40,
+    VT_EPSILON = 42,
+    VT_MOMENTUM = 44,
+    VT_TRANSPOSE_A = 46,
+    VT_TRANSPOSE_B = 48,
+    VT_PAD = 50,
+    VT_ROUND_MODE = 52,
+    VT_GLOBAL = 54,
+    VT_CHANNEL_SHARED = 56,
+    VT_AXES = 58,
+    VT_KEEP_DIMS = 60,
+    VT_REDUCE_MODE = 62,
+    VT_REDUCE_TO_END = 64,
+    VT_COEFF = 66
+  };
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  float alpha() const {
+    return GetField<float>(VT_ALPHA, 0.0f);
+  }
+  float min_val() const {
+    return GetField<float>(VT_MIN_VAL, 0.0f);
+  }
+  float max_val() const {
+    return GetField<float>(VT_MAX_VAL, 0.0f);
+  }
+  bool is_training() const {
+    return GetField<uint8_t>(VT_IS_TRAINING, 0) != 0;
+  }
+  mindspore::schema::Format format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
+  }
+  const flatbuffers::Vector<int64_t> *kernel_size() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
+  }
+  const flatbuffers::Vector<int64_t> *stride() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
+  }
+  const flatbuffers::Vector<int64_t> *dilation() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
+  }
+  mindspore::schema::PadMode pad_mode() const {
+    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
+  }
+  const flatbuffers::Vector<int64_t> *pad_list() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
+  }
+  int64_t mode() const {
+    return GetField<int64_t>(VT_MODE, 0);
+  }
+  int64_t group() const {
+    return GetField<int64_t>(VT_GROUP, 0);
+  }
+  int64_t in_channel() const {
+    return GetField<int64_t>(VT_IN_CHANNEL, 0);
+  }
+  int64_t out_channel() const {
+    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
+  }
+  mindspore::schema::EltwiseMode eltwise_mode() const {
+    return static_cast<mindspore::schema::EltwiseMode>(GetField<int8_t>(VT_ELTWISE_MODE, 0));
+  }
+  bool has_bias() const {
+    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
+  }
+  bool use_axis() const {
+    return GetField<uint8_t>(VT_USE_AXIS, 0) != 0;
+  }
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, 0);
+  }
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 0.0001f);
+  }
+  float momentum() const {
+    return GetField<float>(VT_MOMENTUM, 0.9f);
+  }
+  bool transpose_a() const {
+    return GetField<uint8_t>(VT_TRANSPOSE_A, 0) != 0;
+  }
+  bool transpose_b() const {
+    return GetField<uint8_t>(VT_TRANSPOSE_B, 0) != 0;
+  }
+  const flatbuffers::Vector<int64_t> *pad() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
+  }
+  mindspore::schema::RoundMode round_mode() const {
+    return static_cast<mindspore::schema::RoundMode>(GetField<int8_t>(VT_ROUND_MODE, 0));
+  }
+  bool global() const {
+    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
+  }
+  bool channel_shared() const {
+    return GetField<uint8_t>(VT_CHANNEL_SHARED, 0) != 0;
+  }
+  const flatbuffers::Vector<int64_t> *axes() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXES);
+  }
+  bool keep_dims() const {
+    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
+  }
+  mindspore::schema::ReduceMode reduce_mode() const {
+    return static_cast<mindspore::schema::ReduceMode>(GetField<int8_t>(VT_REDUCE_MODE, 0));
+  }
+  bool reduce_to_end() const {
+    return GetField<uint8_t>(VT_REDUCE_TO_END, 0) != 0;
+  }
+  float coeff() const {
+    return GetField<float>(VT_COEFF, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           VerifyField<float>(verifier, VT_ALPHA) &&
+           VerifyField<float>(verifier, VT_MIN_VAL) &&
+           VerifyField<float>(verifier, VT_MAX_VAL) &&
+           VerifyField<uint8_t>(verifier, VT_IS_TRAINING) &&
+           VerifyField<int32_t>(verifier, VT_FORMAT) &&
+           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
+           verifier.VerifyVector(kernel_size()) &&
+           VerifyOffset(verifier, VT_STRIDE) &&
+           verifier.VerifyVector(stride()) &&
+           VerifyOffset(verifier, VT_DILATION) &&
+           verifier.VerifyVector(dilation()) &&
+           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
+           VerifyOffset(verifier, VT_PAD_LIST) &&
+           verifier.VerifyVector(pad_list()) &&
+           VerifyField<int64_t>(verifier, VT_MODE) &&
+           VerifyField<int64_t>(verifier, VT_GROUP) &&
+           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
+           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
+           VerifyField<int8_t>(verifier, VT_ELTWISE_MODE) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
+           VerifyField<uint8_t>(verifier, VT_USE_AXIS) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<float>(verifier, VT_MOMENTUM) &&
+           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_A) &&
+           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_B) &&
+           VerifyOffset(verifier, VT_PAD) &&
+           verifier.VerifyVector(pad()) &&
+           VerifyField<int8_t>(verifier, VT_ROUND_MODE) &&
+           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
+           VerifyField<uint8_t>(verifier, VT_CHANNEL_SHARED) &&
+           VerifyOffset(verifier, VT_AXES) &&
+           verifier.VerifyVector(axes()) &&
+           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
+           VerifyField<int8_t>(verifier, VT_REDUCE_MODE) &&
+           VerifyField<uint8_t>(verifier, VT_REDUCE_TO_END) &&
+           VerifyField<float>(verifier, VT_COEFF) &&
+           verifier.EndTable();
+  }
+};
+
+struct GenOPBuilder {
+  typedef GenOP Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(GenOP::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  void add_alpha(float alpha) {
+    fbb_.AddElement<float>(GenOP::VT_ALPHA, alpha, 0.0f);
+  }
+  void add_min_val(float min_val) {
+    fbb_.AddElement<float>(GenOP::VT_MIN_VAL, min_val, 0.0f);
+  }
+  void add_max_val(float max_val) {
+    fbb_.AddElement<float>(GenOP::VT_MAX_VAL, max_val, 0.0f);
+  }
+  void add_is_training(bool is_training) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_IS_TRAINING, static_cast<uint8_t>(is_training), 0);
+  }
+  void add_format(mindspore::schema::Format format) {
+    fbb_.AddElement<int32_t>(GenOP::VT_FORMAT, static_cast<int32_t>(format), 0);
+  }
+  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
+    fbb_.AddOffset(GenOP::VT_KERNEL_SIZE, kernel_size);
+  }
+  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
+    fbb_.AddOffset(GenOP::VT_STRIDE, stride);
+  }
+  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
+    fbb_.AddOffset(GenOP::VT_DILATION, dilation);
+  }
+  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
+    fbb_.AddElement<int8_t>(GenOP::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
+  }
+  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
+    fbb_.AddOffset(GenOP::VT_PAD_LIST, pad_list);
+  }
+  void add_mode(int64_t mode) {
+    fbb_.AddElement<int64_t>(GenOP::VT_MODE, mode, 0);
+  }
+  void add_group(int64_t group) {
+    fbb_.AddElement<int64_t>(GenOP::VT_GROUP, group, 0);
+  }
+  void add_in_channel(int64_t in_channel) {
+    fbb_.AddElement<int64_t>(GenOP::VT_IN_CHANNEL, in_channel, 0);
+  }
+  void add_out_channel(int64_t out_channel) {
+    fbb_.AddElement<int64_t>(GenOP::VT_OUT_CHANNEL, out_channel, 0);
+  }
+  void add_eltwise_mode(mindspore::schema::EltwiseMode eltwise_mode) {
+    fbb_.AddElement<int8_t>(GenOP::VT_ELTWISE_MODE, static_cast<int8_t>(eltwise_mode), 0);
+  }
+  void add_has_bias(bool has_bias) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
+  }
+  void add_use_axis(bool use_axis) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_USE_AXIS, static_cast<uint8_t>(use_axis), 0);
+  }
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(GenOP::VT_AXIS, axis, 0);
+  }
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(GenOP::VT_EPSILON, epsilon, 0.0001f);
+  }
+  void add_momentum(float momentum) {
+    fbb_.AddElement<float>(GenOP::VT_MOMENTUM, momentum, 0.9f);
+  }
+  void add_transpose_a(bool transpose_a) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_TRANSPOSE_A, static_cast<uint8_t>(transpose_a), 0);
+  }
+  void add_transpose_b(bool transpose_b) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_TRANSPOSE_B, static_cast<uint8_t>(transpose_b), 0);
+  }
+  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
+    fbb_.AddOffset(GenOP::VT_PAD, pad);
+  }
+  void add_round_mode(mindspore::schema::RoundMode round_mode) {
+    fbb_.AddElement<int8_t>(GenOP::VT_ROUND_MODE, static_cast<int8_t>(round_mode), 0);
+  }
+  void add_global(bool global) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_GLOBAL, static_cast<uint8_t>(global), 0);
+  }
+  void add_channel_shared(bool channel_shared) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_CHANNEL_SHARED, static_cast<uint8_t>(channel_shared), 0);
+  }
+  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes) {
+    fbb_.AddOffset(GenOP::VT_AXES, axes);
+  }
+  void add_keep_dims(bool keep_dims) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
+  }
+  void add_reduce_mode(mindspore::schema::ReduceMode reduce_mode) {
+    fbb_.AddElement<int8_t>(GenOP::VT_REDUCE_MODE, static_cast<int8_t>(reduce_mode), 0);
+  }
+  void add_reduce_to_end(bool reduce_to_end) {
+    fbb_.AddElement<uint8_t>(GenOP::VT_REDUCE_TO_END, static_cast<uint8_t>(reduce_to_end), 0);
+  }
+  void add_coeff(float coeff) {
+    fbb_.AddElement<float>(GenOP::VT_COEFF, coeff, 0.0f);
+  }
+  explicit GenOPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GenOP> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GenOP>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GenOP> CreateGenOP(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    float alpha = 0.0f,
+    float min_val = 0.0f,
+    float max_val = 0.0f,
+    bool is_training = false,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::EltwiseMode eltwise_mode = mindspore::schema::EltwiseMode_PROD,
+    bool has_bias = false,
+    bool use_axis = false,
+    int64_t axis = 0,
+    float epsilon = 0.0001f,
+    float momentum = 0.9f,
+    bool transpose_a = false,
+    bool transpose_b = false,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
+    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
+    bool global = false,
+    bool channel_shared = false,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes = 0,
+    bool keep_dims = false,
+    mindspore::schema::ReduceMode reduce_mode = mindspore::schema::ReduceMode_ReduceMean,
+    bool reduce_to_end = false,
+    float coeff = 0.0f) {
+  GenOPBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  builder_.add_out_channel(out_channel);
+  builder_.add_in_channel(in_channel);
+  builder_.add_group(group);
+  builder_.add_mode(mode);
+  builder_.add_coeff(coeff);
+  builder_.add_axes(axes);
+  builder_.add_pad(pad);
+  builder_.add_momentum(momentum);
+  builder_.add_epsilon(epsilon);
+  builder_.add_pad_list(pad_list);
+  builder_.add_dilation(dilation);
+  builder_.add_stride(stride);
+  builder_.add_kernel_size(kernel_size);
+  builder_.add_format(format);
+  builder_.add_max_val(max_val);
+  builder_.add_min_val(min_val);
+  builder_.add_alpha(alpha);
+  builder_.add_reduce_to_end(reduce_to_end);
+  builder_.add_reduce_mode(reduce_mode);
+  builder_.add_keep_dims(keep_dims);
+  builder_.add_channel_shared(channel_shared);
+  builder_.add_global(global);
+  builder_.add_round_mode(round_mode);
+  builder_.add_transpose_b(transpose_b);
+  builder_.add_transpose_a(transpose_a);
+  builder_.add_use_axis(use_axis);
+  builder_.add_has_bias(has_bias);
+  builder_.add_eltwise_mode(eltwise_mode);
+  builder_.add_pad_mode(pad_mode);
+  builder_.add_is_training(is_training);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<GenOP> CreateGenOPDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    float alpha = 0.0f,
+    float min_val = 0.0f,
+    float max_val = 0.0f,
+    bool is_training = false,
+    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
+    const std::vector<int64_t> *kernel_size = nullptr,
+    const std::vector<int64_t> *stride = nullptr,
+    const std::vector<int64_t> *dilation = nullptr,
+    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
+    const std::vector<int64_t> *pad_list = nullptr,
+    int64_t mode = 0,
+    int64_t group = 0,
+    int64_t in_channel = 0,
+    int64_t out_channel = 0,
+    mindspore::schema::EltwiseMode eltwise_mode = mindspore::schema::EltwiseMode_PROD,
+    bool has_bias = false,
+    bool use_axis = false,
+    int64_t axis = 0,
+    float epsilon = 0.0001f,
+    float momentum = 0.9f,
+    bool transpose_a = false,
+    bool transpose_b = false,
+    const std::vector<int64_t> *pad = nullptr,
+    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
+    bool global = false,
+    bool channel_shared = false,
+    const std::vector<int64_t> *axes = nullptr,
+    bool keep_dims = false,
+    mindspore::schema::ReduceMode reduce_mode = mindspore::schema::ReduceMode_ReduceMean,
+    bool reduce_to_end = false,
+    float coeff = 0.0f) {
+  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
+  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
+  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
+  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
+  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
+  auto axes__ = axes ? _fbb.CreateVector<int64_t>(*axes) : 0;
+  return mindspore::schema::CreateGenOP(
+      _fbb,
+      activation_type,
+      alpha,
+      min_val,
+      max_val,
+      is_training,
+      format,
+      kernel_size__,
+      stride__,
+      dilation__,
+      pad_mode,
+      pad_list__,
+      mode,
+      group,
+      in_channel,
+      out_channel,
+      eltwise_mode,
+      has_bias,
+      use_axis,
+      axis,
+      epsilon,
+      momentum,
+      transpose_a,
+      transpose_b,
+      pad__,
+      round_mode,
+      global,
+      channel_shared,
+      axes__,
+      keep_dims,
+      reduce_mode,
+      reduce_to_end,
+      coeff);
+}
+
+struct RaggedRange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RaggedRangeBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct RaggedRangeBuilder {
+  typedef RaggedRange Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit RaggedRangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<RaggedRange> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<RaggedRange>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<RaggedRange> CreateRaggedRange(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  RaggedRangeBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct GLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GLUBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_AXIS = 4
+  };
+  int64_t axis() const {
+    return GetField<int64_t>(VT_AXIS, -1LL);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_AXIS) &&
+           verifier.EndTable();
+  }
+};
+
+struct GLUBuilder {
+  typedef GLU Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_axis(int64_t axis) {
+    fbb_.AddElement<int64_t>(GLU::VT_AXIS, axis, -1LL);
+  }
+  explicit GLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GLU> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GLU>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GLU> CreateGLU(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t axis = -1LL) {
+  GLUBuilder builder_(_fbb);
+  builder_.add_axis(axis);
+  return builder_.Finish();
+}
+
+struct TensorArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorArrayBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DYNAMIC_SIZE = 4,
+    VT_IDENTICAL_ELEMENT_SHAPES = 6,
+    VT_ELEMENT_SHAPE = 8,
+    VT_DATA_TYPE = 10
+  };
+  bool dynamic_size() const {
+    return GetField<uint8_t>(VT_DYNAMIC_SIZE, 0) != 0;
+  }
+  bool identical_element_shapes() const {
+    return GetField<uint8_t>(VT_IDENTICAL_ELEMENT_SHAPES, 0) != 0;
+  }
+  const flatbuffers::Vector<int32_t> *element_shape() const {
+    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ELEMENT_SHAPE);
+  }
+  int32_t data_type() const {
+    return GetField<int32_t>(VT_DATA_TYPE, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_DYNAMIC_SIZE) &&
+           VerifyField<uint8_t>(verifier, VT_IDENTICAL_ELEMENT_SHAPES) &&
+           VerifyOffset(verifier, VT_ELEMENT_SHAPE) &&
+           verifier.VerifyVector(element_shape()) &&
+           VerifyField<int32_t>(verifier, VT_DATA_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct TensorArrayBuilder {
+  typedef TensorArray Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_dynamic_size(bool dynamic_size) {
+    fbb_.AddElement<uint8_t>(TensorArray::VT_DYNAMIC_SIZE, static_cast<uint8_t>(dynamic_size), 0);
+  }
+  void add_identical_element_shapes(bool identical_element_shapes) {
+    fbb_.AddElement<uint8_t>(TensorArray::VT_IDENTICAL_ELEMENT_SHAPES, static_cast<uint8_t>(identical_element_shapes), 0);
+  }
+  void add_element_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_shape) {
+    fbb_.AddOffset(TensorArray::VT_ELEMENT_SHAPE, element_shape);
+  }
+  void add_data_type(int32_t data_type) {
+    fbb_.AddElement<int32_t>(TensorArray::VT_DATA_TYPE, data_type, 0);
+  }
+  explicit TensorArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorArray> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorArray>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorArray> CreateTensorArray(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool dynamic_size = false,
+    bool identical_element_shapes = false,
+    flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_shape = 0,
+    int32_t data_type = 0) {
+  TensorArrayBuilder builder_(_fbb);
+  builder_.add_data_type(data_type);
+  builder_.add_element_shape(element_shape);
+  builder_.add_identical_element_shapes(identical_element_shapes);
+  builder_.add_dynamic_size(dynamic_size);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<TensorArray> CreateTensorArrayDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool dynamic_size = false,
+    bool identical_element_shapes = false,
+    const std::vector<int32_t> *element_shape = nullptr,
+    int32_t data_type = 0) {
+  auto element_shape__ = element_shape ? _fbb.CreateVector<int32_t>(*element_shape) : 0;
+  return mindspore::schema::CreateTensorArray(
+      _fbb,
+      dynamic_size,
+      identical_element_shapes,
+      element_shape__,
+      data_type);
+}
+
+struct TensorArrayRead FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorArrayReadBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct TensorArrayReadBuilder {
+  typedef TensorArrayRead Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit TensorArrayReadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorArrayRead> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorArrayRead>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorArrayRead> CreateTensorArrayRead(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  TensorArrayReadBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct TensorArrayWrite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef TensorArrayWriteBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct TensorArrayWriteBuilder {
+  typedef TensorArrayWrite Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit TensorArrayWriteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<TensorArrayWrite> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<TensorArrayWrite>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<TensorArrayWrite> CreateTensorArrayWrite(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  TensorArrayWriteBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct Affine FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AffineBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_CONTEXT = 4,
+    VT_OUTPUT_DIM = 6,
+    VT_ACTIVATION_TYPE = 8,
+    VT_TRANSPOSE_A = 10,
+    VT_TRANSPOSE_B = 12
+  };
+  const flatbuffers::Vector<int64_t> *context() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_CONTEXT);
+  }
+  int64_t output_dim() const {
+    return GetField<int64_t>(VT_OUTPUT_DIM, 0);
+  }
+  mindspore::schema::ActivationType activation_type() const {
+    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
+  }
+  bool transpose_a() const {
+    return GetField<uint8_t>(VT_TRANSPOSE_A, 0) != 0;
+  }
+  bool transpose_b() const {
+    return GetField<uint8_t>(VT_TRANSPOSE_B, 0) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_CONTEXT) &&
+           verifier.VerifyVector(context()) &&
+           VerifyField<int64_t>(verifier, VT_OUTPUT_DIM) &&
+           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
+           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_A) &&
+           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_B) &&
+           verifier.EndTable();
+  }
+};
+
+struct AffineBuilder {
+  typedef Affine Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_context(flatbuffers::Offset<flatbuffers::Vector<int64_t>> context) {
+    fbb_.AddOffset(Affine::VT_CONTEXT, context);
+  }
+  void add_output_dim(int64_t output_dim) {
+    fbb_.AddElement<int64_t>(Affine::VT_OUTPUT_DIM, output_dim, 0);
+  }
+  void add_activation_type(mindspore::schema::ActivationType activation_type) {
+    fbb_.AddElement<int8_t>(Affine::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
+  }
+  void add_transpose_a(bool transpose_a) {
+    fbb_.AddElement<uint8_t>(Affine::VT_TRANSPOSE_A, static_cast<uint8_t>(transpose_a), 0);
+  }
+  void add_transpose_b(bool transpose_b) {
+    fbb_.AddElement<uint8_t>(Affine::VT_TRANSPOSE_B, static_cast<uint8_t>(transpose_b), 0);
+  }
+  explicit AffineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Affine> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Affine>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Affine> CreateAffine(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> context = 0,
+    int64_t output_dim = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    bool transpose_a = false,
+    bool transpose_b = false) {
+  AffineBuilder builder_(_fbb);
+  builder_.add_output_dim(output_dim);
+  builder_.add_context(context);
+  builder_.add_transpose_b(transpose_b);
+  builder_.add_transpose_a(transpose_a);
+  builder_.add_activation_type(activation_type);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Affine> CreateAffineDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *context = nullptr,
+    int64_t output_dim = 0,
+    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
+    bool transpose_a = false,
+    bool transpose_b = false) {
+  auto context__ = context ? _fbb.CreateVector<int64_t>(*context) : 0;
+  return mindspore::schema::CreateAffine(
+      _fbb,
+      context__,
+      output_dim,
+      activation_type,
+      transpose_a,
+      transpose_b);
+}
+
+struct ScatterNdUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ScatterNdUpdateBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct ScatterNdUpdateBuilder {
+  typedef ScatterNdUpdate Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit ScatterNdUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ScatterNdUpdate> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ScatterNdUpdate>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ScatterNdUpdate> CreateScatterNdUpdate(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  ScatterNdUpdateBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct AllGather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AllGatherBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_GROUP = 4,
+    VT_RANK_SIZE = 6
+  };
+  const flatbuffers::String *group() const {
+    return GetPointer<const flatbuffers::String *>(VT_GROUP);
+  }
+  int32_t rank_size() const {
+    return GetField<int32_t>(VT_RANK_SIZE, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_GROUP) &&
+           verifier.VerifyString(group()) &&
+           VerifyField<int32_t>(verifier, VT_RANK_SIZE) &&
+           verifier.EndTable();
+  }
+};
+
+struct AllGatherBuilder {
+  typedef AllGather Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_group(flatbuffers::Offset<flatbuffers::String> group) {
+    fbb_.AddOffset(AllGather::VT_GROUP, group);
+  }
+  void add_rank_size(int32_t rank_size) {
+    fbb_.AddElement<int32_t>(AllGather::VT_RANK_SIZE, rank_size, 0);
+  }
+  explicit AllGatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<AllGather> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<AllGather>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<AllGather> CreateAllGather(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> group = 0,
+    int32_t rank_size = 0) {
+  AllGatherBuilder builder_(_fbb);
+  builder_.add_rank_size(rank_size);
+  builder_.add_group(group);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<AllGather> CreateAllGatherDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *group = nullptr,
+    int32_t rank_size = 0) {
+  auto group__ = group ? _fbb.CreateString(group) : 0;
+  return mindspore::schema::CreateAllGather(
+      _fbb,
+      group__,
+      rank_size);
+}
+
+struct ReduceScatter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef ReduceScatterBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_GROUP = 4,
+    VT_MODE = 6,
+    VT_RANK_SIZE = 8
+  };
+  const flatbuffers::String *group() const {
+    return GetPointer<const flatbuffers::String *>(VT_GROUP);
+  }
+  mindspore::schema::ReduceMode mode() const {
+    return static_cast<mindspore::schema::ReduceMode>(GetField<int8_t>(VT_MODE, 0));
+  }
+  int32_t rank_size() const {
+    return GetField<int32_t>(VT_RANK_SIZE, 0);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_GROUP) &&
+           verifier.VerifyString(group()) &&
+           VerifyField<int8_t>(verifier, VT_MODE) &&
+           VerifyField<int32_t>(verifier, VT_RANK_SIZE) &&
+           verifier.EndTable();
+  }
+};
+
+struct ReduceScatterBuilder {
+  typedef ReduceScatter Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_group(flatbuffers::Offset<flatbuffers::String> group) {
+    fbb_.AddOffset(ReduceScatter::VT_GROUP, group);
+  }
+  void add_mode(mindspore::schema::ReduceMode mode) {
+    fbb_.AddElement<int8_t>(ReduceScatter::VT_MODE, static_cast<int8_t>(mode), 0);
+  }
+  void add_rank_size(int32_t rank_size) {
+    fbb_.AddElement<int32_t>(ReduceScatter::VT_RANK_SIZE, rank_size, 0);
+  }
+  explicit ReduceScatterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<ReduceScatter> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<ReduceScatter>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<ReduceScatter> CreateReduceScatter(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> group = 0,
+    mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean,
+    int32_t rank_size = 0) {
+  ReduceScatterBuilder builder_(_fbb);
+  builder_.add_rank_size(rank_size);
+  builder_.add_group(group);
+  builder_.add_mode(mode);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<ReduceScatter> CreateReduceScatterDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *group = nullptr,
+    mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean,
+    int32_t rank_size = 0) {
+  auto group__ = group ? _fbb.CreateString(group) : 0;
+  return mindspore::schema::CreateReduceScatter(
+      _fbb,
+      group__,
+      mode,
+      rank_size);
+}
+
+struct DynamicQuant FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef DynamicQuantBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SYMMETRIC = 4,
+    VT_DST_TYPE = 6
+  };
+  bool symmetric() const {
+    return GetField<uint8_t>(VT_SYMMETRIC, 0) != 0;
+  }
+  int64_t dst_type() const {
+    return GetField<int64_t>(VT_DST_TYPE, 32LL);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_SYMMETRIC) &&
+           VerifyField<int64_t>(verifier, VT_DST_TYPE) &&
+           verifier.EndTable();
+  }
+};
+
+struct DynamicQuantBuilder {
+  typedef DynamicQuant Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_symmetric(bool symmetric) {
+    fbb_.AddElement<uint8_t>(DynamicQuant::VT_SYMMETRIC, static_cast<uint8_t>(symmetric), 0);
+  }
+  void add_dst_type(int64_t dst_type) {
+    fbb_.AddElement<int64_t>(DynamicQuant::VT_DST_TYPE, dst_type, 32LL);
+  }
+  explicit DynamicQuantBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<DynamicQuant> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<DynamicQuant>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<DynamicQuant> CreateDynamicQuant(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool symmetric = false,
+    int64_t dst_type = 32LL) {
+  DynamicQuantBuilder builder_(_fbb);
+  builder_.add_dst_type(dst_type);
+  builder_.add_symmetric(symmetric);
+  return builder_.Finish();
+}
+
+struct LSTMGradData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LSTMGradDataBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BIDIRECTIONAL = 4,
+    VT_HAS_BIAS = 6,
+    VT_INPUT_SIZE = 8,
+    VT_HIDDEN_SIZE = 10,
+    VT_NUM_LAYERS = 12,
+    VT_NUM_DIRECTIONS = 14,
+    VT_DROPOUT = 16,
+    VT_ZONEOUT_CELL = 18,
+    VT_ZONEOUT_HIDDEN = 20
+  };
+  bool bidirectional() const {
+    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
+  }
+  bool has_bias() const {
+    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
+  }
+  int64_t input_size() const {
+    return GetField<int64_t>(VT_INPUT_SIZE, 0);
+  }
+  int64_t hidden_size() const {
+    return GetField<int64_t>(VT_HIDDEN_SIZE, 0);
+  }
+  int64_t num_layers() const {
+    return GetField<int64_t>(VT_NUM_LAYERS, 0);
+  }
+  int64_t num_directions() const {
+    return GetField<int64_t>(VT_NUM_DIRECTIONS, 0);
+  }
+  float dropout() const {
+    return GetField<float>(VT_DROPOUT, 0.0f);
+  }
+  float zoneout_cell() const {
+    return GetField<float>(VT_ZONEOUT_CELL, 0.0f);
+  }
+  float zoneout_hidden() const {
+    return GetField<float>(VT_ZONEOUT_HIDDEN, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
+           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_HIDDEN_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_NUM_LAYERS) &&
+           VerifyField<int64_t>(verifier, VT_NUM_DIRECTIONS) &&
+           VerifyField<float>(verifier, VT_DROPOUT) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_CELL) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_HIDDEN) &&
+           verifier.EndTable();
+  }
+};
+
+struct LSTMGradDataBuilder {
+  typedef LSTMGradData Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_bidirectional(bool bidirectional) {
+    fbb_.AddElement<uint8_t>(LSTMGradData::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
+  }
+  void add_has_bias(bool has_bias) {
+    fbb_.AddElement<uint8_t>(LSTMGradData::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
+  }
+  void add_input_size(int64_t input_size) {
+    fbb_.AddElement<int64_t>(LSTMGradData::VT_INPUT_SIZE, input_size, 0);
+  }
+  void add_hidden_size(int64_t hidden_size) {
+    fbb_.AddElement<int64_t>(LSTMGradData::VT_HIDDEN_SIZE, hidden_size, 0);
+  }
+  void add_num_layers(int64_t num_layers) {
+    fbb_.AddElement<int64_t>(LSTMGradData::VT_NUM_LAYERS, num_layers, 0);
+  }
+  void add_num_directions(int64_t num_directions) {
+    fbb_.AddElement<int64_t>(LSTMGradData::VT_NUM_DIRECTIONS, num_directions, 0);
+  }
+  void add_dropout(float dropout) {
+    fbb_.AddElement<float>(LSTMGradData::VT_DROPOUT, dropout, 0.0f);
+  }
+  void add_zoneout_cell(float zoneout_cell) {
+    fbb_.AddElement<float>(LSTMGradData::VT_ZONEOUT_CELL, zoneout_cell, 0.0f);
+  }
+  void add_zoneout_hidden(float zoneout_hidden) {
+    fbb_.AddElement<float>(LSTMGradData::VT_ZONEOUT_HIDDEN, zoneout_hidden, 0.0f);
+  }
+  explicit LSTMGradDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LSTMGradData> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LSTMGradData>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LSTMGradData> CreateLSTMGradData(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool bidirectional = false,
+    bool has_bias = false,
+    int64_t input_size = 0,
+    int64_t hidden_size = 0,
+    int64_t num_layers = 0,
+    int64_t num_directions = 0,
+    float dropout = 0.0f,
+    float zoneout_cell = 0.0f,
+    float zoneout_hidden = 0.0f) {
+  LSTMGradDataBuilder builder_(_fbb);
+  builder_.add_num_directions(num_directions);
+  builder_.add_num_layers(num_layers);
+  builder_.add_hidden_size(hidden_size);
+  builder_.add_input_size(input_size);
+  builder_.add_zoneout_hidden(zoneout_hidden);
+  builder_.add_zoneout_cell(zoneout_cell);
+  builder_.add_dropout(dropout);
+  builder_.add_has_bias(has_bias);
+  builder_.add_bidirectional(bidirectional);
+  return builder_.Finish();
+}
+
+struct LSTMGradWeight FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef LSTMGradWeightBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_BIDIRECTIONAL = 4,
+    VT_HAS_BIAS = 6,
+    VT_INPUT_SIZE = 8,
+    VT_HIDDEN_SIZE = 10,
+    VT_NUM_LAYERS = 12,
+    VT_NUM_DIRECTIONS = 14,
+    VT_DROPOUT = 16,
+    VT_ZONEOUT_CELL = 18,
+    VT_ZONEOUT_HIDDEN = 20
+  };
+  bool bidirectional() const {
+    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
+  }
+  bool has_bias() const {
+    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
+  }
+  int64_t input_size() const {
+    return GetField<int64_t>(VT_INPUT_SIZE, 0);
+  }
+  int64_t hidden_size() const {
+    return GetField<int64_t>(VT_HIDDEN_SIZE, 0);
+  }
+  int64_t num_layers() const {
+    return GetField<int64_t>(VT_NUM_LAYERS, 0);
+  }
+  int64_t num_directions() const {
+    return GetField<int64_t>(VT_NUM_DIRECTIONS, 0);
+  }
+  float dropout() const {
+    return GetField<float>(VT_DROPOUT, 0.0f);
+  }
+  float zoneout_cell() const {
+    return GetField<float>(VT_ZONEOUT_CELL, 0.0f);
+  }
+  float zoneout_hidden() const {
+    return GetField<float>(VT_ZONEOUT_HIDDEN, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
+           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
+           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_HIDDEN_SIZE) &&
+           VerifyField<int64_t>(verifier, VT_NUM_LAYERS) &&
+           VerifyField<int64_t>(verifier, VT_NUM_DIRECTIONS) &&
+           VerifyField<float>(verifier, VT_DROPOUT) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_CELL) &&
+           VerifyField<float>(verifier, VT_ZONEOUT_HIDDEN) &&
+           verifier.EndTable();
+  }
+};
+
+struct LSTMGradWeightBuilder {
+  typedef LSTMGradWeight Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_bidirectional(bool bidirectional) {
+    fbb_.AddElement<uint8_t>(LSTMGradWeight::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
+  }
+  void add_has_bias(bool has_bias) {
+    fbb_.AddElement<uint8_t>(LSTMGradWeight::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
+  }
+  void add_input_size(int64_t input_size) {
+    fbb_.AddElement<int64_t>(LSTMGradWeight::VT_INPUT_SIZE, input_size, 0);
+  }
+  void add_hidden_size(int64_t hidden_size) {
+    fbb_.AddElement<int64_t>(LSTMGradWeight::VT_HIDDEN_SIZE, hidden_size, 0);
+  }
+  void add_num_layers(int64_t num_layers) {
+    fbb_.AddElement<int64_t>(LSTMGradWeight::VT_NUM_LAYERS, num_layers, 0);
+  }
+  void add_num_directions(int64_t num_directions) {
+    fbb_.AddElement<int64_t>(LSTMGradWeight::VT_NUM_DIRECTIONS, num_directions, 0);
+  }
+  void add_dropout(float dropout) {
+    fbb_.AddElement<float>(LSTMGradWeight::VT_DROPOUT, dropout, 0.0f);
+  }
+  void add_zoneout_cell(float zoneout_cell) {
+    fbb_.AddElement<float>(LSTMGradWeight::VT_ZONEOUT_CELL, zoneout_cell, 0.0f);
+  }
+  void add_zoneout_hidden(float zoneout_hidden) {
+    fbb_.AddElement<float>(LSTMGradWeight::VT_ZONEOUT_HIDDEN, zoneout_hidden, 0.0f);
+  }
+  explicit LSTMGradWeightBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<LSTMGradWeight> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<LSTMGradWeight>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<LSTMGradWeight> CreateLSTMGradWeight(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    bool bidirectional = false,
+    bool has_bias = false,
+    int64_t input_size = 0,
+    int64_t hidden_size = 0,
+    int64_t num_layers = 0,
+    int64_t num_directions = 0,
+    float dropout = 0.0f,
+    float zoneout_cell = 0.0f,
+    float zoneout_hidden = 0.0f) {
+  LSTMGradWeightBuilder builder_(_fbb);
+  builder_.add_num_directions(num_directions);
+  builder_.add_num_layers(num_layers);
+  builder_.add_hidden_size(hidden_size);
+  builder_.add_input_size(input_size);
+  builder_.add_zoneout_hidden(zoneout_hidden);
+  builder_.add_zoneout_cell(zoneout_cell);
+  builder_.add_dropout(dropout);
+  builder_.add_has_bias(has_bias);
+  builder_.add_bidirectional(bidirectional);
+  return builder_.Finish();
+}
+
+struct RandomNormal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef RandomNormalBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SEED = 4,
+    VT_MEAN = 6,
+    VT_SCALE = 8
+  };
+  float seed() const {
+    return GetField<float>(VT_SEED, 0.0f);
+  }
+  float mean() const {
+    return GetField<float>(VT_MEAN, 0.0f);
+  }
+  float scale() const {
+    return GetField<float>(VT_SCALE, 0.0f);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<float>(verifier, VT_SEED) &&
+           VerifyField<float>(verifier, VT_MEAN) &&
+           VerifyField<float>(verifier, VT_SCALE) &&
+           verifier.EndTable();
+  }
+};
+
+struct RandomNormalBuilder {
+  typedef RandomNormal Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_seed(float seed) {
+    fbb_.AddElement<float>(RandomNormal::VT_SEED, seed, 0.0f);
+  }
+  void add_mean(float mean) {
+    fbb_.AddElement<float>(RandomNormal::VT_MEAN, mean, 0.0f);
+  }
+  void add_scale(float scale) {
+    fbb_.AddElement<float>(RandomNormal::VT_SCALE, scale, 0.0f);
+  }
+  explicit RandomNormalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<RandomNormal> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<RandomNormal>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<RandomNormal> CreateRandomNormal(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    float seed = 0.0f,
+    float mean = 0.0f,
+    float scale = 0.0f) {
+  RandomNormalBuilder builder_(_fbb);
+  builder_.add_scale(scale);
+  builder_.add_mean(mean);
+  builder_.add_seed(seed);
+  return builder_.Finish();
+}
+
+struct NLLLoss FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NLLLossBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_REDUCTION = 4
+  };
+  mindspore::schema::Reduction reduction() const {
+    return static_cast<mindspore::schema::Reduction>(GetField<int8_t>(VT_REDUCTION, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_REDUCTION) &&
+           verifier.EndTable();
+  }
+};
+
+struct NLLLossBuilder {
+  typedef NLLLoss Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_reduction(mindspore::schema::Reduction reduction) {
+    fbb_.AddElement<int8_t>(NLLLoss::VT_REDUCTION, static_cast<int8_t>(reduction), 0);
+  }
+  explicit NLLLossBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<NLLLoss> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<NLLLoss>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<NLLLoss> CreateNLLLoss(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Reduction reduction = mindspore::schema::Reduction_REDUCTION_SUM) {
+  NLLLossBuilder builder_(_fbb);
+  builder_.add_reduction(reduction);
+  return builder_.Finish();
+}
+
+struct NLLLossGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef NLLLossGradBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_REDUCTION = 4
+  };
+  mindspore::schema::Reduction reduction() const {
+    return static_cast<mindspore::schema::Reduction>(GetField<int8_t>(VT_REDUCTION, 0));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int8_t>(verifier, VT_REDUCTION) &&
+           verifier.EndTable();
+  }
+};
+
+struct NLLLossGradBuilder {
+  typedef NLLLossGrad Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_reduction(mindspore::schema::Reduction reduction) {
+    fbb_.AddElement<int8_t>(NLLLossGrad::VT_REDUCTION, static_cast<int8_t>(reduction), 0);
+  }
+  explicit NLLLossGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<NLLLossGrad> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<NLLLossGrad>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<NLLLossGrad> CreateNLLLossGrad(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Reduction reduction = mindspore::schema::Reduction_REDUCTION_SUM) {
+  NLLLossGradBuilder builder_(_fbb);
+  builder_.add_reduction(reduction);
+  return builder_.Finish();
+}
+
+struct FormatTranspose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef FormatTransposeBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_SRC_FORMAT = 4,
+    VT_DST_FORMAT = 6
+  };
+  mindspore::schema::Format src_format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_SRC_FORMAT, 1));
+  }
+  mindspore::schema::Format dst_format() const {
+    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_DST_FORMAT, 1));
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int32_t>(verifier, VT_SRC_FORMAT) &&
+           VerifyField<int32_t>(verifier, VT_DST_FORMAT) &&
+           verifier.EndTable();
+  }
+};
+
+struct FormatTransposeBuilder {
+  typedef FormatTranspose Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_src_format(mindspore::schema::Format src_format) {
+    fbb_.AddElement<int32_t>(FormatTranspose::VT_SRC_FORMAT, static_cast<int32_t>(src_format), 1);
+  }
+  void add_dst_format(mindspore::schema::Format dst_format) {
+    fbb_.AddElement<int32_t>(FormatTranspose::VT_DST_FORMAT, static_cast<int32_t>(dst_format), 1);
+  }
+  explicit FormatTransposeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<FormatTranspose> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<FormatTranspose>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<FormatTranspose> CreateFormatTranspose(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    mindspore::schema::Format src_format = mindspore::schema::Format_NHWC,
+    mindspore::schema::Format dst_format = mindspore::schema::Format_NHWC) {
+  FormatTransposeBuilder builder_(_fbb);
+  builder_.add_dst_format(dst_format);
+  builder_.add_src_format(src_format);
+  return builder_.Finish();
+}
+
+struct GatherD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GatherDBuilder Builder;
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           verifier.EndTable();
+  }
+};
+
+struct GatherDBuilder {
+  typedef GatherD Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  explicit GatherDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GatherD> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GatherD>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GatherD> CreateGatherD(
+    flatbuffers::FlatBufferBuilder &_fbb) {
+  GatherDBuilder builder_(_fbb);
+  return builder_.Finish();
+}
+
+struct GroupNormFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef GroupNormFusionBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NUM_GROUPS = 4,
+    VT_EPSILON = 6,
+    VT_AFFINE = 8
+  };
+  int64_t num_groups() const {
+    return GetField<int64_t>(VT_NUM_GROUPS, 0);
+  }
+  float epsilon() const {
+    return GetField<float>(VT_EPSILON, 1e-5f);
+  }
+  bool affine() const {
+    return GetField<uint8_t>(VT_AFFINE, 1) != 0;
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyField<int64_t>(verifier, VT_NUM_GROUPS) &&
+           VerifyField<float>(verifier, VT_EPSILON) &&
+           VerifyField<uint8_t>(verifier, VT_AFFINE) &&
+           verifier.EndTable();
+  }
+};
+
+struct GroupNormFusionBuilder {
+  typedef GroupNormFusion Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_num_groups(int64_t num_groups) {
+    fbb_.AddElement<int64_t>(GroupNormFusion::VT_NUM_GROUPS, num_groups, 0);
+  }
+  void add_epsilon(float epsilon) {
+    fbb_.AddElement<float>(GroupNormFusion::VT_EPSILON, epsilon, 1e-5f);
+  }
+  void add_affine(bool affine) {
+    fbb_.AddElement<uint8_t>(GroupNormFusion::VT_AFFINE, static_cast<uint8_t>(affine), 1);
+  }
+  explicit GroupNormFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<GroupNormFusion> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<GroupNormFusion>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<GroupNormFusion> CreateGroupNormFusion(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    int64_t num_groups = 0,
+    float epsilon = 1e-5f,
+    bool affine = true) {
+  GroupNormFusionBuilder builder_(_fbb);
+  builder_.add_num_groups(num_groups);
+  builder_.add_epsilon(epsilon);
+  builder_.add_affine(affine);
+  return builder_.Finish();
+}
+
+inline bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type) {
+  switch (type) {
+    case PrimitiveType_NONE: {
+      return true;
+    }
+    case PrimitiveType_Abs: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Abs *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Activation: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Activation *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ActivationGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ActivationGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Adam: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Adam *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AddFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AddFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AdderFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AdderFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AddGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AddGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AddN: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AddN *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_All: {
+      auto ptr = reinterpret_cast<const mindspore::schema::All *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ApplyMomentum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ApplyMomentum *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ArgMaxFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ArgMaxFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ArgMinFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ArgMinFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Assert: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Assert *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Assign: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Assign *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AssignAdd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AssignAdd *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AudioSpectrogram: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AudioSpectrogram *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AvgPoolFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AvgPoolGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BatchNorm: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchNorm *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BatchNormGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchNormGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BatchToSpace: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpace *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BatchToSpaceND: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpaceND *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BiasAdd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BiasAdd *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BinaryCrossEntropy: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropy *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BinaryCrossEntropyGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropyGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BiasAddGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BiasAddGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_BroadcastTo: {
+      auto ptr = reinterpret_cast<const mindspore::schema::BroadcastTo *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Cast: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Cast *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Ceil: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Ceil *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Clip: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Clip *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Concat: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Concat *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Attention: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Attention *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Conv2DBackpropFilterFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropFilterFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Conv2DBackpropInputFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropInputFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Conv2DFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Conv2dTransposeFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Conv2dTransposeFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Cos: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Cos *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ConstantOfShape: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ConstantOfShape *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Crop: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Crop *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_CustomExtractFeatures: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomExtractFeatures *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_CustomNormalize: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomNormalize *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_CustomPredict: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CustomPredict *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DeConv2DGradFilter: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DeConv2DGradFilter *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Depend: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Depend *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DepthToSpace: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DepthToSpace *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DetectionPostProcess: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DetectionPostProcess *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DivFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DivFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DivGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DivGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Dropout: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Dropout *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DropoutGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DropoutGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Elu: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Elu *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Eltwise: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Eltwise *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Equal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Equal *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_EmbeddingLookupFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::EmbeddingLookupFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ExpFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ExpFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ExpandDims: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ExpandDims *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FakeQuantWithMinMaxVars: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVars *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FakeQuantWithMinMaxVarsPerChannel: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsPerChannel *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FftReal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FftReal *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FftImag: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FftImag *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Flatten: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Flatten *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FlattenGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FlattenGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Floor: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Floor *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FloorDiv: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FloorDiv *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FloorMod: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FloorMod *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Fill: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Fill *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FullConnection: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FullConnection *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FusedBatchNorm: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FusedBatchNorm *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Gather: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Gather *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GatherNd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GatherNd *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Greater: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Greater *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GreaterEqual: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GreaterEqual *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_HashtableLookup: {
+      auto ptr = reinterpret_cast<const mindspore::schema::HashtableLookup *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_InstanceNorm: {
+      auto ptr = reinterpret_cast<const mindspore::schema::InstanceNorm *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LayerNormFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LeakyRelu: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LeakyRelu *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Less: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Less *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LessEqual: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LessEqual *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Log: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Log *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LogGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LogicalAnd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogicalAnd *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LogicalNot: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogicalNot *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LogicalOr: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogicalOr *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LpNormalization: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LpNormalization *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LRN: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LRN *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LshProjection: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LshProjection *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LSTM: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTM *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_L2NormalizeFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::L2NormalizeFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MatMulFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MatMulFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Maximum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Maximum *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MaximumGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaximumGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MaxPoolFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MaxPoolGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SwitchLayer: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SwitchLayer *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Mfcc: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Mfcc *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Minimum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Minimum *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MinimumGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MinimumGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Mod: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Mod *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MulFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MulFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_MulGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::MulGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Neg: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Neg *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_NegGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NegGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_NotEqual: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NotEqual *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_NonMaxSuppression: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NonMaxSuppression *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_OneHot: {
+      auto ptr = reinterpret_cast<const mindspore::schema::OneHot *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_OnesLike: {
+      auto ptr = reinterpret_cast<const mindspore::schema::OnesLike *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_PadFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PadFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_PartialFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PartialFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_PowerGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PowerGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_PowFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PowFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_PriorBox: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PriorBox *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_PReLUFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::PReLUFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_QuantDTypeCast: {
+      auto ptr = reinterpret_cast<const mindspore::schema::QuantDTypeCast *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Rank: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Rank *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Range: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Range *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Reciprocal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Reciprocal *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_RealDiv: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RealDiv *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ReduceFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReduceFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Reshape: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Reshape *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Resize: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Resize *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ReverseSequence: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReverseSequence *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ReverseV2: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReverseV2 *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Rfft: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Rfft *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ROIPooling: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ROIPooling *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Round: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Round *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Rsqrt: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Rsqrt *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ScaleFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ScaleFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ScatterNd: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNd *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SGD: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SGD *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Shape: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Shape *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogits *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Sin: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Sin *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SkipGram: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SkipGram *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SliceFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SliceFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SmoothL1Loss: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1Loss *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SmoothL1LossGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1LossGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Softmax: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Softmax *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SoftmaxCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SoftmaxCrossEntropyWithLogits *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SpaceToBatch: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatch *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SpaceToBatchND: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatchND *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SpaceToDepth: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToDepth *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SparseSoftmaxCrossEntropyWithLogits: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SparseSoftmaxCrossEntropyWithLogits *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SparseToDense: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SparseToDense *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Split: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Split *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Sqrt: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Sqrt *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Squeeze: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Squeeze *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Square: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Square *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SquaredDifference: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SquaredDifference *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Stack: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Stack *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_StridedSlice: {
+      auto ptr = reinterpret_cast<const mindspore::schema::StridedSlice *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SubFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SubFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SubGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SubGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Switch: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Switch *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorListFromTensor: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListFromTensor *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorListGetItem: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListGetItem *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorListReserve: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListReserve *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorListSetItem: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListSetItem *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorListStack: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorListStack *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TileFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TileFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TopKFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TopKFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Transpose: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Transpose *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Unique: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Unique *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_UnsortedSegmentSum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::UnsortedSegmentSum *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Unsqueeze: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Unsqueeze *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Unstack: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Unstack *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LSTMGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Where: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Where *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ZerosLike: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ZerosLike *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Select: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Select *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ScatterNdUpdate: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNdUpdate *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GRU: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GRU *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_NonZero: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NonZero *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_InvertPermutation: {
+      auto ptr = reinterpret_cast<const mindspore::schema::InvertPermutation *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Size: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Size *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_RandomStandardNormal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RandomStandardNormal *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_CropAndResize: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CropAndResize *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Erf: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Erf *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_StridedSliceGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::StridedSliceGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_IsFinite: {
+      auto ptr = reinterpret_cast<const mindspore::schema::IsFinite *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LinSpace: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LinSpace *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_UniformReal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::UniformReal *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AbsGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AbsGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_RsqrtGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RsqrtGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SqrtGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SqrtGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LayerNormGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ResizeGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ResizeGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Splice: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Splice *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LogSoftmax: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LogSoftmax *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Call: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Call *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Custom: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Custom *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_CumSum: {
+      auto ptr = reinterpret_cast<const mindspore::schema::CumSum *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_SplitWithOverlap: {
+      auto ptr = reinterpret_cast<const mindspore::schema::SplitWithOverlap *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GenOP: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GenOP *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_RaggedRange: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RaggedRange *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GLU: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GLU *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorArray: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorArray *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorArrayRead: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayRead *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_TensorArrayWrite: {
+      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayWrite *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_Affine: {
+      auto ptr = reinterpret_cast<const mindspore::schema::Affine *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_AllGather: {
+      auto ptr = reinterpret_cast<const mindspore::schema::AllGather *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_ReduceScatter: {
+      auto ptr = reinterpret_cast<const mindspore::schema::ReduceScatter *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_DynamicQuant: {
+      auto ptr = reinterpret_cast<const mindspore::schema::DynamicQuant *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LSTMGradData: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGradData *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_LSTMGradWeight: {
+      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGradWeight *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_RandomNormal: {
+      auto ptr = reinterpret_cast<const mindspore::schema::RandomNormal *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_NLLLoss: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NLLLoss *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_NLLLossGrad: {
+      auto ptr = reinterpret_cast<const mindspore::schema::NLLLossGrad *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_FormatTranspose: {
+      auto ptr = reinterpret_cast<const mindspore::schema::FormatTranspose *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GatherD: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GatherD *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    case PrimitiveType_GroupNormFusion: {
+      auto ptr = reinterpret_cast<const mindspore::schema::GroupNormFusion *>(obj);
+      return verifier.VerifyTable(ptr);
+    }
+    default: return true;
+  }
+}
+
+inline bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
+  if (!values || !types) return !values && !types;
+  if (values->size() != types->size()) return false;
+  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
+    if (!VerifyPrimitiveType(
+        verifier,  values->Get(i), types->GetEnum<PrimitiveType>(i))) {
+      return false;
+    }
+  }
+  return true;
+}
+
+}  // namespace schema
+}  // namespace mindspore
+
+#endif  // FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
diff --git a/mindspore/lite/schema/ops_types_generated.h b/mindspore/lite/schema/ops_types_generated.h
new file mode 100644
index 00000000..cb8de016
--- /dev/null
+++ b/mindspore/lite/schema/ops_types_generated.h
@@ -0,0 +1,747 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+
+
+#ifndef FLATBUFFERS_GENERATED_OPSTYPES_MINDSPORE_SCHEMA_H_
+#define FLATBUFFERS_GENERATED_OPSTYPES_MINDSPORE_SCHEMA_H_
+
+#include "flatbuffers/flatbuffers.h"
+
+namespace mindspore {
+namespace schema {
+
+struct Vec;
+struct VecBuilder;
+
+struct Vec2D;
+struct Vec2DBuilder;
+
+struct Attribute;
+struct AttributeBuilder;
+
+enum ResizeMethod : int8_t {
+  ResizeMethod_UNKNOWN = -1,
+  ResizeMethod_LINEAR = 0,
+  ResizeMethod_NEAREST = 1,
+  ResizeMethod_CUBIC = 2,
+  ResizeMethod_MIN = ResizeMethod_UNKNOWN,
+  ResizeMethod_MAX = ResizeMethod_CUBIC
+};
+
+inline const ResizeMethod (&EnumValuesResizeMethod())[4] {
+  static const ResizeMethod values[] = {
+    ResizeMethod_UNKNOWN,
+    ResizeMethod_LINEAR,
+    ResizeMethod_NEAREST,
+    ResizeMethod_CUBIC
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesResizeMethod() {
+  static const char * const names[5] = {
+    "UNKNOWN",
+    "LINEAR",
+    "NEAREST",
+    "CUBIC",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameResizeMethod(ResizeMethod e) {
+  if (flatbuffers::IsOutRange(e, ResizeMethod_UNKNOWN, ResizeMethod_CUBIC)) return "";
+  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ResizeMethod_UNKNOWN);
+  return EnumNamesResizeMethod()[index];
+}
+
+enum CoordinateTransformMode : int8_t {
+  CoordinateTransformMode_ASYMMETRIC = 0,
+  CoordinateTransformMode_ALIGN_CORNERS = 1,
+  CoordinateTransformMode_HALF_PIXEL = 2,
+  CoordinateTransformMode_MIN = CoordinateTransformMode_ASYMMETRIC,
+  CoordinateTransformMode_MAX = CoordinateTransformMode_HALF_PIXEL
+};
+
+inline const CoordinateTransformMode (&EnumValuesCoordinateTransformMode())[3] {
+  static const CoordinateTransformMode values[] = {
+    CoordinateTransformMode_ASYMMETRIC,
+    CoordinateTransformMode_ALIGN_CORNERS,
+    CoordinateTransformMode_HALF_PIXEL
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesCoordinateTransformMode() {
+  static const char * const names[4] = {
+    "ASYMMETRIC",
+    "ALIGN_CORNERS",
+    "HALF_PIXEL",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameCoordinateTransformMode(CoordinateTransformMode e) {
+  if (flatbuffers::IsOutRange(e, CoordinateTransformMode_ASYMMETRIC, CoordinateTransformMode_HALF_PIXEL)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesCoordinateTransformMode()[index];
+}
+
+enum NearestMode : int8_t {
+  NearestMode_NORMAL = 0,
+  NearestMode_ROUND_HALF_DOWN = 1,
+  NearestMode_ROUND_HALF_UP = 2,
+  NearestMode_FLOOR = 3,
+  NearestMode_CEIL = 4,
+  NearestMode_MIN = NearestMode_NORMAL,
+  NearestMode_MAX = NearestMode_CEIL
+};
+
+inline const NearestMode (&EnumValuesNearestMode())[5] {
+  static const NearestMode values[] = {
+    NearestMode_NORMAL,
+    NearestMode_ROUND_HALF_DOWN,
+    NearestMode_ROUND_HALF_UP,
+    NearestMode_FLOOR,
+    NearestMode_CEIL
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesNearestMode() {
+  static const char * const names[6] = {
+    "NORMAL",
+    "ROUND_HALF_DOWN",
+    "ROUND_HALF_UP",
+    "FLOOR",
+    "CEIL",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameNearestMode(NearestMode e) {
+  if (flatbuffers::IsOutRange(e, NearestMode_NORMAL, NearestMode_CEIL)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesNearestMode()[index];
+}
+
+enum Format : int32_t {
+  Format_NCHW = 0,
+  Format_NHWC = 1,
+  Format_NHWC4 = 2,
+  Format_HWKC = 3,
+  Format_HWCK = 4,
+  Format_KCHW = 5,
+  Format_CKHW = 6,
+  Format_KHWC = 7,
+  Format_CHWK = 8,
+  Format_HW = 9,
+  Format_HW4 = 10,
+  Format_NC = 11,
+  Format_NC4 = 12,
+  Format_NC4HW4 = 13,
+  Format_NUM_OF_FORMAT = 14,
+  Format_NCDHW = 15,
+  Format_NWC = 16,
+  Format_NCW = 17,
+  Format_MIN = Format_NCHW,
+  Format_MAX = Format_NCW
+};
+
+inline const Format (&EnumValuesFormat())[18] {
+  static const Format values[] = {
+    Format_NCHW,
+    Format_NHWC,
+    Format_NHWC4,
+    Format_HWKC,
+    Format_HWCK,
+    Format_KCHW,
+    Format_CKHW,
+    Format_KHWC,
+    Format_CHWK,
+    Format_HW,
+    Format_HW4,
+    Format_NC,
+    Format_NC4,
+    Format_NC4HW4,
+    Format_NUM_OF_FORMAT,
+    Format_NCDHW,
+    Format_NWC,
+    Format_NCW
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesFormat() {
+  static const char * const names[19] = {
+    "NCHW",
+    "NHWC",
+    "NHWC4",
+    "HWKC",
+    "HWCK",
+    "KCHW",
+    "CKHW",
+    "KHWC",
+    "CHWK",
+    "HW",
+    "HW4",
+    "NC",
+    "NC4",
+    "NC4HW4",
+    "NUM_OF_FORMAT",
+    "NCDHW",
+    "NWC",
+    "NCW",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameFormat(Format e) {
+  if (flatbuffers::IsOutRange(e, Format_NCHW, Format_NCW)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesFormat()[index];
+}
+
+enum ActivationType : int8_t {
+  ActivationType_NO_ACTIVATION = 0,
+  ActivationType_RELU = 1,
+  ActivationType_SIGMOID = 2,
+  ActivationType_RELU6 = 3,
+  ActivationType_ELU = 4,
+  ActivationType_LEAKY_RELU = 5,
+  ActivationType_ABS = 6,
+  ActivationType_RELU1 = 7,
+  ActivationType_SOFTSIGN = 8,
+  ActivationType_SOFTPLUS = 9,
+  ActivationType_TANH = 10,
+  ActivationType_SELU = 11,
+  ActivationType_HSWISH = 12,
+  ActivationType_HSIGMOID = 13,
+  ActivationType_THRESHOLDRELU = 14,
+  ActivationType_LINEAR = 15,
+  ActivationType_HARD_TANH = 16,
+  ActivationType_SIGN = 17,
+  ActivationType_SWISH = 18,
+  ActivationType_GELU = 19,
+  ActivationType_UNKNOWN = 20,
+  ActivationType_MIN = ActivationType_NO_ACTIVATION,
+  ActivationType_MAX = ActivationType_UNKNOWN
+};
+
+inline const ActivationType (&EnumValuesActivationType())[21] {
+  static const ActivationType values[] = {
+    ActivationType_NO_ACTIVATION,
+    ActivationType_RELU,
+    ActivationType_SIGMOID,
+    ActivationType_RELU6,
+    ActivationType_ELU,
+    ActivationType_LEAKY_RELU,
+    ActivationType_ABS,
+    ActivationType_RELU1,
+    ActivationType_SOFTSIGN,
+    ActivationType_SOFTPLUS,
+    ActivationType_TANH,
+    ActivationType_SELU,
+    ActivationType_HSWISH,
+    ActivationType_HSIGMOID,
+    ActivationType_THRESHOLDRELU,
+    ActivationType_LINEAR,
+    ActivationType_HARD_TANH,
+    ActivationType_SIGN,
+    ActivationType_SWISH,
+    ActivationType_GELU,
+    ActivationType_UNKNOWN
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesActivationType() {
+  static const char * const names[22] = {
+    "NO_ACTIVATION",
+    "RELU",
+    "SIGMOID",
+    "RELU6",
+    "ELU",
+    "LEAKY_RELU",
+    "ABS",
+    "RELU1",
+    "SOFTSIGN",
+    "SOFTPLUS",
+    "TANH",
+    "SELU",
+    "HSWISH",
+    "HSIGMOID",
+    "THRESHOLDRELU",
+    "LINEAR",
+    "HARD_TANH",
+    "SIGN",
+    "SWISH",
+    "GELU",
+    "UNKNOWN",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameActivationType(ActivationType e) {
+  if (flatbuffers::IsOutRange(e, ActivationType_NO_ACTIVATION, ActivationType_UNKNOWN)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesActivationType()[index];
+}
+
+enum ReduceMode : int8_t {
+  ReduceMode_ReduceMean = 0,
+  ReduceMode_ReduceMax = 1,
+  ReduceMode_ReduceMin = 2,
+  ReduceMode_ReduceProd = 3,
+  ReduceMode_ReduceSum = 4,
+  ReduceMode_ReduceSumSquare = 5,
+  ReduceMode_ReduceASum = 6,
+  ReduceMode_ReduceAll = 7,
+  ReduceMode_ReduceL2 = 8,
+  ReduceMode_MIN = ReduceMode_ReduceMean,
+  ReduceMode_MAX = ReduceMode_ReduceL2
+};
+
+inline const ReduceMode (&EnumValuesReduceMode())[9] {
+  static const ReduceMode values[] = {
+    ReduceMode_ReduceMean,
+    ReduceMode_ReduceMax,
+    ReduceMode_ReduceMin,
+    ReduceMode_ReduceProd,
+    ReduceMode_ReduceSum,
+    ReduceMode_ReduceSumSquare,
+    ReduceMode_ReduceASum,
+    ReduceMode_ReduceAll,
+    ReduceMode_ReduceL2
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesReduceMode() {
+  static const char * const names[10] = {
+    "ReduceMean",
+    "ReduceMax",
+    "ReduceMin",
+    "ReduceProd",
+    "ReduceSum",
+    "ReduceSumSquare",
+    "ReduceASum",
+    "ReduceAll",
+    "ReduceL2",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameReduceMode(ReduceMode e) {
+  if (flatbuffers::IsOutRange(e, ReduceMode_ReduceMean, ReduceMode_ReduceL2)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesReduceMode()[index];
+}
+
+enum PoolMode : int8_t {
+  PoolMode_MAX_POOLING = 0,
+  PoolMode_MEAN_POOLING = 1,
+  PoolMode_MIN = PoolMode_MAX_POOLING,
+  PoolMode_MAX = PoolMode_MEAN_POOLING
+};
+
+inline const PoolMode (&EnumValuesPoolMode())[2] {
+  static const PoolMode values[] = {
+    PoolMode_MAX_POOLING,
+    PoolMode_MEAN_POOLING
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesPoolMode() {
+  static const char * const names[3] = {
+    "MAX_POOLING",
+    "MEAN_POOLING",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNamePoolMode(PoolMode e) {
+  if (flatbuffers::IsOutRange(e, PoolMode_MAX_POOLING, PoolMode_MEAN_POOLING)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesPoolMode()[index];
+}
+
+enum EltwiseMode : int8_t {
+  EltwiseMode_PROD = 0,
+  EltwiseMode_SUM = 1,
+  EltwiseMode_MAXIMUM = 2,
+  EltwiseMode_UNKNOWN = 3,
+  EltwiseMode_MIN = EltwiseMode_PROD,
+  EltwiseMode_MAX = EltwiseMode_UNKNOWN
+};
+
+inline const EltwiseMode (&EnumValuesEltwiseMode())[4] {
+  static const EltwiseMode values[] = {
+    EltwiseMode_PROD,
+    EltwiseMode_SUM,
+    EltwiseMode_MAXIMUM,
+    EltwiseMode_UNKNOWN
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesEltwiseMode() {
+  static const char * const names[5] = {
+    "PROD",
+    "SUM",
+    "MAXIMUM",
+    "UNKNOWN",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameEltwiseMode(EltwiseMode e) {
+  if (flatbuffers::IsOutRange(e, EltwiseMode_PROD, EltwiseMode_UNKNOWN)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesEltwiseMode()[index];
+}
+
+enum PadMode : int8_t {
+  PadMode_PAD = 0,
+  PadMode_SAME = 1,
+  PadMode_VALID = 2,
+  PadMode_MIN = PadMode_PAD,
+  PadMode_MAX = PadMode_VALID
+};
+
+inline const PadMode (&EnumValuesPadMode())[3] {
+  static const PadMode values[] = {
+    PadMode_PAD,
+    PadMode_SAME,
+    PadMode_VALID
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesPadMode() {
+  static const char * const names[4] = {
+    "PAD",
+    "SAME",
+    "VALID",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNamePadMode(PadMode e) {
+  if (flatbuffers::IsOutRange(e, PadMode_PAD, PadMode_VALID)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesPadMode()[index];
+}
+
+enum RoundMode : int8_t {
+  RoundMode_FLOOR = 0,
+  RoundMode_CEIL = 1,
+  RoundMode_MIN = RoundMode_FLOOR,
+  RoundMode_MAX = RoundMode_CEIL
+};
+
+inline const RoundMode (&EnumValuesRoundMode())[2] {
+  static const RoundMode values[] = {
+    RoundMode_FLOOR,
+    RoundMode_CEIL
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesRoundMode() {
+  static const char * const names[3] = {
+    "FLOOR",
+    "CEIL",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameRoundMode(RoundMode e) {
+  if (flatbuffers::IsOutRange(e, RoundMode_FLOOR, RoundMode_CEIL)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesRoundMode()[index];
+}
+
+enum PaddingMode : int8_t {
+  PaddingMode_CONSTANT = 0,
+  PaddingMode_REFLECT = 1,
+  PaddingMode_SYMMETRIC = 2,
+  PaddingMode_MODE_RESERVED = 3,
+  PaddingMode_MIN = PaddingMode_CONSTANT,
+  PaddingMode_MAX = PaddingMode_MODE_RESERVED
+};
+
+inline const PaddingMode (&EnumValuesPaddingMode())[4] {
+  static const PaddingMode values[] = {
+    PaddingMode_CONSTANT,
+    PaddingMode_REFLECT,
+    PaddingMode_SYMMETRIC,
+    PaddingMode_MODE_RESERVED
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesPaddingMode() {
+  static const char * const names[5] = {
+    "CONSTANT",
+    "REFLECT",
+    "SYMMETRIC",
+    "MODE_RESERVED",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNamePaddingMode(PaddingMode e) {
+  if (flatbuffers::IsOutRange(e, PaddingMode_CONSTANT, PaddingMode_MODE_RESERVED)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesPaddingMode()[index];
+}
+
+enum LshProjectionType : int8_t {
+  LshProjectionType_UNKNOWN = 0,
+  LshProjectionType_SPARSE = 1,
+  LshProjectionType_DENSE = 2,
+  LshProjectionType_MIN = LshProjectionType_UNKNOWN,
+  LshProjectionType_MAX = LshProjectionType_DENSE
+};
+
+inline const LshProjectionType (&EnumValuesLshProjectionType())[3] {
+  static const LshProjectionType values[] = {
+    LshProjectionType_UNKNOWN,
+    LshProjectionType_SPARSE,
+    LshProjectionType_DENSE
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesLshProjectionType() {
+  static const char * const names[4] = {
+    "UNKNOWN",
+    "SPARSE",
+    "DENSE",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameLshProjectionType(LshProjectionType e) {
+  if (flatbuffers::IsOutRange(e, LshProjectionType_UNKNOWN, LshProjectionType_DENSE)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesLshProjectionType()[index];
+}
+
+enum Reduction : int8_t {
+  Reduction_REDUCTION_SUM = 0,
+  Reduction_MEAN = 1,
+  Reduction_NONE = 2,
+  Reduction_MIN = Reduction_REDUCTION_SUM,
+  Reduction_MAX = Reduction_NONE
+};
+
+inline const Reduction (&EnumValuesReduction())[3] {
+  static const Reduction values[] = {
+    Reduction_REDUCTION_SUM,
+    Reduction_MEAN,
+    Reduction_NONE
+  };
+  return values;
+}
+
+inline const char * const *EnumNamesReduction() {
+  static const char * const names[4] = {
+    "REDUCTION_SUM",
+    "MEAN",
+    "NONE",
+    nullptr
+  };
+  return names;
+}
+
+inline const char *EnumNameReduction(Reduction e) {
+  if (flatbuffers::IsOutRange(e, Reduction_REDUCTION_SUM, Reduction_NONE)) return "";
+  const size_t index = static_cast<size_t>(e);
+  return EnumNamesReduction()[index];
+}
+
+struct Vec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef VecBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DATA = 4
+  };
+  const flatbuffers::Vector<int64_t> *data() const {
+    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DATA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_DATA) &&
+           verifier.VerifyVector(data()) &&
+           verifier.EndTable();
+  }
+};
+
+struct VecBuilder {
+  typedef Vec Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_data(flatbuffers::Offset<flatbuffers::Vector<int64_t>> data) {
+    fbb_.AddOffset(Vec::VT_DATA, data);
+  }
+  explicit VecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Vec> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Vec>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Vec> CreateVec(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<int64_t>> data = 0) {
+  VecBuilder builder_(_fbb);
+  builder_.add_data(data);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Vec> CreateVecDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<int64_t> *data = nullptr) {
+  auto data__ = data ? _fbb.CreateVector<int64_t>(*data) : 0;
+  return mindspore::schema::CreateVec(
+      _fbb,
+      data__);
+}
+
+struct Vec2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef Vec2DBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_DATA = 4
+  };
+  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>> *data() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>> *>(VT_DATA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_DATA) &&
+           verifier.VerifyVector(data()) &&
+           verifier.VerifyVectorOfTables(data()) &&
+           verifier.EndTable();
+  }
+};
+
+struct Vec2DBuilder {
+  typedef Vec2D Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>>> data) {
+    fbb_.AddOffset(Vec2D::VT_DATA, data);
+  }
+  explicit Vec2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Vec2D> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Vec2D>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Vec2D> CreateVec2D(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>>> data = 0) {
+  Vec2DBuilder builder_(_fbb);
+  builder_.add_data(data);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Vec2D> CreateVec2DDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const std::vector<flatbuffers::Offset<mindspore::schema::Vec>> *data = nullptr) {
+  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Vec>>(*data) : 0;
+  return mindspore::schema::CreateVec2D(
+      _fbb,
+      data__);
+}
+
+struct Attribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef AttributeBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_NAME = 4,
+    VT_DATA = 6
+  };
+  const flatbuffers::String *name() const {
+    return GetPointer<const flatbuffers::String *>(VT_NAME);
+  }
+  const flatbuffers::Vector<uint8_t> *data() const {
+    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffset(verifier, VT_NAME) &&
+           verifier.VerifyString(name()) &&
+           VerifyOffset(verifier, VT_DATA) &&
+           verifier.VerifyVector(data()) &&
+           verifier.EndTable();
+  }
+};
+
+struct AttributeBuilder {
+  typedef Attribute Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
+    fbb_.AddOffset(Attribute::VT_NAME, name);
+  }
+  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
+    fbb_.AddOffset(Attribute::VT_DATA, data);
+  }
+  explicit AttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<Attribute> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<Attribute>(end);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<Attribute> CreateAttribute(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> name = 0,
+    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
+  AttributeBuilder builder_(_fbb);
+  builder_.add_data(data);
+  builder_.add_name(name);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<Attribute> CreateAttributeDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *name = nullptr,
+    const std::vector<uint8_t> *data = nullptr) {
+  auto name__ = name ? _fbb.CreateString(name) : 0;
+  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
+  return mindspore::schema::CreateAttribute(
+      _fbb,
+      name__,
+      data__);
+}
+
+}  // namespace schema
+}  // namespace mindspore
+
+#endif  // FLATBUFFERS_GENERATED_OPSTYPES_MINDSPORE_SCHEMA_H_
-- 
2.34.1

